{"id": 3439214, "updated": "2023-11-07 20:39:24.623", "metadata": {"title": "SeqGAN: Sequence Generative Adversarial Nets with Policy Gradient", "authors": "[{\"first\":\"Lantao\",\"last\":\"Yu\",\"middle\":[]},{\"first\":\"Weinan\",\"last\":\"Zhang\",\"middle\":[]},{\"first\":\"Jun\",\"last\":\"Wang\",\"middle\":[]},{\"first\":\"Yong\",\"last\":\"Yu\",\"middle\":[]}]", "venue": "ArXiv", "journal": "ArXiv", "publication_date": {"year": 2016, "month": 9, "day": 18}, "abstract": "As a new way of training generative models, Generative Adversarial Nets (GAN) that uses a discriminative model to guide the training of the generative model has enjoyed considerable success in generating real-valued data. However, it has limitations when the goal is for generating sequences of discrete tokens. A major reason lies in that the discrete outputs from the generative model make it difficult to pass the gradient update from the discriminative model to the generative model. Also, the discriminative model can only assess a complete sequence, while for a partially generated sequence, it is non-trivial to balance its current score and the future one once the entire sequence has been generated. In this paper, we propose a sequence generation framework, called SeqGAN, to solve the problems. Modeling the data generator as a stochastic policy in reinforcement learning (RL), SeqGAN bypasses the generator differentiation problem by directly performing gradient policy update. The RL reward signal comes from the GAN discriminator judged on a complete sequence, and is passed back to the intermediate state-action steps using Monte Carlo search. Extensive experiments on synthetic data and real-world tasks demonstrate significant improvements over strong baselines.", "fields_of_study": "[\"Computer Science\"]", "external_ids": {"arxiv": "1609.05473", "mag": "2964268978", "acl": null, "pubmed": null, "pubmedcentral": null, "dblp": "journals/corr/YuZWY16", "doi": "10.1609/aaai.v31i1.10804"}}, "content": {"source": {"pdf_hash": "dd35e07773e5f5d3b26bd76a1ceb04dbbef2b5dc", "pdf_src": "Arxiv", "pdf_uri": "[\"https://arxiv.org/pdf/1609.05473v6.pdf\"]", "oa_url_match": false, "oa_info": null}, "grobid": {"id": "200e6dbda25a0ddea524b257794470ece8c3927c", "type": "plain-text", "url": "s3://ai2-s2-pdf-extraction-prod/parse-results/s2orc_worker/dd35e07773e5f5d3b26bd76a1ceb04dbbef2b5dc.txt", "contents": "\nSeqGAN: Sequence Generative Adversarial Nets with Policy Gradient\n\n\nLantao Yu \nWeinan Zhang \nJun Wang j.wang@cs.ucl.ac.uk \nUniversity College London\n\n\nYong Yu \nShanghai \n\nJiao Tong University\n\n\nSeqGAN: Sequence Generative Adversarial Nets with Policy Gradient\n\nAs a new way of training generative models, Generative Adversarial Net (GAN) that uses a discriminative model to guide the training of the generative model has enjoyed considerable success in generating real-valued data. However, it has limitations when the goal is for generating sequences of discrete tokens. A major reason lies in that the discrete outputs from the generative model make it difficult to pass the gradient update from the discriminative model to the generative model. Also, the discriminative model can only assess a complete sequence, while for a partially generated sequence, it is nontrivial to balance its current score and the future one once the entire sequence has been generated. In this paper, we propose a sequence generation framework, called SeqGAN, to solve the problems. Modeling the data generator as a stochastic policy in reinforcement learning (RL), SeqGAN bypasses the generator differentiation problem by directly performing gradient policy update. The RL reward signal comes from the GAN discriminator judged on a complete sequence, and is passed back to the intermediate state-action steps using Monte Carlo search. Extensive experiments on synthetic data and real-world tasks demonstrate significant improvements over strong baselines.\n\nIntroduction\n\nGenerating sequential synthetic data that mimics the real one is an important problem in unsupervised learning. Recently, recurrent neural networks (RNNs) with long shortterm memory (LSTM) cells (Hochreiter and Schmidhuber 1997) have shown excellent performance ranging from natural language generation to handwriting generation (Wen et al. 2015;Graves 2013). The most common approach to training an RNN is to maximize the log predictive likelihood of each true token in the training sequence given the previous observed tokens (Salakhutdinov 2009). However, as argued in , the maximum likelihood approaches suffer from so-called exposure bias in the inference stage: the model generates a sequence iteratively and predicts next token conditioned on its previously predicted ones that may be never observed in the training data. Such a discrepancy between training and inference can incur accumulatively along with the sequence and will become prominent as the length of sequence increases. To address this problem,  proposed a training strategy called scheduled sampling (SS), where the generative model is partially fed with its own synthetic data as prefix (observed tokens) rather than the true data when deciding the next token in the training stage. Nevertheless, (Husz\u00e1r 2015) showed that SS is an inconsistent training strategy and fails to address the problem fundamentally. Another possible solution of the training/inference discrepancy problem is to build the loss function on the entire generated sequence instead of each transition. For instance, in the application of machine translation, a task specific sequence score/loss, bilingual evaluation understudy (BLEU) (Papineni et al. 2002), can be adopted to guide the sequence generation. However, in many other practical applications, such as poem generation (Zhang and Lapata 2014) and chatbot (Hingston 2009), a task specific loss may not be directly available to score a generated sequence accurately.\n\nGeneral adversarial net (GAN) proposed by (Goodfellow and others 2014) is a promising framework for alleviating the above problem. Specifically, in GAN a discriminative net D learns to distinguish whether a given data instance is real or not, and a generative net G learns to confuse D by generating high quality data. This approach has been successful and been mostly applied in computer vision tasks of generating samples of natural images (Denton et al. 2015).\n\nUnfortunately, applying GAN to generating sequences has two problems. Firstly, GAN is designed for generating real-valued, continuous data but has difficulties in directly generating sequences of discrete tokens, such as texts (Husz\u00e1r 2015). The reason is that in GANs, the generator starts with random sampling first and then a determistic transform, govermented by the model parameters. As such, the gradient of the loss from D w.r.t. the outputs by G is used to guide the generative model G (paramters) to slightly change the generated value to make it more realistic. If the generated data is based on discrete tokens, the \"slight change\" guidance from the discriminative net makes little sense because there is probably no corresponding token for such slight change in the limited dictionary space (Goodfellow 2016). Secondly, GAN can only give the score/loss for an entire sequence when it has been generated; for a partially generated sequence, it is non-trivial to balance how good as it is now and the future score as the entire sequence.\n\nIn this paper, to address the above two issues, we follow (Bachman and Precup 2015;Bahdanau et al. 2016) and consider the sequence generation procedure as a sequential decision making process. The generative model is treated as an agent of reinforcement learning (RL); the state is the generated tokens so far and the action is the next token to be generated. Unlike the work in (Bahdanau et al. 2016) that requires a task-specific sequence score, such as BLEU in machine translation, to give the reward, we employ a discriminator to evaluate the sequence and feedback the evaluation to guide the learning of the generative model. To solve the problem that the gradient cannot pass back to the generative model when the output is discrete, we regard the generative model as a stochastic parametrized policy. In our policy gradient, we employ Monte Carlo (MC) search to approximate the state-action value. We directly train the policy (generative model) via policy gradient (Sutton et al. 1999), which naturally avoids the differentiation difficulty for discrete data in a conventional GAN.\n\nExtensive experiments based on synthetic and real data are conducted to investigate the efficacy and properties of the proposed SeqGAN. In our synthetic data environment, SeqGAN significantly outperforms the maximum likelihood methods, scheduled sampling and PG-BLEU. In three realworld tasks, i.e. poem generation, speech language generation and music generation, SeqGAN significantly outperforms the compared baselines in various metrics including human expert judgement.\n\n\nRelated Work\n\nDeep generative models have recently drawn significant attention, and the ability of learning over large (unlabeled) data endows them with more potential and vitality (Salakhutdinov 2009;. (Hinton, Osindero, and Teh 2006) first proposed to use the contrastive divergence algorithm to efficiently training deep belief nets (DBN).  proposed denoising autoencoder (DAE) that learns the data distribution in a supervised learning fashion. Both DBN and DAE learn a low dimensional representation (encoding) for each data instance and generate it from a decoding network. Recently, variational autoencoder (VAE) that combines deep learning with statistical inference intended to represent a data instance in a latent hidden space (Kingma and Welling 2014), while still utilizing (deep) neural networks for non-linear mapping. The inference is done via variational methods. All these generative models are trained by maximizing (the lower bound of) training data likelihood, which, as mentioned by (Goodfellow and others 2014), suffers from the difficulty of approximating intractable probabilistic computations. (Goodfellow and others 2014) proposed an alternative training methodology to generative models, i.e. GANs, where the training procedure is a minimax game between a generative model and a discriminative model. This framework bypasses the difficulty of maximum likelihood learning and has gained striking successes in natural image generation (Denton et al. 2015). However, little progress has been made in applying GANs to sequence discrete data generation problems, e.g. natural language generation (Husz\u00e1r 2015). This is due to the generator network in GAN is designed to be able to adjust the output continuously, which does not work on discrete data generation (Goodfellow 2016).\n\nOn the other hand, a lot of efforts have been made to generate structured sequences. Recurrent neural networks can be trained to produce sequences of tokens in many applications such as machine translation (Sutskever, Vinyals, and Le 2014;Bahdanau, Cho, and Bengio 2014). The most popular way of training RNNs is to maximize the likelihood of each token in the training data whereas  pointed out that the discrepancy between training and generating makes the maximum likelihood estimation suboptimal and proposed scheduled sampling strategy (SS). Later (Husz\u00e1r 2015) theorized that the objective function underneath SS is improper and explained the reason why GANs tend to generate natural-looking samples in theory. Consequently, the GANs have great potential but are not practically feasible to discrete probabilistic models currently.\n\nAs pointed out by (Bachman and Precup 2015), the sequence data generation can be formulated as a sequential decision making process, which can be potentially be solved by reinforcement learning techniques. Modeling the sequence generator as a policy of picking the next token, policy gradient methods (Sutton et al. 1999) can be adopted to optimize the generator once there is an (implicit) reward function to guide the policy. For most practical sequence generation tasks, e.g. machine translation (Sutskever, Vinyals, and Le 2014), the reward signal is meaningful only for the entire sequence, for instance in the game of Go (Silver et al. 2016), the reward signal is only set at the end of the game. In those cases, state-action evaluation methods such as Monte Carlo (tree) search have been adopted (Browne et al. 2012). By contract, our proposed SeqGAN extends GANs with the RL-based generator to solve the sequence generation problem, where a reward signal is provided by the discriminator at the end of each episode via Monte Carlo approach, and the generator picks the action and learns the policy using estimated overall rewards.\n\n\nSequence Generative Adversarial Nets\n\nThe sequence generation problem is denoted as follows. Given a dataset of real-world structured sequences, train a \u03b8-parameterized generative model G \u03b8 to produce a sequence Y 1:T = (y 1 , . . . , y t , . . . , y T ), y t \u2208 Y, where Y is the vocabulary of candidate tokens. We interpret this problem based on reinforcement learning. In timestep t, the state s is the current produced tokens (y 1 , . . . , y t\u22121 ) and the action a is the next token y t to select. Thus the policy model G \u03b8 (y t |Y 1:t\u22121 ) is stochastic, whereas the state transition is deterministic after an action has been chosen, i.e. \u03b4 a s,s = 1 for the next state s = Y 1:t if the current state s = Y 1:t\u22121 and the action a = y t ; for other next states s , \u03b4 a s,s = 0. Additionally, we also train a \u03c6-parameterized discriminative model D \u03c6 (Goodfellow and others 2014) to provide a guidance for improving generator G \u03b8 . D \u03c6 (Y 1:T ) is a probability indicating how likely a sequence Y 1:T is from real sequence data or not. As illustrated in Figure 1, the dis- criminative model D \u03c6 is trained by providing positive examples from the real sequence data and negative examples from the synthetic sequences generated from the generative model G \u03b8 . At the same time, the generative model G \u03b8 is updated by employing a policy gradient and MC search on the basis of the expected end reward received from the discriminative model D \u03c6 . The reward is estimated by the likelihood that it would fool the discriminative model D \u03c6 . The specific formulation is given in the next subsection.\n\n\nSeqGAN via Policy Gradient\n\nFollowing (Sutton et al. 1999), when there is no intermediate reward, the objective of the generator model (policy) G \u03b8 (y t |Y 1:t\u22121 ) is to generate a sequence from the start state s 0 to maximize its expected end reward:\nJ(\u03b8) = E[RT |s0, \u03b8] = y 1 \u2208Y G \u03b8 (y1|s0) \u00b7 Q G \u03b8 D \u03c6 (s0, y1),(1)\nwhere R T is the reward for a complete sequence. Note that the reward is from the discriminator D \u03c6 , which we will discuss later. Q G \u03b8 D \u03c6 (s, a) is the action-value function of a sequence, i.e. the expected accumulative reward starting from state s, taking action a, and then following policy G \u03b8 . The rational of the objective function for a sequence is that starting from a given initial state, the goal of the generator is to generate a sequence which would make the discriminator consider it is real.\n\nThe next question is how to estimate the action-value function. In this paper, we use the REINFORCE algorithm (Williams 1992) and consider the estimated probability of being real by the discriminator D \u03c6 (Y n 1:T ) as the reward. Formally, we have:\nQ G \u03b8 D \u03c6 (a = yT , s = Y1:T \u22121) = D \u03c6 (Y1:T ).(2)\nHowever, the discriminator only provides a reward value for a finished sequence. Since we actually care about the longterm reward, at every timestep, we should not only consider the fitness of previous tokens (prefix) but also the resulted future outcome. This is similar to playing the games such as Go or Chess where players sometimes would give up the immediate interests for the long-term victory (Silver et al. 2016). Thus, to evaluate the action-value for an intermediate state, we apply Monte Carlo search with a roll-out policy G \u03b2 to sample the unknown last T \u2212 t tokens. We represent an N -time Monte Carlo search as\nY 1 1:T , . . . , Y N 1:T = MC G \u03b2 (Y1:t; N ),(3)\nwhere Y n 1:t = (y 1 , . . . , y t ) and Y n t+1:T is sampled based on the roll-out policy G \u03b2 and the current state. In our experiment, G \u03b2 is set the same as the generator, but one can use a simplified version if the speed is the priority (Silver et al. 2016). To reduce the variance and get more accurate assessment of the action value, we run the roll-out policy starting from current state till the end of the sequence for N times to get a batch of output samples. Thus, we have:\nQ G \u03b8 D \u03c6 (s = Y1:t\u22121, a = yt) = (4) 1 N N n=1 D \u03c6 (Y n 1:T ), Y n 1:T \u2208 MC G \u03b2 (Y1:t; N ) for t < T D \u03c6 (Y1:t) for t = T ,\nwhere, we see that when no intermediate reward, the function is iteratively defined as the next-state value starting from state s = Y 1:t and rolling out to the end. A benefit of using the discriminator D \u03c6 as a reward function is that it can be dynamically updated to further improve the generative model iteratively. Once we have a set of more realistic generated sequences, we shall re-train the discriminator model as follows: (5) Each time when a new discriminator model has been obtained, we are ready to update the generator. The proposed policy based method relies upon optimizing a parametrized policy to directly maximize the long-term reward. Following (Sutton et al. 1999), the gradient of the objective function J(\u03b8) w.r.t. the generator's parameters \u03b8 can be derived as\nmin \u03c6 \u2212EY \u223cp data [log D \u03c6 (Y )] \u2212 EY \u223cG \u03b8 [log(1 \u2212 D \u03c6 (Y ))].\u2207 \u03b8 J(\u03b8) = T t=1 E Y1:t\u22121\u223cG\u03b8 yt\u2208Y \u2207 \u03b8 G \u03b8 (y t |Y 1:t\u22121 ) \u00b7 Q G\u03b8 D\u03c6 (Y 1:t\u22121 , y t ) .(6)\nThe above form is due to the deterministic state transition and zero intermediate rewards. The detailed derivation is provided in the appendix. Using likelihood ratios (Glynn 1990;Sutton et al. 1999), we build an unbiased estimation for Eq. (6) (on one episode):\n\u2207\u03b8J(\u03b8) T t=1 yt\u2208Y \u2207\u03b8G\u03b8(yt|Y1:t\u22121) \u00b7 Q G \u03b8 D \u03c6 (Y1:t\u22121, yt) (7) = T t=1 yt\u2208Y G\u03b8(yt|Y1:t\u22121)\u2207\u03b8 log G\u03b8(yt|Y1:t\u22121) \u00b7 Q G \u03b8 D \u03c6 (Y1:t\u22121, yt) = T t=1 E yt\u223cG \u03b8 (yt|Y 1:t\u22121 ) [\u2207\u03b8 log G\u03b8(yt|Y1:t\u22121) \u00b7 Q G \u03b8 D \u03c6 (Y1:t\u22121, yt)],\nwhere Y 1:t\u22121 is the observed intermediate state sampled from G \u03b8 . Since the expectation E[\u00b7] can be approximated by sampling methods, we then update the generator's parameters as:\n\u03b8 \u2190 \u03b8 + \u03b1 h \u2207 \u03b8 J(\u03b8),(8)\nwhere \u03b1 h \u2208 R + denotes the corresponding learning rate at h-th step. Also the advanced gradient algorithms such as Adam and RMSprop can be adopted here.\n\nIn summary, Algorithm 1 shows full details of the proposed SeqGAN. At the beginning of the training, we use the maximum likelihood estimation (MLE) to pre-train G \u03b8 on Algorithm 1 Sequence Generative Adversarial Nets Require: generator policy G \u03b8 ; roll-out policy G \u03b2 ; discriminator D \u03c6 ; a sequence dataset S = {X1:T } 1: Initialize G \u03b8 , D \u03c6 with random weights \u03b8, \u03c6. 2: Pre-train G \u03b8 using MLE on S 3: \u03b2 \u2190 \u03b8 4: Generate negative samples using G \u03b8 for training D \u03c6 5: Pre-train D \u03c6 via minimizing the cross entropy 6: repeat 7:\n\nfor g-steps do 8:\n\nGenerate a sequence Y1:T = (y1, . . . , yT ) \u223c G \u03b8 9:\n\nfor t in 1 : T do 10:\n\nCompute Q(a = yt; s = Y1:t\u22121) by Eq. (4)  training set S. We found the supervised signal from the pretrained discriminator is informative to help adjust the generator efficiently.\n\nAfter the pre-training, the generator and discriminator are trained alternatively. As the generator gets progressed via training on g-steps updates, the discriminator needs to be retrained periodically to keeps a good pace with the generator. When training the discriminator, positive examples are from the given dataset S, whereas negative examples are generated from our generator. In order to keep the balance, the number of negative examples we generate for each d-step is the same as the positive examples. And to reduce the variability of the estimation, we use different sets of negative samples combined with positive ones, which is similar to bootstrapping (Quinlan 1996).\n\n\nThe Generative Model for Sequences\n\nWe use recurrent neural networks (RNNs) (Hochreiter and Schmidhuber 1997) as the generative model. An RNN maps the input embedding representations x 1 , . . . , x T of the sequence x 1 , . . . , x T into a sequence of hidden states h 1 , . . . , h T by using the update function g recursively.\nht = g(ht\u22121, xt)(9)\nMoreover, a softmax output layer z maps the hidden states into the output token distribution\np(yt|x1, . . . , xt) = z(ht) = softmax(c + V ht),(10)\nwhere the parameters are a bias vector c and a weight matrix V . To deal with the common vanishing and exploding gradient problem (Goodfellow, Bengio, and Courville 2016) of the backpropagation through time, we leverage the Long Short-Term Memory (LSTM) cells (Hochreiter and Schmidhuber 1997) to implement the update function g in Eq. (9). It is worth noticing that most of the RNN variants, such as the gated recurrent unit (GRU) ) and soft attention mechanism (Bahdanau, Cho, and Bengio 2014), can be used as a generator in SeqGAN.\n\n\nThe Discriminative Model for Sequences\n\nDeep discriminative models such as deep neural network (DNN) (Vesel\u1ef3 et al. 2013), convolutional neural network (CNN) (Kim 2014) and recurrent convolutional neural network (RCNN) (Lai et al. 2015) have shown a high performance in complicated sequence classification tasks. In this paper, we choose the CNN as our discriminator as CNN has recently been shown of great effectiveness in text (token sequence) classification (Zhang and LeCun 2015). Most discriminative models can only perform classification well for an entire sequence rather than the unfinished one. In this paper, we also focus on the situation where the discriminator predicts the probability that a finished sequence is real. 1 We first represent an input sequence x 1 , . . . , x T as:\nE1:T = x1 \u2295 x2 \u2295 . . . \u2295 xT ,(11)\nwhere x t \u2208 R k is the k-dimensional token embedding and \u2295 is the concatenation operator to build the matrix E 1:T \u2208 R T \u00d7k . Then a kernel w \u2208 R l\u00d7k applies a convolutional operation to a window size of l words to produce a new feature map:\nci = \u03c1(w \u2297 E i:i+l\u22121 + b),(12)\nwhere \u2297 operator is the summation of elementwise production, b is a bias term and \u03c1 is a non-linear function. We can use various numbers of kernels with different window sizes to extract different features. Finally we apply a max-over-time pooling operation over the feature maps c = max {c 1 , . . . , c T \u2212l+1 }.\n\nTo enhance the performance, we also add the highway architecture (Srivastava, Greff, and Schmidhuber 2015) based on the pooled feature maps. Finally, a fully connected layer with sigmoid activation is used to output the probability that the input sequence is real. The optimization target is to minimize the cross entropy between the ground truth label and the predicted probability as formulated in Eq. (5).\n\nDetailed implementations of the generative and discriminative models are provided in the appendix.\n\n\nSynthetic Data Experiments\n\nTo test the efficacy and add our understanding of SeqGAN, we conduct a simulated test with synthetic data 2 . To simulate the real-world structured sequences, we consider a language model to capture the dependency of the tokens. We use a randomly initialized LSTM as the true model, aka, the oracle, to generate the real data distribution p(x t |x 1 , . . . , x t\u22121 ) for the following experiments.\n\n\nEvaluation Metric\n\nThe benefit of having such oracle is that firstly, it provides the training dataset and secondly evaluates the exact performance of the generative models, which will not be possible with real data. We know that MLE is trying to minimize the cross-entropy between the true data distribution p and our approximation q, i.e. \u2212E x\u223cp log q(x). However, the most accurate way of evaluating generative models is that we draw some samples from it and let human observers review them based on their prior knowledge. We assume that the human observer has learned an accurate model of the natural distribution p human (x). Then in order to increase the chance of passing Turing Test, we actually need to minimize the exact opposite average negative log-likelihood \u2212E x\u223cq log p human (x) (Husz\u00e1r 2015), with the role of p and q exchanged. In our synthetic data experiments, we can consider the oracle to be the human observer for real-world problems, thus a perfect evaluation metric should be\nNLLoracle = \u2212EY 1:T \u223cG \u03b8 T t=1 log Goracle(yt|Y1:t\u22121) ,(13)\nwhere G \u03b8 and G oracle denote our generative model and the oracle respectively. At the test stage, we use G \u03b8 to generate 100,000 sequence samples and calculate NLL oracle for each sample by G oracle and their average score. Also significance tests are performed to compare the statistical properties of the generation performance between the baselines and SeqGAN.\n\n\nTraining Setting\n\nTo set up the synthetic data experiments, we first initialize the parameters of an LSTM network following the normal distribution N (0, 1) as the oracle describing the real data distribution G oracle (x t |x 1 , . . . , x t\u22121 ). Then we use it to generate 10,000 sequences of length 20 as the training set S for the generative models.\n\nIn SeqGAN algorithm, the training set for the discriminator is comprised by the generated examples with the label 0 and the instances from S with the label 1. For different tasks, one should design specific structure for the convolutional layer and in our synthetic data experiments, the kernel size is from 1 to T and the number of each kernel size is between 100 to 200 3 . Dropout (Srivastava et al. 2014) and L2 regularization are used to avoid over-fitting.\n\nFour generative models are compared with SeqGAN. The first model is a random token generation. The second one is the MLE trained LSTM G \u03b8 . The third one is scheduled sampling . The fourth one is the Policy Gradient with BLEU (PG-BLEU). In the scheduled sampling, the training process gradually changes from a fully guided scheme feeding the true previous tokens into LSTM, towards a less guided scheme which mostly feeds the LSTM with its generated tokens. A curriculum rate \u03c9 is used to control the probability of replacing the true tokens with the generated ones. To get a good and stable performance, we decrease \u03c9 by 0.002 for every training epoch. In the PG-BLEU algorithm, we use BLEU, a metric measuring the similarity between a generated sequence and references (training data), to score the finished samples from Monte Carlo search.  \n\n\nResults\n\nThe NLL oracle performance of generating sequences from the compared policies is provided in Table 1. Since the evaluation metric is fundamentally instructive, we can see the impact of SeqGAN, which outperforms other baselines significantly. A significance T-test on the NLL oracle score distribution of the generated sequences from the compared models is also performed, which demonstrates the significant improvement of SeqGAN over all compared models. The learning curves shown in Figure 4 illustrate the superiority of SeqGAN explicitly. After about 150 training epochs, both the maximum likelihood estimation and the schedule sampling methods converge to a relatively high NLL oracle score, whereas SeqGAN can improve the limit of the generator with the same structure as the baselines significantly. This indicates the prospect of applying adversarial training strategies to discrete sequence generative models to breakthrough the limitations of MLE. Additionally, SeqGAN outperforms PG-BLEU, which means the discriminative signal in GAN is more general and effective than a predefined score (e.g. BLEU) to guide the generative policy to capture the underlying distribution of the sequence data.\n\n\nDiscussion\n\nIn our synthetic data experiments, we find that the stability of SeqGAN depends on the training strategy. More specifically, the g-steps, d-steps and k parameters in Algorithm 1 have a large effect on the convergence and performance of SeqGAN. Figure 3 shows the effect of these parameters. In Figure 3(a), the g-steps is much larger than the d-steps and epoch number k, which means we train the generator for many times until we update the discriminator. This strategy leads to a fast convergence but as the generator improves quickly, the discriminator cannot get fully trained and thus will provide a misleading signal gradually. In Figure 3(b), with more discriminator training epochs, the unstable training process is alleviated. In Figure 3(c), we train the generator for only one epoch and then before the discriminator gets  are emphasized, which will lead to a more comprehensive guidance for training generator. This is in line with the theorem in (Goodfellow and others 2014). When analyzing the convergence of generative adversarial nets, an important assumption is that the discriminator is allowed to reach its optimum given G. Only if the discriminator is capable of differentiating real data from unnatural data consistently, the supervised signal from it can be meaningful and the whole adversarial training process can be stable and effective.\n\n\nReal-world Scenarios\n\nTo complement the previous experiments, we also test Se-qGAN on several real-world tasks, i.e. poem composition, speech language generation and music generation.\n\n\nText Generation\n\nFor text generation scenarios, we apply the proposed Seq-GAN to generate Chinese poems and Barack Obama political speeches. In the poem composition task, we use a corpus 4 of 16,394 Chinese quatrains, each containing four lines   of twenty characters in total. To focus on a fully automatic solution and stay general, we did not use any prior knowledge of special structure rules in Chinese poems such as specific phonological rules. In the Obama political speech generation task, we use a corpus 5 , which is a collection of 11,092 paragraphs from Obama's political speeches. We use BLEU score as an evaluation metric to measure the similarity degree between the generated texts and the human-created texts. BLEU is originally designed to automatically judge the machine translation quality (Papineni et al. 2002). The key point is to compare the similarity between the results created by machine and the references provided by human. Specifically, for poem evaluation, we set n-gram to be 2 (BLEU-2) since most words (dependency) in classical Chinese poems consist of one or two characters (Yi, Li, and Sun 2016) and for the similar reason, we use BLEU-3 and BLEU-4 to evaluate Obama speech generation performance. In our work, we use the whole test set as the references instead of trying to find some references for the following line given the previous line (He, Zhou, and Jiang 2012). The reason is in generation tasks we only provide some positive examples and then let the model catch the patterns of them and generate new ones. In addition to BLEU, we also choose poem generation as a case for human judgement since a poem is a creative text construction and human evaluation is ideal. Specifically, we mix the 20 real poems and 20 each generated from SeqGAN and MLE. Then 70 experts on Chinese poems are invited to judge whether each of the 60 poem is created by human or machines. Once regarded to be real, it gets +1 score, otherwise 0. Finally, the average score for each algorithm is calculated.\n\nThe experiment results are shown in Tables 2 and 3, from which we can see the significant advantage of SeqGAN over the MLE in text generation. Particularly, for poem composition, SeqGAN performs comparably to real human data.\n\n\nMusic Generation\n\nFor music composition, we use Nottingham 6 dataset as our training data, which is a collection of 695 music of folk tunes in midi file format. We study the solo track of each music. In our work, we use 88 numbers to represent 88 pitches, which correspond to the 88 keys on the piano. With the pitch sampling for every 0.4s 7 , we transform the midi files into sequences of numbers from 1 to 88 with the length 32.\n\nTo model the fitness of the discrete piano key patterns, BLEU is used as the evaluation metric. To model the fitness of the continuous pitch data patterns, the mean squared error (MSE) (Manaris et al. 2007) is used for evaluation.\n\nFrom Table 4, we see that SeqGAN outperforms the MLE significantly in both metrics in the music generation task.\n\n\nConclusion\n\nIn this paper, we proposed a sequence generation method, SeqGAN, to effectively train generative adversarial nets for structured sequences generation via policy gradient. To our best knowledge, this is the first work extending GANs to generate sequences of discrete tokens. In our synthetic data experiments, we used an oracle evaluation mechanism to explicitly illustrate the superiority of SeqGAN over strong baselines. For three real-world scenarios, i.e., poems, speech language and music generation, SeqGAN showed excellent performance on generating the creative sequences. We also performed a set of experiments to investigate the robustness and stability of training SeqGAN. For future work, we plan to build Monte Carlo tree search and value network (Silver et al. 2016) to improve action decision making for large scale data and in the case of longer-term planning.\n\n\nProof for Eq. (6)\n\nFor readability, we provide the detailed derivation of Eq. (6) here by following (Sutton et al. 1999).\n\nAs mentioned in SEQUENCE GENERATIVE ADVERSARIAL NETS section, the state transition is deterministic after an action has been chosen, i.e. \u03b4 a s,s = 1 for the next state s = Y 1:t if the current state s = Y 1:t\u22121 and the action a = y t ; for other next states s , \u03b4 a s,s = 0. In addition, the intermediate reward R a s is 0. We re-write the action value and state value as follows:\nQ G \u03b8 (s = Y 1:t\u22121 , a = y t ) = R a s + s \u2208S \u03b4 a ss V G \u03b8 (s ) = V G \u03b8 (Y 1:t ) (14) V G \u03b8 (s = Y 1:t\u22121 ) = yt\u2208Y G \u03b8 (y t |Y 1:t\u22121 ) \u00b7 Q G \u03b8 (Y 1:t\u22121 , y t )(15)\nFor the start state s 0 , the value is calculated as\nV G \u03b8 (s 0 ) = E[R T |s 0 , \u03b8] (16) = y1\u2208Y G \u03b8 (y 1 |s 0 ) \u00b7 Q G \u03b8 (s 0 , y 1 ),\nwhich is the objective function J(\u03b8) to maximize in Eq.\n\n(1) of the paper. Then we can obtain the gradient of the objective function, defined in Eq. (1), w.r.t. the generator's parameters \u03b8:\n\u2207 \u03b8 J(\u03b8) = \u2207 \u03b8 V G \u03b8 (s0) = \u2207 \u03b8 [ y 1 \u2208Y G \u03b8 (y1|s0) \u00b7 Q G \u03b8 (s0, y1)] = y 1 \u2208Y [\u2207 \u03b8 G \u03b8 (y1|s0) \u00b7 Q G \u03b8 (s0, y1) + G \u03b8 (y1|s0) \u00b7 \u2207 \u03b8 Q G \u03b8 (s0, y1)] = y 1 \u2208Y [\u2207 \u03b8 G \u03b8 (y1|s0) \u00b7 Q G \u03b8 (s0, y1) + G \u03b8 (y1|s0) \u00b7 \u2207 \u03b8 V G \u03b8 (Y1:1)] = y 1 \u2208Y \u2207 \u03b8 G \u03b8 (y1|s0) \u00b7 Q G \u03b8 (s0, y1) + y 1 \u2208Y G \u03b8 (y1|s0)\u2207 \u03b8 [ y 2 \u2208Y G \u03b8 (y2|Y1:1)Q G \u03b8 (Y1:1, y2)] = y 1 \u2208Y \u2207 \u03b8 G \u03b8 (y1|s0) \u00b7 Q G \u03b8 (s0, y1) + y 1 \u2208Y G \u03b8 (y1|s0) y 2 \u2208Y [\u2207 \u03b8 G \u03b8 (y2|Y1:1) \u00b7 Q G \u03b8 (Y1:1, y2) + G \u03b8 (y2|Y1:1)\u2207 \u03b8 Q G \u03b8 (Y1:1, y2)] = y 1 \u2208Y \u2207 \u03b8 G \u03b8 (y1|s0) \u00b7 Q G \u03b8 (s0, y1) + Y 1:1 P (Y1:1|s0; G \u03b8 ) y 2 \u2208Y \u2207 \u03b8 G \u03b8 (y2|Y1:1) \u00b7 Q G \u03b8 (Y1:1, y2) + Y 1:2 P (Y1:2|s0; G \u03b8 )\u2207 \u03b8 V G \u03b8 (Y1:2) = T t=1 Y 1:t\u22121 P (Y1:t\u22121|s0; G \u03b8 ) y t \u2208Y \u2207 \u03b8 G \u03b8 (yt|Y1:t\u22121) \u00b7 Q G \u03b8 (Y1:t\u22121, yt) = T t=1 EY 1:t\u22121 \u223cG \u03b8 [ y t \u2208Y \u2207 \u03b8 G \u03b8 (yt|Y1:t\u22121) \u00b7 Q G \u03b8 (Y1:t\u22121, yt)],(17)\nwhich is the result in Eq. (6) of the paper.\n\n\nModel Implementations\n\nIn this section, we present a full version of the discussed generative model and discriminative model in our paper submission.\n\nThe Generative Model for Sequences We use recurrent neural networks (RNNs) (Hochreiter and Schmidhuber 1997) as the generative model. An RNN maps the input embedding representations x 1 , . . . , x T of the sequence x 1 , . . . , x T into a sequence of hidden states h 1 , . . . , h T by using the update function g recursively.\nh t = g(h t\u22121 , x t )(18)\nMoreover, a softmax output layer z maps the hidden states into the output token distribution\np(y t |x 1 , . . . , x t ) = z(h t ) = softmax(c + V h t ),(19)\nwhere the parameters are a bias vector c and a weight matrix V . The vanishing and exploding gradient problem in backpropagation through time (BPTT) issues a challenge of learning longterm dependencies to recurrent neural network (Goodfellow, Bengio, and Courville 2016). To address such problems, gated RNNs have been designed based on the basic idea of creating paths through time that have derivatives that neither vanish nor explode. Among various gated RNNs, we choose the Long Short-Term Memory (LSTM) (Hochreiter and Schmidhuber 1997) to be our generative networks with the update equations:\nf t = \u03c3(W f \u00b7 [h t\u22121 , x t ] + b f ), i t = \u03c3(W i \u00b7 [h t\u22121 , x t ] + b i ), o t = \u03c3(W o \u00b7 [h t\u22121 , x t ] + b o ), s t = f t s t\u22121 + i t tanh(W s \u00b7 [h t\u22121 , x t ] + b s ), h t = o t tanh(s t ),(20)\nwhere [h, x] is the vector concatenation and is the elementwise product.\n\nFor simplicity, we use the standard LSTM as the generator, while it is worth noticing that most of the RNN variants, such as the gated recurrent unit (GRU) ) and soft attention mechanism (Bahdanau, Cho, and Bengio 2014), can be used as a generator in SeqGAN.\n\nThe standard way of training an RNN G \u03b8 is the maximum likelihood estimation (MLE), which involves minimizing the negative log-likelihood \u2212 T t=1 log G \u03b8 (y t = x t | {x 1 , . . . , x t\u22121 }) for a generated sequence (y 1 , . . . , y T ) given input (x 1 , . . . , x T ). However, when applying MLE to generative models, there is a discrepancy between training and generating Husz\u00e1r 2015), which motivates our work.\n\nThe Discriminative Model for Sequences Deep discriminative models such as deep neural network (DNN) (Vesel\u1ef3 et al. 2013), convolutional neural network (CNN) (Kim 2014) and recurrent convolutional neural network (RCNN) (Lai et al. 2015) have shown a high performance in complicated sequence classification tasks. In this paper, we choose the CNN as our discriminator as CNN has recently been shown of great effectiveness in text (token sequence) classification (Zhang and LeCun 2015).\n\nAs far as we know, except for some specific tasks, most discriminative models can only perform classification well for a whole sequence rather than the unfinished one. In case of some specific tasks, one may design a classifier to provide intermediate reward signal to enhance the performance of our framework. But to make it more general, we focus on the situation where discriminator can only provide final reward, i.e., the probability that a finished sequence was real.\n\nWe first represent an input sequence x 1 , . . . , x T as:\nE 1:T = x 1 \u2295 x 2 \u2295 . . . \u2295 x T ,(21)\nwhere x t \u2208 R k is the k-dimensional token embedding and \u2295 is the vertical concatenation operator to build the matrix E 1:T \u2208 R T \u00d7k . Then a kernel w \u2208 R l\u00d7k applies a convolutional operation to a window size of l words to produce a new feature map:\nc i = \u03c1(w \u2297 E i:i+l\u22121 + b),(22)\nwhere \u2297 operator is the summation of elementwise production, b is a bias term and \u03c1 is a non-linear function. We can use various numbers of kernels with different window sizes to extract different features. Specifically, a kernel w with window size l applied to the concatenated embeddings of input sequence will produce a feature map\nc = [c 1 , . . . , c T \u2212l+1 ].(23)\nFinally we apply a max-over-time pooling operation over the feature mapc = max {c} and pass all pooled features from different kernels to a fully connected softmax layer to get the probability that a given sequence is real.\n\nWe perform an empirical experiment to choose the kernel window sizes and numbers as shown in Table 5. For different tasks, one should design specific structures for the discriminator.\n\nTo enhance the performance, we also add the highway architecture (Srivastava, Greff, and Schmidhuber 2015) before the final fully connected layer: (1, 100),(2, 200), (3,200),(4, 200),(5, 200) (6, 100), (7,100),(8, 100),(9, 100),(10, 100) (15, 160),(20, 160)\n\u03c4 = \u03c3(W T \u00b7c + b T ), C = \u03c4 \u00b7 H(c, W H ) + (1 \u2212 \u03c4 ) \u00b7c,(24)\n\n32\n\n(1, 100),(2, 200), (3,200),(4, 200),(5, 200) (6, 100), (7,100),(8, 100),(9, 100),(10, 100) (16, 160),(24, 160), (32,160) where W T , b T and W H are highway layer weights, H denotes an affine transform followed by a non-linear activation function such as a rectified linear unit (ReLU) and \u03c4 is the \"transform gate\" with the same dimensionality as H(c, W H ) andc. Finally, we apply a sigmoid transformation to get the probability that a given sequence is real:\ny = \u03c3(W o \u00b7C + b o )(25)\nwhere W o and b o is the output layer weight and bias. When optimizing discriminative models, supervised training is applied to minimize the cross entropy, which is widely used as the objective function for classification and prediction tasks:\nL(y,\u0177) = \u2212y log\u0177 \u2212 (1 \u2212 y) log(1 \u2212\u0177),(26)\nwhere y is the ground truth label of the input sequence and\u0177 is the predicted probability from the discriminative models. In the DISCUSSION subsection of SYNTHETIC DATA EXPERIMENTS section of our paper, we discussed the ablation study of three hyperparameters of SeqGAN, i.e., g-steps, d-steps and k epoch number. Here we provide another ablation study which is instructive for the better training of SeqGAN.\n\n\nMore Ablation Study\n\nAs described in our paper, we start the adversarial training process after the convergence of MLE supervised pre-training. Here we further conduct experiments to investigate the performance of SeqGAN when the supervised pre-training is insufficient.\n\nAs shown in Figure 4, if we pre-train the generative model with conventional MLE methods for only 20 epochs, which is far from convergence, then the adversarial training process improves the generator quite slowly and unstably. The reason is that in SeqGAN, the discriminative model provides reward guidance when training the generator and if the generator acts almost randomly, the discriminator will identify the generated sequence to be unreal with high confidence and almost every action the generator takes receives a low (unified) reward, which does not guide the generator towards a good improvement direction, resulting in an ineffective training procedure. This indicates that in order to apply adversarial training strategies to sequence generative models, a sufficient pre-training is necessary.\n\nFigure 1 :\n1The illustration of SeqGAN. Left: D is trained over the real data and the generated data by G. Right: G is trained by policy gradient where the final reward signal is provided by D and is passed back to the intermediate action value via Monte Carlo search.\n\nFigure 2 :\n2Negative log-likelihood convergence w.r.t. the training epochs. The vertical dashed line represents the end of pre-training for SeqGAN, SS and PG-BLEU.\n\nFigure 3 :\n3Negative log-likelihood convergence performance of SeqGAN with different training strategies. The vertical dashed line represents the beginning of adversarial training. fooled, we update it immediately based on the more realistic negative examples. In such a case, SeqGAN learns stably. The d-steps in all three training strategies described above is set to 1, which means we only generate one set of negative examples with the same number as the given dataset, and then train the discriminator on it for various k epochs. But actually we can utilize the potentially unlimited number of negative examples to improve the discriminator. This trick can be considered as a type of bootstrapping, where we combine the fixed positive examples with different negative examples to obtain multiple training sets. Figure 3(d) shows this technique can improve the overall performance with good stability, since the discriminator is shown more negative examples and each time the positive examples\n\nFigure 4 :\n4Negative log-likelihood performance with different pre-training epochs before the adversarial training. The vertical dashed lines represent the start of adversarial training.\n\nTable 1 :\n1Sequence generation performance comparison. The p-value is between SeqGAN and the baseline from T-test.Algorithm Random \nMLE \nSS \nPG-BLEU SeqGAN \nNLL \n10.310 \n9.038 \n8.985 \n8.946 \n8.736 \np-value \n< 10 \u22126 \n< 10 \u22126 < 10 \u22126 \n< 10 \u22126 \n\n0 \n50 \n100 \n150 \n200 \n250 \n\nEpochs \n\n8.6 \n\n8.8 \n\n9.0 \n\n9.2 \n\n9.4 \n\n9.6 \n\n9.8 \n\n10.0 \n\nNLL by oracle \n\nLearning curve \n\nSeqGAN \nMLE \nSchedule Sampling \nPGBLEU \n\n\n\nTable 2 :\n2Chinese poem generation performance comparison.Algorithm Human score p-value BLEU-2 p-value \nMLE \n0.4165 \n0.0034 \n0.6670 \n< 10 \u22126 \nSeqGAN \n0.5356 \n0.7389 \nReal data \n0.6011 \n0.746 \n\n\n\nTable 3 :\n3Obama political speech generation performance.Algorithm BLEU-3 p-value BLEU-4 \np-value \nMLE \n0.519 \n< 10 \u22126 \n0.416 \n0.00014 \nSeqGAN \n0.556 \n0.427 \n\n\n\nTable 4 :\n4Music generation performance comparison.Algorithm BLEU-4 p-value \nMSE \np-value \nMLE \n0.9210 \n< 10 \u22126 22.38 0.00034 \nSeqGAN \n0.9406 \n20.62 \n\n\n\nTable 5 :\n5Convolutional layer structures.Sequence length \n(window size, kernel numbers) \n\n20 \n\n\nIn our work, the generated sequence has a fixed length T , but note that CNN is also capable of the variable-length sequence discrimination with the max-over-time pooling technique(Kim 2014).2 Experiment code: https://github.com/LantaoYu/SeqGAN\nImplementation details are in the appendix.\nhttp://homepages.inf.ed.ac.uk/mlap/Data/EMNLP14/\nhttps://github.com/samim23/obama-rnn 6 http://www.iro.umontreal.ca/\u02dclisa/deep/data\nAcknowledgmentsWe sincerely thank Tianxing He for many helpful discussions and comments on the manuscript.AppendixIn Section 1, we present the step-by-step derivation of Eq. (6) in the paper. In Section 2, the detailed realization of the generative model and the discriminative model is discussed, including the model parameter settings. In Section 3, an interesting ablation study is provided, which is a supplementary to the discussions of the synthetic data experiments.\nData generation as sequential decision making. P Bachman, D Precup, NIPS. References [Bachman and Precup 2015] Bachman, P., and Precup, D. 2015. Data generation as sequential decision making. In NIPS, 3249- 3257.\n\nGeneralized denoising auto-encoders as generative models. [ Bahdanau, arXiv:1607.07086arXiv:1409.0473Neural machine translation by jointly learning to align and translate. NIPS[Bahdanau et al. 2016] Bahdanau, D.; Brakel, P.; Xu, K.; et al. 2016. An actor-critic algorithm for sequence prediction. arXiv:1607.07086. [Bahdanau, Cho, and Bengio 2014] Bahdanau, D.; Cho, K.; and Bengio, Y. 2014. Neural machine translation by jointly learning to align and translate. arXiv:1409.0473. [Bengio et al. 2013] Bengio, Y.; Yao, L.; Alain, G.; and Vincent, P. 2013. Generalized denoising auto-encoders as generative models. In NIPS, 899-907.\n\nScheduled sampling for sequence prediction with recurrent neural networks. NIPS. et al. 2015] Bengio, S.; Vinyals, O.; Jaitly, N.; and Shazeer, N. 2015. Scheduled sampling for sequence prediction with recur- rent neural networks. In NIPS, 1171-1179.\n\nA survey of monte carlo tree search methods. [ Browne, IEEE TCIAIG. 41[Browne et al. 2012] Browne, C. B.; Powley, E.; Whitehouse, D.; Lucas, S. M.; et al. 2012. A survey of monte carlo tree search methods. IEEE TCIAIG 4(1):1-43.\n\nLearning phrase representations using RNN encoderdecoder for statistical machine translation. [ Cho, NIPS. Deep generative image models using a laplacian pyramid of adversarial networks[Cho et al. 2014] Cho, K.; Van Merri\u00ebnboer, B.; Gulcehre, C.; et al. 2014. Learning phrase representations using RNN encoder- decoder for statistical machine translation. EMNLP. [Denton et al. 2015] Denton, E. L.; Chintala, S.; Fergus, R.; et al. 2015. Deep generative image models using a laplacian pyramid of adversarial networks. In NIPS, 1486-1494.\n\nLikelihood ratio gradient estimation for stochastic systems. P W Glynn, Communications of the ACM. 3310http://deeplearning.net/tutorial/rnnrbm.html [Glynn 1990] Glynn, P. W. 1990. Likelihood ratio gradient es- timation for stochastic systems. Communications of the ACM 33(10):75-84.\n\nGenerative adversarial nets. I Goodfellow, NIPS. [Goodfellow and others 2014] Goodfellow, I., et al. 2014. Genera- tive adversarial nets. In NIPS, 2672-2680.\n\nDeep learning. Bengio Goodfellow, I Courville ; Goodfellow, Y Bengio, A Courville, I Goodfellow, A Graves, arXiv:1308.0850Generating sequences with recurrent neural networks. Generative adversarial networks for textGoodfellow, Bengio, and Courville 2016] Goodfellow, I.; Bengio, Y.; and Courville, A. 2016. Deep learning. 2015. [Goodfellow 2016] Goodfellow, I. 2016. Generative adversarial networks for text. http://goo.gl/Wg9DR7. [Graves 2013] Graves, A. 2013. Generating sequences with recur- rent neural networks. arXiv:1308.0850.\n\nGenerating chinese classical poems with statistical machine translation models. Zhou Jiang ; He, J Zhou, M Jiang, L , AAAI. 1A turing test for computer game bots, Zhou, and Jiang 2012] He, J.; Zhou, M.; and Jiang, L. 2012. Generating chinese classical poems with statistical machine trans- lation models. In AAAI. [Hingston 2009] Hingston, P. 2009. A turing test for computer game bots. IEEE TCIAIG 1(3):169-186.\n\nA fast learning algorithm for deep belief nets. Osindero Hinton, G E Teh ; Hinton, S Osindero, Y.-W Teh, Neural computation. 187Hinton, Osindero, and Teh 2006] Hinton, G. E.; Osindero, S.; and Teh, Y.-W. 2006. A fast learning algorithm for deep belief nets. Neural computation 18(7):1527-1554.\n\nHow (not) to train your generative model: Scheduled sampling, likelihood. S Hochreiter, J Schmidhuber, F Husz\u00e1r, arXiv:1511.05101Neural computation. 98Long short-term memory[Hochreiter and Schmidhuber 1997] Hochreiter, S., and Schmidhu- ber, J. 1997. Long short-term memory. Neural computation 9(8):1735-1780. [Husz\u00e1r 2015] Husz\u00e1r, F. 2015. How (not) to train your generative model: Scheduled sampling, likelihood, adversary? arXiv:1511.05101.\n\nRecurrent convolutional neural networks for text classification. Y Kim, D P Kingma, M ; S Welling, L Xu, K Liu, J Zhao, arXiv:1408.5882Convolutional neural networks for sentence classification. ICLR. [Lai et al. 2015] Lai,AAAIKim, Y. 2014. Convolutional neural networks for sen- tence classification. arXiv:1408.5882. [Kingma and Welling 2014] Kingma, D. P., and Welling, M. 2014. Auto-encoding variational bayes. ICLR. [Lai et al. 2015] Lai, S.; Xu, L.; Liu, K.; and Zhao, J. 2015. Recur- rent convolutional neural networks for text classification. In AAAI, 2267-2273.\n\nA corpus-based hybrid approach to music analysis and composition. Manaris, NCAI. 22ACL[Manaris et al. 2007] Manaris, B.; Roos, P.; Machado, P.; et al. 2007. A corpus-based hybrid approach to music analysis and com- position. In NCAI, volume 22, 839. [Papineni et al. 2002] Papineni, K.; Roukos, S.; Ward, T.; and Zhu, W.-J. 2002. Bleu: a method for automatic evaluation of machine translation. In ACL, 311-318.\n\nLearning deep generative models. J R Quinlan, R Salakhutdinov, 725-730AAAI/IAAI. Quinlan1University of TorontoBagging, boosting, and c4. 5. Ph.D. Dissertation[Quinlan 1996] Quinlan, J. R. 1996. Bagging, boosting, and c4. 5. In AAAI/IAAI, Vol. 1, 725-730. [Salakhutdinov 2009] Salakhutdinov, R. 2009. Learning deep gen- erative models. Ph.D. Dissertation, University of Toronto.\n\nMastering the game of go with deep neural networks and tree search. [ Silver, Nature. 5297587JMLR[Silver et al. 2016] Silver, D.; Huang, A.; Maddison, C. J.; Guez, A.; Sifre, L.; et al. 2016. Mastering the game of go with deep neural networks and tree search. Nature 529(7587):484-489. [Srivastava et al. 2014] Srivastava, N.; Hinton, G. E.; Krizhevsky, A.; Sutskever, I.; and Salakhutdinov, R. 2014. Dropout: a simple way to prevent neural networks from overfitting. JMLR 15(1):1929-1958.\n\n. Greff Srivastava, Schmidhuber, R K Srivastava, K Greff, J Schmidhuber, arXiv:1505.00387Srivastava, Greff, and Schmidhuber 2015] Srivastava, R. K.; Gr- eff, K.; and Schmidhuber, J. 2015. Highway networks. arXiv:1505.00387.\n\nSequence to sequence learning with neural networks. Vinyals Sutskever, Le ; Sutskever, I Vinyals, O Le, Q V , NIPS. Sutskever, Vinyals, and Le 2014] Sutskever, I.; Vinyals, O.; and Le, Q. V. 2014. Sequence to sequence learning with neural net- works. In NIPS, 3104-3112.\n\nPolicy gradient methods for reinforcement learning with function approximation. Sutton, NIPS. [Sutton et al. 1999] Sutton, R. S.; McAllester, D. A.; Singh, S. P.; Mansour, Y.; et al. 1999. Policy gradient methods for reinforce- ment learning with function approximation. In NIPS, 1057-1063.\n\n[ Vesel\u1ef3, Sequence-discriminative training of deep neural networks. In INTERSPEECH. [Vesel\u1ef3 et al. 2013] Vesel\u1ef3, K.; Ghoshal, A.; Burget, L.; and Povey, D. 2013. Sequence-discriminative training of deep neural net- works. In INTERSPEECH, 2345-2349.\n\nSemantically conditioned LSTM-based natural language generation for spoken dialogue systems. [ Wen, arXiv:1508.01745[Wen et al. 2015] Wen, T.-H.; Gasic, M.; Mrksic, N.; Su, P.-H.; Vandyke, D.; and Young, S. 2015. Semantically conditioned LSTM-based natural language generation for spoken dialogue sys- tems. arXiv:1508.01745.\n\nSimple statistical gradientfollowing algorithms for connectionist reinforcement learning. R J Williams, Machine learning. 83-4[Williams 1992] Williams, R. J. 1992. Simple statistical gradient- following algorithms for connectionist reinforcement learning. Machine learning 8(3-4):229-256.\n\nLi Sun, X Yi, R Li, M Sun, arXiv:1604.01537Generating chinese classical poems with RNN encoder-decoder. , Li, and Sun 2016] Yi, X.; Li, R.; and Sun, M. 2016. Gen- erating chinese classical poems with RNN encoder-decoder. arXiv:1604.01537.\n\nChinese poetry generation with recurrent neural networks. X Zhang, M Lapata, EMNLP. and Lapata 2014] Zhang, X., and Lapata, M. 2014. Chinese poetry generation with recurrent neural networks. In EMNLP, 670- 680.\n\nX Zhang, Y Lecun, arXiv:1502.01710Text understanding from scratch. [Zhang and LeCun 2015] Zhang, X., and LeCun, Y. 2015. Text understanding from scratch. arXiv:1502.01710.\n", "annotations": {"author": "[{\"end\":79,\"start\":69},{\"end\":93,\"start\":80},{\"end\":151,\"start\":94},{\"end\":160,\"start\":152},{\"end\":170,\"start\":161},{\"end\":194,\"start\":171}]", "publisher": null, "author_last_name": "[{\"end\":78,\"start\":76},{\"end\":92,\"start\":87},{\"end\":102,\"start\":98},{\"end\":159,\"start\":157}]", "author_first_name": "[{\"end\":75,\"start\":69},{\"end\":86,\"start\":80},{\"end\":97,\"start\":94},{\"end\":156,\"start\":152},{\"end\":169,\"start\":161}]", "author_affiliation": "[{\"end\":150,\"start\":124},{\"end\":193,\"start\":172}]", "title": "[{\"end\":66,\"start\":1},{\"end\":260,\"start\":195}]", "venue": null, "abstract": "[{\"end\":1539,\"start\":262}]", "bib_ref": "[{\"attributes\":{\"ref_id\":\"b10\"},\"end\":1783,\"start\":1750},{\"attributes\":{\"ref_id\":\"b19\"},\"end\":1901,\"start\":1884},{\"attributes\":{\"ref_id\":\"b7\"},\"end\":1913,\"start\":1901},{\"attributes\":{\"ref_id\":\"b13\"},\"end\":2102,\"start\":2083},{\"end\":2631,\"start\":2627},{\"attributes\":{\"ref_id\":\"b10\"},\"end\":2838,\"start\":2825},{\"attributes\":{\"ref_id\":\"b12\"},\"end\":3257,\"start\":3235},{\"attributes\":{\"ref_id\":\"b22\"},\"end\":3402,\"start\":3379},{\"end\":3595,\"start\":3568},{\"attributes\":{\"ref_id\":\"b4\"},\"end\":3988,\"start\":3968},{\"attributes\":{\"ref_id\":\"b10\"},\"end\":4231,\"start\":4218},{\"attributes\":{\"ref_id\":\"b7\"},\"end\":4811,\"start\":4794},{\"attributes\":{\"ref_id\":\"b0\"},\"end\":5123,\"start\":5098},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":5143,\"start\":5123},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":5440,\"start\":5419},{\"attributes\":{\"ref_id\":\"b17\"},\"end\":6033,\"start\":6013},{\"attributes\":{\"ref_id\":\"b13\"},\"end\":6808,\"start\":6788},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":6842,\"start\":6810},{\"end\":7755,\"start\":7727},{\"attributes\":{\"ref_id\":\"b4\"},\"end\":8088,\"start\":8068},{\"attributes\":{\"ref_id\":\"b10\"},\"end\":8239,\"start\":8226},{\"attributes\":{\"ref_id\":\"b7\"},\"end\":8408,\"start\":8391},{\"attributes\":{\"ref_id\":\"b16\"},\"end\":8650,\"start\":8617},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":8681,\"start\":8650},{\"attributes\":{\"ref_id\":\"b0\"},\"end\":9293,\"start\":9268},{\"attributes\":{\"ref_id\":\"b17\"},\"end\":9571,\"start\":9551},{\"attributes\":{\"ref_id\":\"b16\"},\"end\":9782,\"start\":9749},{\"attributes\":{\"ref_id\":\"b14\"},\"end\":9897,\"start\":9877},{\"attributes\":{\"ref_id\":\"b3\"},\"end\":10073,\"start\":10053},{\"end\":11271,\"start\":11243},{\"attributes\":{\"ref_id\":\"b17\"},\"end\":12044,\"start\":12024},{\"attributes\":{\"ref_id\":\"b20\"},\"end\":12939,\"start\":12924},{\"attributes\":{\"ref_id\":\"b14\"},\"end\":13535,\"start\":13515},{\"attributes\":{\"ref_id\":\"b14\"},\"end\":14052,\"start\":14032},{\"attributes\":{\"ref_id\":\"b17\"},\"end\":15084,\"start\":15064},{\"attributes\":{\"ref_id\":\"b5\"},\"end\":15517,\"start\":15505},{\"attributes\":{\"ref_id\":\"b17\"},\"end\":15536,\"start\":15517},{\"attributes\":{\"ref_id\":\"b13\"},\"end\":17668,\"start\":17654},{\"attributes\":{\"ref_id\":\"b10\"},\"end\":17780,\"start\":17748},{\"attributes\":{\"ref_id\":\"b7\"},\"end\":18339,\"start\":18299},{\"attributes\":{\"ref_id\":\"b10\"},\"end\":18462,\"start\":18429},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":18664,\"start\":18632},{\"attributes\":{\"ref_id\":\"b18\"},\"end\":18827,\"start\":18807},{\"attributes\":{\"ref_id\":\"b11\"},\"end\":18873,\"start\":18864},{\"end\":18942,\"start\":18925},{\"attributes\":{\"ref_id\":\"b23\"},\"end\":19189,\"start\":19167},{\"end\":19440,\"start\":19439},{\"attributes\":{\"ref_id\":\"b15\"},\"end\":20229,\"start\":20188},{\"attributes\":{\"ref_id\":\"b14\"},\"end\":23252,\"start\":23229},{\"end\":26367,\"start\":26339},{\"attributes\":{\"ref_id\":\"b12\"},\"end\":27762,\"start\":27740},{\"attributes\":{\"ref_id\":\"b21\"},\"end\":28062,\"start\":28040},{\"attributes\":{\"ref_id\":\"b8\"},\"end\":28337,\"start\":28311},{\"attributes\":{\"ref_id\":\"b12\"},\"end\":29825,\"start\":29805},{\"attributes\":{\"ref_id\":\"b14\"},\"end\":30757,\"start\":30737},{\"attributes\":{\"ref_id\":\"b17\"},\"end\":30976,\"start\":30956},{\"attributes\":{\"ref_id\":\"b10\"},\"end\":32949,\"start\":32916},{\"attributes\":{\"ref_id\":\"b7\"},\"end\":33623,\"start\":33583},{\"attributes\":{\"ref_id\":\"b10\"},\"end\":33894,\"start\":33861},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":34442,\"start\":34410},{\"attributes\":{\"ref_id\":\"b10\"},\"end\":34870,\"start\":34858},{\"attributes\":{\"ref_id\":\"b18\"},\"end\":35019,\"start\":34999},{\"attributes\":{\"ref_id\":\"b11\"},\"end\":35065,\"start\":35056},{\"end\":35134,\"start\":35117},{\"attributes\":{\"ref_id\":\"b23\"},\"end\":35381,\"start\":35359},{\"attributes\":{\"ref_id\":\"b15\"},\"end\":37125,\"start\":37084},{\"end\":37188,\"start\":37185},{\"end\":37192,\"start\":37188},{\"attributes\":{\"ref_id\":\"b5\"},\"end\":37224,\"start\":37221},{\"end\":37228,\"start\":37224},{\"end\":37364,\"start\":37361},{\"end\":37368,\"start\":37364},{\"attributes\":{\"ref_id\":\"b5\"},\"end\":37400,\"start\":37397},{\"end\":37404,\"start\":37400},{\"end\":37458,\"start\":37454},{\"end\":37462,\"start\":37458},{\"attributes\":{\"ref_id\":\"b11\"},\"end\":42429,\"start\":42419}]", "figure": "[{\"attributes\":{\"id\":\"fig_0\"},\"end\":39874,\"start\":39605},{\"attributes\":{\"id\":\"fig_1\"},\"end\":40039,\"start\":39875},{\"attributes\":{\"id\":\"fig_2\"},\"end\":41038,\"start\":40040},{\"attributes\":{\"id\":\"fig_3\"},\"end\":41226,\"start\":41039},{\"attributes\":{\"id\":\"tab_1\",\"type\":\"table\"},\"end\":41631,\"start\":41227},{\"attributes\":{\"id\":\"tab_3\",\"type\":\"table\"},\"end\":41826,\"start\":41632},{\"attributes\":{\"id\":\"tab_4\",\"type\":\"table\"},\"end\":41987,\"start\":41827},{\"attributes\":{\"id\":\"tab_5\",\"type\":\"table\"},\"end\":42140,\"start\":41988},{\"attributes\":{\"id\":\"tab_6\",\"type\":\"table\"},\"end\":42238,\"start\":42141}]", "paragraph": "[{\"end\":3524,\"start\":1555},{\"end\":3989,\"start\":3526},{\"end\":5038,\"start\":3991},{\"end\":6129,\"start\":5040},{\"end\":6604,\"start\":6131},{\"end\":8409,\"start\":6621},{\"end\":9248,\"start\":8411},{\"end\":10388,\"start\":9250},{\"end\":11983,\"start\":10429},{\"end\":12237,\"start\":12014},{\"end\":12812,\"start\":12304},{\"end\":13062,\"start\":12814},{\"end\":13740,\"start\":13114},{\"end\":14275,\"start\":13791},{\"end\":15183,\"start\":14400},{\"end\":15599,\"start\":15337},{\"end\":15996,\"start\":15815},{\"end\":16175,\"start\":16022},{\"end\":16708,\"start\":16177},{\"end\":16727,\"start\":16710},{\"end\":16782,\"start\":16729},{\"end\":16805,\"start\":16784},{\"end\":16986,\"start\":16807},{\"end\":17669,\"start\":16988},{\"end\":18001,\"start\":17708},{\"end\":18114,\"start\":18022},{\"end\":18703,\"start\":18169},{\"end\":19499,\"start\":18746},{\"end\":19775,\"start\":19534},{\"end\":20121,\"start\":19807},{\"end\":20531,\"start\":20123},{\"end\":20631,\"start\":20533},{\"end\":21060,\"start\":20662},{\"end\":22063,\"start\":21082},{\"end\":22488,\"start\":22124},{\"end\":22843,\"start\":22509},{\"end\":23307,\"start\":22845},{\"end\":24153,\"start\":23309},{\"end\":25366,\"start\":24165},{\"end\":26742,\"start\":25381},{\"end\":26928,\"start\":26767},{\"end\":28957,\"start\":26948},{\"end\":29184,\"start\":28959},{\"end\":29618,\"start\":29205},{\"end\":29850,\"start\":29620},{\"end\":29964,\"start\":29852},{\"end\":30853,\"start\":29979},{\"end\":30977,\"start\":30875},{\"end\":31360,\"start\":30979},{\"end\":31576,\"start\":31524},{\"end\":31713,\"start\":31658},{\"end\":31848,\"start\":31715},{\"end\":32687,\"start\":32643},{\"end\":32839,\"start\":32713},{\"end\":33169,\"start\":32841},{\"end\":33288,\"start\":33196},{\"end\":33951,\"start\":33353},{\"end\":34221,\"start\":34149},{\"end\":34481,\"start\":34223},{\"end\":34897,\"start\":34483},{\"end\":35382,\"start\":34899},{\"end\":35857,\"start\":35384},{\"end\":35917,\"start\":35859},{\"end\":36206,\"start\":35956},{\"end\":36573,\"start\":36239},{\"end\":36832,\"start\":36609},{\"end\":37017,\"start\":36834},{\"end\":37276,\"start\":37019},{\"end\":37803,\"start\":37342},{\"end\":38072,\"start\":37829},{\"end\":38523,\"start\":38115},{\"end\":38796,\"start\":38547},{\"end\":39604,\"start\":38798}]", "formula": "[{\"attributes\":{\"id\":\"formula_0\"},\"end\":12303,\"start\":12238},{\"attributes\":{\"id\":\"formula_1\"},\"end\":13113,\"start\":13063},{\"attributes\":{\"id\":\"formula_2\"},\"end\":13790,\"start\":13741},{\"attributes\":{\"id\":\"formula_3\"},\"end\":14399,\"start\":14276},{\"attributes\":{\"id\":\"formula_4\"},\"end\":15247,\"start\":15184},{\"attributes\":{\"id\":\"formula_5\"},\"end\":15336,\"start\":15247},{\"attributes\":{\"id\":\"formula_6\"},\"end\":15814,\"start\":15600},{\"attributes\":{\"id\":\"formula_7\"},\"end\":16021,\"start\":15997},{\"attributes\":{\"id\":\"formula_8\"},\"end\":18021,\"start\":18002},{\"attributes\":{\"id\":\"formula_9\"},\"end\":18168,\"start\":18115},{\"attributes\":{\"id\":\"formula_10\"},\"end\":19533,\"start\":19500},{\"attributes\":{\"id\":\"formula_11\"},\"end\":19806,\"start\":19776},{\"attributes\":{\"id\":\"formula_12\"},\"end\":22123,\"start\":22064},{\"attributes\":{\"id\":\"formula_13\"},\"end\":31523,\"start\":31361},{\"attributes\":{\"id\":\"formula_14\"},\"end\":31657,\"start\":31577},{\"attributes\":{\"id\":\"formula_15\"},\"end\":32642,\"start\":31849},{\"attributes\":{\"id\":\"formula_16\"},\"end\":33195,\"start\":33170},{\"attributes\":{\"id\":\"formula_17\"},\"end\":33352,\"start\":33289},{\"attributes\":{\"id\":\"formula_18\"},\"end\":34148,\"start\":33952},{\"attributes\":{\"id\":\"formula_19\"},\"end\":35955,\"start\":35918},{\"attributes\":{\"id\":\"formula_20\"},\"end\":36238,\"start\":36207},{\"attributes\":{\"id\":\"formula_21\"},\"end\":36608,\"start\":36574},{\"attributes\":{\"id\":\"formula_22\"},\"end\":37336,\"start\":37277},{\"attributes\":{\"id\":\"formula_23\"},\"end\":37828,\"start\":37804},{\"attributes\":{\"id\":\"formula_24\"},\"end\":38114,\"start\":38073}]", "table_ref": "[{\"attributes\":{\"ref_id\":\"tab_1\"},\"end\":24265,\"start\":24258},{\"attributes\":{\"ref_id\":\"tab_3\"},\"end\":29009,\"start\":28995},{\"attributes\":{\"ref_id\":\"tab_5\"},\"end\":29864,\"start\":29857},{\"attributes\":{\"ref_id\":\"tab_6\"},\"end\":36934,\"start\":36927}]", "section_header": "[{\"end\":1553,\"start\":1541},{\"end\":6619,\"start\":6607},{\"end\":10427,\"start\":10391},{\"end\":12012,\"start\":11986},{\"end\":17706,\"start\":17672},{\"end\":18744,\"start\":18706},{\"end\":20660,\"start\":20634},{\"end\":21080,\"start\":21063},{\"end\":22507,\"start\":22491},{\"end\":24163,\"start\":24156},{\"end\":25379,\"start\":25369},{\"end\":26765,\"start\":26745},{\"end\":26946,\"start\":26931},{\"end\":29203,\"start\":29187},{\"end\":29977,\"start\":29967},{\"end\":30873,\"start\":30856},{\"end\":32711,\"start\":32690},{\"end\":37340,\"start\":37338},{\"end\":38545,\"start\":38526},{\"end\":39616,\"start\":39606},{\"end\":39886,\"start\":39876},{\"end\":40051,\"start\":40041},{\"end\":41050,\"start\":41040},{\"end\":41237,\"start\":41228},{\"end\":41642,\"start\":41633},{\"end\":41837,\"start\":41828},{\"end\":41998,\"start\":41989},{\"end\":42151,\"start\":42142}]", "table": "[{\"end\":41631,\"start\":41342},{\"end\":41826,\"start\":41691},{\"end\":41987,\"start\":41885},{\"end\":42140,\"start\":42040},{\"end\":42238,\"start\":42184}]", "figure_caption": "[{\"end\":39874,\"start\":39618},{\"end\":40039,\"start\":39888},{\"end\":41038,\"start\":40053},{\"end\":41226,\"start\":41052},{\"end\":41342,\"start\":41239},{\"end\":41691,\"start\":41644},{\"end\":41885,\"start\":41839},{\"end\":42040,\"start\":42000},{\"end\":42184,\"start\":42153}]", "figure_ref": "[{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":11454,\"start\":11446},{\"attributes\":{\"ref_id\":\"fig_3\"},\"end\":24657,\"start\":24649},{\"attributes\":{\"ref_id\":\"fig_2\"},\"end\":25633,\"start\":25625},{\"attributes\":{\"ref_id\":\"fig_2\"},\"end\":25686,\"start\":25675},{\"attributes\":{\"ref_id\":\"fig_2\"},\"end\":26028,\"start\":26017},{\"attributes\":{\"ref_id\":\"fig_2\"},\"end\":26127,\"start\":26119},{\"attributes\":{\"ref_id\":\"fig_3\"},\"end\":38818,\"start\":38810}]", "bib_author_first_name": "[{\"end\":43182,\"start\":43181},{\"end\":43193,\"start\":43192},{\"end\":43407,\"start\":43406},{\"end\":44277,\"start\":44276},{\"end\":44556,\"start\":44555},{\"end\":45062,\"start\":45061},{\"end\":45064,\"start\":45063},{\"end\":45314,\"start\":45313},{\"end\":45464,\"start\":45458},{\"end\":45478,\"start\":45477},{\"end\":45504,\"start\":45503},{\"end\":45514,\"start\":45513},{\"end\":45527,\"start\":45526},{\"end\":45541,\"start\":45540},{\"end\":46062,\"start\":46058},{\"end\":46076,\"start\":46075},{\"end\":46084,\"start\":46083},{\"end\":46093,\"start\":46092},{\"end\":46448,\"start\":46440},{\"end\":46458,\"start\":46457},{\"end\":46460,\"start\":46459},{\"end\":46476,\"start\":46475},{\"end\":46491,\"start\":46487},{\"end\":46762,\"start\":46761},{\"end\":46776,\"start\":46775},{\"end\":46791,\"start\":46790},{\"end\":47198,\"start\":47197},{\"end\":47205,\"start\":47204},{\"end\":47207,\"start\":47206},{\"end\":47217,\"start\":47216},{\"end\":47221,\"start\":47218},{\"end\":47232,\"start\":47231},{\"end\":47238,\"start\":47237},{\"end\":47245,\"start\":47244},{\"end\":48149,\"start\":48148},{\"end\":48151,\"start\":48150},{\"end\":48162,\"start\":48161},{\"end\":48563,\"start\":48562},{\"end\":48992,\"start\":48987},{\"end\":49019,\"start\":49018},{\"end\":49021,\"start\":49020},{\"end\":49035,\"start\":49034},{\"end\":49044,\"start\":49043},{\"end\":49269,\"start\":49262},{\"end\":49283,\"start\":49281},{\"end\":49285,\"start\":49284},{\"end\":49298,\"start\":49297},{\"end\":49309,\"start\":49308},{\"end\":49315,\"start\":49314},{\"end\":49317,\"start\":49316},{\"end\":49775,\"start\":49774},{\"end\":50118,\"start\":50117},{\"end\":50442,\"start\":50441},{\"end\":50444,\"start\":50443},{\"end\":50643,\"start\":50641},{\"end\":50650,\"start\":50649},{\"end\":50656,\"start\":50655},{\"end\":50662,\"start\":50661},{\"end\":50940,\"start\":50939},{\"end\":50949,\"start\":50948},{\"end\":51094,\"start\":51093},{\"end\":51103,\"start\":51102}]", "bib_author_last_name": "[{\"end\":43190,\"start\":43183},{\"end\":43200,\"start\":43194},{\"end\":43416,\"start\":43408},{\"end\":44284,\"start\":44278},{\"end\":44560,\"start\":44557},{\"end\":45070,\"start\":45065},{\"end\":45325,\"start\":45315},{\"end\":45475,\"start\":45465},{\"end\":45501,\"start\":45479},{\"end\":45511,\"start\":45505},{\"end\":45524,\"start\":45515},{\"end\":45538,\"start\":45528},{\"end\":45548,\"start\":45542},{\"end\":46073,\"start\":46063},{\"end\":46081,\"start\":46077},{\"end\":46090,\"start\":46085},{\"end\":46455,\"start\":46449},{\"end\":46473,\"start\":46461},{\"end\":46485,\"start\":46477},{\"end\":46495,\"start\":46492},{\"end\":46773,\"start\":46763},{\"end\":46788,\"start\":46777},{\"end\":46798,\"start\":46792},{\"end\":47202,\"start\":47199},{\"end\":47214,\"start\":47208},{\"end\":47229,\"start\":47222},{\"end\":47235,\"start\":47233},{\"end\":47242,\"start\":47239},{\"end\":47250,\"start\":47246},{\"end\":47776,\"start\":47769},{\"end\":48159,\"start\":48152},{\"end\":48176,\"start\":48163},{\"end\":48570,\"start\":48564},{\"end\":49003,\"start\":48993},{\"end\":49016,\"start\":49005},{\"end\":49032,\"start\":49022},{\"end\":49041,\"start\":49036},{\"end\":49056,\"start\":49045},{\"end\":49279,\"start\":49270},{\"end\":49295,\"start\":49286},{\"end\":49306,\"start\":49299},{\"end\":49312,\"start\":49310},{\"end\":49568,\"start\":49562},{\"end\":49782,\"start\":49776},{\"end\":50122,\"start\":50119},{\"end\":50453,\"start\":50445},{\"end\":50647,\"start\":50644},{\"end\":50653,\"start\":50651},{\"end\":50659,\"start\":50657},{\"end\":50666,\"start\":50663},{\"end\":50946,\"start\":50941},{\"end\":50956,\"start\":50950},{\"end\":51100,\"start\":51095},{\"end\":51109,\"start\":51104}]", "bib_entry": "[{\"attributes\":{\"id\":\"b0\",\"matched_paper_id\":6103843},\"end\":43346,\"start\":43134},{\"attributes\":{\"doi\":\"arXiv:1607.07086\",\"id\":\"b1\",\"matched_paper_id\":5554756},\"end\":43978,\"start\":43348},{\"attributes\":{\"id\":\"b2\",\"matched_paper_id\":1820089},\"end\":44229,\"start\":43980},{\"attributes\":{\"id\":\"b3\",\"matched_paper_id\":9316331},\"end\":44459,\"start\":44231},{\"attributes\":{\"id\":\"b4\",\"matched_paper_id\":5590763},\"end\":44998,\"start\":44461},{\"attributes\":{\"id\":\"b5\",\"matched_paper_id\":8473536},\"end\":45282,\"start\":45000},{\"attributes\":{\"id\":\"b6\",\"matched_paper_id\":1033682},\"end\":45441,\"start\":45284},{\"attributes\":{\"id\":\"b7\",\"matched_paper_id\":1779661},\"end\":45976,\"start\":45443},{\"attributes\":{\"id\":\"b8\",\"matched_paper_id\":341808},\"end\":46390,\"start\":45978},{\"attributes\":{\"id\":\"b9\",\"matched_paper_id\":2309950},\"end\":46685,\"start\":46392},{\"attributes\":{\"id\":\"b10\",\"matched_paper_id\":17206794},\"end\":47130,\"start\":46687},{\"attributes\":{\"id\":\"b11\",\"matched_paper_id\":16756501},\"end\":47701,\"start\":47132},{\"attributes\":{\"id\":\"b12\",\"matched_paper_id\":10025831},\"end\":48113,\"start\":47703},{\"attributes\":{\"id\":\"b13\",\"matched_paper_id\":5569557},\"end\":48492,\"start\":48115},{\"attributes\":{\"id\":\"b14\",\"matched_paper_id\":515925},\"end\":48983,\"start\":48494},{\"attributes\":{\"id\":\"b15\"},\"end\":49208,\"start\":48985},{\"attributes\":{\"id\":\"b16\",\"matched_paper_id\":7961699},\"end\":49480,\"start\":49210},{\"attributes\":{\"id\":\"b17\",\"matched_paper_id\":1211821},\"end\":49772,\"start\":49482},{\"attributes\":{\"id\":\"b18\"},\"end\":50022,\"start\":49774},{\"attributes\":{\"id\":\"b19\"},\"end\":50349,\"start\":50024},{\"attributes\":{\"id\":\"b20\",\"matched_paper_id\":2332513},\"end\":50639,\"start\":50351},{\"attributes\":{\"id\":\"b21\"},\"end\":50879,\"start\":50641},{\"attributes\":{\"id\":\"b22\",\"matched_paper_id\":12964363},\"end\":51091,\"start\":50881},{\"attributes\":{\"id\":\"b23\"},\"end\":51264,\"start\":51093}]", "bib_title": "[{\"end\":43179,\"start\":43134},{\"end\":43404,\"start\":43348},{\"end\":44053,\"start\":43980},{\"end\":44274,\"start\":44231},{\"end\":44553,\"start\":44461},{\"end\":45059,\"start\":45000},{\"end\":45311,\"start\":45284},{\"end\":45456,\"start\":45443},{\"end\":46056,\"start\":45978},{\"end\":46438,\"start\":46392},{\"end\":46759,\"start\":46687},{\"end\":47195,\"start\":47132},{\"end\":47767,\"start\":47703},{\"end\":48146,\"start\":48115},{\"end\":48560,\"start\":48494},{\"end\":49260,\"start\":49210},{\"end\":49560,\"start\":49482},{\"end\":50439,\"start\":50351},{\"end\":50937,\"start\":50881}]", "bib_author": "[{\"end\":43192,\"start\":43181},{\"end\":43202,\"start\":43192},{\"end\":43418,\"start\":43406},{\"end\":44286,\"start\":44276},{\"end\":44562,\"start\":44555},{\"end\":45072,\"start\":45061},{\"end\":45327,\"start\":45313},{\"end\":45477,\"start\":45458},{\"end\":45503,\"start\":45477},{\"end\":45513,\"start\":45503},{\"end\":45526,\"start\":45513},{\"end\":45540,\"start\":45526},{\"end\":45550,\"start\":45540},{\"end\":46075,\"start\":46058},{\"end\":46083,\"start\":46075},{\"end\":46092,\"start\":46083},{\"end\":46096,\"start\":46092},{\"end\":46457,\"start\":46440},{\"end\":46475,\"start\":46457},{\"end\":46487,\"start\":46475},{\"end\":46497,\"start\":46487},{\"end\":46775,\"start\":46761},{\"end\":46790,\"start\":46775},{\"end\":46800,\"start\":46790},{\"end\":47204,\"start\":47197},{\"end\":47216,\"start\":47204},{\"end\":47231,\"start\":47216},{\"end\":47237,\"start\":47231},{\"end\":47244,\"start\":47237},{\"end\":47252,\"start\":47244},{\"end\":47778,\"start\":47769},{\"end\":48161,\"start\":48148},{\"end\":48178,\"start\":48161},{\"end\":48572,\"start\":48562},{\"end\":49005,\"start\":48987},{\"end\":49018,\"start\":49005},{\"end\":49034,\"start\":49018},{\"end\":49043,\"start\":49034},{\"end\":49058,\"start\":49043},{\"end\":49281,\"start\":49262},{\"end\":49297,\"start\":49281},{\"end\":49308,\"start\":49297},{\"end\":49314,\"start\":49308},{\"end\":49320,\"start\":49314},{\"end\":49570,\"start\":49562},{\"end\":49784,\"start\":49774},{\"end\":50124,\"start\":50117},{\"end\":50455,\"start\":50441},{\"end\":50649,\"start\":50641},{\"end\":50655,\"start\":50649},{\"end\":50661,\"start\":50655},{\"end\":50668,\"start\":50661},{\"end\":50948,\"start\":50939},{\"end\":50958,\"start\":50948},{\"end\":51102,\"start\":51093},{\"end\":51111,\"start\":51102}]", "bib_venue": "[{\"end\":48203,\"start\":48196},{\"end\":43206,\"start\":43202},{\"end\":43518,\"start\":43449},{\"end\":44059,\"start\":44055},{\"end\":44297,\"start\":44286},{\"end\":44566,\"start\":44562},{\"end\":45097,\"start\":45072},{\"end\":45331,\"start\":45327},{\"end\":45616,\"start\":45565},{\"end\":46100,\"start\":46096},{\"end\":46515,\"start\":46497},{\"end\":46834,\"start\":46816},{\"end\":47324,\"start\":47267},{\"end\":47782,\"start\":47778},{\"end\":48194,\"start\":48185},{\"end\":48578,\"start\":48572},{\"end\":49324,\"start\":49320},{\"end\":49574,\"start\":49570},{\"end\":49856,\"start\":49784},{\"end\":50115,\"start\":50024},{\"end\":50471,\"start\":50455},{\"end\":50743,\"start\":50684},{\"end\":50963,\"start\":50958},{\"end\":51158,\"start\":51127}]"}}}, "year": 2023, "month": 12, "day": 17}