{"id": 233423456, "updated": "2023-10-06 04:30:03.526", "metadata": {"title": "Reachability in Vector Addition Systems is Ackermann-complete", "authors": "[{\"first\":\"Wojciech\",\"last\":\"Czerwi'nski\",\"middle\":[]},{\"first\":\"Lukasz\",\"last\":\"Orlikowski\",\"middle\":[]}]", "venue": "ArXiv", "journal": "2021 IEEE 62nd Annual Symposium on Foundations of Computer Science (FOCS)", "publication_date": {"year": 2021, "month": null, "day": null}, "abstract": "Vector Addition Systems and equivalent Petri nets are a well established models of concurrency. The central algorithmic problem for Vector Addition Systems with a long research history is the reachability problem asking whether there exists a run from one given configuration to another. We settle its complexity to be Ackermann-complete thus closing the problem open for 45 years. In particular we prove that the problem is $\\mathcal{F}_k$-hard for Vector Addition Systems with States in dimension $6k$, where $\\mathcal{F}_k$ is the $k$-th complexity class from the hierarchy of fast-growing complexity classes.", "fields_of_study": "[\"Computer Science\"]", "external_ids": {"arxiv": "2104.13866", "mag": null, "acl": null, "pubmed": null, "pubmedcentral": null, "dblp": "conf/focs/CzerwinskiO21", "doi": "10.1109/focs52979.2021.00120"}}, "content": {"source": {"pdf_hash": "3b484d902aa93b71dac972e03952f5e6a78a9bbb", "pdf_src": "Arxiv", "pdf_uri": "[\"https://export.arxiv.org/pdf/2104.13866v4.pdf\"]", "oa_url_match": false, "oa_info": {"license": null, "open_access_url": "http://arxiv.org/pdf/2104.13866", "status": "GREEN"}}, "grobid": {"id": "8d0b39fbc9de4bcfd5ce71fbc91c4fd519f3fc40", "type": "plain-text", "url": "s3://ai2-s2-pdf-extraction-prod/parse-results/s2orc_worker/3b484d902aa93b71dac972e03952f5e6a78a9bbb.txt", "contents": "\nReachability in Vector Addition Systems is Ackermann-complete\n25 Oct 2022 October 27, 2022\n\nWojciech Czerwi\u0144ski \nUniversity of Warsaw\nUniversity of Warsaw\n\n\nLukasz Orlikowski \nUniversity of Warsaw\nUniversity of Warsaw\n\n\nReachability in Vector Addition Systems is Ackermann-complete\n25 Oct 2022 October 27, 2022\nVector Addition Systems and equivalent Petri nets are a well established models of concurrency. The central algorithmic problem for Vector Addition Systems with a long research history is the reachability problem asking whether there exists a run from one given configuration to another. We settle its complexity to be Ackermann-complete thus closing the problem open for 45 years. In particular we prove that the problem is F k -hard for Vector Addition Systems with States in dimension 6k, where F k is the k-th complexity class from the hierarchy of fast-growing complexity classes.\n\nIntroduction\n\nThe model of Vector Addition Systems (VASes) is a fundamental computation model well suited to model concurrent phenomena. Together with essentially equivalent Petri nets it is long studied and has numerous applications in modelling and analysis of computer systems and natural processes. The central algorithmic problem for VASes is the reachability problem, which asks whether there exists a run from one given configuration to another. The reachability problem has a long research history. In 1976 it was shown to be ExpSpace-hard by Lipton [18]. Decidability of the reachability problem was first proven by Mayr in 1981 [19]. The construction was simplified later by Kosaraju [10] and Lambert [11]. Their approach was to use an equivalent model of VASes with states (VASSes) and in certain situations, when the answer to the problem is not clear use a nontrivial decomposition of the system into simpler ones. This technique is called the KLM decomposition after the names of its three inventors. Despite a substantial effort of the community for a long time there was no known upper complexity bound for the VASS reachability problem. There were however important results in the special cases when the dimension is fixed. Haase et al. shown an NP-completeness of the problem in binary encoded one-dimensional VASSes [7]. In dimension one the reachability problem for unary encoded VASSes can be easily shown NL-complete. In 2015 Blondin et al. have shown that the reachability problem for two-dimensional VASSes is PSpace-complete in the case when transitions are encoded in binary [1]. Further improvement came soon after that, a year later Englert et al. proved that the same problem in the case of unary encodings of transitions is NL-complete [5].\n\nIn 2015 Leroux and Schmitz have obtained the first upper complexity bound for the reachability problem proving that it belongs to the cubic-Ackermannian complexity class denoted also F \u03c9 3 [16]. The same authors have improved their result recently in 2019 showing that the problem can be solved in the Ackermann complexity class (denoted F \u03c9 ) [17]. They have actually shown that the reachability problem for k-dimensional VASSes (denoted k-VASSes) can be solved in the complexity class F k+4 , where F i is the hierarchy of complexity classes related to the hierarchy of fast-growing functions F i . In the meanwhile in [2] it was shown that the reachability problem is Tower-hard, recall that Tower = F 3 . Thus the complexity gap was decreased to the gap between Tower and Ackermann complexity classes.\n\nOur contribution In this paper we close the above mentioned complexity gap. Our main result is actually a more detailed hardness result, which depends on the dimension of the input VASS.\n\nTheorem 1. For each k \u2265 3 the reachability problem for 6k-VASSes is F k -hard.\n\nIn particular the reachability problem for 18-VASSes is Tower-hard, as Tower = F 3 . An immediate consequence of Theorem 1 is that reachability problem for VASSes is Ackermannhard. Together with [17] it implies the following.\n\nCorollary 2. The VASS reachability problem is Ackermann-complete.\n\nRecently J\u00e9r\u00f4me Leroux independently has shown Ackermann-hardness of the VASS reachability problem [13]. He relies on similar known techniques, but his new contribution is substantially different than ours.\n\nOrganisation of the paper In Section 2 we introduce preliminary notions. Next, in Section 3 we present known approach to the problem, introduce technical notions necessary to show our result and formulate the main technical Lemma 7. In Section 4 we present the main technique, which led to our result, namely the technique of performing many zero-tests by using only one additional counter. We also present there two examples of application of this technique. The examples are not necessary to understand the main construction, but are interesting in their own and introduce mildly the new technique. In Section 5 we prove the main technical result, namely the Lemma 7. Finally, in Section 6 we present possible future research directions. \n\n\nPreliminaries\n\u2286 Q \u00d7 Z d \u00d7 Q. Configuration of a VASS is a pair (q, v) \u2208 Q \u00d7 N d , usually written q(v). We write Conf = Q \u00d7 N d . Transition (p, t, q) \u2208 T can be fired in the configuration r(v) \u2208 Conf if p = r and v + t \u2208 N d . Then we write p(v) (p,t,q) \u2212\u2192 q(v + t). The effect of transition (p, t, q) is a vector t \u2208 N d , we write eff((p, t, q)) = t. A sequence of triples \u03c1 = (c 1 , t 1 , c \u2032 1 ), (c 2 , t 2 , c \u2032 2 ), . . . , (c n , t n , c \u2032 n ) \u2208 Conf \u00d7 T \u00d7 Conf is a run of VASS V = (Q, T ) if for all i \u2208 [1, n] we have c i t i \u2212\u2192 c \u2032 i and for all i \u2208 [1, n \u2212 1] we have c \u2032 i = c i+1\n. We extend naturally the definition of the effect to runs, eff(\u03c1) = t 1 + . . . + t n . Such a run \u03c1 is said to be from the configuration c 1 to the configuration c \u2032 n . We write then c 1 \u03c1 \u2212\u2192 c \u2032 n slightly overloading the notation or simply\nc 1 \u2212\u2192 c \u2032 n if there is some \u03c1 such that c 1 \u03c1 \u2212\u2192 c \u2032 n .\nWe also say then that the configuration c 1 reaches the configuration c \u2032 n or c \u2032 n is reachable from c 1 . By Reach(src, V ) = {c | src \u2212\u2192 c} we denote the set of all the configurations reachable from configuration src and we call it the reachability set. We also write simply Reach(src) if VASS V is clear from the context. The following problem is the main focus of this paper.\n\n\nReachability problem for VASSes\n\nInput A VASS V and two its configurations src, trg Question Does src \u2212\u2192 trg in V ?\n\nThe size of VASS V , denoted size(V ), is the total number of bits needed to represent states and transitions of V . A Vector Addition System (VAS) is a VASS with only one state (thus the state can be ignored). It is folklore that reachability problems for VASSes and for VASes are interreducible in polynomial time, therefore one can wlog. focus on one of them. In this paper we decide to work with VASSes as they form a more robust model.\n\nCounter programs We often work with VASSes which have a special sequential form: each run of such a VASS performs first some sequence of operations, then some other sequence of operations etc. Such VASSes can be very conveniently described as counter programs. A counter program is a sequence of instructions, each one being either the counter values modifications of the form x 1 += a 1 . . . x d += a d or a loop of the form 1: loop 2: P where P is another counter program. Such a counter program with k instructions and d counters x 1 , . . . , x d represents a d-VASS V with states q 1 , . . . , q k , q k+1 (and some other ones) such that:\n\n\u2022 there are two distinguished states of V , the state q 1 called the source state of V and the state q k+1 called the target state of V ;\n\n\u2022 if the i-th instruction is of the form\nx 1 += a 1 . . . x d += a d then in V there is a transition q i v \u2212\u2192 q i+1 where v[j] = a j if x j += a j is listed in the sequence of increments and v[j] = 0 otherwise;\n\u2022 if the i-th instruction is the loop with body equal to counter program P then in V there are transitions q i 0 d \u2212\u2192 src P and trg P 0 d \u2212\u2192 q i where src P and trg P are source and target states of VASS V P represented by program P\n\n\u2022 if the i-th instruction is the loop then in V there is a transition q i\n0 d \u2212\u2192 q i+1 .\nIf the last instruction is a loop we often omit q k+1 as the only transition incoming to it is q k 0 d \u2212\u2192 q k+1 and treat q k as the target state. x \u2212= 1 y += 1 4: loop 5: x += 2 y \u2212= 1 6: loop 7:\n\nx \u2212= 1 y += 1 8: loop 9:\n\nx += 2 y \u2212= 1 represents the 2-VASS presented below, state names are chosen arbitrary. Notice that in the program there are five instructions: line 1 and loops in lines 2-3, 4-5, 6-7 and 8-9, so the corresponding VASS has five states and can be depicted as follows.\ns p 1 q 1 p 2 q 2 (\u22121, 1) (2, \u22121) (\u22121, 1) (2, \u22121) (1, 0) (0, 0) (0, 0) (0, 0)\nWe often use macro for i := 1 to n do, by which we represent just the counter program in which the body of the for-loop is repeated n times. We do not allow for the use of variable i inside the for-loop.\n\nExample 4. The following counter program uses the macro for. For n = 2 it is equivalent to the above example.\n\n1: x += 1 2: for i := 1 to n do 3:\n\nloop 4:\n\nx \u2212= 1 y += 1 5:\nloop 6:\nx += 2 y \u2212= 1\n\nThe counter program represents the following 2-VASS.\ns p 1 q 1 . . . p n q n (\u22121, 1) (2, \u22121) (\u22121, 1) (2, \u22121) (1, 0) (0, 0) (0, 0) (0, 0) (0, 0)\nFor a counter program V we write u in V \u2212\u2192 u out if there is a run of V starting in counter valuation u in in the source state of V and finishing in counter valuation u out in the target state of V .\n\nFast-growing functions and its complexity classes We introduce here a hierarchy of fastgrowing functions and the corresponding complexity classes. There are many known variants of the definition of the fast-growing function hierarchy. Notice however, that the definition of the corresponding complexity classes F i is robust and does not depend on the small changes in the definitions of the fast-growing hierarchy (for the robustness argument see [20,Section 4]).\n\nLet F 1 (n) = 2n and let F k (n) = F k\u22121 \u2022 . . . \u2022 F k\u22121 n (1) for any k > 1. Therefore we have F 2 (n) = 2 n and F 3 (n) = 2 2 . . . 2 n = Tower(n). We define the function F \u03c9 as F \u03c9 (n) = F n (n). The\n\nAckermann function is defined exactly to be the F \u03c9 function from the fast-growing hierarchy. Based on functions F k we define complexity classes F k also following definitions in [20]. The complexity class F k contains all the problems, which can be solved in time f \u2022 g, where g \u2208 F k and f belongs to levels F i for i < k closed under composition and limited primitive recursion. The idea is that problems in F k can be solved by some easier-then-F k reduction to an F k -solvable problem. For example the class F 3 , also called Tower, contains all the problems, which can be solved in the time Tower(n), but also for example those, which can be solved in time Tower(2 2 n ), as Tower(2 2 n ) = Tower(n) \u2022 2 2 n . It is well known that complexity classes F k have natural complete problems concerning counter automata, which we formulate precisely in Section 3.\n\n\nOutline\n\nHere we outline the proof of our main result, Theorem 1. We introduce gradually intuitions, which led us to this contribution.\n\nCounter automata and F k -hardness We follow some of the ideas of the previous lower bound result showing Tower-hardness [2]. In particular we reduce from a similar problem concerning counter automata. Counter automata are extensions of VASSes in which transitions may have an additional condition that they are fired only if certain counter is equal to exactly zero. Such transitions are called zero-tests. We say that a run of counter automaton is accepting if it starts in the distinguished initial state with all counters equal to zero and finishes in the distinguished accepting state also with all counters equal to zero. A run is N -bounded if all the counters along this run have values not exceeding N . It is a folklore that the following problem is F k -hard for k \u2265 3 (for a similar problem see [20, Section 2.3.2]):\n\nF k -reachability for counter automaton Input Three-counter automaton A, number n \u2208 N Question Does A have an F k (n)-bounded accepting run?\n\nOur aim is to provide a polynomial time reduction, which for each k \u2265 3, three-counter automaton A and number n \u2208 N constructs a 6k-VASS together with source and target configurations src and trg such that src \u2212\u2192 trg iff A has an F k (n)-bounded accepting run. This will finish the proof of Theorem 1.\n\nMultiplication triples As suggested above the main challenge in showing F k -hardness is the need to simulate F k (n)-bounded counters and provide zero-tests for them. We first recall an idea from [2] which reduces the problem to constructing three counters with appropriate properties. On an intuitive level the argument proceeds as follows. Assume a machine (in our case VASS) has access to triples of the form (M, y, M y). Then it can use them to perform exactly y sequences of actions, whatever these actions exactly are, and in each sequence perform exactly M actions. The idea is that in each sequence VASS decreases the second counter by one therefore assuring that the number of sequences is exactly y. It uses the first counter to assure that in each sequence the number of actions is at most M . During each action the third counter is decreased by one, thus each sequence of actions decreases the third counter by at most M . Therefore y sequences of actions can decrease the third counter maximally by M y and moreover if this counter was decreased by exactly M y it means that in every sequence exactly the maximal possible number M of actions was performed. Thus by checking at the end of the whole process whether the second and the third counters are equal to zero we check whether there were exactly y sequences and in all the sequences there were exactly M actions. Below we exploit this idea roughly speaking for simulating zero-tests on counters which are bounded by some value M an arbitrary number y of times. So typically in our application M will be bounded and y is a guessed arbitrarily big number. We also explain below more precisely what kind of VASS we need to prove the F k -hardness of the reachability problem.\n\nWe say that a (d + 3)-VASS V for d \u2265 0 together with its initial configuration c, accepting state q and a set of test counters\nT \u2286 [1, d] is an M -generator if: \u2022 all the configurations of the form q(x, y, z, v) with v \u2208 N d in the set Reach(c, V ) such that v[t] = 0 for all t \u2208 T fulfil v = 0 d , x = M and z = M y; \u2022 for each y \u2208 N we have q(M, y, M y, 0 d ) \u2208 Reach(c, V ).\nWe call the counters x, y, z the output counters. In other words an M -generator generates triples (x, y, z) on its output counters such that we are guaranteed that they are of the form (M, y, M y) and moreover each such triple can be generated. We also say briefly that (V, c, q, t) is an M -generator.\n\nThe following lemma shows that it is enough to focus on the construction of M -generators, as they allow for simulation of M -bounded counters. The same idea and a similar statement was already present in [2], but we prove the lemma in order to be self-contained.\n\nLemma 5. For any d-VASS (V, s, q, T ) with d \u2265 12 and |T | \u2264 4, which is an M -generator, and a three-counter automaton A one can construct in polynomial time a d-VASS V A with configurations src and trg such that src \u2212\u2192 trg iff A has an M -bounded accepting run.\n\nProof. The construction of the d-VASS V A proceeds as follows. The configuration src of V A is the source configuration of the M -generator (V, s, q, T ). We first run the d-VASS (V, s, q, T ), which outputs a triple (c 1 , c 2 , c 3 , 0 d\u22123 ) under the condition that the test counters equal zero. For technical simplicity we assume that the test counters are the ones with the biggest indices. In the rest of the run we do not modify the test counters in order to assure (by setting trg[t] = 0 for all t \u2208 T ) that indeed these test counters equals zero at output of V . Recall that as d \u2265 12 and we have at most 4 test counters then we are at least 8 counters beside the test ones, namely: c 1 , . . . , c 8 . We need to simulate three counters of the automaton A, say counters x, y and z. In order to assure that each run of V A corresponds to an M -bounded run of A we add for each counter c another counterc such that at any time after an initialisation phase it holds c +c = M . We will use the counters c 1 , c 4 and c 5 to simulate counters x, y and z, respectively and the counters c 6 , c 7 and c 8 to simulate countersx,\u0233 andz, respectively. We thus need to set c 6 = c 7 = c 8 = M in the initialisation phase, which is realised by the following program fragment\n1: c 2 \u2212= 1 2: loop 3: c 1 \u2212= 1 c 3 \u2212= 1 c 6 += 1 c 7 += 1 c 8 += 1\nCounter c 2 is decreased here by 1, while counter c 3 is decreased by at most value of c 1 , which is M . As explained before the only option for counter c 3 to reach value 0 at the end of the run is to match each decrease of c 2 by 1 by a decrease by M . Therefore we are guaranteed that in any run reaching configuration trg the initialisation phase indeed setsx =\u0233 =z = M and also we have x = y = z = 0 after this phase. The configuration trg of V A is defined as follows: the state corresponds to the accepting state of three-counter automaton A, eight first counter values correspond to counter values of accepting configuration of A, namely (c 1 , . . . , c 8 ) = (0 5 , M, M, M ) and all the other counters of V A are equal zero in the configuration trg.\n\nNext VASS V A simulates operations of counter automaton A, namely increments, decrements and zero-tests. Concretely speaking there is a copy of A inside of V A with slightly modified transitions. Simulation of operation c += a (for both positive and negative a) in A is straightforward, we add operations c += a andc \u2212= a to V A . It is more challenging to simulate zero-test(c) in A, we use the pair of counters (c 2 , c 3 ) = (b, M b) generated by the M -generator for that. Recall that using this pair we are able to perform exactly b sequences of exactly M actions. The idea is that for checking whether c = 0 (and thusc = M ) we first transfer value ofc to c (i.e. decrementc and increment c) and simultaneously decrement c 3 . Then we transfer value of c back toc also decrementing c 3 . In that way we can decrement c 3 at most 2M times and decrement by exactly 2M can happen only if the initial value of c was zero and also final value of c is zero as well. If we decrement c 2 by 2 we assure that indeed c 3 needs to be decremented by 2M and hence the zero-test(c) can be simulated as follows. As increments, decrements and zero-tests of A can be simulated faithfully by V A one can see that runs from src to trg of V A are in one-to-one correspondence with M -bounded runs of automaton A.\n\nOur approach is therefore to construct 6k-VASSes of not too big size which are F k (n)generators.\n\nAmplifiers At this moment it is natural to introduce a notion of amplifier, which can be used to produce an N -generator from an M -generator for N much bigger than M . For a function f : N \u2192 N we say that a d-VASS V together with its input state p in , output state p out and set of test counters T \u2286 [1, d] is an f -amplifier if the following holds\n\u2022 if p in (M, x, M x, 0 d\u22123 ) \u2212\u2192 p out (v, b, y, z) for v \u2208 N d with v[T ] = 0 then v = 0 d\u22123 , b = f (M )\nand z = by; and\n\u2022 for each y \u2208 N there exists an x \u2208 N such that p in (M, x, M x, 0 d\u22123 ) \u2212\u2192 p out (0 d\u22123 , f (M ), y, f (M )\u00b7 y).\nIn other words, intuitively, if an amplifier inputs triples (M, x, M x) it outputs triples (f (M ), y, f (M )\u00b7 y) and moreover each such triple can be output if an appropriate triple is delivered to the input.\n\nIn the above case we call the first three counters the input counters and the last three counters the output counters, but in general we do not impose any order of the input and output counters. Notice that notions of amplifier and generators are very much connected as suggested by the following claim. \nv, x, y, z) with v \u2208 N d\u22123 such that v[t] = 0 for all test counters t \u2208 T fulfil v = 0 d\u22123 , x = f (M ), z = f (M ) \u00b7 y\nand additionally such configurations for all y \u2208 N can be reached, which finishes the proof.\n\nObserve that taking into account Lemmas 5 and 6 in order to prove Theorem 1 it is enough to show the following lemma.\n\nLemma 7. For each k \u2265 1 there exists a 6k-VASS of size exponential in k (at most C k for some constant C \u2208 N) which is an F k -amplifier with at most four test counters.\n\nThe advantage of amplifiers over generators is that we can easily compose them. Notice that having two VASSes: a (d 1 + 3)-VASS being an f 1 -amplifier and a (d 2 + 3)-VASS being an f 2 -amplifier it is easy to construct a (d 1 + d 2 + 3)-VASS being an f 1 \u2022 f 2 -amplifier just by using sequential composition of the f 2 -amplifier and f 1 -amplifier. However, the drawback of the construction is that the dimension grows substantially. The main challenge in the proof of Lemma 7 is to build amplifiers for much bigger functions from amplifiers for much smaller functions without adding too many new counters. The proof of Lemma 7 is presented in Section 5.\n\nBig counter values In order to prove F k -hardness for VASS reachability problem one should in particular construct VASSes V k in which the shortest run from some source configuration to some target configuration has length at least F k (n), where n = size(V k ). Notice that some configuration on such a run needs to have some counters of value at least roughly F k (n). It has been known since a long time that such VASSes exist and it is relatively easy to construct them. The hard part is to design a VASS, in which every run reaches high counter values and on a very high level of abstraction one can see our construction as mainly achieving this goal.\n\nBelow we present an example family of VASSes V k in growing dimension k + 1 with reachability sets being finite, but which can reach values of counters up to F k (n). Knowing this construction is absolutely not needed to understand our construction and this part of the paper can be omitted during the reading without any harm. We present it however as we believe that it helps to distinguish which parts of the proof of Lemma 7 are pretty standard and which were the real challenge. In short words the real challenge was to force the runs to have values zero at some precise points, we show in Section 4 in details how to guarantee this.\n\nFor d = 2 we have the following 3-VASS V 2 . x 1 \u2212= 1 x 2 += 1 6:\nx 3 \u2212= 1\nIn general we construct (k+1)-dimensional VASS V k in the following way from k-dimensional VASS V k\u22121 . x 1 \u2212= 1 x k += 1 5:\nx k+1 \u2212= 1 x 3 += 1 . . . x k\u22121 += 1\nIt is quite easy to see that the reachability set of V k is finite when starting from any counter valuation and one can show it easily by induction on k. Therefore it remains to show the following proposition.\nProposition 8. For each k \u2208 N it holds (1, 0, 1 k\u22122 , m \u2212 1) V k \u2212\u2192 (F k (m), 0 k ).\nProof. We show the proposition by induction on k. We start the induction from k = 2, one can easily see that indeed (1, 0, m \u2212 1) 0, 0). For the induction step assume that\nV 2 \u2212\u2192 (2 m ,(1, 0, 1 k\u22123 , m \u2212 1) V k\u22121 \u2212\u2192 (F k\u22121 (m), 0 k\u22121 )\n. We therefore have for any \u2113 \u2208 N that\n(1, 0, 1 k\u22123 , m \u2212 1, \u2113) (2) \u2212\u2192 (F k\u22121 (m), 0 k\u22121 , \u2113) (3\u22124) \u2212\u2192 (1, 0 k\u22122 , F k\u22121 (m) \u2212 1, \u2113) (5) \u2212\u2192 (1, 0, 1 k\u22123 , F k\u22121 (m) \u2212 1, \u2113 \u2212 1),\nwhere by \n(1, 0, 1 k\u22123 , 1, m \u2212 1) (2\u22125) \u2212\u2192 (1, 0, 1 k\u22123 , F k\u22121 (1) \u2212 1, m \u2212 1) (2\u22125) \u2212\u2192 (1, 0, 1 k\u22123 , F k\u22121 \u2022 F k\u22121 (1) \u2212 1, m \u2212 2) (2\u22125) \u2212\u2192 . . . (2\u22125) \u2212\u2192 (1, 0, 1 k\u22123 , F k\u22121 \u2022 . . . \u2022 F k\u22121 m\u22121 (1) \u2212 1, 0) (2) \u2212\u2192 (F k\u22121 \u2022 . . . \u2022 F k\u22121 m (1), 0 k ) = (F k (m), 0 k ).\nwhich finishes the induction step.\n\n\nZero-tests\n\nThe main contribution of this paper is a novel technique of zero-testing, which allows for performing many zero-tests simultaneously. This will be the key technique in the proof of Lemma 7. We prefer to introduce it mildly before using it in Section 5 and present first how it works on a few simple examples. Already on these examples its power is visible.\n\nExample 9. Imagine first that we are given a VASS run \u03c1 and we want to test some counter x for being exactly zero in three moments along this run: in configurations c 1 , c 2 and c 3 . Assume that value of x is zero at the beginning of \u03c1. Let value of x in these configurations be x 1 , x 2 and x 3 , respectively. A naive way to solve this problem is to add three new counters, which are copies of x, but the first one stops copying effects of transitions on x in c 1 , the second one in c 2 and the third one in c 3 . In that way the additional counters keep values of x 1 , x 2 and x 3 till the end of the run and can be checked there for zero (just by setting the target configuration to zero on these counters). We show here how to perform these three zero-tests using just one additional counter, we call it the controlling counter and say that it controls the other counters. Let \u03c1 1 be the part of \u03c1 before c 1 , \u03c1 2 the part in between c 1 and c 2 and \u03c1 3 the part in between c 2 and c 3 . Let y 1 , y 2 and y 3 be the effects of \u03c1 1 , \u03c1 2 and \u03c1 3 on x, respectively. We can easily see that x 1 = y 1 , x 2 = y 1 + y 2 and x 3 = y 1 + y 2 + y 3 . Notice that we can check whether all the x 1 , x 2 and x 3 are equal to zero by checking whether its sum x 1 + x 2 + x 3 equals zero, as all the x i are nonnegative. We have x 1 + x 2 + x 3 = 3y 1 + 2y 2 + y 3 , so it is enough to check whether 3y 1 + 2y 2 + y 3 = 0. Instead of adding three new counters we add only one, which computes the value 3y 1 + 2y 2 + y 3 . We realise it in the following way. Every increase of x by a during \u03c1 1 is reflected by an increase of the controlling counter by 3a. Similarly, an increase of x by a on \u03c1 2 is reflected by an increase of the controlling counter by 2a and on \u03c1 3 just by a. After configuration c 3 the controlling counter is not modified. Therefore testing the controlling counter for 0 at the end of the run (by setting appropriately the target configuration on that counter) checks indeed whether\nx 1 = x 2 = x 3 = 0.\nThis approach can be generalised to more zero-tests and moreover to zero-tests on different counters, as shown by the following lemma. In the lemma the aim of the last (controlling) counter is to allow for zero-testing the i-th counter on configurations with indices in S i , for all i \u2208 [1, d]. Notice also that configurations c i are not necessarily all the configurations on the run \u03c1, but some subset, which can be restricted only to those in which we want to perform some zero-test.  Let S 1 , . . . , S d \u2286 [0, n] be the sets of indices of c j , in which we want to zero-test counters numbered 1, . . . , d, respectively and let N j,i = |{k \u2265 j | k \u2208 S i }| for i \u2208 [1, d], j \u2208 [0, n] be the number of zero-tests, which we want to perform on the i-th counter starting from configuration c j (in other words after the run \u03c1 j for j > 0). Then if:\n(1) src[d + 1] = d i=1 N 0,i \u00b7 src[i];\n(2) for each j \u2208 [1, n] we have eff(\u03c1 j , d Before we proceed with the proof of Lemma 10 we comment a bit on the lemma and see how the example above fulfils its conditions. The condition (1) assures that at the configuration src the controlling (d + 1)-th counter is appropriately related to the other ones. In the example it is trivially fulfilled by the equation 0 = 0. The condition (2) assures that the effect of each part of the run \u03c1 is appropriately reflected by the controlling counter. On the example it is fulfilled as each change of the x-counter by a on \u03c1 1 , \u03c1 2 and \u03c1 3 is reflected by the change of controlling counter by 3a, 2a and a, respectively. Notice that in the case of our example the condition (2) is satisfied even if we set \u03c1 j to be single transitions and n equals length of the run. However in many applications of Lemma 10 condition (2) is true only if we set \u03c1 j to be some groups of transitions forming a longer sub-run of \u03c1, this is why we formulate the lemma in such a stronger version. Condition (3) assures that the controlling counter is indeed zero at the end of the run.\n+ 1) = d i=1 N j,i \u00b7 eff(\u03c1 j ,\nProof. Notice first that in order to check whether for each i \u2208 Below we present two examples of the application of Lemma 10: an example of a 3-VASS with transitions represented in unary (shortly unary 3-VASS) with exponential shortest run and an example of a 7-VASS with transitions represented in binary (shortly binary 7-VASS) with doubly-exponential shortest run. Low dimensional unary VASSes with exponential shortest runs and binary VASSes with doubly-exponential shortest run have been presented in [3]. We present here the new examples in order to illustrate our technique, but also to provide another set of nontrivial VASS examples in low dimensions.\n\nExample 11. We consider the 2-VASS from Example 4 with one controlling counter added, the counter c. We analyse runs starting from all zeros and finishing in all zeros. We will observe that adding the controlling counter forces the loops in lines 3-4 (or states p i ) and in lines 5-6 (or states q i ) to be performed maximal possible number of times, namely the x counter is zero when run leaves line 4 and the y counter is zero when run leaves line 6. We have added comments in the program below to emphasise where which counters are forced to be zero. This forces the run to visit configuration (2 n , 0, 0) in line 6 and therefore to be exponential in VASS size. 1: x += 1 c += n 2: for i := 1 to n do x += 2 y \u2212= 1 c += n \u2212 i \u2212 1 // zero-test on y after the loop 7: loop 8:\n\nx \u2212= 1 To see the comparison with Example 4 we also present our VASS in a more traditional way. For simplicity we do not write labels if they are vectors with all entries being zero.\ns p 1 q 1 . . . p n q n t (\u22121, 1, 0) (2, \u22121, n \u2212 2) (\u22121, 1, 0) (2, \u22121, \u22121) (\u22121, 0, 0) (1, 0, n)\nAny run from s(0, 0, 0) to t(0, 0, 0) crosses through states p 1 , . . . , q n and therefore can be divided into 2n + 1 parts \u03c1 1 , . . . , \u03c1 2n+1 by cutting in the last configurations in appropriate states. We want the counter x to be zero-tested in states p 1 , . . . , p n and counter y to be zero-tested in states q 1 , . . . , q n , so we set S 1 = {1, 3, . . . , 2n \u2212 1} and S 2 = {2, 4, . . . , 2n}. One can easily check that the considered VASS fulfils conditions of Lemma 10. Condition (1) is trivially fulfilled as 0 = 0 and condition (3) is fulfilled as we demand to reach t(0, 0, 0), so the controlling counter is equal to zero at the target configuration. In order to see that condition (2) is also fulfilled we show that it is even fulfilled for each transition (not only for runs in between of zero-tests). Let us consider four lines: 1, 4, 6 and 8. In line 1 counter x is awaiting n zero-tests, so increase of x by 1 should be reflected by increase of c by n. In line 4 counter x is awaiting (n + 1) \u2212 i zero-tests and so similarly counter y. Therefore in line 4 counter c should be increased by (n + 1 \u2212 i) \u00b7 1 + (n + 1 \u2212 i) \u00b7 (\u22121) = 0. In line 6 counter x is awaiting n \u2212 i zero-tests, while counter y is awaiting (n + 1) \u2212 i zero-tests, therefore counter c should be increased here by (n \u2212 i) \u00b7 2 + (n + 1 \u2212 i) \u00b7 (\u22121) = 2n \u2212 2i \u2212 n \u2212 1 + i = n \u2212 1 \u2212 i. In line 8 counter x is not awaiting for any zero-test, so counter c should not be changed because of its changes. Summarising all of that we see that c = 0 at the target configuration forces the run to perform maximal number of times loops in the states p i and q i and therefore there is only one run of our 3-VASS, which in particular visits the configuration q n (2 n , 0, 0) and has exponential length.\n\nExample 12. Here we present an example of a binary 7-VASS with doubly-exponential shortest run. This result is not needed in the proof of Lemma 7, we show it however in order to illustrate how to use the technique of performing many zero-tests in the case when the number of zerotests is bigger then the size of the VASS. In Example 11 the number of zero-tests both on x and y counters was comparable to the size of the VASS. Therefore different behaviour of controlling c in different phases of the run could be implemented by different behaviour of c in different states. In the current example this is not possible. Let us recall the well known Hopcroft-Pansiot example of a 3-VASS from [9]. As n is given in binary it can have a doubly-exponential run.\n\n1: x += 1 z += n 2: loop 3:\n\nloop 4:\n\nx \u2212= 1 y += 1 5:\nloop 6:\nx += 2 y \u2212= 1 7:\n\nz \u2212= 1 We can observe that there is a run which finishes with counter values (x, y, z) = (2 n , 0, 0) and 2 n is doubly-exponential wrt. the VASS size. Notice however that nothing forces the run to reach so high value of x. Our aim is now to add a controlling counter c which would force the loops in lines 3-4 and in lines 5-6 to be applied maximal number of times. In the case when z = 0 at the end of the run we know that the main loop in lines 2-7 is executed exactly n times, therefore we want to test both x and y exactly n times for zero. It is easy to observe that in lines 3-4 both counters are awaiting z zero-tests and in lines 5-6 counter x is awaiting (z \u2212 1) zero-tests, while y is awaiting z zero-tests. Therefore the correct updates on controlling counter c should be: increase by 0 in line 4, and increase by (z \u2212 1) \u00b7 2 + z \u00b7 (\u22121) = z \u2212 2 in line 6. The counter program thus should be the following. x += 2 y \u2212= 1 c += z \u2212 2 7: z \u2212= 1 One can however easily observe that the operation c += z \u2212 2 is not a valid VASS operation, as z \u2212 2 is not a constant. Fortunately counter z is a counter bounded by n and in that case we can implement this operation using only VASS operations. Very intuitively in order to implement c += z it is enough to decrement z from its current value to value zero and simultaneously increment value of counter c. In order to be able to restore the original value of z and to be able to check whether z reached zero we need to add auxiliary counters. We add three additional counters z \u2032 ,z andz \u2032 such that all the time after line 1 we keep invariants z +z = n and z \u2032 +z \u2032 = n. Notice that with those invariants we can easily check whether z = 0 just by performing two operations:z \u2212= n and thenz += n, similarly we test whether z \u2032 = 0. We introduce a macro for these operations here, writing zero-test(z) and zero-test(z \u2032 ). These zero-tests should not be confused with zero-tests on counters x and y. Notice that they are of a very different nature and we implement zero-test(z) without using controlling counter c, but by the use of the fact that z is n-bounded.\n\nTherefore in line 1 we have now additionally operationz \u2032 + = n, in line 7 additionally operationz += 1 and in line 6 instead of operation c += z \u2212 2 we place the following code of VASS \nc += 1 z \u2212= 1 z \u2032 += 1 3:z += 1z \u2032 \u2212= 1 4: zero-test(z) 5: loop 6: z += 1 z \u2032 \u2212= 1 7:z \u2212= 1z \u2032 += 1 8: zero-test(z \u2032 ) 9: c \u2212= 2\nThe aim of line 2 is to perform c += z and keep z + z \u2032 constant. We need to keep z + z \u2032 constant to be able to reconstruct later the original value of z. In line 3 we updatez andz \u2032 to keep the invariants and in line 4 we check whether indeed we have added everything from z to c. Lines 5-8 are devoted to moving values of z and z \u2032 back to original ones, while the line 9 takes care of subtracting 2 from c, as our aim is to perform c += z \u2212 2, not c += z.\n\nOne can easily check that Lemma 10 applies to our situation when one defines parts of the run \u03c1 j corresponding to the single lines of the considered 7-VASS. Therefore if we demand c = 0 and z = 0 after the line 7 of the 7-VASS then both the loops in lines 3-4 and in lines 5-6 have to be executed maximally each time. Notice that here we need to consider run fragments \u03c1 j in Lemma 10 to be longer than single transitions. For example all the operations x + = 2, y \u2212= 1 and c += z \u2212 2 should be contained in one fragment \u03c1 j and operation c += z \u2212 2 is implemented as long sequence of transitions, as presented above. Summarising, by Lemma 10 at the end of the run we have x = 2 n , which is indeed doubly-exponential in VASS size since n is encoded in binary.\n\n\nAmplifiers\n\nThis section is devoted to the proof of Lemma 7. Recall that we need to show that for each k \u2265 1 there exists a 6k-VASS of size exponential in k which is an F k -amplifier. We prove it by induction on k with induction assumption additionally strengthened by the fact that the test counters include all the input counters and at most one additional counter. For k = 1 it is not hard to construct a 6-VASS, which is an F 1 -amplifier, recall that F 1 (n) = 2n. The following VASS realises our goal, the input counters are x 1 , x 2 and x 3 , the output counters are x 4 , x 5 and x 6 and the test counters are only the input counters.\n\n\n1: loop\n\n2:\nx 2 \u2212= 2 x 5 += 1 3:\nloop 4:\nx 1 \u2212= 1 x 4 += 1 x 3 \u2212= 1 x 6 += 1 5: loop 6: x 1 += 1 x 4 \u2212= 1 x 3 \u2212= 1 x 6 += 1 7: x 2 \u2212= 1 8: loop\n9:\nx 1 \u2212= 1 x 4 += 2 x 3 \u2212= 1\nLines 1-6 are devoted to set the correct values of x 5 and x 6 , while lines 7-9 set the correct value of x 4 . Assume that at the input we have (x 1 , x 2 , x 3 ) = (n, x, nx) and recall that initially x 4 = x 5 = x 6 = 0. The proof idea is similar as in the proof of Lemma 5, triple (n, x, nx) is used to perform exactly x sequences of exactly n actions. Observe first that until line 8 the sum x 1 + x 4 does not change, thus we have x 1 + x 4 = n. This means that loops in lines 3-4, 5-6 and 8-9 all can be fired at most n times. Each such a loop corresponds to one operation x 2 \u2212= 1 (in lines 2 or 7) and at most n operations x 3 \u2212= 1 (in lines 4, 6 and 9). This means that in order to reach x 3 = 0 at the end of the run each loop has to be fired exactly n times. Moreover the loop in lines 1-6 has to be fired exactly x\u22121 2 times, as the final value of x 2 also needs to be 0. Therefore final values of (x 4 , x 5 , x 6 ) are (2n, x\u22121 2 , 2n \u00b7 x\u22121 2 ), which finishes the proof for k = 1. For an induction step assume that V k\u22121 is a (6k \u2212 6)-dimensional VASS of size exponential in k \u2212 1 and an F k\u22121 -amplifier. We aim at constructing a 6k-VASS, which is an F k -amplifier and its size is at most C \u00b7 size(V k\u22121 ) for some constant C which does not depend on k. The idea to obtain F k -amplifier is the following: start from the triple (1, x, x) and apply the F k\u22121 -amplifier n times in a row, where n is the input value. The main challenge is to achieve it without adding new counters for each application. We show here how we obtain it by adding only six new counters. We crucially rely on the Lemma 10.\n\nThe F k -amplifier has the following 6k counters: input triple (i 1 , i 2 , i 3 ), output triple (o 1 , o 2 , o 3 ), an auxiliary triple (s 1 , s 2 , s 3 ), controlling counter c, two auxiliary counters y 1 , y 2 and 6k \u2212 12 counters, which are the counters of V k\u22121 being neither its input nor output counters. The triple (s 1 , s 2 , s 3 ) will be used inside the F k -amplifier as an input triple of a F k\u22121 -amplifier. The test counters are the input counters (i 1 , i 2 , i 3 ) and the controlling counter c.\n\nWe first present the code for an F k -amplifier V k , which uses illegal constructions like \"for i:= 1 to n do\" or \"c += z\" where z is current value of another counter, in order to provide an intuition what V k does. Then we show how we can implement the mentioned constructions using only legal VASS operations. Assume that input counter values on (i 1 , i 2 , i 3 ) are (n, x, nx).\n\nThus we aim at producing on output counters (\no 1 , o 2 , o 3 ) values (F k (n), m, F k (n) \u00b7 m) for some m \u2208 N. Let V [i]\nk\u22121 be the modified version of V k\u22121 in which the controlling counter c is also appropriately modified: each modification x += 1 (or x \u2212= 1) for counter x being any output or test counter of V k\u22121 is accompanied with a modification c += (n+1)\u2212i (or c \u2212= (n+1)\u2212i). It is important to emphasise that all the counters of V k\u22121 and o j counters is tested exactly n times in the program. In order to fulfil condition (2) of Lemma 10 we have the following modifications of counter c in our program. In line 1 we update c += n and in line 3 we have c += 2n, as counters s 1 , s 2 and s 3 are here modified and all of them await n tests. In lines 7, 9 and 11 each counter s j awaits for n \u2212 i tests, while counter o j awaits for n + 1 \u2212 i tests, this is why counter c is increased here by \u22121 = (n \u2212 i) \u00b7 1 + (n + 1 \u2212 i) \u00b7 (\u22121) = \u22121. It is easy to verify conditions (1) and (3) of Lemma 10. Indeed, recall that in order to check whether the considered program is an F k -amplifier we consider only runs starting with values of all the counters of V  (1)) and finishing with counter value of controlling counter c being zero (which guarantees condition (3)). So counter c together with the counters it controls indeed fulfil conditions of the Lemma 10. Therefore amplifier V k\u22121 computes correctly its output values and values of o j are correctly transferred to counters s j . Thus using the induction assumption stating that V k\u22121 is an F k\u22121 -amplifier we can easily show that in the ith iteration of the for-loop we indeed have values of (o 1 , o 2 , o 3 ) equal to (F\n(i) k\u22121 (1), a i , F (i) k\u22121 (1)\u00b7a i )\nfor some a i \u2208 N guessed nondeterministically. Therefore after n iterations of the for-loop final values of (o 1 , o 2 , o 3 ) are (F (n) k\u22121 (1), a n , F (n) k\u22121 (1) \u00b7 a n ) = (F k (n), a n , F k (n) \u00b7 a n ) under the condition that the controlling counter and the input counters are equal to zero at the end of the run. So indeed V k is an F k -amplifier with output counters o 1 , o 2 and o 3 and test counters i 1 , i 2 , i 3 and c.\n\nIt remains to show how the for-loop and operations c + = (n + 1) \u2212 i are implemented. Intuitively speaking it is not problematic because we have an access to the triple of input counters (i 1 , i 2 , i 3 ) fulfilling i 1 i 2 = i 3 and n = i 1 . Therefore using the idea of multiplication triples we can allow for zero-testing counters bounded by n and thus also for the needed operations. Below we describe these constructions in detail.\n\nFor the implementation of the needed operations we use the input counters (i 1 , i 2 , i 3 ) and auxiliary counters y 1 and y 2 . Assume that the for-loop has the following shape 1: for i := 1 to n do 2: body and inside the body we have operations c += (n + 1) \u2212 i. The initial value of i 1 equals n. Below we implement the for-loop in such a way that all the time counter value of i 1 is equal to (n + 1) \u2212 i. So in order to perform c += (n + 1) \u2212 i it is enough to implement c += i 1 . \ni 1 \u2212= 1 y 2 += 1\nAs i 1 is one of the test counters, we are guaranteed that the loop indeed will be iterated exactly n times. Now we show how to implement operation c += i 1 , which together shows how to implement c += n in lines 1 and 3 and c += (n + 1) \u2212 i in the i-th iteration of the for-loop. Operation c \u2212 = (n + 1) \u2212 i is implemented totally analogously to c + = (n + 1) \u2212 i. The implementation works similarly as in the Example 12, but here we show how to implement c += (n + 1) \u2212 i using only two, not three, auxiliary counters. At the beginning we have i 1 = n, y 1 = y 2 = 0. We will keep the invariant i 1 + y 1 + y 2 = n. Notice that in the i-th iteration values of counters are (i 1 , y 1 , y 2 ) = (n + 1 \u2212 i, 0, i \u2212 1). We implement the increment c += (n + 1) \u2212 i as follows. \ni 1 \u2212= 1 y 1 += 1 c += 1 3: zero-test(i 1 ) 4: loop 5: i 1 += 1 y 1 \u2212= 1 6: zero-test(y 1 )\nIf zero-tests in lines 3 and 6 are performed correctly then it is easy to see that when the above program fragment starts in valuation (i 1 , y 1 ) = (n+1\u2212i, 0) it also finishes in the same valuation, but a side effect is the increment c += i 1 . Thus it remains to show that we can implement zero-tests or counters i 1 and y 1 . We present how to perform zero-test(i 1 ), the zero-test(y 1 ) is performed analogously with roles of i 1 and y 1 swapped. Notice that counter i 1 is here bounded by n, so testing it for zero is much simpler than testing counters s i or o i above. On the other hand zero-testing of i 1 is more complicated than the zero-tests in Example 12, as there the tested counters were bounded by the size of VASS transitions. Here the tested counters are also bounded by n, but n is arbitrary, so in order to implement zero-tests we need to use triples (i 1 , i 2 , i 3 ). Additional technical complication is caused by the fact that we want to optimise the number of the auxiliary counters from three to two. The zero-test(i 1 ) is performed as follows. We aim to show that if i 1 + y 1 + y 2 = n then the total effect of loops in lines 2-8 on the counter i 3 is the decrease by at most 2n and the decrease is exactly 2n if and only if initially i 1 = 0. As in line 1 counter i 2 is decreased by 2 then counter i 3 have to be decreased by exactly 2n in the rest of the program fragment, as finally values of both i 2 and i 3 need to be zero. Therefore it remains to argue about the decrease of counter i 3 . The easiest way to see this is to see the loop in lines 2-3 as transferring value of counter y 1 to counter i 1 , but maybe not fully. We write it y 1 \u2192 i 1 . Similarly next loops correspond to transfers y 2 \u2192 y 1 , y 1 \u2192 y 2 and i 1 \u2192 y 1 , each of the transfers may be not fully realised. The total decrease on c 3 equals exactly the total amount of value transferred during all the four loops. Notice now that the value of original y 2 can be used in at most two transfers: y 2 \u2192 y 1 , y 1 \u2192 y 2 . Similarly the value of original y 1 can be used either only in y 1 \u2192 y 2 or in two transfers y 1 \u2192 i 1 and i 1 \u2192 y 1 . Value of original i 1 can be used only in the transfer i 1 \u2192 y 2 . Therefore the total amount of the transfer equals at most 2y 1 + 2y 2 + i 1 and this equals 2n only if i 1 = 0. Moreover in order to obtain the transfer of exactly 2n we need to perform all the transfers fully. Therefore one can easily observe that in that case after the zero-test(i 1 ) values of counters i 1 , y 1 and y 2 come back to the same values as before the zero-test(i 1 ). This finishes the proof that the above fragment faithfully implements zero-test(i 1 ).\n\nIn order to finish the proof of Lemma 7 it is enough to observe that size(V k ) is bounded by C \u00b7 size(V k\u22121 ) for some constant C \u2208 N. Indeed V k was obtained from V k\u22121 by adding several new lines and for each operation x += 1 (or x \u2212= 1) for any controlled counter x adding an appropriate operation c += (n + 1) \u2212 i (or c \u2212= (n + 1) \u2212 i). Implementing each operation on counter c requires a few new lines which is responsible by multiplying the size by some constant, but not more. Thus altogether indeed size(V k ) \u2264 C \u00b7 size(V k\u22121 ) which finishes the proof.\n\n\nFuture research\n\nWe have settled the complexity of the reachability problem for VASSes, but there are still many intriguing questions in this topic. Here we present some, which we think need investigation in the future works of our community.\n\nWe still lack understanding of VASSes in small dimensions. The most striking example is the reachability problem for 3-VASSes, where the complexity gap is between PSpace-hardness (inherited from dimension 2 [1]) and algorithm working in F 7 [17]. We do not see any way of applying our techniques or any other known techniques of proving lower bounds to dimension 3, as all of them require some additional counter, which helps to enforce the run to be exact at some control configurations. We conjecture that the reachability problem is actually elementary for VASSes in dimension 3 and maybe even in a few higher dimensions. Showing this seems to be a very challenging task.\n\nAnother future goal is to settle the exact complexity of the reachability problem for d-VASSes depending on d. After our work showing F d -hardness in dimension 6d and independent work by J\u00e9r\u00f4me Leroux [13] showing the same in dimension 4d + 9 a lot of improvement appeared very recently. S lawomir Lasota in [12] building on results in the arXiv version of this paper [4] improved the F d -hardness result to dimension 3d + 2. Also J\u00e9r\u00f4me Leroux improved his own result and showed F d -hardness for VASSes in dimension 2d + 4 [14]. Thus the lower bounds to improve are Tower-hardness for d \u2265 10 [14], ExpSpace-hardness as well for d \u2265 10 [14] and NP-hardness for d \u2265 7 for unary encoding [3] and the best published upper bounds are stated in [17] to be F d+4 complexity for dimension d. One can also suspect that even VASSes in higher dimensions can be solved efficiently under some condition on their structure (for example avoiding some kind of bad patterns).\n\nComplexity of the reachability problem for VASS extensions such as pushdown VASSes [15], branching VASSes [6] or data VASSes [8] is almost totally unexplored and even decidability is not known for them. We hope that techniques introduced in this paper may help better understanding the mentioned extensions of VASSes and in particular prove some complexity lower bounds.\n\n\nBasic notions For a, b \u2208 N, b \u2265 a we write [a, b] for the set {a, a + 1, . . . , b \u2212 1, b}. For a vector v \u2208 Z d and i \u2208 [1, d] we write v[i] for the i-th entry of v. For a vector v \u2208 Z d and the set of indices S \u2286 [1, d] by v[S] \u2208 Z |S| we denote vector v restricted to the indices in S. By 0 d we represent the d-dimensional vector with all entries being 0. Vector Addition Systems A d-dimensional Vector Addition System with States (d-VASS) consists of a finite set of states Q and a finite set of transitions T\n\n\ninspect the code to see that it indeed reflects the above story. Recall that we keep all the time the invariant c +c = M , soc \u2264 M . Therefore the loop in lines 2-3 is fired at most M times. Similarly the loop in lines 4-5 is fired at most M times. Thus indeed the result of loops in lines 2-5 is the decrease of counter c 3 by at most 2M and decrease by exactly 2M corresponds to initial and final value of c being zero. Thus lines 1-5 indeed simulate faithfully the zero-test.\n\nLemma 6 .\n6For any d \u2265 3 if there exists a d-dimensional f -amplifier V then exists a ddimensional f (M )-generator of size linear in size(V ) + log(M ) with the same number of test counters as V . Proof. We construct the f (M )-generator as follows. In its initial state we have a loop with the effect (0, 1, M, 0 d\u22123 ), thus after x applications of it we get a vector (0, x, M x, 0 d\u22123 ). Then a transition with effect (M, 0, 0, 0 d\u22123 ) leads to the input state of the f -amplifier, so the f -amplifier inputs a tuple (M, x, M x, 0 d\u22123 ). Immediately from the definition of an amplifier we get that all the runs reaching the output state of the amplifier with vectors of the form (\n\n\nwe denote the transformation on counters caused by line i of program V k . There-fore we have\n\nLemma 10 .\u2212\n10Let src \u03c1 \u2212\u2192 trg be a run of a (d+ 1)-VASS V and let src = c 0 , c 1 , . . . , c n\u22121 , c n = trg be some of the configurations on \u03c1. Let \u03c1 j for j \u2208 [1, n] be the parts of the run \u03c1 starting in c j\u22121 and finishing in c j , namely \u2192 . . .\n\n\nc n .\n\n\neach i \u2208 [1, d] and for each j \u2208 S i we have c j [i] = 0.\n\n\n[1, d]  and for each j \u2208 S i we have c j [i] = 0 it is enough to check whether the sum of all c j [i] is zero, namely to check whether sum = i\u2208[1,d],j\u2208S i c j [i] = 0.For each i \u2208 [1, d] and j \u2208 S i the value c j [i] is the sum of the initial value of the i-th counter and effects of all the runs \u03c1 k before configuration c j on the i-th counter. In other wordsc j [i] = c 0 [i] + j k=1 eff(\u03c1 k , i).In the rightmost expression c 0 [i] occurs exactly N 0,i times and each eff(\u03c1 k , i) occurs exactly N k,i times. Thereforesum = src[d + 1] + n k=1 eff(\u03c1 k , d + 1) = trg[d + 1],where the first equation follows from(1)and(2). By(3)we have trg[d + 1] = 0 which implies that indeed sum = 0 and finishes the proof.\n\n\ndifferent i. Recall that the test counters of V [i] k\u22121 contain all the input counters s 1 , s 2 , s 3 and possibly one additional counter. \u2212= 1 s 3 += 1 c \u2212= 1 Claim 13. The above counter program is an F k -amplifier. Proof. The aim of lines 1-3 is to set the triple (s 1 , s 2 , s 3 ) to values (1, a 0 , a 0 ) for some arbitrary guessed a 0 \u2208 N. For a function f : N \u2192 N let us denote by f (m) (n) the m-fold application of f to n. Then in lines 4-11 we perform n times, for i \u2208 {1, . . . , n} the following operations: 1) \u00b7 a i\u22121 ) for some a i\u22121 \u2208 N on counters (s 1 , s 2 , s 3 ) the F k\u22121 -amplifier V 1) \u00b7 a i ) for some a i \u2208 N on counters (o 1 , o 2 , o 3 ) under the condition that the test counters of V 1) \u00b7 a i ) from counters (o 1 , o 2 , o 3 ) back to the counters (s 1 , s 2 , s 3 ). The controlling counter c controls counters o 1 , o 2 and o 3 for each i \u2208 [1, d] the test counters of V [i] k\u22121 , which in particular contain counters s 1 , s 2 and s 3 . Counter c is designed to test whether each time after line 5 test counters of V [i] k\u22121 are zero and each time after line 11 counters o 1 , o 2 and o 3 are zero. The first condition assures that indeed output of amplifier V [i] k\u22121 is computed correctly, while the second condition assures that values of o j are fully copied back to values of i j . Notice that each of the test counters of V [i]\n\n\n(s 1 , s 2 , s 3 ) being zero (which guarantees condition\nAcknowledgements We thank S lawomir Lasota for many inspiring and fruitful discussions and Filip Mazowiecki for careful reading of the draft of this paper. We also thank anonymous reviewers for helpful remarks.\nReachability in two-dimensional vector addition systems with states is PSpace-complete. Michael Blondin, Alain Finkel, Stefan G\u00f6ller, Christoph Haase, Pierre Mckenzie, Proceedings of LICS 2015. LICS 2015Michael Blondin, Alain Finkel, Stefan G\u00f6ller, Christoph Haase, and Pierre McKenzie. Reachability in two-dimensional vector addition systems with states is PSpace-complete. In Proceedings of LICS 2015, pages 32-43, 2015.\n\nThe reachability problem for Petri nets is not elementary. Wojciech Czerwinski, Slawomir Lasota, Ranko Lazic, J\u00e9r\u00f4me Leroux, Filip Mazowiecki, Proceedings of STOC 2019. STOC 2019ACMWojciech Czerwinski, Slawomir Lasota, Ranko Lazic, J\u00e9r\u00f4me Leroux, and Filip Mazowiecki. The reachability problem for Petri nets is not elementary. In Proceedings of STOC 2019, pages 24-33. ACM, 2019.\n\nReachability in fixed dimension vector addition systems with states. Wojciech Czerwinski, Slawomir Lasota, Ranko Lazic, J\u00e9r\u00f4me Leroux, Filip Mazowiecki, Proceedings of CONCUR 2020. CONCUR 202048Wojciech Czerwinski, Slawomir Lasota, Ranko Lazic, J\u00e9r\u00f4me Leroux, and Filip Mazowiecki. Reachability in fixed dimension vector addition systems with states. In Proceedings of CONCUR 2020, pages 48:1-48:21, 2020.\n\nReachability in vector addition systems is Ackermann-complete. CoRR, abs. Wojciech Czerwi\u0144ski, Lukasz Orlikowski, Wojciech Czerwi\u0144ski and Lukasz Orlikowski. Reachability in vector addition systems is Ackermann-complete. CoRR, abs/2104.13866, 2021.\n\nReachability in two-dimensional unary vector addition systems with states is NL-complete. Matthias Englert, Ranko Lazic, Patrick Totzke, Proceedings of LICS 2016. LICS 2016Matthias Englert, Ranko Lazic, and Patrick Totzke. Reachability in two-dimensional unary vector addition systems with states is NL-complete. In Proceedings of LICS 2016, pages 477-484, 2016.\n\nPolynomial-space completeness of reachability for succinct branching VASS in dimension one. Diego Figueira, Ranko Lazic, J\u00e9r\u00f4me Leroux, Filip Mazowiecki, Gr\u00e9goire Sutre, Proceedings of ICALP 2017. ICALP 2017119Diego Figueira, Ranko Lazic, J\u00e9r\u00f4me Leroux, Filip Mazowiecki, and Gr\u00e9goire Sutre. Polynomial-space completeness of reachability for succinct branching VASS in dimension one. In Proceedings of ICALP 2017, pages 119:1-119:14, 2017.\n\nReachability in succinct and parametric one-counter automata. Christoph Haase, Stephan Kreutzer, Jo\u00ebl Ouaknine, James Worrell, Proceedings of CONCUR 2009. CONCUR 2009Christoph Haase, Stephan Kreutzer, Jo\u00ebl Ouaknine, and James Worrell. Reachability in succinct and parametric one-counter automata. In Proceedings of CONCUR 2009, pages 369-383, 2009.\n\nCoverability trees for Petri nets with unordered data. Piotr Hofman, Slawomir Lasota, Ranko Lazic, J\u00e9r\u00f4me Leroux, Sylvain Schmitz, Patrick Totzke, Proceedings of FoSSaCS. FoSSaCSPiotr Hofman, Slawomir Lasota, Ranko Lazic, J\u00e9r\u00f4me Leroux, Sylvain Schmitz, and Patrick Totzke. Coverability trees for Petri nets with unordered data. In Proceedings of FoSSaCS 2016, pages 445-461, 2016.\n\nOn the reachability problem for 5-dimensional vector addition systems. John E Hopcroft, Jean-Jacques Pansiot, Theor. Comput. Sci. 8John E. Hopcroft and Jean-Jacques Pansiot. On the reachability problem for 5-dimensional vector addition systems. Theor. Comput. Sci., 8:135-159, 1979.\n\nDecidability of reachability in vector addition systems (preliminary version). S Rao Kosaraju, Proceedings of STOC 1982. STOC 1982S. Rao Kosaraju. Decidability of reachability in vector addition systems (preliminary version). In Proceedings of STOC 1982, pages 267-281, 1982.\n\nA structure to decide reachability in Petri nets. Jean-Luc Lambert, Theor. Comput. Sci. 991Jean-Luc Lambert. A structure to decide reachability in Petri nets. Theor. Comput. Sci., 99(1):79-104, 1992.\n\nImproved Ackermannian lower bound for the VASS reachability problem. Lasota S Lawomir, abs/2105.08551CoRRS lawomir Lasota. Improved Ackermannian lower bound for the VASS reachability problem. CoRR, abs/2105.08551, 2021.\n\nThe reachability problem for Petri nets is not primitive recursive. J\u00e9r\u00f4me Leroux, Proceedings of FOCS 2021. FOCS 2021To appearJ\u00e9r\u00f4me Leroux. The reachability problem for Petri nets is not primitive recursive. In Proceedings of FOCS 2021. To appear. IEEE Computer Society, 2021.\n\nThe reachability problem for Petri nets is not primitive recursive. CoRR, abs. J\u00e9r\u00f4me Leroux, J\u00e9r\u00f4me Leroux. The reachability problem for Petri nets is not primitive recursive. CoRR, abs/2104.12695, 2021.\n\nOn functions weakly computable by pushdown Petri nets and related systems. J\u00e9r\u00f4me Leroux, M Praveen, Philippe Schnoebelen, Gr\u00e9goire Sutre, Log. Methods Comput. Sci. 154J\u00e9r\u00f4me Leroux, M. Praveen, Philippe Schnoebelen, and Gr\u00e9goire Sutre. On functions weakly computable by pushdown Petri nets and related systems. Log. Methods Comput. Sci., 15(4), 2019.\n\nDemystifying reachability in vector addition systems. J\u00e9r\u00f4me Leroux, Sylvain Schmitz, Proceedings of LICS 2015. LICS 2015J\u00e9r\u00f4me Leroux and Sylvain Schmitz. Demystifying reachability in vector addition systems. In Proceedings of LICS 2015, pages 56-67, 2015.\n\nReachability in vector addition systems is primitiverecursive in fixed dimension. J\u00e9r\u00f4me Leroux, Sylvain Schmitz, Proceedings of LICS 2019. LICS 2019IEEEJ\u00e9r\u00f4me Leroux and Sylvain Schmitz. Reachability in vector addition systems is primitive- recursive in fixed dimension. In Proceedings of LICS 2019, pages 1-13. IEEE, 2019.\n\nThe reachability problem requires exponential space. Richard J Lipton, Yale UniversityTechnical reportRichard J. Lipton. The reachability problem requires exponential space. Technical report, Yale University, 1976.\n\nAn algorithm for the general Petri net reachability problem. Ernst W Mayr, Proceedings of STOC 1981. STOC 1981Ernst W. Mayr. An algorithm for the general Petri net reachability problem. In Proceedings of STOC 1981, pages 238-246, 1981.\n\nComplexity hierarchies beyond elementary. Sylvain Schmitz, 10.1145/2858784doi:10.1145/2858784ACM Trans. Comput. Theory. 81Sylvain Schmitz. Complexity hierarchies beyond elementary. ACM Trans. Comput. Theory, 8(1):3:1-3:36, 2016. URL: https://doi.org/10.1145/2858784, doi:10.1145/2858784.\n", "annotations": {"author": "[{\"end\":157,\"start\":93},{\"end\":220,\"start\":158}]", "publisher": null, "author_last_name": "[{\"end\":112,\"start\":102},{\"end\":175,\"start\":165}]", "author_first_name": "[{\"end\":101,\"start\":93},{\"end\":164,\"start\":158}]", "author_affiliation": "[{\"end\":156,\"start\":114},{\"end\":219,\"start\":177}]", "title": "[{\"end\":62,\"start\":1},{\"end\":282,\"start\":221}]", "venue": null, "abstract": "[{\"end\":897,\"start\":312}]", "bib_ref": "[{\"attributes\":{\"ref_id\":\"b17\"},\"end\":1461,\"start\":1457},{\"attributes\":{\"ref_id\":\"b18\"},\"end\":1541,\"start\":1537},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":1597,\"start\":1593},{\"attributes\":{\"ref_id\":\"b10\"},\"end\":1614,\"start\":1610},{\"end\":2152,\"start\":2140},{\"attributes\":{\"ref_id\":\"b6\"},\"end\":2237,\"start\":2234},{\"attributes\":{\"ref_id\":\"b0\"},\"end\":2503,\"start\":2500},{\"attributes\":{\"ref_id\":\"b4\"},\"end\":2668,\"start\":2665},{\"attributes\":{\"ref_id\":\"b15\"},\"end\":2864,\"start\":2860},{\"attributes\":{\"ref_id\":\"b16\"},\"end\":3019,\"start\":3015},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":3295,\"start\":3292},{\"attributes\":{\"ref_id\":\"b16\"},\"end\":3945,\"start\":3941},{\"attributes\":{\"ref_id\":\"b12\"},\"end\":4143,\"start\":4139},{\"end\":8324,\"start\":8322},{\"attributes\":{\"ref_id\":\"b19\"},\"end\":9919,\"start\":9915},{\"end\":9929,\"start\":9919},{\"attributes\":{\"ref_id\":\"b19\"},\"end\":10321,\"start\":10317},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":11266,\"start\":11263},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":12617,\"start\":12614},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":15053,\"start\":15050},{\"end\":19188,\"start\":19182},{\"end\":26395,\"start\":26389},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":27381,\"start\":27378},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":28641,\"start\":28638},{\"end\":29463,\"start\":29461},{\"attributes\":{\"ref_id\":\"b8\"},\"end\":32326,\"start\":32323},{\"end\":42272,\"start\":42270},{\"attributes\":{\"ref_id\":\"b0\"},\"end\":47153,\"start\":47150},{\"attributes\":{\"ref_id\":\"b16\"},\"end\":47188,\"start\":47184},{\"attributes\":{\"ref_id\":\"b12\"},\"end\":47825,\"start\":47821},{\"attributes\":{\"ref_id\":\"b11\"},\"end\":47932,\"start\":47928},{\"attributes\":{\"ref_id\":\"b3\"},\"end\":47991,\"start\":47988},{\"attributes\":{\"ref_id\":\"b13\"},\"end\":48150,\"start\":48146},{\"attributes\":{\"ref_id\":\"b13\"},\"end\":48219,\"start\":48215},{\"attributes\":{\"ref_id\":\"b13\"},\"end\":48262,\"start\":48258},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":48311,\"start\":48308},{\"attributes\":{\"ref_id\":\"b16\"},\"end\":48366,\"start\":48362},{\"attributes\":{\"ref_id\":\"b14\"},\"end\":48670,\"start\":48666},{\"attributes\":{\"ref_id\":\"b5\"},\"end\":48692,\"start\":48689},{\"attributes\":{\"ref_id\":\"b7\"},\"end\":48711,\"start\":48708}]", "figure": "[{\"attributes\":{\"id\":\"fig_0\"},\"end\":49470,\"start\":48954},{\"attributes\":{\"id\":\"fig_2\"},\"end\":49951,\"start\":49471},{\"attributes\":{\"id\":\"fig_3\"},\"end\":50636,\"start\":49952},{\"attributes\":{\"id\":\"fig_6\"},\"end\":50732,\"start\":50637},{\"attributes\":{\"id\":\"fig_7\"},\"end\":50985,\"start\":50733},{\"attributes\":{\"id\":\"fig_8\"},\"end\":50993,\"start\":50986},{\"attributes\":{\"id\":\"fig_9\"},\"end\":51053,\"start\":50994},{\"attributes\":{\"id\":\"fig_10\"},\"end\":51766,\"start\":51054},{\"attributes\":{\"id\":\"fig_13\"},\"end\":53138,\"start\":51767},{\"attributes\":{\"id\":\"fig_14\"},\"end\":53198,\"start\":53139}]", "paragraph": "[{\"end\":2669,\"start\":913},{\"end\":3476,\"start\":2671},{\"end\":3664,\"start\":3478},{\"end\":3744,\"start\":3666},{\"end\":3971,\"start\":3746},{\"end\":4038,\"start\":3973},{\"end\":4246,\"start\":4040},{\"end\":4988,\"start\":4248},{\"end\":5831,\"start\":5587},{\"end\":6272,\"start\":5891},{\"end\":6390,\"start\":6308},{\"end\":6832,\"start\":6392},{\"end\":7478,\"start\":6834},{\"end\":7617,\"start\":7480},{\"end\":7659,\"start\":7619},{\"end\":8062,\"start\":7830},{\"end\":8137,\"start\":8064},{\"end\":8349,\"start\":8153},{\"end\":8375,\"start\":8351},{\"end\":8642,\"start\":8377},{\"end\":8924,\"start\":8721},{\"end\":9035,\"start\":8926},{\"end\":9071,\"start\":9037},{\"end\":9080,\"start\":9073},{\"end\":9098,\"start\":9082},{\"end\":9120,\"start\":9107},{\"end\":9174,\"start\":9122},{\"end\":9465,\"start\":9266},{\"end\":9931,\"start\":9467},{\"end\":10135,\"start\":9933},{\"end\":11002,\"start\":10137},{\"end\":11140,\"start\":11014},{\"end\":11970,\"start\":11142},{\"end\":12112,\"start\":11972},{\"end\":12415,\"start\":12114},{\"end\":14160,\"start\":12417},{\"end\":14288,\"start\":14162},{\"end\":14843,\"start\":14540},{\"end\":15108,\"start\":14845},{\"end\":15373,\"start\":15110},{\"end\":16649,\"start\":15375},{\"end\":17479,\"start\":16718},{\"end\":18779,\"start\":17481},{\"end\":18878,\"start\":18781},{\"end\":19230,\"start\":18880},{\"end\":19353,\"start\":19338},{\"end\":19678,\"start\":19469},{\"end\":19984,\"start\":19680},{\"end\":20197,\"start\":20105},{\"end\":20316,\"start\":20199},{\"end\":20487,\"start\":20318},{\"end\":21147,\"start\":20489},{\"end\":21806,\"start\":21149},{\"end\":22446,\"start\":21808},{\"end\":22513,\"start\":22448},{\"end\":22647,\"start\":22523},{\"end\":22894,\"start\":22685},{\"end\":23151,\"start\":22980},{\"end\":23254,\"start\":23216},{\"end\":23403,\"start\":23394},{\"end\":23702,\"start\":23668},{\"end\":24073,\"start\":23717},{\"end\":26079,\"start\":24075},{\"end\":26952,\"start\":26101},{\"end\":28100,\"start\":26992},{\"end\":28792,\"start\":28132},{\"end\":29572,\"start\":28794},{\"end\":29756,\"start\":29574},{\"end\":31631,\"start\":29853},{\"end\":32389,\"start\":31633},{\"end\":32418,\"start\":32391},{\"end\":32427,\"start\":32420},{\"end\":32445,\"start\":32429},{\"end\":32470,\"start\":32454},{\"end\":34585,\"start\":32472},{\"end\":34773,\"start\":34587},{\"end\":35362,\"start\":34903},{\"end\":36125,\"start\":35364},{\"end\":36772,\"start\":36140},{\"end\":36786,\"start\":36784},{\"end\":36815,\"start\":36808},{\"end\":36921,\"start\":36919},{\"end\":38565,\"start\":36949},{\"end\":39080,\"start\":38567},{\"end\":39465,\"start\":39082},{\"end\":39512,\"start\":39467},{\"end\":41152,\"start\":39590},{\"end\":41628,\"start\":41192},{\"end\":42067,\"start\":41630},{\"end\":42557,\"start\":42069},{\"end\":43351,\"start\":42576},{\"end\":46131,\"start\":43444},{\"end\":46696,\"start\":46133},{\"end\":46941,\"start\":46716},{\"end\":47617,\"start\":46943},{\"end\":48581,\"start\":47619},{\"end\":48953,\"start\":48583}]", "formula": "[{\"attributes\":{\"id\":\"formula_0\"},\"end\":5586,\"start\":5005},{\"attributes\":{\"id\":\"formula_1\"},\"end\":5890,\"start\":5832},{\"attributes\":{\"id\":\"formula_2\"},\"end\":7829,\"start\":7660},{\"attributes\":{\"id\":\"formula_3\"},\"end\":8152,\"start\":8138},{\"attributes\":{\"id\":\"formula_4\"},\"end\":8720,\"start\":8643},{\"attributes\":{\"id\":\"formula_5\"},\"end\":9106,\"start\":9099},{\"attributes\":{\"id\":\"formula_6\"},\"end\":9265,\"start\":9175},{\"attributes\":{\"id\":\"formula_7\"},\"end\":14539,\"start\":14289},{\"attributes\":{\"id\":\"formula_8\"},\"end\":16717,\"start\":16650},{\"attributes\":{\"id\":\"formula_9\"},\"end\":19337,\"start\":19231},{\"attributes\":{\"id\":\"formula_10\"},\"end\":19468,\"start\":19354},{\"attributes\":{\"id\":\"formula_11\"},\"end\":20104,\"start\":19985},{\"attributes\":{\"id\":\"formula_12\"},\"end\":22522,\"start\":22514},{\"attributes\":{\"id\":\"formula_13\"},\"end\":22684,\"start\":22648},{\"attributes\":{\"id\":\"formula_14\"},\"end\":22979,\"start\":22895},{\"attributes\":{\"id\":\"formula_15\"},\"end\":23165,\"start\":23152},{\"attributes\":{\"id\":\"formula_16\"},\"end\":23215,\"start\":23165},{\"attributes\":{\"id\":\"formula_17\"},\"end\":23393,\"start\":23255},{\"attributes\":{\"id\":\"formula_18\"},\"end\":23667,\"start\":23404},{\"attributes\":{\"id\":\"formula_19\"},\"end\":26100,\"start\":26080},{\"attributes\":{\"id\":\"formula_20\"},\"end\":26991,\"start\":26953},{\"attributes\":{\"id\":\"formula_21\"},\"end\":28131,\"start\":28101},{\"attributes\":{\"id\":\"formula_22\"},\"end\":29852,\"start\":29757},{\"attributes\":{\"id\":\"formula_23\"},\"end\":32453,\"start\":32446},{\"attributes\":{\"id\":\"formula_24\"},\"end\":34902,\"start\":34774},{\"attributes\":{\"id\":\"formula_25\"},\"end\":36807,\"start\":36787},{\"attributes\":{\"id\":\"formula_26\"},\"end\":36918,\"start\":36816},{\"attributes\":{\"id\":\"formula_27\"},\"end\":36948,\"start\":36922},{\"attributes\":{\"id\":\"formula_28\"},\"end\":39589,\"start\":39513},{\"attributes\":{\"id\":\"formula_29\"},\"end\":41191,\"start\":41153},{\"attributes\":{\"id\":\"formula_30\"},\"end\":42575,\"start\":42558},{\"attributes\":{\"id\":\"formula_31\"},\"end\":43443,\"start\":43352}]", "table_ref": null, "section_header": "[{\"attributes\":{\"n\":\"1\"},\"end\":911,\"start\":899},{\"attributes\":{\"n\":\"2\"},\"end\":5004,\"start\":4991},{\"end\":6306,\"start\":6275},{\"attributes\":{\"n\":\"3\"},\"end\":11012,\"start\":11005},{\"attributes\":{\"n\":\"4\"},\"end\":23715,\"start\":23705},{\"attributes\":{\"n\":\"5\"},\"end\":36138,\"start\":36128},{\"end\":36782,\"start\":36775},{\"attributes\":{\"n\":\"6\"},\"end\":46714,\"start\":46699},{\"end\":49962,\"start\":49953},{\"end\":50745,\"start\":50734}]", "table": null, "figure_caption": "[{\"end\":49470,\"start\":48956},{\"end\":49951,\"start\":49473},{\"end\":50636,\"start\":49964},{\"end\":50732,\"start\":50639},{\"end\":50985,\"start\":50748},{\"end\":50993,\"start\":50988},{\"end\":51053,\"start\":50996},{\"end\":51766,\"start\":51056},{\"end\":53138,\"start\":51769},{\"end\":53198,\"start\":53141}]", "figure_ref": "[{\"end\":23115,\"start\":23110}]", "bib_author_first_name": "[{\"end\":53505,\"start\":53498},{\"end\":53520,\"start\":53515},{\"end\":53535,\"start\":53529},{\"end\":53553,\"start\":53544},{\"end\":53567,\"start\":53561},{\"end\":53901,\"start\":53893},{\"end\":53922,\"start\":53914},{\"end\":53936,\"start\":53931},{\"end\":53950,\"start\":53944},{\"end\":53964,\"start\":53959},{\"end\":54293,\"start\":54285},{\"end\":54314,\"start\":54306},{\"end\":54328,\"start\":54323},{\"end\":54342,\"start\":54336},{\"end\":54356,\"start\":54351},{\"end\":54705,\"start\":54697},{\"end\":54724,\"start\":54718},{\"end\":54970,\"start\":54962},{\"end\":54985,\"start\":54980},{\"end\":55000,\"start\":54993},{\"end\":55333,\"start\":55328},{\"end\":55349,\"start\":55344},{\"end\":55363,\"start\":55357},{\"end\":55377,\"start\":55372},{\"end\":55398,\"start\":55390},{\"end\":55748,\"start\":55739},{\"end\":55763,\"start\":55756},{\"end\":55778,\"start\":55774},{\"end\":55794,\"start\":55789},{\"end\":56087,\"start\":56082},{\"end\":56104,\"start\":56096},{\"end\":56118,\"start\":56113},{\"end\":56132,\"start\":56126},{\"end\":56148,\"start\":56141},{\"end\":56165,\"start\":56158},{\"end\":56485,\"start\":56481},{\"end\":56487,\"start\":56486},{\"end\":56510,\"start\":56498},{\"end\":56774,\"start\":56773},{\"end\":56778,\"start\":56775},{\"end\":57029,\"start\":57021},{\"end\":57247,\"start\":57241},{\"end\":57467,\"start\":57461},{\"end\":57758,\"start\":57752},{\"end\":57960,\"start\":57954},{\"end\":57970,\"start\":57969},{\"end\":57988,\"start\":57980},{\"end\":58010,\"start\":58002},{\"end\":58292,\"start\":58286},{\"end\":58308,\"start\":58301},{\"end\":58579,\"start\":58573},{\"end\":58595,\"start\":58588},{\"end\":58877,\"start\":58870},{\"end\":58879,\"start\":58878},{\"end\":59099,\"start\":59094},{\"end\":59101,\"start\":59100},{\"end\":59319,\"start\":59312}]", "bib_author_last_name": "[{\"end\":53513,\"start\":53506},{\"end\":53527,\"start\":53521},{\"end\":53542,\"start\":53536},{\"end\":53559,\"start\":53554},{\"end\":53576,\"start\":53568},{\"end\":53912,\"start\":53902},{\"end\":53929,\"start\":53923},{\"end\":53942,\"start\":53937},{\"end\":53957,\"start\":53951},{\"end\":53975,\"start\":53965},{\"end\":54304,\"start\":54294},{\"end\":54321,\"start\":54315},{\"end\":54334,\"start\":54329},{\"end\":54349,\"start\":54343},{\"end\":54367,\"start\":54357},{\"end\":54716,\"start\":54706},{\"end\":54735,\"start\":54725},{\"end\":54978,\"start\":54971},{\"end\":54991,\"start\":54986},{\"end\":55007,\"start\":55001},{\"end\":55342,\"start\":55334},{\"end\":55355,\"start\":55350},{\"end\":55370,\"start\":55364},{\"end\":55388,\"start\":55378},{\"end\":55404,\"start\":55399},{\"end\":55754,\"start\":55749},{\"end\":55772,\"start\":55764},{\"end\":55787,\"start\":55779},{\"end\":55802,\"start\":55795},{\"end\":56094,\"start\":56088},{\"end\":56111,\"start\":56105},{\"end\":56124,\"start\":56119},{\"end\":56139,\"start\":56133},{\"end\":56156,\"start\":56149},{\"end\":56172,\"start\":56166},{\"end\":56496,\"start\":56488},{\"end\":56518,\"start\":56511},{\"end\":56787,\"start\":56779},{\"end\":57037,\"start\":57030},{\"end\":57257,\"start\":57248},{\"end\":57474,\"start\":57468},{\"end\":57765,\"start\":57759},{\"end\":57967,\"start\":57961},{\"end\":57978,\"start\":57971},{\"end\":58000,\"start\":57989},{\"end\":58016,\"start\":58011},{\"end\":58299,\"start\":58293},{\"end\":58316,\"start\":58309},{\"end\":58586,\"start\":58580},{\"end\":58603,\"start\":58596},{\"end\":58886,\"start\":58880},{\"end\":59106,\"start\":59102},{\"end\":59327,\"start\":59320}]", "bib_entry": "[{\"attributes\":{\"id\":\"b0\",\"matched_paper_id\":8050534},\"end\":53832,\"start\":53410},{\"attributes\":{\"id\":\"b1\",\"matched_paper_id\":52301597},\"end\":54214,\"start\":53834},{\"attributes\":{\"id\":\"b2\",\"matched_paper_id\":210164449},\"end\":54621,\"start\":54216},{\"attributes\":{\"id\":\"b3\"},\"end\":54870,\"start\":54623},{\"attributes\":{\"id\":\"b4\",\"matched_paper_id\":14316067},\"end\":55234,\"start\":54872},{\"attributes\":{\"id\":\"b5\",\"matched_paper_id\":19259522},\"end\":55675,\"start\":55236},{\"attributes\":{\"id\":\"b6\",\"matched_paper_id\":56046971},\"end\":56025,\"start\":55677},{\"attributes\":{\"id\":\"b7\",\"matched_paper_id\":6468362},\"end\":56408,\"start\":56027},{\"attributes\":{\"id\":\"b8\",\"matched_paper_id\":43372474},\"end\":56692,\"start\":56410},{\"attributes\":{\"id\":\"b9\",\"matched_paper_id\":17177691},\"end\":56969,\"start\":56694},{\"attributes\":{\"id\":\"b10\",\"matched_paper_id\":29728488},\"end\":57170,\"start\":56971},{\"attributes\":{\"doi\":\"abs/2105.08551\",\"id\":\"b11\"},\"end\":57391,\"start\":57172},{\"attributes\":{\"id\":\"b12\",\"matched_paper_id\":233393969},\"end\":57671,\"start\":57393},{\"attributes\":{\"id\":\"b13\"},\"end\":57877,\"start\":57673},{\"attributes\":{\"id\":\"b14\",\"matched_paper_id\":102352165},\"end\":58230,\"start\":57879},{\"attributes\":{\"id\":\"b15\",\"matched_paper_id\":11306975},\"end\":58489,\"start\":58232},{\"attributes\":{\"id\":\"b16\",\"matched_paper_id\":84186333},\"end\":58815,\"start\":58491},{\"attributes\":{\"id\":\"b17\"},\"end\":59031,\"start\":58817},{\"attributes\":{\"id\":\"b18\",\"matched_paper_id\":5884932},\"end\":59268,\"start\":59033},{\"attributes\":{\"doi\":\"10.1145/2858784\",\"id\":\"b19\",\"matched_paper_id\":15155865},\"end\":59557,\"start\":59270}]", "bib_title": "[{\"end\":53496,\"start\":53410},{\"end\":53891,\"start\":53834},{\"end\":54283,\"start\":54216},{\"end\":54960,\"start\":54872},{\"end\":55326,\"start\":55236},{\"end\":55737,\"start\":55677},{\"end\":56080,\"start\":56027},{\"end\":56479,\"start\":56410},{\"end\":56771,\"start\":56694},{\"end\":57019,\"start\":56971},{\"end\":57459,\"start\":57393},{\"end\":57952,\"start\":57879},{\"end\":58284,\"start\":58232},{\"end\":58571,\"start\":58491},{\"end\":59092,\"start\":59033},{\"end\":59310,\"start\":59270}]", "bib_author": "[{\"end\":53515,\"start\":53498},{\"end\":53529,\"start\":53515},{\"end\":53544,\"start\":53529},{\"end\":53561,\"start\":53544},{\"end\":53578,\"start\":53561},{\"end\":53914,\"start\":53893},{\"end\":53931,\"start\":53914},{\"end\":53944,\"start\":53931},{\"end\":53959,\"start\":53944},{\"end\":53977,\"start\":53959},{\"end\":54306,\"start\":54285},{\"end\":54323,\"start\":54306},{\"end\":54336,\"start\":54323},{\"end\":54351,\"start\":54336},{\"end\":54369,\"start\":54351},{\"end\":54718,\"start\":54697},{\"end\":54737,\"start\":54718},{\"end\":54980,\"start\":54962},{\"end\":54993,\"start\":54980},{\"end\":55009,\"start\":54993},{\"end\":55344,\"start\":55328},{\"end\":55357,\"start\":55344},{\"end\":55372,\"start\":55357},{\"end\":55390,\"start\":55372},{\"end\":55406,\"start\":55390},{\"end\":55756,\"start\":55739},{\"end\":55774,\"start\":55756},{\"end\":55789,\"start\":55774},{\"end\":55804,\"start\":55789},{\"end\":56096,\"start\":56082},{\"end\":56113,\"start\":56096},{\"end\":56126,\"start\":56113},{\"end\":56141,\"start\":56126},{\"end\":56158,\"start\":56141},{\"end\":56174,\"start\":56158},{\"end\":56498,\"start\":56481},{\"end\":56520,\"start\":56498},{\"end\":56789,\"start\":56773},{\"end\":57039,\"start\":57021},{\"end\":57259,\"start\":57241},{\"end\":57476,\"start\":57461},{\"end\":57767,\"start\":57752},{\"end\":57969,\"start\":57954},{\"end\":57980,\"start\":57969},{\"end\":58002,\"start\":57980},{\"end\":58018,\"start\":58002},{\"end\":58301,\"start\":58286},{\"end\":58318,\"start\":58301},{\"end\":58588,\"start\":58573},{\"end\":58605,\"start\":58588},{\"end\":58888,\"start\":58870},{\"end\":59108,\"start\":59094},{\"end\":59329,\"start\":59312}]", "bib_venue": "[{\"end\":53613,\"start\":53604},{\"end\":54012,\"start\":54003},{\"end\":54408,\"start\":54397},{\"end\":55044,\"start\":55035},{\"end\":55443,\"start\":55433},{\"end\":55843,\"start\":55832},{\"end\":56205,\"start\":56198},{\"end\":56824,\"start\":56815},{\"end\":57511,\"start\":57502},{\"end\":58353,\"start\":58344},{\"end\":58640,\"start\":58631},{\"end\":59143,\"start\":59134},{\"end\":53602,\"start\":53578},{\"end\":54001,\"start\":53977},{\"end\":54395,\"start\":54369},{\"end\":54695,\"start\":54623},{\"end\":55033,\"start\":55009},{\"end\":55431,\"start\":55406},{\"end\":55830,\"start\":55804},{\"end\":56196,\"start\":56174},{\"end\":56538,\"start\":56520},{\"end\":56813,\"start\":56789},{\"end\":57057,\"start\":57039},{\"end\":57239,\"start\":57172},{\"end\":57500,\"start\":57476},{\"end\":57750,\"start\":57673},{\"end\":58042,\"start\":58018},{\"end\":58342,\"start\":58318},{\"end\":58629,\"start\":58605},{\"end\":58868,\"start\":58817},{\"end\":59132,\"start\":59108},{\"end\":59388,\"start\":59363}]"}}}, "year": 2023, "month": 12, "day": 17}