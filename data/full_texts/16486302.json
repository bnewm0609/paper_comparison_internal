{"id": 16486302, "updated": "2023-11-11 00:11:31.813", "metadata": {"title": "Reachability in Two-Clock Timed Automata is PSPACE-complete", "authors": "[{\"first\":\"John\",\"last\":\"Fearnley\",\"middle\":[]},{\"first\":\"Marcin\",\"last\":\"Jurdzi\u00b4nski\",\"middle\":[]}]", "venue": "ICALP", "journal": "212-223", "publication_date": {"year": 2013, "month": null, "day": null}, "abstract": ". A recent result has shown that reachability in two-clock timed automata is log-space equivalent to reachability in bounded one-counter automata [6]. We show that reachability in bounded one-counter automata is PSPACE-complete.", "fields_of_study": "[\"Computer Science\"]", "external_ids": {"arxiv": null, "mag": "2952380278", "acl": null, "pubmed": null, "pubmedcentral": null, "dblp": "conf/icalp/FearnleyJ13", "doi": "10.1016/j.ic.2014.12.004"}}, "content": {"source": {"pdf_hash": "755b28c3e39b4024f6028c41a3025dab23ab4866", "pdf_src": "Arxiv", "pdf_uri": "[\"https://arxiv.org/pdf/1302.3109v2.pdf\"]", "oa_url_match": false, "oa_info": {"license": "elsevier-specific: oa user license", "open_access_url": "https://doi.org/10.1016/j.ic.2014.12.004", "status": "BRONZE"}}, "grobid": {"id": "5f02b488c728d488e760677241e822777fba57aa", "type": "plain-text", "url": "s3://ai2-s2-pdf-extraction-prod/parse-results/s2orc_worker/755b28c3e39b4024f6028c41a3025dab23ab4866.txt", "contents": "\nReachability in Two-Clock Timed Automata is PSPACE-complete\n20 Feb 2013\n\nJohn Fearnley \nDepartment of Computer Science\nUniversity of Liverpool\nUK\n\nMarcin Jurdzi\u0144ski \nDepartment of Computer Science\nUniversity of Warwick\nUK\n\nReachability in Two-Clock Timed Automata is PSPACE-complete\n20 Feb 2013\nA recent result has shown that reachability in two-clock timed automata is log-space equivalent to reachability in bounded onecounter automata[6]. We show that reachability in bounded one-counter automata is PSPACE-complete.\n\nIntroduction\n\nTimed automata [1] are a successful and widely used formalism, which are used in the analysis and verification of real time systems. A timed automaton is a nondeterministic finite automaton that is equipped with a number of real-valued clocks, which allow the automaton to measure the passage of time.\n\nPerhaps the most fundamental problem for timed automata is the reachability problem: given an initial state, can the automaton perform a sequence of transitions in order to reach a specified target state? In their seminal paper on timed automata [1], Alur and Dill showed that this problem is PSPACE-complete. To show hardness for PSPACE, their proof starts with a linear bounded automaton (LBA), which is a non-deterministic Turing machine with a fixed tape length n. They produce a timed automaton with 2n + 1 clocks, and showed that the timed automaton can reach a specified state if and only if the LBA halts.\n\nHowever, the work of Alur and Dill did not address the case where the number of clocks is small. This was rectified by Courcoubetis and Yannakakis [4], who showed that reachability in timed automata with only three clocks is still PSPACE-complete. Their proof cleverly encodes the tape of an LBA in a single clock, and then uses the two additional clocks to perform all necessary operations on the encoded tape. In contrast to this, Laroussinie et al. have shown that reachability in one-clock timed automata is complete for NLOGSPACE, and therefore no more difficult than computing reachability in directed graphs [7].\n\nThe complexity of reachability in two-clock timed automata has been left open. The best known lower bound was given by Laroussinie et al., who gave a proof that the problem is NP-hard via a very natural reduction from subsetsum [7]. Moreover, the problem lies in PSPACE, because reachability in two-clock timed automata is obviously easier than reachability in three-clock timed automata. However, the PSPACE-hardness proof of Courcoubetis and Yannakakis seems to fundamentally require three clocks, and does not naturally extend to the two-clock case. Naves [8] has shown that several extensions to two-clock timed automata lead to PSPACE-completeness, but his work does not advance upon the NP-hard lower bound for unextended two-clock timed automata.\n\nIn a recent paper, Haase et al. have shown a link between reachability in timed automata and reachability in bounded counter automata [6]. A bounded counter automaton is a non-deterministic finite automaton equipped with a set of counters, and the transitions of the automaton may add or subtract arbitrary integer constants to the counters. The state space of each counter is bounded by some natural number b, so the counter may only take values in the range [0, b]. Moreover, transitions may only be taken if they do not increase or decrease a counter beyond the allowable bounds. This gives these seemingly simple automata a surprising amount of power, because the bounds can be used to implement inequality tests against the counters.\n\nHaase et al. show that reachability in two-clock timed automata is log-space equivalent to reachability in bounded one-counter automata. Reachability in bounded one-counter automata has also been studied in the context of one-clock timed automata with energy constraints [2], where it was shown that the problem lies in PSPACE, and is NP-hard. It has also been shown that the reachability problem for unbounded one-counter automata is NP-complete [5], but the NP containment proof does not seem to generalise to bounded one-counter automata.\n\nOur contribution. We show that satisfiability for quantified boolean formulas can be reduced, in polynomial time, to reachability in bounded one-counter automata. Hence, we show that reachability in bounded one-counter automata is PSPACE-complete, and therefore we resolve the complexity of reachability in two-clock timed automata. Our reduction uses two intermediate steps: subsetsum games and bounded counter-stack automata.\n\nCounter automata are naturally suited for solving subset-sum problems, so our reduction starts with a quantified version of subset-sum, which we call subsetsum games. One interpretation of satisfiability for quantified boolean formulas is to view the problem as a game between an existential player, and a universal player. The players take in turns to set their propositions to true or false, and the existential player wins if and only if the boolean formula is satisfied. Subsetsum games follow the same pattern, but apply it to subset-sum: the two players alternate in choosing numbers from sets, and the existential player wins if and only if the chosen numbers sum to a given target. Previous work by Travers can be applied to show that subset-sum games are PSPACE-complete [9].\n\nWe reduce subset-sum games to reachability in bounded one-counter automata. However, we will not do this directly. Instead, we introduce bounded counter-stack automata, which are able to store multiple counters, but have a stack-like restriction on how these counters may be accessed. These automata are a convenient intermediate step, because having access to multiple counters makes it easier for us to implement subset-sum games. Moreover, the stack based restrictions means that it is relatively straightforward to to show that reachability in bounded counter-stack automata is reducible, in polynomial time, to reachability in bounded one-counter automata, which completes our result.\n\n\nBounded one-counter automata\n\nA bounded one-counter automaton has a single counter that can store values between 0 and some bound b \u2208 N. The automaton may add or subtract values from the counter, so long as the bounds of 0 and b are not overstepped. This can be used to test inequalities against the counter. For example, to test whether the counter is larger than some n \u2208 N, we first attempt to subtract n + 1 from the counter, then, if that works, we add n + 1 back to the counter. This creates a sequence of two transitions which can be taken if, and only if, the counter is greater than n. A similar construction can be given for less-than tests. For the sake of convenience, we will include explicit inequality testing in our formal definition, with the understanding that this is not actually necessary.\n\nWe now give a formal definition. For two integers a, b \u2208 Z we define [a, b] = {n \u2208 Z : a \u2264 n \u2264 b} to be the subset of integers between a and b. A bounded one-counter automaton is defined by a tuple (L, b, \u2206, l 0 ), where L is a finite set of locations, b \u2208 N is a global counter bound, \u2206 specifies the set of transitions, and l 0 \u2208 L is the initial location. Each transition in \u2206 has the form (l, p, g 1 , g 2 , l \u2032 ), where l and l \u2032 are locations, p \u2208 [\u2212b, b] specifies how the counter should be modified, and g 1 , g 2 \u2208 [0, b] give lower and upper guards for the counter.\n\nEach state of the automaton consists of a location l \u2208 L along with a counter value c. Thus, we define the set of states to be L \u00d7 [0, b]. A transition exists between a state (l, c) \u2208 S, and a state (l \u2032 , c \u2032 ) \u2208 S if there is a transition (l, p, g 1 , g 2 , l \u2032 ) \u2208 \u2206, where g 1 \u2264 c \u2264 g 2 , and c \u2032 = c + p.\n\nThe reachability problem for bounded one-counter automaton is: starting at the state (l 0 , 0), can the automaton reach a specified target state (l t , c t )? It has been shown that the reachability problem for bounded one-counter automata is equivalent to the reachability problem for two-clock timed automata.\n\nTheorem 1 ( [6]). Reachability in bounded one-counter automata is log-space equivalent to reachability in two-clock timed automata.\n\n\nSubset-sum games\n\nA subset-sum game is played between an existential player and a universal player. The game is specified by a pair (\u03c8, T ), where T \u2208 N, and \u03c8 is a list:\n\u2200 {A 1 , B 1 } \u2203 {E 1 , F 1 } . . . \u2200 {A n , B n } \u2203 {E n , F n }, where A i , B i , E i , and F i , are all natural numbers.\nThe game is played in rounds. In the first round, the universal player chooses an element from {A 1 , B 1 }, and the existential player responds by choosing an element from {E 1 , F 1 }. In the second round, the universal player chooses an element from {A 2 , B 2 }, and existential player responds by choosing an element from {E 2 , F 2 }. This pattern repeats for rounds 3 through n. Thus, at the end of the game, the players will have constructed a sequence of numbers, and the existential player wins if and only if the sum of these numbers is T .\n\nFormally, the set of plays of the game is the set:\nP = 1\u2264j\u2264n {A j , B j } \u00d7 {E j , F j }.\nA play P \u2208 P is winning for the existential player if and only if P = T . A strategy for the existential player is a list of functions s = (s 1 , s 2 , . . . , s n ), where each function s i dictates how the existential player should play in the ith round of the game. Thus, each function s i is of the form:\ns i : 1\u2264j\u2264i {A j , B j } \u2192 {E i , F i }.\nThis means that the function s i maps the first i moves of the universal player to a decision for the existential player in the ith round.\n\nA play P conforms to a strategy s if the decisions made by the existential player in P always agree with s. More formally, for each i in the range 1 \u2264 i \u2264 n, we define F i = P \u2229 1\u2264j\u2264i {A j , B j } to be the first i moves made by the universal player. The play P conforms to a strategy s = (s 1 , s 2 , . . . , s k ) if s i (F i ) \u2208 P , for all i. Given a strategy s, we define the set of conforming plays to be Plays(s). Note that, since the universal player makes exactly n choices, the set Plays(s) contains exactly 2 n different plays.\n\nA strategy s is winning if every play P \u2208 Plays(s) is winning for the existential player. The subset-sum game problem is to decide, for a given SSG instance (\u03c8, T ), whether the existential player has a winning strategy for (\u03c8, T ).\n\nThe SSG problem clearly lies in PSPACE, because it can be solved on a polynomial time alternating Turing machine. A quantified version of subset-sum has been shown to be PSPACE-hard, via a reduction from quantified boolean formulas [9]. Since SSGs are essentially a quantified version of subset-sum, the proof of PSPACE-hardness easily carries over. See Appendix A for further details. \n\n\nCounter-Stack Automata\n\nOutline. In this section we ask: can we use a bounded one-counter automaton to store multiple counters? The answer is yes, but doing so forces an interesting set of restrictions on the way in which the counters are accessed. By the end of this section, we will have formalised these restrictions as counter-stack automata.\n\nSuppose that we have a bounded-one counter automaton with counter c and bound b = 15. Hence, the width of the counter is 4 bits. Now suppose that we wish to store two 2-bit counters c 1 and c 2 in c. We can do this as follows:\nc = 1 0 0 1 c 2 c 1\nWe allocate the top two bits of c to store c 2 , and the bottom two bits to store c 1 . We can easily write to both counters: if we want to increment c 2 then we add 4 to c, and if we want to increment c 1 then we add 1 to c. However, if we want to test equality, then things become more interesting. It is easy to test equality against c 2 : if we want to test whether c 2 = 2, then we test whether 8 \u2264 c \u2264 11 holds. But, we cannot easily test whether c 1 = 2 because we would have to test whether c is 2, 6, 10, or 14, and this list grows exponentially as the counters get wider. However, if we know that c 2 = 1, then we only need to test whether c = 6. Thus, we arrive at the following guiding principal: if you want to test equality against c i , then you must know the values of c j for all j > i. Counter-stack automata are a formalisation of this principal.\n\nCounter-stack automata. A counter-stack automaton has a set of k distinct counters, which are referred to as c 1 through c k . For our initial definitions, we will allow the counters to take all values from N, but we will later refine this by defining bounded counter-stack automata. The defining feature of a counter-stack automaton is that the counters are arranged in a stack-like fashion:\n\n-All counters may be increased at any time. When the automaton increases a counter, it adds a specified number n \u2208 N to that counter. The automaton has the ability to perform equality tests against a counter, but the stack-based restrictions must be respected. An example of a valid equality test would be c k = 3 \u2227 c k\u22121 = 10, because c k\u22121 = 10 only needs to be tested in the case where c k = 3 is known to hold. Conversely, the test c k\u22121 = 10 by itself is invalid, because it places no restrictions on the value of c k .\n\nThe automaton may also reset a counter, but the stack-based restrictions apply. Counter c i may only be reset by a transition, if that transition tests equality against the values of c i through c k . For example, c k\u22121 may only be reset if the transition is guarded by a test of the form c k\u22121 = n 1 \u2227 c k\u22122 = n 2 .\n\nFormal definition. A counter-stack automaton is a tuple (L, C, \u2206, l 0 ), where L is a finite set of locations, C = [1, k] is a set of counter indexes, l 0 \u2208 L is an initial state, and \u2206 specifies the transition relation. Each transition in \u2206 has the form (l, E, I, R, l \u2032 ) where:\n-l, l \u2032 \u2208 L is a pair of locations, -E is a partial function from C to N which specifies the equality tests. If E(i)\nis defined for some i, then E(j) must be defined for all j \u2208 C with j > i. -I \u2208 N k specifies the how the counters must be increased, -R \u2286 C specifies the set of counters that must be reset. It is required that E(r) is defined for every r \u2208 R.\n\nEach state of the automaton is a location annotated with values for each of the k counters. That is, the state space of the automaton is L \u00d7 N k . A state (l, c 1 , c 2 , . . . , c k ) can transition to a state (l \u2032 , c \u2032 1 , c \u2032 2 , . . . , c \u2032 k ) if, and only if, there exists a transition (l, E, I, R, l \u2032 ) \u2208 \u2206, where the following conditions hold:\n-For every i for which E(i) is defined, we must have c i = E(i). -For every i \u2208 R, we must have c \u2032 i = 0. -For every i / \u2208 R, we must have c \u2032 i = c i + I i .\nA run is a sequence of states s 0 , s 1 , . . . , s n , where each s i can transition to s i+1 . To solve the reachability problem for counter-stack automata, we must decide whether there is a run from (l 0 , 0, 0, . . . , 0) to a target state (l t , t 1 , t 2 , . . . , t k ).\n\nA counter-stack automaton is b-bounded, for some b \u2208 N, if it is impossible for the automaton to increase a counter beyond b. Formally, this condition requires that, for every state (l, c 1 , c 2 , . . . , c k ) that can be reached by a run from (l 0 , 0, 0, . . . , 0), we have c i \u2264 b for all i. We say that a counter-stack automaton\nis bounded, if it is b-bounded for some b \u2208 N.\nSimulation by a bounded one-counter automaton. A bounded counterstack automaton is designed to be simulated by a bounded one-counter automaton. To do this, we follow the construction outlined at the start of this section: we split the bits of the counter c into k chunks, where each chunk represents one of the counters c i . Note that the boundedness assumption is crucial, because otherwise incrementing c i may overflow the allotted space, and inadvertently modify the value of c i+1 . See Appendix B for more details of the construction.\n\n\nLemma 3. Reachability in bounded counter-stack automata is polynomial-time reducible to reachability in bounded one-counter automata.\n\n\nOutline Of The Construction\n\nOur goal is to show that reachability in bounded counter-stack automata is PSPACE-hard. To do this, we will show that subset-sum games can be solved by bounded counter-stack automata. In this section, we give an overview of our construction using the following two-round QSS game.\n\u2200 {A 1 , B 1 } \u2203 {E 1 , F 1 } \u2200 {A 2 , B 2 } \u2203 {E 2 , F 2 }, T .\nFor brevity, we will refer to this instance as (\u03c8, T ) for the rest of this section. The construction is split into two parts: the play gadget, and the reset gadget. The play gadget. The play gadget is shown in Figure 1. The construction uses 9 counters. The locations are represented by circles, and the transitions are represented by edges. The annotations on the transitions describe the increments, resets, and equality tests: the notation c i + n indicates that n is added to counter i, the notation R(c i ) indicates that counter i is reset to 0, and the notation c i = n indicates that the transition may only be taken when c i = n is satisfied. This gadget allows the automaton to implement a play of the SSG. The locations u 1 and u 2 allow the automaton to choose the first and second moves of the universal player, while the locations e 1 and e 2 allow the automaton to choose the first and second moves for the existential player. As the play is constructed, a running total is stored in c 9 , which is the top counter on the stack. The final transition between w 1 and w 2 checks whether the existential player wins the play, and then resets c 9 . Thus, the set of runs between u 1 and w 2 corresponds precisely to the set of plays won by the existential player in the SSG.\nu 1 e 1 u 2 e 2 w 1 w 2 c1 + 1, c9 + A1 c2 + 1, c9 + B1 c3 + 1, c9 + E1 c4 + 1, c9 + F1 c5 + 1, c9 + A2 c6 + 1, c9 + B2 c7 + 1, c9 + E2 c8 + 1, c9 + F2 c9 = T R(c9)\nIn addition to this, each outgoing transition from u i or e i comes equipped with its own counter. This counter is incremented if and only if the corresponding edge is used during the play, and this allows us to check precisely which play was chosen. These counters will be used by the reset gadget. The idea behind our construction is to force the automaton to pass through the play gadget multiple times. Each time we pass through the play gadget, we will check a different play, and our goal is to check a set of plays that verify whether the existential player has a winning strategy for the SSG.\n\nWhich plays should be checked? In our example, we must check four plays. The format of these plays is shown in Table 1. Table 1. The set of plays that the automaton will check.\nPlay u1 e1 u2 e2 1 A1 E1 or F1 A2 E2 or F2 2 A1 Unchanged B2 E2 or F2 3 B1 E1 or F1 A2 E2 or F2 4 B1 Unchanged B2 E2 or F2\nThe table shows four different plays, which cover every possible strategy choice of the universal player. Clearly, if the existential player does have a winning strategy, then that strategy should be able to win against all strategy choices of the universal player. The plays are given in a very particular order: the first two plays contain A 1 , while the second two plays contain B 1 . Moreover, we always check A 2 , before moving on to B 2 .\n\nWe want to force the decisions made at e 1 and e 2 to form a coherent strategy for the existential player. In this game, a strategy for the existential player is a pair s = (s 1 , s 2 ), where s i describes the move that should be made at e i . It is critical to note that s 1 only knows whether A 1 or B 1 was chosen at u 1 . This restriction is shown in the table: the automaton may choose freely between E 1 and F 1 in the first play. However, in the second play, the automaton must make the same choice as it did in the first play. The same relationship holds between the third and fourth plays. These restrictions ensure that the plays shown in Table 1 are a description of a strategy for the existential player.\nw 2 r \u2032 2 r 2 r \u2032 1 r 1 u 1 t c7 = 1, c8 = 0 R(c7, c8) c7 = 0, c8 = 1 R(c7, c8) c5 = 1, c6 = 0 c 5 = 1 , c 6 = 1 R ( c 5 , c 6 ) c3 = 2, c4 = 0 R(c3, c4) c3 = 0, c4 = 2 R(c3, c4) c 1 = 2 , c 2 = 0 c 1 = 2 , c 2 = 2 R ( c 1 , c 2 )\n\nFig. 2. The reset gadget\n\nThe reset gadget. The reset gadget, shown in Figure 2, enforces the constraints shown in Table 1. The locations w 2 and u 1 represent the same locations as they did in Figure 1. To simplify the diagram, we have only included meaningful equality tests. Whenever we omit a required equality test, it should be assumed that the counter is 0. For example, the outgoing transitions from r 2 implicitly include the requirement that c 7 , c 8 , and c 9 are all 0. We consider the following reachability problem: can (t, 0, 0, . . . , 0) be reached from (u 1 , 0, 0, . . . , 0)? The structure of the reset gadget places restrictions on the runs that reach t. All such runs pass through the reset gadget exactly four times, and the following table describes each pass:\nPass Path 1 w 2 \u2192 r \u2032 2 \u2192 r 2 \u2192 u 1 2 w 2 \u2192 r \u2032 2 \u2192 r 2 \u2192 r \u2032 1 \u2192 r 1 \u2192 u 1 3 w 2 \u2192 r \u2032 2 \u2192 r 2 \u2192 u 1 4 w 2 \u2192 r \u2032 2 \u2192 r 2 \u2192 r \u2032 1 \u2192 r 1 \u2192 t\nTo see why these paths must be taken, observe that, for every i \u2208 {1, 3}, each pass through the play gadget increments either c i or c i+1 , but not both. This means that the first time that we arrive at r 2 , we must take the transition directly to u 1 , because the guard on the transition to r \u2032 1 cannot possibly be satisfied after a single pass through the play gadget. When we arrive at r 2 on the second pass, we are forced to take the transition to r \u2032 1 , because we cannot have c 5 = 1 and c 6 = 0 after two passes through the play gadget. This transition resets both c 5 and c 6 , so the pattern can repeat again on the third and fourth visits to r 2 . The location r 1 behaves in the same way as r 2 , but the equality tests are scaled up, because r 1 is only visited on every second pass through the reset gadget.\n\nWe can now see that all strategies of the universal player must be considered. The transition between r 2 and u 1 forces the play gadget to increment c 5 , and therefore the first and third plays must include A 2 . Similarly, the transition between r 2 and r \u2032 1 forces the second and fourth plays to include B 2 . Meanwhile, the transition between r 1 and u 1 forces the first and second plays to include A 1 , and the transition between r 1 and t forces the third and fourth plays to include B 1 . Thus, we select the universal player strategies exactly as Table 1 prescribes.\n\nThe transitions between r \u2032 1 and r 1 check that the existential player is playing a coherent strategy. When the automaton arrives at r \u2032 1 during the second pass, it verifies that either E 1 was included in the first and second plays, or that F 1 was included in the first and second plays. If this is not the case, then the automaton gets stuck. The counters c 3 and c 4 are reset when moving to r 1 , which allows the same check to occur during the fourth pass. For the sake of completeness, we have included the transitions between r \u2032 2 and r 2 , which perform the same check for E 2 and F 2 . However, since the existential player is allowed to change this decision on every pass, the automaton can never get stuck at r \u2032 2 . The end result is that location t can be reached if and only if the existential player has a winning strategy for (\u03c8, T ). As we will show in the next section, the construction extends to arbitrarily large SSGs, which then leads to a proof that reachability in counter-stack automata is PSPACE-hard. Note that all counters in this construction are bounded: c 9 is clearly bounded by the maximum value that can be achieved by a play of the SSG, and reset gadget ensures that no other counter may exceed 4. Thus, we will have completed our proof of PSPACEhardness for bounded one-counter automata and two-clock timed automata.\n\n\nFormal Definition and Proof\n\nSequential strategies for SSGs. We start by formalising the ideas behind Table 1. Recall that the table gives a strategy for the existential player in the form of a list of plays. Moreover, the table gave a very specific ordering in which these plays must appear. We now formalise this ordering.\n\nWe start by dividing the integers in the interval [1, 2 n ] into i-blocks. The 1-blocks partition the interval into two equally sized blocks. The first 1-block consists of the range [1, 2 n\u22121 ], and the second 1-block consists of the range [2 n\u22121 + 1, 2 n ]. There are four 2-blocks, which partition the 1-blocks into two equally sized sub-ranges. This pattern continues until we reach the n-blocks.\n\nFormally, for each i \u2208 {1, 2, . . . , n}, then there are 2 i distinct i-blocks. The set of i-blocks can be generated by considering the intervals [k + 1, k + 2 n\u2212i ] for the first 2 i numbers k \u2265 0 that satisfy k mod 2 n\u2212i = 0. An i-block is even if k is an even multiple of 2 n\u2212i , and it is odd if k is an odd multiple of 2 n\u2212i .\n\nThe ordering of the plays in Table 1 can be described using blocks. There are four 2-blocks, and A 2 appears only in even 2-blocks, while B 2 only appears in odd 2-blocks. Similarly, A 1 only appears in the even 1-block, while B 1 only appears in the odd 1-block. The restrictions on the existential player can also be described using blocks: the existential player's strategy may not change between E i and F i during a i-block. We generalise this idea in the following definition.\n\nDefinition 4 (Sequential strategy). A sequential strategy for the existential player in (\u03c8, T ) is a list of 2 n plays S = P 1 , P 2 , . . . , P 2 n , where for every i-block L we have:\n\n-If L is an even i-block, then P j must contain A i for all j \u2208 L.\n\n-If L is an odd i-block, then P j must contain B i for all j \u2208 L.\n\n-We either have E i \u2208 P j for all j \u2208 L, or we have F i \u2208 P j for all j \u2208 L.\n\nWe say that S is winning for the existential player if P j = T for every P j \u2208 S. Since a sequential strategy is simply a strategy written in the form of a list, we have the following lemma. See Appendix C for further details.\n\n\nLemma 5. The existential player has a winning strategy if and only if the existential player has a sequential winning strategy.\n\nThe base automaton. We describe the construction in two steps. Recall, from Figures 1 and 2, that the top counter is used by the play gadget to store the value of the play, and to test whether the play is winning. We begin by constructing a version of the automaton that omits the top counter. That is, if c k is the top counter, we modify the play gadget by removing all increases to c k , and the equality test for c k between w 1 and w 2 . We call this the base automaton. Later, we will add the constraints for c k back in, to construct the full automaton.\n\nWe now give a formal definition of the base automaton. Throughout this definition, we keep consistency with the location and counter names used in Figures 1 and 2. For each natural number n, we define a counter-stack automaton A n as follows. The automaton has the following set of locations The automaton uses k = 2n + 1 counters. The top counter c k is reserved for the full automaton, and will not be used in this construction. We will identify counters 1 through 2n using the following shorthands. For each integer i, we define a i = c 4(i\u22121)+1 , we define b i = c 4(i\u22121)+2 , we define e i = c 4(i\u22121)+3 , and we define f i = c 4(i\u22121)+4 . Note that, in Figure 1, we have a 1 = c 1 and a 2 = c 5 , and these are precisely the counters associated with A 1 and A 2 , respectively. The same relationship holds between b i and B i , and so on.\n\nThe transitions of the automaton are defined as follows. Whenever we omit a required equality test against a counter c i , it should be assumed that the transition includes the test c i = 0.\n\n-Each location u i has two transitions to e i .\n\n\u2022 A transition that adds 1 to a i .\n\n\u2022 A transition that adds 1 to b i . -We define u n+1 to be a shorthand for w 1 . Each location e i has two transitions to u i+1 .\n\n\u2022 A transition that adds 1 to e i .\n\n\u2022 A transition that adds 1 to f i . -Location w 1 has a transition to w 2 , and w 2 has a transition to r \u2032 n . These transitions do not increase any counter, and do not test any equalities.\n\n-Each location r \u2032 i has two outgoing transitions to r i . \u2022 A transition that tests e i = 2 n\u2212i and f i = 0.\n\n\u2022 A transition that tests e i = 0 and f i = 2 n\u2212i .\n\n-We define r \u2032 0 to be shorthand for location t. Each location r i has two outgoing transitions.\n\n\u2022 A transition to u 1 that tests a i = 2 n\u2212i and b i = 0.\n\n\u2022 A transition to r \u2032 i\u22121 that tests a i = 2 n\u2212i and b i = 2 n\u2212i .\n\nRuns in the base automaton. We now describe the set of runs are possible in the base automaton. We decompose every run of the automaton into segments, such that each segment contains a single pass through the play gadget. More formally, we decompose R into segments R 1 , R 2 , . . . , where each segment R i starts at u 1 , and ends at the next visit to u 1 . We say that a run gets stuck if the run does not end at (t, 0, 0, . . . , 0), and if the final state of the run has no outgoing transitions. We say that a run R gets stuck during an i-block L if there exists a j \u2208 L such that R j gets stuck. The following lemma gives a characterisation of the runs in A n . See Appendix D for further details. -If L is an even i-block, then R j must increment a i for every j \u2208 L.\n\n-If L is an odd i-block, then R j must increment b i for every j \u2208 L.\n\n-Either R j increments e i for every j \u2208 L, or R j increments f i for every j \u2208 L.\n\nWe say that a run is successful if it eventually reaches (t, 0, 0, . . . , 0). By definition, a run is successful if and only if it never gets stuck. Also, the transition from r 1 to t ensures that every successful run must have exactly 2 n segments. With these facts in mind, if we compare Lemma 6 with Definition 4, then we can see that the set of successful runs in A n corresponds exactly to the set of sequential strategies for the existential player in the SSG.\n\nSince we eventually want to implement A n as a bounded one-counter automaton, it is important to prove the A n is bounded. We do this in the following Lemma. See Appendix E for full details. The full automaton. Let (\u03c8, T ) be an SSG instance, where \u03c8 is:\n\u2200 {A 1 , B 1 } \u2203 {E 1 , F 1 } . . . \u2200 {A n , B n } \u2203 {E n , F n }.\nWe will construct a counter-stack automaton A \u03c8 from A n . Recall that the top counter c k is unused in A n . We modify the transitions of A n as follows. Let \u03b4 be a transition. If \u03b4 increments a i then it also adds A i to c k , if \u03b4 increments b i then it also adds B i to c k , if \u03b4 increments e i then it also adds E i to c k , and if \u03b4 increments f i then it also adds F i to c k . We also modify the transition between w 1 and w 2 , so that it checks whether c k = T , and resets c k .\n\nSince we only add extra constraints to A n , the set of successful runs in A \u03c8 is contained in the set of successful runs of A n . Recall that the set of successful runs in A n encodes the set of sequential strategies for the existential player in (\u03c8, T ). In A \u03c8 , we simply check whether each play in the sequential strategy is winning for the existential player. Thus, we have shown the following lemma.\n\nLemma 8. The set of successful runs in A \u03c8 corresponds precisely to the set of winning sequential strategies for the existential player in (\u03c8, T ).\n\nWe also have that A \u03c8 is bounded. Counters c 1 through c k\u22121 are bounded due to Lemma 7, and counter c k is bounded by\n{A i , B i , E i , F i : 1 \u2264 i \u2264 n}.\nThis completes the reduction from subset-sum games to bounded counter-stack automata, and gives us our main theorem.\n\n\nTheorem 9. Reachability in bounded counter-stack automata is PSPACE-hard.\n\nCorollary 10. We have:\n\n-Reachability in bounded one-counter automata is PSPACE-complete.\n\n-Reachability in 2-clock timed automata is PSPACE-complete.\n\n\nA Proof of Lemma 2\n\nOutline. A quantified version of subset-sum has already been shown to be PSPACE-hard [9], and the proof easily carries over for the case of SSGs. For the sake of completeness, we provide a direct proof that SSGs are PSPACE-hard, which closely follows the ideas laid out in [9].\n\nThe proof follows the NP-hardness proof for subset-sum, taken from [3][Theorem 34.10]. The key observation is that, if we begin with a quantified version of 3-SAT, then we end up with an SSG.\n\nSubset-sum is NP-hard. We now give a summary of the NP-hardness proof given in [3][Theorem 34.10]. We will describe the reduction using a worked example taken from [3]. Consider the following 3-CNF formula:\n\u03c6 = C 1 \u2227 C 2 \u2227 C 3 \u2227 C 4 C 1 = (x 1 \u2228 \u00acx 2 \u2228 \u00acx 3 ) C 2 = (\u00acx 1 \u2228 \u00acx 2 \u2228 \u00acx 3 ) C 3 = (\u00acx 1 \u2228 \u00acx 2 \u2228 x 3 ) C 4 = (x 1 \u2228 x 2 \u2228 x 3 )\nThis formula has three variables, x 1 , x 2 , and x 3 , and four clauses, C 1 through C 4 . The reduction assumes that there is no clause C i that contains both x i and \u00acx i , because otherwise C i would be always be satisfied.\n\nThe reduction constructs a subset-sum instance, which is described in the following table:\nx 1 x 2 x 3 C 1 C 2 C 3 C 4 v 1 = 1 0 0 1 0 0 1 v \u2032 1 = 1 0 0 0 1 1 0 v 2 = 0 1 0 0 0 0 1 v \u2032 2 = 0 1 0 1 1 1 0 v 3 = 0 0 1 0 0 1 1 v \u2032 3 = 0 0 1 1 1 0 0 s 1 = 0 0 0 1 0 0 0 s \u2032 1 = 0 0 0 2 0 0 0 s 2 = 0 0 0 0 1 0 0 s \u2032 2 = 0 0 0 0 2 0 0 s 3 = 0 0 0 0 0 1 0 s \u2032 3 = 0 0 0 0 0 2 0 s 4 = 0 0 0 0 0 0 1 s \u2032 4 = 0 0 0 0 0 0 2 t = 1 1 1 4 4 4 4\nEach row should be read as a number written in decimal. For example, the first row specifies the number v 1 = 1001001. The subset-sum instance asks whether there is a subset of rows v 1 through s \u2032 4 that sums to row t.\n\nThe table is constructed according to the following rules. Each column is labelled: the first three columns are labelled by the variables x 1 through x 3 , and the rest of the columns are labelled by the clauses C 1 through C 4 . For each variable x i we define two rows:\n\nv i has a 1 in column x i , and a 1 in every column C i that contains x i .\n\nv \u2032 i has a 1 in column x i , and a 1 in every column C i that contains \u00acx i .\n\nIn addition to these, for each clause C i we define two slack rows: the row s i has a 1 in column C i , and the row s \u2032 i has a 2 in column C i . To see that this reduction works, suppose that we know a satisfying assignment of the CNF formula. We can use this to construct a solution to the subset-sum instance. If x i is true in the satisfying assignment, then we select v i , and if it is false then we select v \u2032 i . In doing so, we construct a subset with the following properties:\n\n-For each column x i , we have that the sum of that column is 1, because we never select both v i and v \u2032 i . -For each column C i , we have that the sum of that column is at least 1, because every clause must be satisfied. -For each column C i , we have that the sum of that column is at most 3, because each clause contains exactly 3 variables.\n\nThese properties ensure that, for each column C i , we can always select a subset of the slack columns, s i and s \u2032 i , so that the sum of the column is 4. Thus, every satisfying assignment of the CNF formula corresponds to a solution of the subset-sum instance.\n\nFor similar reasons, every solution of the subset-sum instance corresponds to a satisfying assignment of the CNF formula, by simply ignoring the slack rows. Since every column C i must sum to 4, we know that after removing the slacks, each column must sum to at least 1. This, combined with the fact that v i and v \u2032 i cannot be selected at the same time, implies that we have a satisfying assignment for the CNF formula.\n\nSee [3] for a full proof correctness of the NP-hardness reduction.\n\nChanging the format. Our definition of an SSG requires a very specific format for the input instance. In particular, each quantifier is associated with exactly two natural numbers. However, the reduction that we have described can be written down very naturally as a one-player SSG, in which only the existential player is allowed to move. For our example, the instance is (V S 1 S 2 S 3 S 4 , t), where:\nV = \u2203 {v 1 , v \u2032 1 } \u2203 {v 2 , v \u2032 2 } \u2203 {v 3 , v \u2032 3 }, S i = \u2203 {s i , 0} \u2203 {s \u2032 i , 0}.\nNote that it is valid to force the choice between v i and v \u2032 i , because no solution of the subset-sum instance can contain both of these numbers.\n\nSubset-sum games are PSPACE-complete. It is now easy to reduce a quantified boolean formula to an SSG. We simply follow the existing reduction, but if variable x i is universally quantified, then we use \u2200{v i , v \u2032 i } rather than \u2203{v i , v \u2032 i }. For example, if we consider the quantified boolean formula \u2200x 1 \u2203x 2 \u2200x 3 \u03c6, where \u03c6 is defined as before, then we produce the quantified subset-sum instance (V \u2032 S 1 S 2 S 3 S 4 , t), where:\nV \u2032 = \u2200{v 1 , v \u2032 1 } \u2203{v 2 , v \u2032 2 } \u2200{v 3 , v \u2032 3 },\nand S i is defined as before. The final step is to ensure a strict alternation of quantifiers, which the definition of an SSG requires. This can easily be achieved by inserting \"dummy\" quantifiers, where necessary. That is, we can insert \u2203{0, 0} between two consecutive \u2200 quantifiers, and we can insert \u2200{0, 0} between two consecutive \u2203 quantifiers. This change obviously cannot affect the winner of the SSG.\n\n\nB Proof of Lemma 3\n\nLet S = (L, C, \u2206, l 0 ) be a b-bounded counter-stack automaton. Without loss of generality, we will assume that b = 2 n \u2212 1, which means that each counter in S is n bits wide. We will construct a bounded one-counter automaton B = (L \u2032 , b \u2032 , \u2206 \u2032 , l \u2032 0 ) that simulates S. We will refer to the counters of S as c 1 through c k , and the counter of B as c.\n\nWe will follow the approach laid out at the start of Section 4. That is, we will set the bound b \u2032 = 2 k\u00b7n \u2212 1 so that c is k \u00b7 n bits wide. We then partition these bits in order to implement the counters c 1 through c k . The counter c k will use the n most significant bits, the counter c k\u22121 will use the next n most significant bits, and so on.\n\nWe introduce some notation to formalise this encoding. Let x \u2208 [0, b] be a counter value for counter c i . We define Enc(x, i) = x \u00b7 2 (i\u22121)\u00b7n . To understand this definition, note that for i = 1, we have Enc(x, i) = x. Then, for i = 2, we have that Enc(x, i) is the value of x bit-shifted to the left n times. Thus, this definition simply translates x to the correct position in c.\n\nWe can now define the translation. We will set L \u2032 = L and l \u2032 0 = l 0 , which means that both automata have the same set of locations, and the same start location. We will use the transitions in \u2206 \u2032 to simulate S. For each transition t = (l, E, I, R, l \u2032 ) \u2208 \u2206, we construct a transition t \u2032 = (l, p, g 1 , g 2 , l \u2032 ) \u2208 \u2206 \u2032 between the same pair of locations. We want to have the following property: transition t can be used from a state (l, c 1 , c 2 , . . . , c k ) in S if and only if transition t \u2032 can be used from the state (l, i Enc(c i , i)) in B.\n\nWe begin by defining p. We set:\np = i / \u2208R Enc(I i , i) \u2212 i\u2208R Enc(E(i), i).\nIn other words, for each counter i / \u2208 R that is not to be reset, we add Enc(I i , i) to c, which correctly adds I i to c i . Note that the boundedness assumption on S implies that the counters can never overflow due to this operation. For the counters i \u2208 R, we subtract E(i) from c i . Recall that E(i) must always be defined for the indices i \u2208 R. Furthermore, the transition may only be taken if c i = E(i). Thus, subtracting E(i) from c i will correctly set it to 0.\n\nNext we define the inequality tests. Let j be the smallest index for which E(j) is defined. Our guards are:\ng 1 = i\u2265j\nEnc(E(i), i),\ng 2 = i\u2265j Enc(E(i), i) + Enc(1, j) \u2212 1.\nIt is straightforward to show that, in our encoding scheme, we have c i = E(i) for all i \u2265 j if and only if g 1 \u2264 c \u2264 g 2 .\n\nIf we are given a target state s = (t, c 1 , c 2 , . . . , c k ) for S, then we can translate it into a target state s \u2032 = (t, i Enc(c i , i)) for B. The equivalence between the transitions in \u2206, and the transitions in \u2206 \u2032 implies that s can be reached from (l 0 , 0, 0, . . . , 0) if and only if s \u2032 can be reached from (l \u2032 0 , 0). This completes the proof of Lemma 3.\n\n\nC Proof of Lemma 5\n\nLet s = (s 1 , s 2 , . . . , s n ) be a winning strategy for the existential player. We define a sequential winning strategy as follows. Recall that Plays(s) contains exactly 2 n plays. We argue that these plays can be ordered so that they form a sequential strategy. We give an iterative procedure that achieves this task: the first step of the procedure will ensure that the 1-blocks contain the correct plays, the second step will ensure that the 2-blocks contain the correct plays, and so on. In the first step, we observe that exactly 2 n\u22121 of the plays contain A 1 , while exactly 2 n\u22121 of the plays contain B 1 , so we can order the plays so that the even 1-block contains all plays containing A 1 . Now suppose that we have found the i-blocks. We observe that each i-block L has exactly 2 n\u2212(i+1) plays that contain A i+1 . Therefore, for each i-block L, we can order the plays in L so that the even (i + 1)-block has all plays that contain A i+1 , and the odd (i + 1)-block has all plays that contain B i+1 . At the end of this procedure, we will have a list of plays S = P 1 , P 2 , . . . , P 2 n where:\n\n-P j contains A i whenever j is in an even i-block.\n\n-P j contains B i whenever j is in an odd i-block.\n\nSo S satisfies the first two conditions of Definition 4. We argue that S also satisfies the third condition. Let L be an i-block. By definition, for every j < i, there is a unique j-block that contains L. These blocks define a play prefix F \u2208 \u03a0 1\u2264j\u2264i {A i , B i }, and, for each play P j with j \u2208 L, we have F \u2286 P j . Since S is a reordering of Plays(s), we must have s i (F ) \u2208 P j for every j \u2208 L. Hence, S satisfies Definition 4. Moreover, since s is winning, we have that every play in Plays(s) is winning, and therefore S is a sequential winning strategy. Now let S = P 1 , P 2 , . . . , P 2 n be a winning sequential strategy. We give a high level description of a winning strategy for the SSG. At the start of the strategy we set L 0 = [1, 2 n ]. In each round i of the game, let D i \u2208 {A i , B i } be the decision made by the universal player. We select L i to be the unique i-block in L i\u22121 such that D i \u2208 P j for all j \u2208 L i . We play E i if E i \u2208 P j for all j \u2208 L i , and we play F i if F i \u2208 P j for all j \u2208 L i . It is straightforward to encode this strategy in the form s = (s 1 , s 2 , . . . , s n ). By construction, when we play s, the outcome of the game will be some play P j from S. Since every play P j in S is winning for the existential player, we have that s is a winning strategy.\n\n\nD Proof of Lemma 6\n\nLet R be a run in A n . The following lemma describes the set of reset states that each segment of R must pass through.\n\nLemma 11. Let R be a run in A n . Either:\n\n-R j visits precisely the reset locations {r \u2032 i , r i } for which j mod 2 n\u2212i = 0, or -R j gets stuck.\n\nProof. We will prove this lemma by induction over i. The base case, where i = n, is trivial because j mod 2 n\u2212n is always equal to 0, and it is clear from the construction that every segment R j must always visit both r \u2032 n and r n . For the inductive step, suppose that the lemma has been shown for i + 1, and will show that the lemma holds for i. We know that, in order to reach r \u2032 i or r i , a segment must first visit r \u2032 i+1 . By the inductive hypothesis, we know that only segments R j with j mod 2 n\u2212(i+1) visit r i+1 . At the start of R, we have a i = b i = 0. On the first visit to r i+1 , we clearly cannot take the transition to r \u2032 i , because we have a i + b i = 2 n\u2212(i+1) , and the transition to r \u2032 i requires a i + b i = 2 n\u2212i . Thus, we either have to take the transition to u 1 , or we get stuck. On the second visit to r i+1 , we cannot take the transition to u 1 , because we have a i + b i = 2 n\u2212i , and the transition to u 1 requires a i + b i = 2 n\u2212(i+1) . Thus, either we get stuck, or we take the transition to r \u2032 i . The transition between r i+1 and r \u2032 i resets a i and b i . Thus, we can repeat the argument, and conclude that locations r \u2032 i and r i are only visited by segments R j where j mod 2 n\u2212i = 0. \u2293 \u2294 Having shown Lemma 11 it is now easy to prove Lemma 6. Let R be a run of A n . For the counters a i and b i , we have the following facts:\n\n-At the start of the first i-block, we have a i = b i = 0.\n\n-Each i-block contains exactly 2 n\u2212i segments. Each segment must increment one of a i or b i , but not both. -At the end of each odd i-block, we must take the transition from r i to u 1 to avoid getting stuck. This transition requires a i = 2 n\u2212i and b i = 0.\n\n-At the end of each even i-block, we must take the transition from r i to r \u2032 i\u22121 to avoid getting stuck. This transition requires a i = 2 n\u2212i and b i = 2 n\u2212i , and resets a i and b i to 0.\n\nThese facts imply that a i must be incremented during every run in an odd iblock to prevent the automaton getting stuck, and b i must be incremented during every run in an even i-block to prevent the automaton getting stuck. It can also be verified that, if a i is incremented during every run in an odd i-block, and b i is incremented during every run in an even i-block, then the automaton will never get stuck at r i . Similarly, for the counters e i and f i we have the following facts.\n\n-At the start of the first i-block, we have e i = f i = 0.\n\n-Each i-block contains exactly 2 n\u2212i runs. Each run must increment one of e i or f i , but not both. -At the end of each i-block, we must take one of the two transitions from r \u2032 i to r i to avoid getting stuck. These transitions require that e i = 2 n\u2212i and f i = 0, or e i = 0 and f i = 2 n\u2212i .\n\nThese facts imply that either e i is incremented during every run in an i-block, or f i is incremented during every run in an i-block, or the automaton will get stuck when moving from r \u2032 i to r i at end of the i-block. It can also be verified that, if the automaton increases e i during every run in an i-block, then the automaton will not get stuck moving from r \u2032 i to r i , and if the automaton increases f i during every run in an i-block, then the automaton will not get stuck moving from r \u2032 i to r i .\n\nNote that, in A n , it is only possible for R to get stuck at the locations r \u2032 i and r i . Therefore, we have shown that R does not get stuck if and only if the three conditions of Lemma 6 hold for R.\n\n\nE Proof of Lemma 7\n\nThis lemma follows from Lemma 11. Let R be a run. Lemma 11 implies that the transition from r i to r \u2032 i\u22121 is taken in every segment R j such that j mod 2 n\u2212(i\u22121) . This transition resets both a i and b i to 0. Therefore, neither of these counters may exceed 2 n\u2212(i\u22121) . Similarly, Lemma 11 implies that every segment R j such that j mod 2 n\u2212i = 0 must move from r \u2032 i to r i . Both of the transitions from between r \u2032 i and r i reset e i and f i , and therefore neither of these counters may exceed 2 n\u2212i .\n\nLemma 2 .\n2The subset-sum game problem is PSPACE-complete.\n\n\nc i may only be tested for equality if the values of c i+1 through c k are known. -c i may only be reset if the values of c i through c k are known.\n\nFig. 1 .\n1The play gadget\n\n-\nFor each i \u2208 [1, n] we have a location u i and a location e i . -We have two check states w 1 and w 2 . -For each i \u2208 [1, n] we have two reset locations r i and r \u2032 i . -We have a goal location t.\n\nLemma 6 .\n6Let R be a run in A n . R does not get stuck if and only if, for every i-block L, all of the following hold.\n\nLemma 7 .\n7Along every run of A n we have that: -a i and b i are bounded by 2 n\u2212i+1 , and e i and f i are bounded by 2 n\u2212i .\n\nA theory of timed automata. R Alur, D L Dill, Theoretical Computer Science. 1262R. Alur and D. L. Dill. A theory of timed automata. Theoretical Computer Science, 126(2):183-235, 1994.\n\nInfinite runs in weighted timed automata with energy constraints. P Bouyer, U Fahrenberg, K G Larsen, N Markey, J Srba, Proc. of FORMATS. of FORMATSP. Bouyer, U. Fahrenberg, K. G. Larsen, N. Markey, and J. Srba. Infinite runs in weighted timed automata with energy constraints. In Proc. of FORMATS, pages 33-47, 2008.\n\nIntroduction to Algorithms, Third Edition. T H Cormen, C E Leiserson, R L Rivest, C Stein, The MIT PressT. H. Cormen, C. E. Leiserson, R. L. Rivest, and C. Stein. Introduction to Algo- rithms, Third Edition. The MIT Press, 2009.\n\nMinimum and maximum delay problems in real-time systems. C Courcoubetis, M Yannakakis, Formal Methods in System Design. 14C. Courcoubetis and M. Yannakakis. Minimum and maximum delay problems in real-time systems. Formal Methods in System Design, 1(4):385-415, 1992.\n\nReachability in succinct and parametric one-counter automata. C Haase, S Kreutzer, J Ouaknine, J Worrell, Proc. of CONCUR. of CONCURC. Haase, S. Kreutzer, J. Ouaknine, and J. Worrell. Reachability in succinct and parametric one-counter automata. In Proc. of CONCUR, pages 369-383, 2009.\n\nOn the relationship between reachability problems in timed and counter automata. C Haase, J Ouaknine, J Worrell, Proc. of RP. of RPC. Haase, J. Ouaknine, and J. Worrell. On the relationship between reachability problems in timed and counter automata. In Proc. of RP, pages 54-65, 2012.\n\nModel checking timed automata with one or two clocks. F Laroussinie, N Markey, P Schnoebelen, Proc. of CONCUR. of CONCURF. Laroussinie, N. Markey, and P. Schnoebelen. Model checking timed automata with one or two clocks. In Proc. of CONCUR, pages 387-401, 2004.\n\nAccessibilit\u00e9 dans les automates temporis\u00e9\u00e0 deux horloges. G Naves, MPRIParis, FranceRapport de MasterG. Naves. Accessibilit\u00e9 dans les automates temporis\u00e9\u00e0 deux horloges. Rapport de Master, MPRI, Paris, France, 2006.\n\nThe complexity of membership problems for circuits over sets of integers. S Travers, Theoretical Computer Science. 36913S. Travers. The complexity of membership problems for circuits over sets of integers. Theoretical Computer Science, 369(13):211-229, 2006.\n", "annotations": {"author": "[{\"end\":147,\"start\":74},{\"end\":223,\"start\":148}]", "publisher": null, "author_last_name": "[{\"end\":87,\"start\":79},{\"end\":165,\"start\":155}]", "author_first_name": "[{\"end\":78,\"start\":74},{\"end\":154,\"start\":148}]", "author_affiliation": "[{\"end\":146,\"start\":89},{\"end\":222,\"start\":167}]", "title": "[{\"end\":60,\"start\":1},{\"end\":283,\"start\":224}]", "venue": null, "abstract": "[{\"end\":520,\"start\":296}]", "bib_ref": "[{\"attributes\":{\"ref_id\":\"b0\"},\"end\":554,\"start\":551},{\"attributes\":{\"ref_id\":\"b0\"},\"end\":1088,\"start\":1085},{\"end\":1098,\"start\":1090},{\"attributes\":{\"ref_id\":\"b3\"},\"end\":1604,\"start\":1601},{\"attributes\":{\"ref_id\":\"b6\"},\"end\":2072,\"start\":2069},{\"attributes\":{\"ref_id\":\"b6\"},\"end\":2306,\"start\":2303},{\"attributes\":{\"ref_id\":\"b7\"},\"end\":2637,\"start\":2634},{\"attributes\":{\"ref_id\":\"b5\"},\"end\":2967,\"start\":2964},{\"end\":3296,\"start\":3290},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":3844,\"start\":3841},{\"attributes\":{\"ref_id\":\"b4\"},\"end\":4020,\"start\":4017},{\"attributes\":{\"ref_id\":\"b8\"},\"end\":5325,\"start\":5322},{\"attributes\":{\"ref_id\":\"b5\"},\"end\":8048,\"start\":8045},{\"attributes\":{\"ref_id\":\"b8\"},\"end\":10606,\"start\":10603},{\"attributes\":{\"ref_id\":\"b8\"},\"end\":31896,\"start\":31893},{\"attributes\":{\"ref_id\":\"b8\"},\"end\":32084,\"start\":32081},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":32157,\"start\":32154},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":32362,\"start\":32359},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":32447,\"start\":32444},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":35461,\"start\":35458}]", "figure": "[{\"attributes\":{\"id\":\"fig_0\"},\"end\":46846,\"start\":46787},{\"attributes\":{\"id\":\"fig_1\"},\"end\":46997,\"start\":46847},{\"attributes\":{\"id\":\"fig_2\"},\"end\":47024,\"start\":46998},{\"attributes\":{\"id\":\"fig_3\"},\"end\":47224,\"start\":47025},{\"attributes\":{\"id\":\"fig_4\"},\"end\":47345,\"start\":47225},{\"attributes\":{\"id\":\"fig_5\"},\"end\":47471,\"start\":47346}]", "paragraph": "[{\"end\":837,\"start\":536},{\"end\":1452,\"start\":839},{\"end\":2073,\"start\":1454},{\"end\":2828,\"start\":2075},{\"end\":3568,\"start\":2830},{\"end\":4111,\"start\":3570},{\"end\":4540,\"start\":4113},{\"end\":5326,\"start\":4542},{\"end\":6017,\"start\":5328},{\"end\":6830,\"start\":6050},{\"end\":7407,\"start\":6832},{\"end\":7718,\"start\":7409},{\"end\":8031,\"start\":7720},{\"end\":8164,\"start\":8033},{\"end\":8337,\"start\":8185},{\"end\":9015,\"start\":8464},{\"end\":9067,\"start\":9017},{\"end\":9415,\"start\":9107},{\"end\":9595,\"start\":9457},{\"end\":10135,\"start\":9597},{\"end\":10369,\"start\":10137},{\"end\":10757,\"start\":10371},{\"end\":11106,\"start\":10784},{\"end\":11334,\"start\":11108},{\"end\":12220,\"start\":11355},{\"end\":12614,\"start\":12222},{\"end\":13140,\"start\":12616},{\"end\":13458,\"start\":13142},{\"end\":13740,\"start\":13460},{\"end\":14101,\"start\":13858},{\"end\":14456,\"start\":14103},{\"end\":14894,\"start\":14617},{\"end\":15231,\"start\":14896},{\"end\":15820,\"start\":15279},{\"end\":16268,\"start\":15988},{\"end\":17620,\"start\":16334},{\"end\":18386,\"start\":17786},{\"end\":18564,\"start\":18388},{\"end\":19134,\"start\":18688},{\"end\":19853,\"start\":19136},{\"end\":20871,\"start\":20112},{\"end\":21838,\"start\":21012},{\"end\":22418,\"start\":21840},{\"end\":23776,\"start\":22420},{\"end\":24103,\"start\":23808},{\"end\":24504,\"start\":24105},{\"end\":24837,\"start\":24506},{\"end\":25321,\"start\":24839},{\"end\":25508,\"start\":25323},{\"end\":25576,\"start\":25510},{\"end\":25643,\"start\":25578},{\"end\":25721,\"start\":25645},{\"end\":25949,\"start\":25723},{\"end\":26641,\"start\":26081},{\"end\":27484,\"start\":26643},{\"end\":27676,\"start\":27486},{\"end\":27725,\"start\":27678},{\"end\":27762,\"start\":27727},{\"end\":27893,\"start\":27764},{\"end\":27930,\"start\":27895},{\"end\":28122,\"start\":27932},{\"end\":28233,\"start\":28124},{\"end\":28286,\"start\":28235},{\"end\":28384,\"start\":28288},{\"end\":28443,\"start\":28386},{\"end\":28511,\"start\":28445},{\"end\":29288,\"start\":28513},{\"end\":29359,\"start\":29290},{\"end\":29443,\"start\":29361},{\"end\":29912,\"start\":29445},{\"end\":30168,\"start\":29914},{\"end\":30726,\"start\":30236},{\"end\":31134,\"start\":30728},{\"end\":31283,\"start\":31136},{\"end\":31403,\"start\":31285},{\"end\":31557,\"start\":31441},{\"end\":31657,\"start\":31635},{\"end\":31724,\"start\":31659},{\"end\":31785,\"start\":31726},{\"end\":32085,\"start\":31808},{\"end\":32278,\"start\":32087},{\"end\":32486,\"start\":32280},{\"end\":32847,\"start\":32620},{\"end\":32939,\"start\":32849},{\"end\":33499,\"start\":33280},{\"end\":33772,\"start\":33501},{\"end\":33849,\"start\":33774},{\"end\":33929,\"start\":33851},{\"end\":34417,\"start\":33931},{\"end\":34765,\"start\":34419},{\"end\":35029,\"start\":34767},{\"end\":35452,\"start\":35031},{\"end\":35520,\"start\":35454},{\"end\":35926,\"start\":35522},{\"end\":36163,\"start\":36016},{\"end\":36604,\"start\":36165},{\"end\":37068,\"start\":36660},{\"end\":37448,\"start\":37091},{\"end\":37798,\"start\":37450},{\"end\":38182,\"start\":37800},{\"end\":38741,\"start\":38184},{\"end\":38774,\"start\":38743},{\"end\":39290,\"start\":38819},{\"end\":39399,\"start\":39292},{\"end\":39423,\"start\":39410},{\"end\":39587,\"start\":39464},{\"end\":39959,\"start\":39589},{\"end\":41095,\"start\":39982},{\"end\":41148,\"start\":41097},{\"end\":41200,\"start\":41150},{\"end\":42509,\"start\":41202},{\"end\":42651,\"start\":42532},{\"end\":42694,\"start\":42653},{\"end\":42799,\"start\":42696},{\"end\":44180,\"start\":42801},{\"end\":44240,\"start\":44182},{\"end\":44501,\"start\":44242},{\"end\":44692,\"start\":44503},{\"end\":45184,\"start\":44694},{\"end\":45244,\"start\":45186},{\"end\":45542,\"start\":45246},{\"end\":46053,\"start\":45544},{\"end\":46256,\"start\":46055},{\"end\":46786,\"start\":46279}]", "formula": "[{\"attributes\":{\"id\":\"formula_0\"},\"end\":8463,\"start\":8338},{\"attributes\":{\"id\":\"formula_1\"},\"end\":9106,\"start\":9068},{\"attributes\":{\"id\":\"formula_2\"},\"end\":9456,\"start\":9416},{\"attributes\":{\"id\":\"formula_3\"},\"end\":11354,\"start\":11335},{\"attributes\":{\"id\":\"formula_4\"},\"end\":13857,\"start\":13741},{\"attributes\":{\"id\":\"formula_5\"},\"end\":14616,\"start\":14457},{\"attributes\":{\"id\":\"formula_6\"},\"end\":15278,\"start\":15232},{\"attributes\":{\"id\":\"formula_7\"},\"end\":16333,\"start\":16269},{\"attributes\":{\"id\":\"formula_8\"},\"end\":17785,\"start\":17621},{\"attributes\":{\"id\":\"formula_9\"},\"end\":18687,\"start\":18565},{\"attributes\":{\"id\":\"formula_10\"},\"end\":20084,\"start\":19854},{\"attributes\":{\"id\":\"formula_11\"},\"end\":21011,\"start\":20872},{\"attributes\":{\"id\":\"formula_12\"},\"end\":30235,\"start\":30169},{\"attributes\":{\"id\":\"formula_13\"},\"end\":31440,\"start\":31404},{\"attributes\":{\"id\":\"formula_14\"},\"end\":32619,\"start\":32487},{\"attributes\":{\"id\":\"formula_15\"},\"end\":33279,\"start\":32940},{\"attributes\":{\"id\":\"formula_16\"},\"end\":36015,\"start\":35927},{\"attributes\":{\"id\":\"formula_17\"},\"end\":36659,\"start\":36605},{\"attributes\":{\"id\":\"formula_18\"},\"end\":38818,\"start\":38775},{\"attributes\":{\"id\":\"formula_19\"},\"end\":39409,\"start\":39400},{\"attributes\":{\"id\":\"formula_20\"},\"end\":39463,\"start\":39424}]", "table_ref": "[{\"end\":18506,\"start\":18499},{\"end\":18515,\"start\":18508},{\"end\":19793,\"start\":19786},{\"end\":20208,\"start\":20201},{\"end\":22406,\"start\":22399},{\"end\":23888,\"start\":23881},{\"end\":24875,\"start\":24868}]", "section_header": "[{\"attributes\":{\"n\":\"1\"},\"end\":534,\"start\":522},{\"attributes\":{\"n\":\"2\"},\"end\":6048,\"start\":6020},{\"attributes\":{\"n\":\"3\"},\"end\":8183,\"start\":8167},{\"attributes\":{\"n\":\"4\"},\"end\":10782,\"start\":10760},{\"end\":15956,\"start\":15823},{\"attributes\":{\"n\":\"5\"},\"end\":15986,\"start\":15959},{\"end\":20110,\"start\":20086},{\"attributes\":{\"n\":\"6\"},\"end\":23806,\"start\":23779},{\"end\":26079,\"start\":25952},{\"end\":31633,\"start\":31560},{\"end\":31806,\"start\":31788},{\"end\":37089,\"start\":37071},{\"end\":39980,\"start\":39962},{\"end\":42530,\"start\":42512},{\"end\":46277,\"start\":46259},{\"end\":46797,\"start\":46788},{\"end\":47007,\"start\":46999},{\"end\":47027,\"start\":47026},{\"end\":47235,\"start\":47226},{\"end\":47356,\"start\":47347}]", "table": null, "figure_caption": "[{\"end\":46846,\"start\":46799},{\"end\":46997,\"start\":46849},{\"end\":47024,\"start\":47009},{\"end\":47224,\"start\":47028},{\"end\":47345,\"start\":47237},{\"end\":47471,\"start\":47358}]", "figure_ref": "[{\"attributes\":{\"ref_id\":\"fig_2\"},\"end\":16553,\"start\":16545},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":20165,\"start\":20157},{\"attributes\":{\"ref_id\":\"fig_2\"},\"end\":20288,\"start\":20280},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":26172,\"start\":26157},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":26805,\"start\":26790},{\"attributes\":{\"ref_id\":\"fig_2\"},\"end\":27307,\"start\":27299}]", "bib_author_first_name": "[{\"end\":47502,\"start\":47501},{\"end\":47510,\"start\":47509},{\"end\":47512,\"start\":47511},{\"end\":47725,\"start\":47724},{\"end\":47735,\"start\":47734},{\"end\":47749,\"start\":47748},{\"end\":47751,\"start\":47750},{\"end\":47761,\"start\":47760},{\"end\":47771,\"start\":47770},{\"end\":48021,\"start\":48020},{\"end\":48023,\"start\":48022},{\"end\":48033,\"start\":48032},{\"end\":48035,\"start\":48034},{\"end\":48048,\"start\":48047},{\"end\":48050,\"start\":48049},{\"end\":48060,\"start\":48059},{\"end\":48265,\"start\":48264},{\"end\":48281,\"start\":48280},{\"end\":48538,\"start\":48537},{\"end\":48547,\"start\":48546},{\"end\":48559,\"start\":48558},{\"end\":48571,\"start\":48570},{\"end\":48845,\"start\":48844},{\"end\":48854,\"start\":48853},{\"end\":48866,\"start\":48865},{\"end\":49105,\"start\":49104},{\"end\":49120,\"start\":49119},{\"end\":49130,\"start\":49129},{\"end\":49373,\"start\":49372},{\"end\":49606,\"start\":49605}]", "bib_author_last_name": "[{\"end\":47507,\"start\":47503},{\"end\":47517,\"start\":47513},{\"end\":47732,\"start\":47726},{\"end\":47746,\"start\":47736},{\"end\":47758,\"start\":47752},{\"end\":47768,\"start\":47762},{\"end\":47776,\"start\":47772},{\"end\":48030,\"start\":48024},{\"end\":48045,\"start\":48036},{\"end\":48057,\"start\":48051},{\"end\":48066,\"start\":48061},{\"end\":48278,\"start\":48266},{\"end\":48292,\"start\":48282},{\"end\":48544,\"start\":48539},{\"end\":48556,\"start\":48548},{\"end\":48568,\"start\":48560},{\"end\":48579,\"start\":48572},{\"end\":48851,\"start\":48846},{\"end\":48863,\"start\":48855},{\"end\":48874,\"start\":48867},{\"end\":49117,\"start\":49106},{\"end\":49127,\"start\":49121},{\"end\":49142,\"start\":49131},{\"end\":49379,\"start\":49374},{\"end\":49614,\"start\":49607}]", "bib_entry": "[{\"attributes\":{\"id\":\"b0\",\"matched_paper_id\":18129339},\"end\":47656,\"start\":47473},{\"attributes\":{\"id\":\"b1\",\"matched_paper_id\":3064045},\"end\":47975,\"start\":47658},{\"attributes\":{\"id\":\"b2\"},\"end\":48205,\"start\":47977},{\"attributes\":{\"id\":\"b3\",\"matched_paper_id\":42550462},\"end\":48473,\"start\":48207},{\"attributes\":{\"id\":\"b4\",\"matched_paper_id\":56046971},\"end\":48761,\"start\":48475},{\"attributes\":{\"id\":\"b5\",\"matched_paper_id\":240735},\"end\":49048,\"start\":48763},{\"attributes\":{\"id\":\"b6\",\"matched_paper_id\":582421},\"end\":49311,\"start\":49050},{\"attributes\":{\"id\":\"b7\"},\"end\":49529,\"start\":49313},{\"attributes\":{\"id\":\"b8\",\"matched_paper_id\":7313483},\"end\":49789,\"start\":49531}]", "bib_title": "[{\"end\":47499,\"start\":47473},{\"end\":47722,\"start\":47658},{\"end\":48262,\"start\":48207},{\"end\":48535,\"start\":48475},{\"end\":48842,\"start\":48763},{\"end\":49102,\"start\":49050},{\"end\":49603,\"start\":49531}]", "bib_author": "[{\"end\":47509,\"start\":47501},{\"end\":47519,\"start\":47509},{\"end\":47734,\"start\":47724},{\"end\":47748,\"start\":47734},{\"end\":47760,\"start\":47748},{\"end\":47770,\"start\":47760},{\"end\":47778,\"start\":47770},{\"end\":48032,\"start\":48020},{\"end\":48047,\"start\":48032},{\"end\":48059,\"start\":48047},{\"end\":48068,\"start\":48059},{\"end\":48280,\"start\":48264},{\"end\":48294,\"start\":48280},{\"end\":48546,\"start\":48537},{\"end\":48558,\"start\":48546},{\"end\":48570,\"start\":48558},{\"end\":48581,\"start\":48570},{\"end\":48853,\"start\":48844},{\"end\":48865,\"start\":48853},{\"end\":48876,\"start\":48865},{\"end\":49119,\"start\":49104},{\"end\":49129,\"start\":49119},{\"end\":49144,\"start\":49129},{\"end\":49381,\"start\":49372},{\"end\":49616,\"start\":49605}]", "bib_venue": "[{\"end\":47547,\"start\":47519},{\"end\":47794,\"start\":47778},{\"end\":48018,\"start\":47977},{\"end\":48325,\"start\":48294},{\"end\":48596,\"start\":48581},{\"end\":48887,\"start\":48876},{\"end\":49159,\"start\":49144},{\"end\":49370,\"start\":49313},{\"end\":49644,\"start\":49616},{\"end\":47806,\"start\":47796},{\"end\":48607,\"start\":48598},{\"end\":48894,\"start\":48889},{\"end\":49170,\"start\":49161}]"}}}, "year": 2023, "month": 12, "day": 17}