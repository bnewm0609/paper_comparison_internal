{"id": 239011966, "updated": "2022-12-10 14:57:42.222", "metadata": {"title": "Cryptographic Capability Computing", "authors": "[{\"first\":\"Michael\",\"last\":\"LeMay\",\"middle\":[]},{\"first\":\"Joydeep\",\"last\":\"Rakshit\",\"middle\":[]},{\"first\":\"Sergej\",\"last\":\"Deutsch\",\"middle\":[]},{\"first\":\"David\",\"last\":\"Durham\",\"middle\":[\"M.\"]},{\"first\":\"Santosh\",\"last\":\"Ghosh\",\"middle\":[]},{\"first\":\"Anant\",\"last\":\"Nori\",\"middle\":[]},{\"first\":\"Jayesh\",\"last\":\"Gaur\",\"middle\":[]},{\"first\":\"Andrew\",\"last\":\"Weiler\",\"middle\":[]},{\"first\":\"Salmin\",\"last\":\"Sultana\",\"middle\":[]},{\"first\":\"Karanvir\",\"last\":\"Grewal\",\"middle\":[]},{\"first\":\"Sreenivas\",\"last\":\"Subramoney\",\"middle\":[]}]", "venue": null, "journal": "MICRO-54: 54th Annual IEEE/ACM International Symposium on Microarchitecture", "publication_date": {"year": 2021, "month": null, "day": null}, "abstract": "Capability architectures for memory safety have traditionally required expanding pointers and radically changing microarchitectural structures throughout processors, while only providing superficial hardening. We hence propose Cryptographic Capability Computing (C3) - the first memory safety mechanism that is stateless to avoid requiring extra metadata storage. C3 retains 64-bit pointer sizes providing legacy binary compatibility while imposing minimal touchpoints. Pointers are encrypted to unforgeably (within cryptographic bounds) reference each object. Data is encrypted even in caches and entangled with pointers for both spatial and temporal object-granular protection. Pointers become like unique keys for each allocation. C3 deploys a novel form of prediction for address translation that mitigates performance overheads even when addresses are partially encrypted. Use of a low-latency, low-area cipher from the NIST Lightweight Cryptography project avoids delaying loads by readying a data keystream by the time data is returned from the L1 cache. C3 is compatible with legacy binaries. Simulated performance overhead on SPEC CPU2006 is negligible with no memory overhead, which is a big leap forward compared to the overheads imposed by past memory safety approaches. C3 effectively replaces inefficient metadata with efficient cryptography.", "fields_of_study": "[\"Computer Science\"]", "external_ids": {"arxiv": null, "mag": null, "acl": null, "pubmed": null, "pubmedcentral": null, "dblp": "conf/micro/LeMayRDDGNGWSGS21", "doi": "10.1145/3466752.3480076"}}, "content": {"source": {"pdf_hash": "61a9a15e498697188150a60fd0fe5f5c3b2a6639", "pdf_src": "ACM", "pdf_uri": null, "oa_url_match": false, "oa_info": {"license": null, "open_access_url": "https://dl.acm.org/doi/pdf/10.1145/3466752.3480076", "status": "BRONZE"}}, "grobid": {"id": "d232847a38ea30f0163c4cc1e8de4fef16ea8156", "type": "plain-text", "url": "s3://ai2-s2-pdf-extraction-prod/parse-results/s2orc_worker/61a9a15e498697188150a60fd0fe5f5c3b2a6639.txt", "contents": "\nCryptographic Capability Com-puting\nVirtual EventCopyright Virtual EventOctober 18-22, 2021. 2021. October 18-22, 2021\n\nMichael Lemay \nJoydeep Rakshit \nSergej Deutsch \nDavid M Durham \nSantosh Ghosh \nAnant Nori \nJayesh Gaur \nAndrew Weiler \nKaranvir Grewal \nSreenivas Subramoney \nMichael Lemay \nJoydeep Rakshit \nSergej Deutsch \nDavid M Durham \nSantosh Ghosh \nAnant Nori \nJayesh Gaur \nAndrew Weiler \nSalmin Sultana \nKaranvir Grewal \nSreenivas Subramoney \n\nIntel Labs\nUSA\n\n\nIntel Labs\nIndia\n\n\nIntel Labs\nUSA\n\n\nIntel Labs\nUSA\n\n\nIntel Labs\nUSA\n\n\nIntel Labs\nIndia\n\n\nIntel Labs\nIndia\n\n\nIntel Labs\nUSA\n\n\nIntel Labs\nUSA\n\n\nIntel Labs\nIndia\n\nCryptographic Capability Com-puting\n\nMICRO-54: 54th Annual IEEE/ACM International Symposium on Microarchitecture (MICRO '21)\nAthens, Greece; GreeceVirtual EventOctober 18-22, 2021. 2021. October 18-22, 202110.1145/3466752.3480076Permission to make digital or hard copies of part or all of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for third-party components of this work must be honored. For all other uses, contact the owner/author(s). ACM, New York, NY, USA, 15 pages. https://memory safetycapabilitiesmemory encryption\nCapability architectures for memory safety have traditionally required expanding pointers and radically changing microarchitectural structures throughout processors, while only providing superficial hardening. We hence propose Cryptographic Capability Computing (C 3 ) -the first memory safety mechanism that is stateless to avoid requiring extra metadata storage. C 3 retains 64-bit pointer sizes providing legacy binary compatibility while imposing minimal touchpoints. Pointers are encrypted to unforgeably (within cryptographic bounds) reference each object. Data is encrypted even in caches and entangled with pointers for both spatial and temporal object-granular protection. Pointers become like unique keys for each allocation. C 3 deploys a novel form of prediction for address translation that mitigates performance overheads even when addresses are partially encrypted. Use of a low-latency, lowarea cipher from the NIST Lightweight Cryptography project avoids delaying loads by readying a data keystream by the time data is returned from the L1 cache. C 3 is compatible with legacy binaries. Simulated performance overhead on SPEC CPU2006 is negligible with no memory overhead, which is a big leap forward compared to the overheads imposed by past memory safety approaches. C 3 effectively replaces inefficient metadata with efficient cryptography.CCS CONCEPTS\u2022 Security and privacy \u2192 Security in hardware; \u2022 Computer systems organization \u2192 Architectures; \u2022 Software and its engineering \u2192 Software safety.\n\nINTRODUCTION\n\nMemory safety vulnerabilities have afflicted computer systems for decades, accounting for \u223c70% of vulnerabilities [37], and the looselytyped programming languages that give rise to them remain popular. Spatial memory safety vulnerabilities include buffer overflows to adjacent and non-adjacent allocations, or to fields within a single allocation. Use-After-Free (UAF) and uninitialized use are common examples of temporal memory safety vulnerabilities.\n\nMany memory safety solutions have been proposed in the past, but they either suffer from high overheads and extensive touchpoints due to metadata storage and accesses or they only provide limited protections. For example, some approaches rely on fat pointers (e.g. 128 bits) containing bounds information and other metadata. These drastically increase the memory footprint of software and require the use of tagged memory to protect the integrity of metadata within the fat pointers [38,54]. Other approaches assign a separate copy of metadata to every granule of each allocation for some fixed granule size, e.g. ARM\u00ae Memory Tagging Extension (MTE) with four tag bits for every 16-byte granule of data [44,46]. Still other approaches assign separate metadata for every copy of a pointer, such as Intel\u00ae MPX that associates bounds with pointers in a multi-level table with high overheads [42,57].\n\nAuthenticating or encrypting pointers to mitigate pointer corruption is an approach that avoids the need for separate metadata, but that does not protect data directly [9,33]. For example, Heartbleed disclosed private keys without corrupting any pointers [17]. Authentication of base addresses for pointers can be used to generate keys for hash tables containing bounds to enforce spatial safety, and those can be invalidated when allocations are freed to enforce temporal safety as in Always-On memory Safety (AOS) [25]. However, this reintroduces the overheads of in-memory metadata.\n\nFurthermore, pointer authentication consumes pointer bits that could otherwise be used for memory addressing, and it provides weak protection based on small authentication codes.\n\nIn this paper we propose Cryptographic Capability Computing (C 3 ) -the first stateless mechanism that enforces memory safety in a fully flexible memory layout without relying on any additional metadata besides what is encoded in a 64-bit pointer. It replaces inefficient metadata memory accesses with efficient cryptography by assigning a unique and distinct cryptographically isolated space for each allocation.\n\nThe isolated space for each allocation is identified by information encoded in a novel Cryptographic Address (CA) format. No additional metadata is needed. The CA format is illustrated in Figure 1. Each CA specifies a radix to identify what portion of the address is constant throughout the entire allocation. We will show that this pair of attributes is sufficient to uniquely identify every allocation throughout the linear address space, and that they can also distinguish allocations temporally. Cryptography mitigates forgery or corruption of the CA portion uniquely identifying the allocation. CAs have a legacy-compatible binary encoding usable with ordinary pointer arithmetic instructions to avoid requiring software recompilation. The linear memory layout is completely unchanged by C 3 . C 3 encrypts data in memory and throughout the entire cache hierarchy. It entangles the data encryption for each allocation to the unforgeable (within cryptographic bounds) identity specified in its authorized CA. This makes pointers like unique keys for each allocation to enforce both spatial and temporal safety.\n\nMany prior approaches emphasize generating exceptions for memory safety violations. This is undeniably useful for bug hunting. However, a novel aspect of C 3 is the observation that simply preserving data confidentiality and avoiding adversarial plaintext injection is adequate to enforce memory safety. C 3 does this without relying on the costly metadata needed for prior approaches that insist on generating exceptions.\n\nEncrypting pointers rather than authenticating them as in past approaches avoids limiting address space sizes and strengthens the cryptographic protections for mitigating pointer corruption and forgery by permitting address bits to be encrypted. Pointers do not require special protections or tags beyond the cryptographic encoding itself.\n\nEncrypting data in the cache holds the potential of more strongly mitigating physical attacks and threats from erroneous or compromised IP within SoCs. C 3 contributes innovative techniques for avoiding disruptions from encrypted pointers and cache data to performance critical microarchitectural flows involving Translation Lookaside Buffer (TLB) lookups and the generation of keying material on the critical load path. We show that C 3 can be built on a modern high performance processor while causing negligible performance overheads.\n\nThis paper demonstrates that C 3 is a stateless mechanism that strongly mitigates prevalent categories of vulnerabilities.\n\nThe novel contributions of this paper include:\n\n(1) First stateless spatial and temporal safety mechanism applicable to entire address space with no extra storage demands for metadata, no added restrictions on memory layouts, and no pointer size increases. (2) Compact cryptographic pointer encoding that generates a unique encoding for every simultaneously active allocation and an expansive space for distinguishing allocations temporally. Up to 1 million times as strong as memory tagging. The rest of this paper is organized as follows: \u00a72 provides background, \u00a73 enumerates requirements and the threat model, \u00a74 describes the design of C 3 including microarchitectural optimizations, \u00a75 evaluates C 3 , \u00a76 discusses related work, \u00a77 describes limitations and future work, and \u00a78 concludes this paper.\n\n\nBACKGROUND 2.1 Memory Safety\n\nMemory safety vulnerabilities have long been a major affliction for software written in loosely-typed languages such as C and C++. Data from Microsoft\u00ae and Google\u00ae LLC show around 70% of vulnerabilities fitting this category [7,37], at least at the high severity level, with most of those vulnerabilities affecting heap allocations.\n\nThe most prevalent vulnerabilities violate either spatial or temporal safety. Spatial safety violations include buffer overflows and underflows, whereas temporal safety violations encompass UAF, in which a dangling pointer is used to reference a region of memory that was freed after the pointer to that region was generated, and uninitialized use. Type confusion is an additional type of vulnerability, in which data is processed as though it has a different type. For example, treating data as a pointer may permit pointer forgery. Some other type confusion vulnerabilities operate at the level of types defined in high-level programming languages.\n\nThe spatial safety category can be subdivided further into adjacent and non-adjacent overflows, with the former extending from an allocation into adjoining allocations and the latter skipping over adjoining allocations or randomly access memory to reach nonadjoining allocations. Non-adjacent overflow vulnerabilities have become more common than adjacent overflow vulnerabilities starting in 2014 [37]. Spatial safety hardening approaches can vary in their effectiveness at mitigating each of these types of vulnerabilities.\n\nExamples of both types of spatial vulnerabilities as well as UAF are provided in the following sample code listing. These are the types of vulnerabilities that we focus on in this paper. For the purposes of this example, assume that the heap allocator places each allocation at the lowest available address, including immediately reclaiming memory that is freed. Also assume that it stores allocator metadata separately from allocations, e.g. rather than interspersing it between allocations. Memory safety vulnerabilities may lead directly to information leakage or data corruption, or they may be used as just one or more links in an overall exploit chain that may lead to Control-Flow Integrity (CFI) violations and the execution of arbitrary code [37]. Thus, mitigating memory safety vulnerabilities offers a way to disrupt a wide variety of possible exploits.\n\nOther types of software vulnerabilities outside of the memory safety category are also common, but they are often outgrowths from logic errors in high-level applications, languages, or frameworks, and thus not readily addressable by hardware.\n\nThe goal of memory-safety enforcement mechanisms is to prevent information leakage and adversarial control due to memory safety violations. A variety of mechanisms have been proposed, and we will next describe the category of mechanisms that includes C 3 .\n\n\nMemory and Pointer Encryption and Authentication\n\nThere has been a progression of encryption being applied more pervasively and deeply over time as hardware support has matured. Instructions for accelerating symmetric encryption have led to nearuniversal encryption of web traffic [19,28]. Many storage devices have acceleration for full device encryption, if not also based on the acceleration instructions in the processor to which the device is attached. Hardware-accelerated total memory encryption has recently attained wide availability even on consumer-level devices to mitigate physical attacks on memory [40], but that does not extend into caches. Pointers have been encrypted and authenticated in caches and registers in prior work. This mitigates attempts to use pointers corrupted via memory safety violations, which indirectly mitigates some memory safety violations. PointGuard encrypts entire pointers so that corrupting a pointer will result in a garbled linear address when that pointer is decrypted [9,51]. PARTS authenticates pointers to generate an exception when a corrupted pointer is used [33].\n\nThe drawback of pointer authentication compared to pointer encryption is that a Pointer Authentication Code (PAC) consumes pointer bits whereas pointer encryption preserves pointer bit values that can be recovered later via decryption. Pointers have few unused bits that can be repurposed for a PAC, which limits the cryptographic strength of that PAC.\n\nOn the other hand, pointer authentication detects pointer corruption with a predictable probability, whereas the ability of pointer encryption mechanisms to detect pointer corruption depends on multiple factors that determine the likelihood of garbled, decrypted pointers referencing unmapped or inaccessible memory that leads to page faults: 1) how many pointer bits are encrypted, 2) the encryption algorithm, and 3) the process-specific density of accessible data pages.\n\nAOS uses a PAC to lookup bounds for an allocation to directly enforce spatial and temporal safety, but it does not encrypt data. C 3 is the first mechanism that entangles data encryption with encoded CAs, and it does so in the cache. Bringing data encryption into the cache in this way is both a logical progression and a radical advance, since it integrates stateless, object-granular (we use the terms \"object\" and \"allocation\" interchangeably) control over encryption with memory access instructions for the first time. This converges software attack protections with physical attack mitigations and directly enforces both spatial and temporal memory safety.\n\n\nREQUIREMENTS AND THREAT MODEL\n\nThe program is assumed to be initially benign but vulnerable to malicious inputs, e.g. from network packets or files.\n\nWe initially evaluate C 3 for protecting heap allocations due to the prevalence of heap vulnerabilities, and since we want to avoid requiring recompilation. Most exploits target the heap [3]. However, C 3 can also be used to harden stack and global allocations. C 3 supports encrypted allocations up to 16GiB. Larger allocations can be handled without encryption, and pointers to them could not be abused to access encrypted allocations. Furthermore, C 3 can be extended to protect larger allocations by supporting additional pointer encoding options with a wider range of radixes. C 3 meets or exceeds the exploit detection probabilities of other memory safety techniques, e.g. the 1/16 chance of an adversary bypassing memory safety checks in memory tagging.\n\nSince C 3 is a capability architecture, if an adversary is directly able to harvest a valid (i.e., non-stale) pointer, then accesses to the allocation referenced by that pointer are not considered memory safety violations.\n\nSide channels and vulnerabilities or malicious behavior in privileged software or the heap allocator are considered out-of-scope for this paper, although invalid speculative overflows will similarly access ciphertext.\n\nThe focus of this paper is on hardening unprivileged, usermode software, but C 3 could be applied to privileged kernels and VMMs with system software support. Figure 2: Best-fit assignment of allocations to power-of-twoaligned slots. Each radix implies a distinct set of naturallyaligned power-of-two slot boundaries to be used throughout the linear address space. Every slot is encrypted uniquely to isolate all allocations, even if they overlap in the linear space. C 3 does not disrupt the memory layout; allocations do not need to be padded to fill slots.\n\n\nDESIGN\n\nThis section describes how C 3 mitigates both spatial and temporal vulnerabilities by binding stateless, object-granular data encryption in caches to CAs that are unique to each allocation.\n\n\nObject-Granular Cryptographic Isolation\n\nEach allocation is assigned a distinct Cryptographic Address (CA), which results in every allocation being uniquely encrypted. To understand how every allocation is distinguished spatially from all other simultaneously-valid allocations, it is helpful to think of each CA effectively defining a naturally-aligned power-of-two slot that contains the allocation in its entirety as depicted in Figure 2. Allocations do not need to be aligned to a power-of-two, i.e. there is no requirement for an allocation to fill its assigned slot.\n\nTo ensure that each allocation is assigned to a distinct slot, a \"best-fit\" criterion should be used to select the smallest slot that completely contains a given allocation, which will have the minimum space in the slot that is outside of the actual allocation. Consider that every allocation will then cross the midpoint of its assigned allocation slot. Only a single allocation can cross any particular slot's midpoint. If the allocation fits within some slot, but it does not cross that slot's midpoint, then it must fit more tightly in some smaller slot, and hence the best-fit algorithm would have selected that smaller slot. Therefore, for a given spatial memory layout, only a single allocation can be assigned to any slot.\n\nThe memory layout of allocations is not disrupted. The best-fit power-of-two slot of a particular allocation can overlap with other allocations, as we don't require padding to fill the slot. Even in this case, the data for the separate allocations remains cryptographically isolated due to the allocations each being assigned unique CAs to which the data encryption is bound. Using a pointer to an allocation in some slot to read or overwrite a different allocation within the bounds of the same slot results in the data for the second allocation being garbled. This preserves the confidentiality of that data and makes data corruption unpredictable to adversaries. Figure 3 shows how the flow of processing for C 3 mitigates covered memory safety violations.  [9,51], PARTS [33], MTE [44], AOS [25], and C 3 . Legend:\n\n#2: 56B #3: 48B #4: 32B ... pletely unchanged by C 3 ent of allocations to power-of-twoimplies a distinct set of naturallyboundaries to be used throughout Every slot is encrypted uniquely even if they overlap in the linear t the memory layout; allocations to fill slots. r Cryptographic Isolation distinct Cryptographic Address (CA), cation being uniquely encrypted. To cation is distinguished spatially from lid allocations, it is helpful to think of a naturally-aligned power-of-two slot in its entirety as depicted in Figure 2. e aligned to a power-of-two, i.e. there cation to fill its assigned slot. cation is assigned to a distinct slot, a used to select the smallest slot that comcation, which will have the minimum ide of the actual allocation. Consider en cross the midpoint of its assigned le allocation can cross any particular tion fits within some slot, but it does t, then it must fit more tightly in some est-fit algorithm would have selected or a given spatial memory layout, only signed to any slot. locations is not disrupted. The best-fit ular allocation can overlap with other ire padding to fill the slot. Even in this allocations remains cryptographically ns each being assigned unique CAs to bound. Using a pointer to an allocation write a different allocation within the lts in the data for the second allocation es the confidentiality of that data and dictable to adversaries. Figure 3 shows or C 3 mitigates covered memory safety Examples of how OOB and UAF vulnerabilities are mitigated by the object-granular cryptographic isolation in C 3 are shown in Figure 4. Example (a) shows a pointer overflowing Allocation 1 into Allocation 2. Example (b) shows a pointer skipping from Allocation 1 all the way into Allocation 3. Allocation 3 has the same radix (64) as Allocation 1, but it has a different value for its least-significant radix-64 digit. Example (c) shows a stale pointer to Allocation 1 after it has been freed being used when the same underlying linear memory has been reused for Allocation 4. Note that Allocation 4 crosses a radix-64 boundary, so it requires a radix-128 slot. Since that is a different radix than was used for Allocation 1, they are cryptographically isolated even though the linear memory for Allocation 1 is reused in Allocation 4. In all of these cases, data will be garbled. Example (b) may generate an exception even before the data can be accessed, as will be explained below.\n\nFurthermore, data encryption is distinctly well-suited to comprehensively mitigating uninitialized use throughout an entire allocation. C 3 breaks adversaries' control over uninitialized data values by encrypting stale data from previous allocations when read through a fresh CA with a different radix or version. This applies separately to every byte of the allocation, such that even a single remaining uninitialized byte is still mitigated by C 3 . In contrast, the overheads of per-byte initialization metadata would be prohibitive.\n\nNote that pointer authentication or encryption alone [? ? ? ] is unable to mitigate some of the types of vulnerabilities addressed by C 3 , which additionally entangles data encryption with unique, per-allocation CAs. For example, Heartbleed illustrates this benefit of C 3 , since it only performs OOB reads that disclose data without corrupting pointers [? ]. Fundamentally, the limitation of prior approaches based solely on pointer authentication or encryption is that unencrypted data in memory remains accessible.\n\nIn contrast, when a C 3 pointer is dereferenced that is corrupted, stale, or references an uninitialized allocation, the data will be garbled with high probability if the decrypted pointer even references accessible memory in the first place. We compare the types of violations that can be mitigated by C 3 and closely related memory safety mechanisms in Table 1. The \"Physical\" column represents threats to data confidentiality and pointer integrity from physical attacks and erroneous or compromised IP. C 3 can detect certain physical pointer corruptions and provides data confidentiality via encryption.  Figure 2: Best-fit assignment of allocations to power-of-twoaligned slots. Each radix implies a distinct set of naturallyaligned power-of-two slot boundaries to be used throughout the linear address space. Every slot is encrypted uniquely to isolate all allocations, even if they overlap in the linear space. C 3 does not disrupt the memory layout; allocations do not need to be padded to fill slots.\n\n\nDESIGN\n\nThis section describes how C 3 mitigates both spatial and temporal vulnerabilities by binding stateless, object-granular data encryption in caches to CAs that are unique to each allocation.\n\n\nObject-Granular Cryptographic Isolation\n\nEach allocation is assigned a distinct Cryptographic Address (CA), which results in every allocation being uniquely encrypted. To understand how every allocation is distinguished spatially from all other simultaneously-valid allocations, it is helpful to think of each CA effectively defining a naturally-aligned power-of-two slot that contains the allocation in its entirety as depicted in Figure 2.\n\nAllocations do not need to be aligned to a power-of-two, i.e. there is no requirement for an allocation to fill its assigned slot.\n\nTo ensure that each allocation is assigned to a distinct slot, a \"best-fit\" criterion should be used to select the smallest slot that completely contains a given allocation, which will have the minimum space in the slot that is outside of the actual allocation. Consider that every allocation will then cross the midpoint of its assigned allocation slot. Only a single allocation can cross any particular slot's midpoint. If the allocation fits within some slot, but it does not cross that slot's midpoint, then it must fit more tightly in some smaller slot, and hence the best-fit algorithm would have selected that smaller slot. Therefore, for a given spatial memory layout, only a single allocation can be assigned to any slot.\n\nThe memory layout of allocations is not disrupted. The best-fit power-of-two slot of a particular allocation can overlap with other allocations, as we don't require padding to fill the slot. Even in this case, the data for the separate allocations remains cryptographically isolated due to the allocations each being assigned unique CAs to which the data encryption is bound. Using a pointer to an allocation in some slot to read or overwrite a different allocation within the bounds of the same slot results in the data for the second allocation being garbled. This preserves the confidentiality of that data and makes data corruption unpredictable to adversaries. Figure 3 shows how the flow of processing for C 3 mitigates covered memory safety violations. Examples of how OOB and UAF vulnerabilities are mitig by the object-granular cryptographic isolation in C 3 are sho in Figure 4. Example (a) shows a pointer overflowing Alloca 1 into Allocation 2. Example (b) shows a pointer skipping f Allocation 1 all the way into Allocation 3. Allocation 3 has same radix (64) as Allocation 1, but it has a different value fo least-significant radix-64 digit. Example (c) shows a stale poi to Allocation 1 after it has been freed being used when the s underlying linear memory has been reused for Allocation 4. N that Allocation 4 crosses a radix-64 boundary, so it requires a ra 128 slot. Since that is a different radix than was used for Allocati they are cryptographically isolated even though the linear mem for Allocation 1 is reused in Allocation 4. In all of these cases, will be garbled. Example (b) may generate an exception even be the data can be accessed, as will be explained below.\n\nFurthermore, data encryption is distinctly well-suited to com hensively mitigating uninitialized use throughout an entire al tion. C 3 breaks adversaries' control over uninitialized data value encrypting stale data from previous allocations when read thro a fresh CA with a different radix or version. This applies separa to every byte of the allocation, such that even a single remain uninitialized byte is still mitigated by C 3 . In contrast, the overh of per-byte initialization metadata would be prohibitive.\n\nNote that pointer authentication or encryption alone [? ? ? unable to mitigate some of the types of vulnerabilities addre by C 3 , which additionally entangles data encryption with uni per-allocation CAs. For example, Heartbleed illustrates this ben of C 3 , since it only performs OOB reads that disclose data with corrupting pointers [? ]. Fundamentally, the limitation of p approaches based solely on pointer authentication or encryptio that unencrypted data in memory remains accessible.\n\nIn contrast, when a C 3 pointer is dereferenced that is corrup stale, or references an uninitialized allocation, the data will be bled with high probability if the decrypted pointer even refere accessible memory in the first place. We compare the types o olations that can be mitigated by C 3 and closely related mem safety mechanisms in Table 1. The \"Physical\" column repres threats to data confidentiality and pointer integrity from phy attacks and erroneous or compromised IP. C 3 can detect cer physical pointer corruptions and provides data confidentiality encryption.\n\n: Mitigated with detection iff a corrupted pointer is used later,  Figure 2: Best-fit assignment of allocations to power-of-twoaligned slots. Each radix implies a distinct set of naturallyaligned power-of-two slot boundaries to be used throughout the linear address space. Every slot is encrypted uniquely to isolate all allocations, even if they overlap in the linear space. C 3 does not disrupt the memory layout; allocations do not need to be padded to fill slots.\n\n\nDESIGN\n\nThis section describes how C 3 mitigates both spatial and temporal vulnerabilities by binding stateless, object-granular data encryption in caches to CAs that are unique to each allocation.\n\n\nObject-Granular Cryptographic Isolation\n\nEach allocation is assigned a distinct Cryptographic Address (CA), which results in every allocation being uniquely encrypted. To understand how every allocation is distinguished spatially from all other simultaneously-valid allocations, it is helpful to think of each CA effectively defining a naturally-aligned power-of-two slot that contains the allocation in its entirety as depicted in Figure 2.\n\nAllocations do not need to be aligned to a power-of-two, i.e. there is no requirement for an allocation to fill its assigned slot.\n\nTo ensure that each allocation is assigned to a distinct slot, a \"best-fit\" criterion should be used to select the smallest slot that completely contains a given allocation, which will have the minimum space in the slot that is outside of the actual allocation. Consider that every allocation will then cross the midpoint of its assigned allocation slot. Only a single allocation can cross any particular slot's midpoint. If the allocation fits within some slot, but it does not cross that slot's midpoint, then it must fit more tightly in some smaller slot, and hence the best-fit algorithm would have selected that smaller slot. Therefore, for a given spatial memory layout, only a single allocation can be assigned to any slot.\n\nThe memory layout of allocations is not disrupted. The best-fit power-of-two slot of a particular allocation can overlap with other allocations, as we don't require padding to fill the slot. Even in this case, the data for the separate allocations remains cryptographically isolated due to the allocations each being assigned unique CAs to which the data encryption is bound. Using a pointer to an allocation in some slot to read or overwrite a different allocation within the bounds of the same slot results in the data for the second allocation being garbled. This preserves the confidentiality of that data and makes data corruption unpredictable to adversaries. Figure 3 shows how the flow of processing for C 3 mitigates covered memory safety violations. Examples of how OOB and UAF vulnerabilities a by the object-granular cryptographic isolation in C in Figure 4. Example (a) shows a pointer overflowin 1 into Allocation 2. Example (b) shows a pointer sk Allocation 1 all the way into Allocation 3. Allocati same radix (64) as Allocation 1, but it has a different least-significant radix-64 digit. Example (c) shows a to Allocation 1 after it has been freed being used wh underlying linear memory has been reused for Alloc that Allocation 4 crosses a radix-64 boundary, so it req 128 slot. Since that is a different radix than was used for they are cryptographically isolated even though the li for Allocation 1 is reused in Allocation 4. In all of the will be garbled. Example (b) may generate an exceptio the data can be accessed, as will be explained below.\n\nFurthermore, data encryption is distinctly well-suit hensively mitigating uninitialized use throughout an tion. C 3 breaks adversaries' control over uninitialized d encrypting stale data from previous allocations when a fresh CA with a different radix or version. This appli to every byte of the allocation, such that even a sing uninitialized byte is still mitigated by C 3 . In contrast, t of per-byte initialization metadata would be prohibit Note that pointer authentication or encryption alo unable to mitigate some of the types of vulnerabiliti by C 3 , which additionally entangles data encryption per-allocation CAs. For example, Heartbleed illustrate of C 3 , since it only performs OOB reads that disclose corrupting pointers [? ]. Fundamentally, the limita approaches based solely on pointer authentication or that unencrypted data in memory remains accessible In contrast, when a C 3 pointer is dereferenced that stale, or references an uninitialized allocation, the dat bled with high probability if the decrypted pointer ev accessible memory in the first place. We compare th olations that can be mitigated by C 3 and closely rela safety mechanisms in Table 1. The \"Physical\" colum threats to data confidentiality and pointer integrity f attacks and erroneous or compromised IP. C 3 can d physical pointer corruptions and provides data confid encryption. : Best-fit assignment of allocations to power-of-twoslots. Each radix implies a distinct set of naturallypower-of-two slot boundaries to be used throughout ar address space. Every slot is encrypted uniquely te all allocations, even if they overlap in the linear 3 does not disrupt the memory layout; allocations eed to be padded to fill slots. SIGN tion describes how C 3 mitigates both spatial and temporal ilities by binding stateless, object-granular data encryption s to CAs that are unique to each allocation.\n\n\nbject-Granular Cryptographic Isolation\n\nocation is assigned a distinct Cryptographic Address (CA), esults in every allocation being uniquely encrypted. To and how every allocation is distinguished spatially from simultaneously-valid allocations, it is helpful to think of effectively defining a naturally-aligned power-of-two slot tains the allocation in its entirety as depicted in Figure 2. ons do not need to be aligned to a power-of-two, i.e. there uirement for an allocation to fill its assigned slot. sure that each allocation is assigned to a distinct slot, a criterion should be used to select the smallest slot that comontains a given allocation, which will have the minimum the slot that is outside of the actual allocation. Consider ry allocation will then cross the midpoint of its assigned n slot. Only a single allocation can cross any particular idpoint. If the allocation fits within some slot, but it does s that slot's midpoint, then it must fit more tightly in some slot, and hence the best-fit algorithm would have selected ller slot. Therefore, for a given spatial memory layout, only allocation can be assigned to any slot. emory layout of allocations is not disrupted. The best-fit f-two slot of a particular allocation can overlap with other ns, as we don't require padding to fill the slot. Even in this data for the separate allocations remains cryptographically due to the allocations each being assigned unique CAs to e data encryption is bound. Using a pointer to an allocation slot to read or overwrite a different allocation within the f the same slot results in the data for the second allocation rbled. This preserves the confidentiality of that data and ata corruption unpredictable to adversaries. Figure 3 shows flow of processing for C 3 mitigates covered memory safety s. Examples of how OOB and UAF vulnerabilities are mitigated by the object-granular cryptographic isolation in C 3 are shown in Figure 4. Example (a) shows a pointer overflowing Allocation 1 into Allocation 2. Example (b) shows a pointer skipping from Allocation 1 all the way into Allocation 3. Allocation 3 has the same radix (64) as Allocation 1, but it has a different value for its least-significant radix-64 digit. Example (c) shows a stale pointer to Allocation 1 after it has been freed being used when the same underlying linear memory has been reused for Allocation 4. Note that Allocation 4 crosses a radix-64 boundary, so it requires a radix-128 slot. Since that is a different radix than was used for Allocation 1, they are cryptographically isolated even though the linear memory for Allocation 1 is reused in Allocation 4. In all of these cases, data will be garbled. Example (b) may generate an exception even before the data can be accessed, as will be explained below.\n\nFurthermore, data encryption is distinctly well-suited to comprehensively mitigating uninitialized use throughout an entire allocation. C 3 breaks adversaries' control over uninitialized data values by encrypting stale data from previous allocations when read through a fresh CA with a different radix or version. This applies separately to every byte of the allocation, such that even a single remaining uninitialized byte is still mitigated by C 3 . In contrast, the overheads of per-byte initialization metadata would be prohibitive.\n\nNote that pointer authentication or encryption alone [? ? ? ] is unable to mitigate some of the types of vulnerabilities addressed by C 3 , which additionally entangles data encryption with unique, per-allocation CAs. For example, Heartbleed illustrates this benefit of C 3 , since it only performs OOB reads that disclose data without corrupting pointers [? ]. Fundamentally, the limitation of prior approaches based solely on pointer authentication or encryption is that unencrypted data in memory remains accessible.\n\nIn contrast, when a C 3 pointer is dereferenced that is corrupted, stale, or references an uninitialized allocation, the data will be garbled with high probability if the decrypted pointer even references accessible memory in the first place. We compare the types of violations that can be mitigated by C 3 and closely related memory safety mechanisms in Table 1. The \"Physical\" column represents threats to data confidentiality and pointer integrity from physical attacks and erroneous or compromised IP. C 3 can detect certain physical pointer corruptions and provides data confidentiality via encryption.  re 2: Best-fit assignment of allocations to power-of-twoed slots. Each radix implies a distinct set of naturallyed power-of-two slot boundaries to be used throughout linear address space. Every slot is encrypted uniquely olate all allocations, even if they overlap in the linear e. C 3 does not disrupt the memory layout; allocations ot need to be padded to fill slots. DESIGN section describes how C 3 mitigates both spatial and temporal erabilities by binding stateless, object-granular data encryption ches to CAs that are unique to each allocation.\n\n\nObject-Granular Cryptographic Isolation\n\nallocation is assigned a distinct Cryptographic Address (CA), h results in every allocation being uniquely encrypted. To rstand how every allocation is distinguished spatially from ther simultaneously-valid allocations, it is helpful to think of CA effectively defining a naturally-aligned power-of-two slot contains the allocation in its entirety as depicted in Figure 2. cations do not need to be aligned to a power-of-two, i.e. there requirement for an allocation to fill its assigned slot. ensure that each allocation is assigned to a distinct slot, a -fit\" criterion should be used to select the smallest slot that comly contains a given allocation, which will have the minimum e in the slot that is outside of the actual allocation. Consider every allocation will then cross the midpoint of its assigned ation slot. Only a single allocation can cross any particular s midpoint. If the allocation fits within some slot, but it does ross that slot's midpoint, then it must fit more tightly in some ler slot, and hence the best-fit algorithm would have selected smaller slot. Therefore, for a given spatial memory layout, only gle allocation can be assigned to any slot. he memory layout of allocations is not disrupted. The best-fit er-of-two slot of a particular allocation can overlap with other ations, as we don't require padding to fill the slot. Even in this the data for the separate allocations remains cryptographically ted due to the allocations each being assigned unique CAs to h the data encryption is bound. Using a pointer to an allocation me slot to read or overwrite a different allocation within the ds of the same slot results in the data for the second allocation Examples of how OOB and UAF vulnerabilities are mitigated by the object-granular cryptographic isolation in C 3 are shown in Figure 4. Example (a) shows a pointer overflowing Allocation 1 into Allocation 2. Example (b) shows a pointer skipping from Allocation 1 all the way into Allocation 3. Allocation 3 has the same radix (64) as Allocation 1, but it has a different value for its least-significant radix-64 digit. Example (c) shows a stale pointer to Allocation 1 after it has been freed being used when the same underlying linear memory has been reused for Allocation 4. Note that Allocation 4 crosses a radix-64 boundary, so it requires a radix-128 slot. Since that is a different radix than was used for Allocation 1, they are cryptographically isolated even though the linear memory for Allocation 1 is reused in Allocation 4. In all of these cases, data will be garbled. Example (b) may generate an exception even before the data can be accessed, as will be explained below.\n\nFurthermore, data encryption is distinctly well-suited to comprehensively mitigating uninitialized use throughout an entire allocation. C 3 breaks adversaries' control over uninitialized data values by encrypting stale data from previous allocations when read through a fresh CA with a different radix or version. This applies separately to every byte of the allocation, such that even a single remaining uninitialized byte is still mitigated by C 3 . In contrast, the overheads of per-byte initialization metadata would be prohibitive.\n\nNote that pointer authentication or encryption alone [? ? ? ] is unable to mitigate some of the types of vulnerabilities addressed by C 3 , which additionally entangles data encryption with unique, per-allocation CAs. For example, Heartbleed illustrates this benefit of C 3 , since it only performs OOB reads that disclose data without corrupting pointers [? ]. Fundamentally, the limitation of prior approaches based solely on pointer authentication or encryption is that unencrypted data in memory remains accessible.\n\nIn contrast, when a C 3 pointer is dereferenced that is corrupted, stale, or references an uninitialized allocation, the data will be garbled with high probability if the decrypted pointer even references accessible memory in the first place. We compare the types of violations that can be mitigated by C 3 and closely related memory safety mechanisms in Table 1. The \"Physical\" column represents \n\n\nDESIGN\n\nThis section describes how C 3 mitigates both spatial and temporal vulnerabilities by binding stateless, object-granular data encryption in caches to CAs that are unique to each allocation.\n\n\nObject-Granular Cryptographic Isolation\n\nEach allocation is assigned a distinct Cryptographic Address (CA), which results in every allocation being uniquely encrypted. To understand how every allocation is distinguished spatially from all other simultaneously-valid allocations, it is helpful to think of each CA effectively defining a naturally-aligned power-of-two slot that contains the allocation in its entirety as depicted in Figure 2. Allocations do not need to be aligned to a power-of-two, i.e. there is no requirement for an allocation to fill its assigned slot.\n\nTo ensure that each allocation is assigned to a distinct slot, a \"best-fit\" criterion should be used to select the smallest slot that completely contains a given allocation, which will have the minimum space in the slot that is outside of the actual allocation. Consider that every allocation will then cross the midpoint of its assigned allocation slot. Only a single allocation can cross any particular slot's midpoint. If the allocation fits within some slot, but it does not cross that slot's midpoint, then it must fit more tightly in some smaller slot, and hence the best-fit algorithm would have selected that smaller slot. Therefore, for a given spatial memory layout, only a single allocation can be assigned to any slot.\n\nThe memory layout of allocations is not disrupted. The best-fit power-of-two slot of a particular allocation can overlap with other allocations, as we don't require padding to fill the slot. Even in this case, the data for the separate allocations remains cryptographically isolated due to the allocations each being assigned unique CAs to which the data encryption is bound. Using a pointer to an allocation in some slot to read or overwrite a different allocation within the bounds of the same slot results in the data for the second allocation Examples of how OOB and UAF vulnerabilities are mitiga by the object-granular cryptographic isolation in C 3 are sho in Figure 4. Example (a) shows a pointer overflowing Allocat 1 into Allocation 2. Example (b) shows a pointer skipping fr Allocation 1 all the way into Allocation 3. Allocation 3 has same radix (64) as Allocation 1, but it has a different value for least-significant radix-64 digit. Example (c) shows a stale poin to Allocation 1 after it has been freed being used when the sa underlying linear memory has been reused for Allocation 4. N that Allocation 4 crosses a radix-64 boundary, so it requires a ra 128 slot. Since that is a different radix than was used for Allocatio they are cryptographically isolated even though the linear mem for Allocation 1 is reused in Allocation 4. In all of these cases, d will be garbled. Example (b) may generate an exception even bef the data can be accessed, as will be explained below.\n\nFurthermore, data encryption is distinctly well-suited to com hensively mitigating uninitialized use throughout an entire allo tion. C 3 breaks adversaries' control over uninitialized data values encrypting stale data from previous allocations when read throu a fresh CA with a different radix or version. This applies separat to every byte of the allocation, such that even a single remain uninitialized byte is still mitigated by C 3 . In contrast, the overhe of per-byte initialization metadata would be prohibitive.\n\nNote that pointer authentication or encryption alone [? ? ? unable to mitigate some of the types of vulnerabilities addres by C 3 , which additionally entangles data encryption with uniq per-allocation CAs. For example, Heartbleed illustrates this ben of C 3 , since it only performs OOB reads that disclose data with corrupting pointers [? ]. Fundamentally, the limitation of pr approaches based solely on pointer authentication or encryptio that unencrypted data in memory remains accessible.\n\nIn contrast, when a C 3 pointer is dereferenced that is corrup stale, or references an uninitialized allocation, the data will be g bled with high probability if the decrypted pointer even referen accessible memory in the first place. We compare the types of olations that can be mitigated by C 3 and closely related mem safety mechanisms in Table 1. The \"Physical\" column represe  2: Best-fit assignment of allocations to power-of-twoslots. Each radix implies a distinct set of naturallypower-of-two slot boundaries to be used throughout ear address space. Every slot is encrypted uniquely ate all allocations, even if they overlap in the linear C 3 does not disrupt the memory layout; allocations need to be padded to fill slots. SIGN ction describes how C 3 mitigates both spatial and temporal bilities by binding stateless, object-granular data encryption es to CAs that are unique to each allocation.\n\n\nbject-Granular Cryptographic Isolation\n\nlocation is assigned a distinct Cryptographic Address (CA), results in every allocation being uniquely encrypted. To tand how every allocation is distinguished spatially from r simultaneously-valid allocations, it is helpful to think of effectively defining a naturally-aligned power-of-two slot ntains the allocation in its entirety as depicted in Figure 2. ions do not need to be aligned to a power-of-two, i.e. there quirement for an allocation to fill its assigned slot. nsure that each allocation is assigned to a distinct slot, a \" criterion should be used to select the smallest slot that comcontains a given allocation, which will have the minimum the slot that is outside of the actual allocation. Consider ery allocation will then cross the midpoint of its assigned on slot. Only a single allocation can cross any particular idpoint. If the allocation fits within some slot, but it does ss that slot's midpoint, then it must fit more tightly in some slot, and hence the best-fit algorithm would have selected aller slot. Therefore, for a given spatial memory layout, only allocation can be assigned to any slot. memory layout of allocations is not disrupted. The best-fit of-two slot of a particular allocation can overlap with other ons, as we don't require padding to fill the slot. Even in this e data for the separate allocations remains cryptographically due to the allocations each being assigned unique CAs to he data encryption is bound. Using a pointer to an allocation slot to read or overwrite a different allocation within the of the same slot results in the data for the second allocation Examples of how OOB and UAF vulnerabilities are mitigated by the object-granular cryptographic isolation in C 3 are shown in Figure 4. Example (a) shows a pointer overflowing Allocation 1 into Allocation 2. Example (b) shows a pointer skipping from Allocation 1 all the way into Allocation 3. Allocation 3 has the same radix (64) as Allocation 1, but it has a different value for its least-significant radix-64 digit. Example (c) shows a stale pointer to Allocation 1 after it has been freed being used when the same underlying linear memory has been reused for Allocation 4. Note that Allocation 4 crosses a radix-64 boundary, so it requires a radix-128 slot. Since that is a different radix than was used for Allocation 1, they are cryptographically isolated even though the linear memory for Allocation 1 is reused in Allocation 4. In all of these cases, data will be garbled. Example (b) may generate an exception even before the data can be accessed, as will be explained below.\n\nFurthermore, data encryption is distinctly well-suited to comprehensively mitigating uninitialized use throughout an entire allocation. C 3 breaks adversaries' control over uninitialized data values by encrypting stale data from previous allocations when read through a fresh CA with a different radix or version. This applies separately to every byte of the allocation, such that even a single remaining uninitialized byte is still mitigated by C 3 . In contrast, the overheads of per-byte initialization metadata would be prohibitive.\n\nNote that pointer authentication or encryption alone [? ? ? ] is unable to mitigate some of the types of vulnerabilities addressed by C 3 , which additionally entangles data encryption with unique, per-allocation CAs. For example, Heartbleed illustrates this benefit of C 3 , since it only performs OOB reads that disclose data without corrupting pointers [? ]. Fundamentally, the limitation of prior approaches based solely on pointer authentication or encryption is that unencrypted data in memory remains accessible.\n\nIn contrast, when a C 3 pointer is dereferenced that is corrupted, stale, or references an uninitialized allocation, the data will be garbled with high probability if the decrypted pointer even references accessible memory in the first place. We compare the types of violations that can be mitigated by C 3 and closely related memory safety mechanisms in Table 1. The \"Physical\" column represents \n\n\nDESIGN\n\nThis section describes how C 3 mitigates both spatial and temporal vulnerabilities by binding stateless, object-granular data encryption in caches to CAs that are unique to each allocation.\n\n\nObject-Granular Cryptographic Isolation\n\nEach allocation is assigned a distinct Cryptographic Address (CA), which results in every allocation being uniquely encrypted. To understand how every allocation is distinguished spatially from all other simultaneously-valid allocations, it is helpful to think of each CA effectively defining a naturally-aligned power-of-two slot that contains the allocation in its entirety as depicted in Figure 2. Allocations do not need to be aligned to a power-of-two, i.e. there is no requirement for an allocation to fill its assigned slot.\n\nTo ensure that each allocation is assigned to a distinct slot, a \"best-fit\" criterion should be used to select the smallest slot that completely contains a given allocation, which will have the minimum space in the slot that is outside of the actual allocation. Consider that every allocation will then cross the midpoint of its assigned allocation slot. Only a single allocation can cross any particular slot's midpoint. If the allocation fits within some slot, but it does not cross that slot's midpoint, then it must fit more tightly in some smaller slot, and hence the best-fit algorithm would have selected that smaller slot. Therefore, for a given spatial memory layout, only a single allocation can be assigned to any slot.\n\nThe memory layout of allocations is not disrupted. The best-fit power-of-two slot of a particular allocation can overlap with other allocations, as we don't require padding to fill the slot. Even in this case, the data for the separate allocations remains cryptographically isolated due to the allocations each being assigned unique CAs to which the data encryption is bound. Using a pointer to an allocation in some slot to read or overwrite a different allocation within the bounds of the same slot results in the data for the second allocation Examples of how OOB and UAF vulnerabilities are by the object-granular cryptographic isolation in C 3 a in Figure 4. Example (a) shows a pointer overflowing A 1 into Allocation 2. Example (b) shows a pointer skip Allocation 1 all the way into Allocation 3. Allocation same radix (64) as Allocation 1, but it has a different va least-significant radix-64 digit. Example (c) shows a sta to Allocation 1 after it has been freed being used when underlying linear memory has been reused for Allocati that Allocation 4 crosses a radix-64 boundary, so it requi 128 slot. Since that is a different radix than was used for A they are cryptographically isolated even though the linea for Allocation 1 is reused in Allocation 4. In all of these will be garbled. Example (b) may generate an exception e the data can be accessed, as will be explained below.\n\nFurthermore, data encryption is distinctly well-suited hensively mitigating uninitialized use throughout an en tion. C 3 breaks adversaries' control over uninitialized dat encrypting stale data from previous allocations when rea a fresh CA with a different radix or version. This applies to every byte of the allocation, such that even a single uninitialized byte is still mitigated by C 3 . In contrast, the of per-byte initialization metadata would be prohibitive Note that pointer authentication or encryption alone unable to mitigate some of the types of vulnerabilities by C 3 , which additionally entangles data encryption wi per-allocation CAs. For example, Heartbleed illustrates t of C 3 , since it only performs OOB reads that disclose da corrupting pointers [? ]. Fundamentally, the limitatio approaches based solely on pointer authentication or en that unencrypted data in memory remains accessible.\n\nIn contrast, when a C 3 pointer is dereferenced that is stale, or references an uninitialized allocation, the data w bled with high probability if the decrypted pointer even accessible memory in the first place. We compare the t olations that can be mitigated by C 3 and closely relate safety mechanisms in Table 1. The \"Physical\" column re 2: Best-fit assignment of allocations to power-of-twoed slots. Each radix implies a distinct set of naturallyed power-of-two slot boundaries to be used throughout linear address space. Every slot is encrypted uniquely olate all allocations, even if they overlap in the linear e. C 3 does not disrupt the memory layout; allocations ot need to be padded to fill slots. DESIGN section describes how C 3 mitigates both spatial and temporal erabilities by binding stateless, object-granular data encryption ches to CAs that are unique to each allocation.\n\n\nObject-Granular Cryptographic Isolation\n\nallocation is assigned a distinct Cryptographic Address (CA), h results in every allocation being uniquely encrypted. To rstand how every allocation is distinguished spatially from ther simultaneously-valid allocations, it is helpful to think of CA effectively defining a naturally-aligned power-of-two slot contains the allocation in its entirety as depicted in Figure 2. cations do not need to be aligned to a power-of-two, i.e. there requirement for an allocation to fill its assigned slot. ensure that each allocation is assigned to a distinct slot, a -fit\" criterion should be used to select the smallest slot that comly contains a given allocation, which will have the minimum e in the slot that is outside of the actual allocation. Consider every allocation will then cross the midpoint of its assigned ation slot. Only a single allocation can cross any particular s midpoint. If the allocation fits within some slot, but it does ross that slot's midpoint, then it must fit more tightly in some ler slot, and hence the best-fit algorithm would have selected smaller slot. Therefore, for a given spatial memory layout, only gle allocation can be assigned to any slot. he memory layout of allocations is not disrupted. The best-fit er-of-two slot of a particular allocation can overlap with other ations, as we don't require padding to fill the slot. Even in this the data for the separate allocations remains cryptographically ted due to the allocations each being assigned unique CAs to h the data encryption is bound. Using a pointer to an allocation me slot to read or overwrite a different allocation within the Examples of how OOB and UAF vulnerabilities are mitigated by the object-granular cryptographic isolation in C 3 are shown in Figure 4. Example (a) shows a pointer overflowing Allocation 1 into Allocation 2. Example (b) shows a pointer skipping from Allocation 1 all the way into Allocation 3. Allocation 3 has the same radix (64) as Allocation 1, but it has a different value for its least-significant radix-64 digit. Example (c) shows a stale pointer to Allocation 1 after it has been freed being used when the same underlying linear memory has been reused for Allocation 4. Note that Allocation 4 crosses a radix-64 boundary, so it requires a radix-128 slot. Since that is a different radix than was used for Allocation 1, they are cryptographically isolated even though the linear memory for Allocation 1 is reused in Allocation 4. In all of these cases, data will be garbled. Example (b) may generate an exception even before the data can be accessed, as will be explained below.\n\nFurthermore, data encryption is distinctly well-suited to comprehensively mitigating uninitialized use throughout an entire allocation. C 3 breaks adversaries' control over uninitialized data values by encrypting stale data from previous allocations when read through a fresh CA with a different radix or version. This applies separately to every byte of the allocation, such that even a single remaining uninitialized byte is still mitigated by C 3 . In contrast, the overheads of per-byte initialization metadata would be prohibitive.\n\nNote that pointer authentication or encryption alone [? ? ? ] is unable to mitigate some of the types of vulnerabilities addressed by C 3 , which additionally entangles data encryption with unique, per-allocation CAs. For example, Heartbleed illustrates this benefit of C 3 , since it only performs OOB reads that disclose data without corrupting pointers [? ]. Fundamentally, the limitation of prior approaches based solely on pointer authentication or encryption is that unencrypted data in memory remains accessible.\n\nIn contrast, when a C 3 pointer is dereferenced that is corrupted, stale, or references an uninitialized allocation, the data will be garbled with high probability if the decrypted pointer even references accessible memory in the first place. We compare the types of violations that can be mitigated by C 3 and closely related memory \n\n\nDESIGN\n\nThis section describes how C 3 mitigates both spatial and temporal vulnerabilities by binding stateless, object-granular data encryption in caches to CAs that are unique to each allocation.\n\n\nObject-Granular Cryptographic Isolation\n\nEach allocation is assigned a distinct Cryptographic Address (CA), which results in every allocation being uniquely encrypted. To understand how every allocation is distinguished spatially from all other simultaneously-valid allocations, it is helpful to think of each CA effectively defining a naturally-aligned power-of-two slot that contains the allocation in its entirety as depicted in Figure 2. Allocations do not need to be aligned to a power-of-two, i.e. there is no requirement for an allocation to fill its assigned slot.\n\nTo ensure that each allocation is assigned to a distinct slot, a \"best-fit\" criterion should be used to select the smallest slot that completely contains a given allocation, which will have the minimum space in the slot that is outside of the actual allocation. Consider that every allocation will then cross the midpoint of its assigned allocation slot. Only a single allocation can cross any particular slot's midpoint. If the allocation fits within some slot, but it does not cross that slot's midpoint, then it must fit more tightly in some smaller slot, and hence the best-fit algorithm would have selected that smaller slot. Therefore, for a given spatial memory layout, only a single allocation can be assigned to any slot.\n\nThe memory layout of allocations is not disrupted. The best-fit power-of-two slot of a particular allocation can overlap with other allocations, as we don't require padding to fill the slot. Even in this case, the data for the separate allocations remains cryptographically isolated due to the allocations each being assigned unique CAs to which the data encryption is bound. Using a pointer to an allocation in some slot to read or overwrite a different allocation within the Examples of how OOB and UAF vulnerabilities are mitiga by the object-granular cryptographic isolation in C 3 are sho in Figure 4. Example (a) shows a pointer overflowing Allocat 1 into Allocation 2. Example (b) shows a pointer skipping fr Allocation 1 all the way into Allocation 3. Allocation 3 has same radix (64) as Allocation 1, but it has a different value for least-significant radix-64 digit. Example (c) shows a stale poin to Allocation 1 after it has been freed being used when the sa underlying linear memory has been reused for Allocation 4. N that Allocation 4 crosses a radix-64 boundary, so it requires a ra 128 slot. Since that is a different radix than was used for Allocatio they are cryptographically isolated even though the linear mem for Allocation 1 is reused in Allocation 4. In all of these cases, d will be garbled. Example (b) may generate an exception even bef the data can be accessed, as will be explained below.\n\nFurthermore, data encryption is distinctly well-suited to com hensively mitigating uninitialized use throughout an entire allo tion. C 3 breaks adversaries' control over uninitialized data values encrypting stale data from previous allocations when read throu a fresh CA with a different radix or version. This applies separat to every byte of the allocation, such that even a single remain uninitialized byte is still mitigated by C 3 . In contrast, the overhe of per-byte initialization metadata would be prohibitive.\n\nNote that pointer authentication or encryption alone [? ? ? unable to mitigate some of the types of vulnerabilities addres by C 3 , which additionally entangles data encryption with uniq per-allocation CAs. For example, Heartbleed illustrates this ben of C 3 , since it only performs OOB reads that disclose data with corrupting pointers [? ]. Fundamentally, the limitation of pr approaches based solely on pointer authentication or encryptio that unencrypted data in memory remains accessible.\n\nIn contrast, when a C 3 pointer is dereferenced that is corrup stale, or references an uninitialized allocation, the data will be g bled with high probability if the decrypted pointer even referen accessible memory in the first place. We compare the types of olations that can be mitigated by C 3 and closely related mem 2: Best-fit assignment of allocations to power-of-twoslots. Each radix implies a distinct set of naturallypower-of-two slot boundaries to be used throughout ear address space. Every slot is encrypted uniquely ate all allocations, even if they overlap in the linear C 3 does not disrupt the memory layout; allocations need to be padded to fill slots. SIGN ction describes how C 3 mitigates both spatial and temporal bilities by binding stateless, object-granular data encryption es to CAs that are unique to each allocation.\n\n\nbject-Granular Cryptographic Isolation\n\nlocation is assigned a distinct Cryptographic Address (CA), results in every allocation being uniquely encrypted. To tand how every allocation is distinguished spatially from r simultaneously-valid allocations, it is helpful to think of effectively defining a naturally-aligned power-of-two slot ntains the allocation in its entirety as depicted in Figure 2. ions do not need to be aligned to a power-of-two, i.e. there quirement for an allocation to fill its assigned slot. nsure that each allocation is assigned to a distinct slot, a \" criterion should be used to select the smallest slot that comcontains a given allocation, which will have the minimum the slot that is outside of the actual allocation. Consider ery allocation will then cross the midpoint of its assigned on slot. Only a single allocation can cross any particular idpoint. If the allocation fits within some slot, but it does ss that slot's midpoint, then it must fit more tightly in some slot, and hence the best-fit algorithm would have selected aller slot. Therefore, for a given spatial memory layout, only allocation can be assigned to any slot. memory layout of allocations is not disrupted. The best-fit of-two slot of a particular allocation can overlap with other ons, as we don't require padding to fill the slot. Even in this e data for the separate allocations remains cryptographically due to the allocations each being assigned unique CAs to he data encryption is bound. Using a pointer to an allocation slot to read or overwrite a different allocation within the Examples of how OOB and UAF vulnerabilities are mitigated by the object-granular cryptographic isolation in C 3 are shown in Figure 4. Example (a) shows a pointer overflowing Allocation 1 into Allocation 2. Example (b) shows a pointer skipping from Allocation 1 all the way into Allocation 3. Allocation 3 has the same radix (64) as Allocation 1, but it has a different value for its least-significant radix-64 digit. Example (c) shows a stale pointer to Allocation 1 after it has been freed being used when the same underlying linear memory has been reused for Allocation 4. Note that Allocation 4 crosses a radix-64 boundary, so it requires a radix-128 slot. Since that is a different radix than was used for Allocation 1, they are cryptographically isolated even though the linear memory for Allocation 1 is reused in Allocation 4. In all of these cases, data will be garbled. Example (b) may generate an exception even before the data can be accessed, as will be explained below.\n\nFurthermore, data encryption is distinctly well-suited to comprehensively mitigating uninitialized use throughout an entire allocation. C 3 breaks adversaries' control over uninitialized data values by encrypting stale data from previous allocations when read through a fresh CA with a different radix or version. This applies separately to every byte of the allocation, such that even a single remaining uninitialized byte is still mitigated by C 3 . In contrast, the overheads of per-byte initialization metadata would be prohibitive.\n\nNote that pointer authentication or encryption alone [? ? ? ] is unable to mitigate some of the types of vulnerabilities addressed by C 3 , which additionally entangles data encryption with unique, per-allocation CAs. For example, Heartbleed illustrates this benefit of C 3 , since it only performs OOB reads that disclose data without corrupting pointers [? ]. Fundamentally, the limitation of prior approaches based solely on pointer authentication or encryption is that unencrypted data in memory remains accessible.\n\nIn contrast, when a C 3 pointer is dereferenced that is corrupted, stale, or references an uninitialized allocation, the data will be garbled with high probability if the decrypted pointer even references accessible memory in the first place. We compare the types of violations that can be mitigated by C 3 and closely related memory \n\n\nDESIGN\n\nThis section describes how C 3 mitigates both spatial and temporal vulnerabilities by binding stateless, object-granular data encryption in caches to CAs that are unique to each allocation.\n\n\nObject-Granular Cryptographic Isolation\n\nEach allocation is assigned a distinct Cryptographic Address (CA), which results in every allocation being uniquely encrypted. To understand how every allocation is distinguished spatially from all other simultaneously-valid allocations, it is helpful to think of each CA effectively defining a naturally-aligned power-of-two slot that contains the allocation in its entirety as depicted in Figure 2. Allocations do not need to be aligned to a power-of-two, i.e. there is no requirement for an allocation to fill its assigned slot.\n\nTo ensure that each allocation is assigned to a distinct slot, a \"best-fit\" criterion should be used to select the smallest slot that completely contains a given allocation, which will have the minimum space in the slot that is outside of the actual allocation. Consider that every allocation will then cross the midpoint of its assigned allocation slot. Only a single allocation can cross any particular slot's midpoint. If the allocation fits within some slot, but it does not cross that slot's midpoint, then it must fit more tightly in some smaller slot, and hence the best-fit algorithm would have selected that smaller slot. Therefore, for a given spatial memory layout, only a single allocation can be assigned to any slot.\n\nThe memory layout of allocations is not disrupted. The best-fit power-of-two slot of a particular allocation can overlap with other allocations, as we don't require padding to fill the slot. Even in this case, the data for the separate allocations remains cryptographically isolated due to the allocations each being assigned unique CAs to which the data encryption is bound. Using a pointer to an allocation in some slot to read or overwrite a different allocation within the Examples of how OOB and UAF vulnerabilities are by the object-granular cryptographic isolation in C 3 a in Figure 4. Example (a) shows a pointer overflowing A 1 into Allocation 2. Example (b) shows a pointer skip Allocation 1 all the way into Allocation 3. Allocation same radix (64) as Allocation 1, but it has a different va least-significant radix-64 digit. Example (c) shows a sta to Allocation 1 after it has been freed being used when underlying linear memory has been reused for Allocati that Allocation 4 crosses a radix-64 boundary, so it requi 128 slot. Since that is a different radix than was used for A they are cryptographically isolated even though the linea for Allocation 1 is reused in Allocation 4. In all of these will be garbled. Example (b) may generate an exception e the data can be accessed, as will be explained below.\n\nFurthermore, data encryption is distinctly well-suited hensively mitigating uninitialized use throughout an en tion. C 3 breaks adversaries' control over uninitialized dat encrypting stale data from previous allocations when rea a fresh CA with a different radix or version. This applies to every byte of the allocation, such that even a single uninitialized byte is still mitigated by C 3 . In contrast, the of per-byte initialization metadata would be prohibitive Note that pointer authentication or encryption alone unable to mitigate some of the types of vulnerabilities by C 3 , which additionally entangles data encryption wi per-allocation CAs. For example, Heartbleed illustrates t of C 3 , since it only performs OOB reads that disclose da corrupting pointers [? ]. Fundamentally, the limitatio approaches based solely on pointer authentication or en that unencrypted data in memory remains accessible.\n\nIn contrast, when a C 3 pointer is dereferenced that is stale, or references an uninitialized allocation, the data w bled with high probability if the decrypted pointer even accessible memory in the first place. We compare the t olations that can be mitigated by C 3 and closely relate : Best-fit assignment of allocations to power-of-twoslots. Each radix implies a distinct set of naturallypower-of-two slot boundaries to be used throughout ar address space. Every slot is encrypted uniquely te all allocations, even if they overlap in the linear 3 does not disrupt the memory layout; allocations eed to be padded to fill slots. SIGN tion describes how C 3 mitigates both spatial and temporal ilities by binding stateless, object-granular data encryption s to CAs that are unique to each allocation.\n\n\nbject-Granular Cryptographic Isolation\n\nocation is assigned a distinct Cryptographic Address (CA), esults in every allocation being uniquely encrypted. To and how every allocation is distinguished spatially from simultaneously-valid allocations, it is helpful to think of effectively defining a naturally-aligned power-of-two slot tains the allocation in its entirety as depicted in Figure 2. ons do not need to be aligned to a power-of-two, i.e. there uirement for an allocation to fill its assigned slot. sure that each allocation is assigned to a distinct slot, a criterion should be used to select the smallest slot that comontains a given allocation, which will have the minimum the slot that is outside of the actual allocation. Consider ry allocation will then cross the midpoint of its assigned n slot. Only a single allocation can cross any particular idpoint. If the allocation fits within some slot, but it does s that slot's midpoint, then it must fit more tightly in some slot, and hence the best-fit algorithm would have selected ller slot. Therefore, for a given spatial memory layout, only allocation can be assigned to any slot. emory layout of allocations is not disrupted. The best-fit f-two slot of a particular allocation can overlap with other ns, as we don't require padding to fill the slot. Even in this data for the separate allocations remains cryptographically due to the allocations each being assigned unique CAs to e data encryption is bound. Using a pointer to an allocation slot to read or overwrite a different allocation within the Examples of how OOB and UAF vulnerabilities are mitigated by the object-granular cryptographic isolation in C 3 are shown in Figure 4. Example (a) shows a pointer overflowing Allocation 1 into Allocation 2. Example (b) shows a pointer skipping from Allocation 1 all the way into Allocation 3. Allocation 3 has the same radix (64) as Allocation 1, but it has a different value for its least-significant radix-64 digit. Example (c) shows a stale pointer to Allocation 1 after it has been freed being used when the same underlying linear memory has been reused for Allocation 4. Note that Allocation 4 crosses a radix-64 boundary, so it requires a radix-128 slot. Since that is a different radix than was used for Allocation 1, they are cryptographically isolated even though the linear memory for Allocation 1 is reused in Allocation 4. In all of these cases, data will be garbled. Example (b) may generate an exception even before the data can be accessed, as will be explained below.\n\nFurthermore, data encryption is distinctly well-suited to comprehensively mitigating uninitialized use throughout an entire allocation. C 3 breaks adversaries' control over uninitialized data values by encrypting stale data from previous allocations when read through a fresh CA with a different radix or version. This applies separately to every byte of the allocation, such that even a single remaining uninitialized byte is still mitigated by C 3 . In contrast, the overheads of per-byte initialization metadata would be prohibitive.\n\nNote that pointer authentication or encryption alone [? ? ? ] is unable to mitigate some of the types of vulnerabilities addressed by C 3 , which additionally entangles data encryption with unique, per-allocation CAs. For example, Heartbleed illustrates this benefit of C 3 , since it only performs OOB reads that disclose data without corrupting pointers [? ]. Fundamentally, the limitation of prior approaches based solely on pointer authentication or encryption is that unencrypted data in memory remains accessible.\n\nIn contrast, when a C 3 pointer is dereferenced that is corrupted, stale, or references an uninitialized allocation, the data will be garbled with high probability if the decrypted pointer even references accessible memory in the first place. We compare the types of violations that can be mitigated by C 3 and closely related memory gure 2: Best-fit assignment of allocations to power-of-twoigned slots. Each radix implies a distinct set of naturallyigned power-of-two slot boundaries to be used throughout e linear address space. Every slot is encrypted uniquely isolate all allocations, even if they overlap in the linear ace. C 3 does not disrupt the memory layout; allocations not need to be padded to fill slots. DESIGN is section describes how C 3 mitigates both spatial and temporal lnerabilities by binding stateless, object-granular data encryption caches to CAs that are unique to each allocation.\n\n1 Object-Granular Cryptographic Isolation ch allocation is assigned a distinct Cryptographic Address (CA), hich results in every allocation being uniquely encrypted. To derstand how every allocation is distinguished spatially from l other simultaneously-valid allocations, it is helpful to think of ch CA effectively defining a naturally-aligned power-of-two slot at contains the allocation in its entirety as depicted in Figure 2. locations do not need to be aligned to a power-of-two, i.e. there no requirement for an allocation to fill its assigned slot. To ensure that each allocation is assigned to a distinct slot, a est-fit\" criterion should be used to select the smallest slot that cometely contains a given allocation, which will have the minimum ace in the slot that is outside of the actual allocation. Consider at every allocation will then cross the midpoint of its assigned location slot. Only a single allocation can cross any particular t's midpoint. If the allocation fits within some slot, but it does t cross that slot's midpoint, then it must fit more tightly in some aller slot, and hence the best-fit algorithm would have selected at smaller slot. Therefore, for a given spatial memory layout, only single allocation can be assigned to any slot. The memory layout of allocations is not disrupted. The best-fit wer-of-two slot of a particular allocation can overlap with other locations, as we don't require padding to fill the slot. Even in this se, the data for the separate allocations remains cryptographically lated due to the allocations each being assigned unique CAs to ich the data encryption is bound. Using a pointer to an allocation some slot to read or overwrite a different allocation within the Examples of how OOB and UAF vulnerabilities are mitig by the object-granular cryptographic isolation in C 3 are sh in Figure 4. Example (a) shows a pointer overflowing Alloc 1 into Allocation 2. Example (b) shows a pointer skipping Allocation 1 all the way into Allocation 3. Allocation 3 ha same radix (64) as Allocation 1, but it has a different value f least-significant radix-64 digit. Example (c) shows a stale po to Allocation 1 after it has been freed being used when the underlying linear memory has been reused for Allocation 4. that Allocation 4 crosses a radix-64 boundary, so it requires a 128 slot. Since that is a different radix than was used for Allocat they are cryptographically isolated even though the linear me for Allocation 1 is reused in Allocation 4. In all of these cases will be garbled. Example (b) may generate an exception even b the data can be accessed, as will be explained below.\n\nFurthermore, data encryption is distinctly well-suited to co hensively mitigating uninitialized use throughout an entire a tion. C 3 breaks adversaries' control over uninitialized data valu encrypting stale data from previous allocations when read thr a fresh CA with a different radix or version. This applies separ to every byte of the allocation, such that even a single rema uninitialized byte is still mitigated by C 3 . In contrast, the overh of per-byte initialization metadata would be prohibitive.\n\nNote that pointer authentication or encryption alone [? ? unable to mitigate some of the types of vulnerabilities addr by C 3 , which additionally entangles data encryption with un per-allocation CAs. For example, Heartbleed illustrates this be of C 3 , since it only performs OOB reads that disclose data wi corrupting pointers [? ]. Fundamentally, the limitation of approaches based solely on pointer authentication or encrypt that unencrypted data in memory remains accessible.\n\nIn contrast, when a C 3 pointer is dereferenced that is corru stale, or references an uninitialized allocation, the data will b bled with high probability if the decrypted pointer even refer accessible memory in the first place. We compare the types olations that can be mitigated by C 3 and closely related me 2: Best-fit assignment of allocations to power-of-twoslots. Each radix implies a distinct set of naturallypower-of-two slot boundaries to be used throughout ear address space. Every slot is encrypted uniquely ate all allocations, even if they overlap in the linear C 3 does not disrupt the memory layout; allocations need to be padded to fill slots. SIGN ction describes how C 3 mitigates both spatial and temporal bilities by binding stateless, object-granular data encryption es to CAs that are unique to each allocation.\n\n\nbject-Granular Cryptographic Isolation\n\nlocation is assigned a distinct Cryptographic Address (CA), results in every allocation being uniquely encrypted. To tand how every allocation is distinguished spatially from r simultaneously-valid allocations, it is helpful to think of effectively defining a naturally-aligned power-of-two slot ntains the allocation in its entirety as depicted in Figure 2. ions do not need to be aligned to a power-of-two, i.e. there quirement for an allocation to fill its assigned slot. nsure that each allocation is assigned to a distinct slot, a \" criterion should be used to select the smallest slot that comcontains a given allocation, which will have the minimum the slot that is outside of the actual allocation. Consider ery allocation will then cross the midpoint of its assigned on slot. Only a single allocation can cross any particular idpoint. If the allocation fits within some slot, but it does ss that slot's midpoint, then it must fit more tightly in some slot, and hence the best-fit algorithm would have selected aller slot. Therefore, for a given spatial memory layout, only allocation can be assigned to any slot. memory layout of allocations is not disrupted. The best-fit of-two slot of a particular allocation can overlap with other ons, as we don't require padding to fill the slot. Even in this e data for the separate allocations remains cryptographically due to the allocations each being assigned unique CAs to he data encryption is bound. Using a pointer to an allocation slot to read or overwrite a different allocation within the Examples of how OOB and UAF vulnerabilities are mitigated by the object-granular cryptographic isolation in C 3 are shown in Figure 4. Example (a) shows a pointer overflowing Allocation 1 into Allocation 2. Example (b) shows a pointer skipping from Allocation 1 all the way into Allocation 3. Allocation 3 has the same radix (64) as Allocation 1, but it has a different value for its least-significant radix-64 digit. Example (c) shows a stale pointer to Allocation 1 after it has been freed being used when the same underlying linear memory has been reused for Allocation 4. Note that Allocation 4 crosses a radix-64 boundary, so it requires a radix-128 slot. Since that is a different radix than was used for Allocation 1, they are cryptographically isolated even though the linear memory for Allocation 1 is reused in Allocation 4. In all of these cases, data will be garbled. Example (b) may generate an exception even before the data can be accessed, as will be explained below.\n\nFurthermore, data encryption is distinctly well-suited to comprehensively mitigating uninitialized use throughout an entire allocation. C 3 breaks adversaries' control over uninitialized data values by encrypting stale data from previous allocations when read through a fresh CA with a different radix or version. This applies separately to every byte of the allocation, such that even a single remaining uninitialized byte is still mitigated by C 3 . In contrast, the overheads of per-byte initialization metadata would be prohibitive.\n\nNote that pointer authentication or encryption alone [? ? ? ] is unable to mitigate some of the types of vulnerabilities addressed by C 3 , which additionally entangles data encryption with unique, per-allocation CAs. For example, Heartbleed illustrates this benefit of C 3 , since it only performs OOB reads that disclose data without corrupting pointers [? ]. Fundamentally, the limitation of prior approaches based solely on pointer authentication or encryption is that unencrypted data in memory remains accessible.\n\nIn contrast, when a C 3 pointer is dereferenced that is corrupted, stale, or references an uninitialized allocation, the data will be garbled with high probability if the decrypted pointer even references accessible memory in the first place. We compare the types of violations that can be mitigated by C 3 and closely related memory \n\n\nDESIGN\n\nThis section describes how C 3 mitigates both spatial and temporal vulnerabilities by binding stateless, object-granular data encryption in caches to CAs that are unique to each allocation.\n\n\nObject-Granular Cryptographic Isolation\n\nEach allocation is assigned a distinct Cryptographic Address (CA), which results in every allocation being uniquely encrypted. To understand how every allocation is distinguished spatially from all other simultaneously-valid allocations, it is helpful to think of each CA effectively defining a naturally-aligned power-of-two slot that contains the allocation in its entirety as depicted in Figure 2. Allocations do not need to be aligned to a power-of-two, i.e. there is no requirement for an allocation to fill its assigned slot.\n\nTo ensure that each allocation is assigned to a distinct slot, a \"best-fit\" criterion should be used to select the smallest slot that completely contains a given allocation, which will have the minimum space in the slot that is outside of the actual allocation. Consider that every allocation will then cross the midpoint of its assigned allocation slot. Only a single allocation can cross any particular slot's midpoint. If the allocation fits within some slot, but it does not cross that slot's midpoint, then it must fit more tightly in some smaller slot, and hence the best-fit algorithm would have selected that smaller slot. Therefore, for a given spatial memory layout, only a single allocation can be assigned to any slot.\n\nThe memory layout of allocations is not disrupted. The best-fit power-of-two slot of a particular allocation can overlap with other allocations, as we don't require padding to fill the slot. Even in this case, the data for the separate allocations remains cryptographically isolated due to the allocations each being assigned unique CAs to which the data encryption is bound. Using a pointer to an allocation in some slot to read or overwrite a different allocation within the Examples of how OOB and UAF vulnerabilities are by the object-granular cryptographic isolation in C 3 a in Figure 4. Example (a) shows a pointer overflowing A 1 into Allocation 2. Example (b) shows a pointer skip Allocation 1 all the way into Allocation 3. Allocation same radix (64) as Allocation 1, but it has a different va least-significant radix-64 digit. Example (c) shows a sta to Allocation 1 after it has been freed being used when underlying linear memory has been reused for Allocati that Allocation 4 crosses a radix-64 boundary, so it requi 128 slot. Since that is a different radix than was used for A they are cryptographically isolated even though the linea for Allocation 1 is reused in Allocation 4. In all of these will be garbled. Example (b) may generate an exception e the data can be accessed, as will be explained below.\n\nFurthermore, data encryption is distinctly well-suited hensively mitigating uninitialized use throughout an en tion. C 3 breaks adversaries' control over uninitialized dat encrypting stale data from previous allocations when rea a fresh CA with a different radix or version. This applies to every byte of the allocation, such that even a single uninitialized byte is still mitigated by C 3 . In contrast, the of per-byte initialization metadata would be prohibitive Note that pointer authentication or encryption alone unable to mitigate some of the types of vulnerabilities by C 3 , which additionally entangles data encryption wi per-allocation CAs. For example, Heartbleed illustrates t of C 3 , since it only performs OOB reads that disclose da corrupting pointers [? ]. Fundamentally, the limitatio approaches based solely on pointer authentication or en that unencrypted data in memory remains accessible.\n\nIn contrast, when a C 3 pointer is dereferenced that is stale, or references an uninitialized allocation, the data w bled with high probability if the decrypted pointer even accessible memory in the first place. We compare the t olations that can be mitigated by C 3 and closely relate : Best-fit assignment of allocations to power-of-twoslots. Each radix implies a distinct set of naturallypower-of-two slot boundaries to be used throughout ar address space. Every slot is encrypted uniquely te all allocations, even if they overlap in the linear 3 does not disrupt the memory layout; allocations eed to be padded to fill slots. SIGN tion describes how C 3 mitigates both spatial and temporal ilities by binding stateless, object-granular data encryption s to CAs that are unique to each allocation.\n\n\nbject-Granular Cryptographic Isolation\n\nocation is assigned a distinct Cryptographic Address (CA), esults in every allocation being uniquely encrypted. To and how every allocation is distinguished spatially from simultaneously-valid allocations, it is helpful to think of effectively defining a naturally-aligned power-of-two slot tains the allocation in its entirety as depicted in Figure 2. ons do not need to be aligned to a power-of-two, i.e. there uirement for an allocation to fill its assigned slot. sure that each allocation is assigned to a distinct slot, a criterion should be used to select the smallest slot that comontains a given allocation, which will have the minimum the slot that is outside of the actual allocation. Consider ry allocation will then cross the midpoint of its assigned n slot. Only a single allocation can cross any particular idpoint. If the allocation fits within some slot, but it does s that slot's midpoint, then it must fit more tightly in some slot, and hence the best-fit algorithm would have selected ller slot. Therefore, for a given spatial memory layout, only allocation can be assigned to any slot. emory layout of allocations is not disrupted. The best-fit f-two slot of a particular allocation can overlap with other ns, as we don't require padding to fill the slot. Even in this data for the separate allocations remains cryptographically due to the allocations each being assigned unique CAs to e data encryption is bound. Using a pointer to an allocation Examples of how OOB and UAF vulnerabilities are mitigated by the object-granular cryptographic isolation in C 3 are shown in Figure 4. Example (a) shows a pointer overflowing Allocation 1 into Allocation 2. Example (b) shows a pointer skipping from Allocation 1 all the way into Allocation 3. Allocation 3 has the same radix (64) as Allocation 1, but it has a different value for its least-significant radix-64 digit. Example (c) shows a stale pointer to Allocation 1 after it has been freed being used when the same underlying linear memory has been reused for Allocation 4. Note that Allocation 4 crosses a radix-64 boundary, so it requires a radix-128 slot. Since that is a different radix than was used for Allocation 1, they are cryptographically isolated even though the linear memory for Allocation 1 is reused in Allocation 4. In all of these cases, data will be garbled. Example (b) may generate an exception even before the data can be accessed, as will be explained below.\n\nFurthermore, data encryption is distinctly well-suited to comprehensively mitigating uninitialized use throughout an entire allocation. C 3 breaks adversaries' control over uninitialized data values by encrypting stale data from previous allocations when read through a fresh CA with a different radix or version. This applies separately to every byte of the allocation, such that even a single remaining uninitialized byte is still mitigated by C 3 . In contrast, the overheads of per-byte initialization metadata would be prohibitive.\n\nNote that pointer authentication or encryption alone [? ? ? ] is unable to mitigate some of the types of vulnerabilities addressed by C 3 , which additionally entangles data encryption with unique, per-allocation CAs. For example, Heartbleed illustrates this benefit of C 3 , since it only performs OOB reads that disclose data without corrupting pointers [? ]. Fundamentally, the limitation of prior approaches based solely on pointer authentication or encryption is that unencrypted data in memory remains accessible.\n\nIn contrast, when a C 3 pointer is dereferenced that is corrupted, stale, or references an uninitialized allocation, the data will be garbled with high probability if the decrypted pointer even references accessible memory in the first place. We compare the types of vi- gure 2: Best-fit assignment of allocations to power-of-twoigned slots. Each radix implies a distinct set of naturallyigned power-of-two slot boundaries to be used throughout e linear address space. Every slot is encrypted uniquely isolate all allocations, even if they overlap in the linear ace. C 3 does not disrupt the memory layout; allocations not need to be padded to fill slots. DESIGN is section describes how C 3 mitigates both spatial and temporal lnerabilities by binding stateless, object-granular data encryption caches to CAs that are unique to each allocation.\n\n\nObject-Granular Cryptographic Isolation\n\nch allocation is assigned a distinct Cryptographic Address (CA), hich results in every allocation being uniquely encrypted. To derstand how every allocation is distinguished spatially from l other simultaneously-valid allocations, it is helpful to think of ch CA effectively defining a naturally-aligned power-of-two slot at contains the allocation in its entirety as depicted in Figure 2. locations do not need to be aligned to a power-of-two, i.e. there no requirement for an allocation to fill its assigned slot. To ensure that each allocation is assigned to a distinct slot, a est-fit\" criterion should be used to select the smallest slot that cometely contains a given allocation, which will have the minimum ace in the slot that is outside of the actual allocation. Consider at every allocation will then cross the midpoint of its assigned location slot. Only a single allocation can cross any particular t's midpoint. If the allocation fits within some slot, but it does t cross that slot's midpoint, then it must fit more tightly in some aller slot, and hence the best-fit algorithm would have selected at smaller slot. Therefore, for a given spatial memory layout, only single allocation can be assigned to any slot. The memory layout of allocations is not disrupted. The best-fit wer-of-two slot of a particular allocation can overlap with other locations, as we don't require padding to fill the slot. Even in this se, the data for the separate allocations remains cryptographically lated due to the allocations each being assigned unique CAs to ich the data encryption is bound. Using a pointer to an allocation Examples of how OOB and UAF vulnerabilities are mitig by the object-granular cryptographic isolation in C 3 are sh in Figure 4. Example (a) shows a pointer overflowing Alloc 1 into Allocation 2. Example (b) shows a pointer skipping Allocation 1 all the way into Allocation 3. Allocation 3 ha same radix (64) as Allocation 1, but it has a different value f least-significant radix-64 digit. Example (c) shows a stale po to Allocation 1 after it has been freed being used when the underlying linear memory has been reused for Allocation 4. that Allocation 4 crosses a radix-64 boundary, so it requires a 128 slot. Since that is a different radix than was used for Allocat they are cryptographically isolated even though the linear me for Allocation 1 is reused in Allocation 4. In all of these cases will be garbled. Example (b) may generate an exception even b the data can be accessed, as will be explained below.\n\nFurthermore, data encryption is distinctly well-suited to co hensively mitigating uninitialized use throughout an entire a tion. C 3 breaks adversaries' control over uninitialized data valu encrypting stale data from previous allocations when read thr a fresh CA with a different radix or version. This applies separ to every byte of the allocation, such that even a single rema uninitialized byte is still mitigated by C 3 . In contrast, the overh of per-byte initialization metadata would be prohibitive.\n\nNote that pointer authentication or encryption alone [? ? unable to mitigate some of the types of vulnerabilities addr by C 3 , which additionally entangles data encryption with un per-allocation CAs. For example, Heartbleed illustrates this be of C 3 , since it only performs OOB reads that disclose data wi corrupting pointers [? ]. Fundamentally, the limitation of approaches based solely on pointer authentication or encrypt that unencrypted data in memory remains accessible.\n\nIn contrast, when a C 3 pointer is dereferenced that is corru stale, or references an uninitialized allocation, the data will b bled with high probability if the decrypted pointer even refer accessible memory in the first place. We compare the types 2: Best-fit assignment of allocations to power-of-twoslots. Each radix implies a distinct set of naturallypower-of-two slot boundaries to be used throughout ear address space. Every slot is encrypted uniquely ate all allocations, even if they overlap in the linear C 3 does not disrupt the memory layout; allocations need to be padded to fill slots. SIGN ction describes how C 3 mitigates both spatial and temporal bilities by binding stateless, object-granular data encryption es to CAs that are unique to each allocation.\n\n\nbject-Granular Cryptographic Isolation\n\nlocation is assigned a distinct Cryptographic Address (CA), results in every allocation being uniquely encrypted. To tand how every allocation is distinguished spatially from r simultaneously-valid allocations, it is helpful to think of effectively defining a naturally-aligned power-of-two slot ntains the allocation in its entirety as depicted in Figure 2. ions do not need to be aligned to a power-of-two, i.e. there quirement for an allocation to fill its assigned slot. nsure that each allocation is assigned to a distinct slot, a \" criterion should be used to select the smallest slot that comcontains a given allocation, which will have the minimum the slot that is outside of the actual allocation. Consider ery allocation will then cross the midpoint of its assigned on slot. Only a single allocation can cross any particular idpoint. If the allocation fits within some slot, but it does ss that slot's midpoint, then it must fit more tightly in some slot, and hence the best-fit algorithm would have selected aller slot. Therefore, for a given spatial memory layout, only allocation can be assigned to any slot. memory layout of allocations is not disrupted. The best-fit of-two slot of a particular allocation can overlap with other ons, as we don't require padding to fill the slot. Even in this e data for the separate allocations remains cryptographically due to the allocations each being assigned unique CAs to he data encryption is bound. Using a pointer to an allocation Examples of how OOB and UAF vulnerabilities are mitigated by the object-granular cryptographic isolation in C 3 are shown in Figure 4. Example (a) shows a pointer overflowing Allocation 1 into Allocation 2. Example (b) shows a pointer skipping from Allocation 1 all the way into Allocation 3. Allocation 3 has the same radix (64) as Allocation 1, but it has a different value for its least-significant radix-64 digit. Example (c) shows a stale pointer to Allocation 1 after it has been freed being used when the same underlying linear memory has been reused for Allocation 4. Note that Allocation 4 crosses a radix-64 boundary, so it requires a radix-128 slot. Since that is a different radix than was used for Allocation 1, they are cryptographically isolated even though the linear memory for Allocation 1 is reused in Allocation 4. In all of these cases, data will be garbled. Example (b) may generate an exception even before the data can be accessed, as will be explained below.\n\nFurthermore, data encryption is distinctly well-suited to comprehensively mitigating uninitialized use throughout an entire allocation. C 3 breaks adversaries' control over uninitialized data values by encrypting stale data from previous allocations when read through a fresh CA with a different radix or version. This applies separately to every byte of the allocation, such that even a single remaining uninitialized byte is still mitigated by C 3 . In contrast, the overheads of per-byte initialization metadata would be prohibitive.\n\nNote that pointer authentication or encryption alone [? ? ? ] is unable to mitigate some of the types of vulnerabilities addressed by C 3 , which additionally entangles data encryption with unique, per-allocation CAs. For example, Heartbleed illustrates this benefit of C 3 , since it only performs OOB reads that disclose data without corrupting pointers [? ]. Fundamentally, the limitation of prior approaches based solely on pointer authentication or encryption is that unencrypted data in memory remains accessible.\n\nIn contrast, when a C 3 pointer is dereferenced that is corrupted, stale, or references an uninitialized allocation, the data will be garbled with high probability if the decrypted pointer even references accessible memory in the first place. We compare the types of vi- \n\n\nDESIGN\n\nThis section describes how C 3 mitigates both spatial and temporal vulnerabilities by binding stateless, object-granular data encryption in caches to CAs that are unique to each allocation.\n\n\nObject-Granular Cryptographic Isolation\n\nEach allocation is assigned a distinct Cryptographic Address (CA), which results in every allocation being uniquely encrypted. To understand how every allocation is distinguished spatially from all other simultaneously-valid allocations, it is helpful to think of each CA effectively defining a naturally-aligned power-of-two slot that contains the allocation in its entirety as depicted in Figure 2. Allocations do not need to be aligned to a power-of-two, i.e. there is no requirement for an allocation to fill its assigned slot.\n\nTo ensure that each allocation is assigned to a distinct slot, a \"best-fit\" criterion should be used to select the smallest slot that completely contains a given allocation, which will have the minimum space in the slot that is outside of the actual allocation. Consider that every allocation will then cross the midpoint of its assigned allocation slot. Only a single allocation can cross any particular slot's midpoint. If the allocation fits within some slot, but it does not cross that slot's midpoint, then it must fit more tightly in some smaller slot, and hence the best-fit algorithm would have selected that smaller slot. Therefore, for a given spatial memory layout, only a single allocation can be assigned to any slot.\n\nThe memory layout of allocations is not disrupted. The best-fit power-of-two slot of a particular allocation can overlap with other allocations, as we don't require padding to fill the slot. Even in this case, the data for the separate allocations remains cryptographically isolated due to the allocations each being assigned unique CAs to which the data encryption is bound. Using a pointer to an allocation Examples of how OOB and UAF vulnerabilities are by the object-granular cryptographic isolation in C 3 a in Figure 4. Example (a) shows a pointer overflowing A 1 into Allocation 2. Example (b) shows a pointer skip Allocation 1 all the way into Allocation 3. Allocation same radix (64) as Allocation 1, but it has a different va least-significant radix-64 digit. Example (c) shows a sta to Allocation 1 after it has been freed being used when underlying linear memory has been reused for Allocati that Allocation 4 crosses a radix-64 boundary, so it requi 128 slot. Since that is a different radix than was used for A they are cryptographically isolated even though the linea for Allocation 1 is reused in Allocation 4. In all of these will be garbled. Example (b) may generate an exception e the data can be accessed, as will be explained below.\n\nFurthermore, data encryption is distinctly well-suited hensively mitigating uninitialized use throughout an en tion. C 3 breaks adversaries' control over uninitialized dat encrypting stale data from previous allocations when rea a fresh CA with a different radix or version. This applies to every byte of the allocation, such that even a single uninitialized byte is still mitigated by C 3 . In contrast, the of per-byte initialization metadata would be prohibitive Note that pointer authentication or encryption alone unable to mitigate some of the types of vulnerabilities by C 3 , which additionally entangles data encryption wi per-allocation CAs. For example, Heartbleed illustrates t of C 3 , since it only performs OOB reads that disclose da corrupting pointers [? ]. Fundamentally, the limitatio approaches based solely on pointer authentication or en that unencrypted data in memory remains accessible.\n\nIn contrast, when a C 3 pointer is dereferenced that is stale, or references an uninitialized allocation, the data w bled with high probability if the decrypted pointer even accessible memory in the first place. We compare the t \n\n\nDESIGN\n\nThis section describes how C 3 mitigates both spatial and temporal vulnerabilities by binding stateless, object-granular data encryption in caches to CAs that are unique to each allocation.\n\n\nObject-Granular Cryptographic Isolation\n\nEach allocation is assigned a distinct Cryptographic Address (CA), which results in every allocation being uniquely encrypted. To understand how every allocation is distinguished spatially from all other simultaneously-valid allocations, it is helpful to think of each CA effectively defining a naturally-aligned power-of-two slot that contains the allocation in its entirety as depicted in Figure 2. Allocations do not need to be aligned to a power-of-two, i.e. there is no requirement for an allocation to fill its assigned slot.\n\nTo ensure that each allocation is assigned to a distinct slot, a \"best-fit\" criterion should be used to select the smallest slot that completely contains a given allocation, which will have the minimum space in the slot that is outside of the actual allocation. Consider that every allocation will then cross the midpoint of its assigned allocation slot. Only a single allocation can cross any particular slot's midpoint. If the allocation fits within some slot, but it does not cross that slot's midpoint, then it must fit more tightly in some smaller slot, and hence the best-fit algorithm would have selected that smaller slot. Therefore, for a given spatial memory layout, only a single allocation can be assigned to any slot.\n\nThe memory layout of allocations is not disrupted. The best-fit power-of-two slot of a particular allocation can overlap with other allocations, as we don't require padding to fill the slot. Even in this case, the data for the separate allocations remains cryptographically isolated due to the allocations each being assigned unique CAs to which the data encryption is bound. Using a pointer to an allocation in some slot to read or overwrite a different allocation within the bounds of the same slot results in the data for the second allocation being garbled. This preserves the confidentiality of that data and makes data corruption unpredictable to adversaries. Figure 3 shows how the flow of processing for C 3 mitigates covered memory safety violations. Examples of how OOB and UAF vulnerabilities are mitigated by the object-granular cryptographic isolation in C 3 are shown in Figure 4. Example (a) shows a pointer overflowing Allocation 1 into Allocation 2. Example (b) shows a pointer skipping from Allocation 1 all the way into Allocation 3. Allocation 3 has the same radix (64) as Allocation 1, but it has a different value for its least-significant radix-64 digit. Example (c) shows a stale pointer to Allocation 1 after it has been freed being used when the same underlying linear memory has been reused for Allocation 4. Note that Allocation 4 crosses a radix-64 boundary, so it requires a radix-128 slot. Since that is a different radix than was used for Allocation 1, they are cryptographically isolated even though the linear memory for Allocation 1 is reused in Allocation 4. In all of these cases, data will be garbled. Example (b) may generate an exception even before the data can be accessed, as will be explained below.\n\nFurthermore, data encryption is distinctly well-suited to comprehensively mitigating uninitialized use throughout an entire allocation. C 3 breaks adversaries' control over uninitialized data values by encrypting stale data from previous allocations when read through a fresh CA with a different radix or version. This applies separately to every byte of the allocation, such that even a single remaining uninitialized byte is still mitigated by C 3 . In contrast, the overheads of per-byte initialization metadata would be prohibitive.\n\nNote that pointer authentication or encryption alone [? ? ? ] is unable to mitigate some of the types of vulnerabilities addressed by C 3 , which additionally entangles data encryption with unique, per-allocation CAs. For example, Heartbleed illustrates this benefit of C 3 , since it only performs OOB reads that disclose data without corrupting pointers [? ]. Fundamentally, the limitation of prior approaches based solely on pointer authentication or encryption is that unencrypted data in memory remains accessible.\n\nIn contrast, when a C 3 pointer is dereferenced that is corrupted, stale, or references an uninitialized allocation, the data will be garbled with high probability if the decrypted pointer even references accessible memory in the first place. We compare the types of violations that can be mitigated by C 3 and closely related memory safety mechanisms in Table 1. The \"Physical\" column represents threats to data confidentiality and pointer integrity from physical attacks and erroneous or compromised IP. C 3 can detect certain physical pointer corruptions and provides data confidentiality via encryption. \n\n\nDESIGN\n\nThis section describes how C 3 mitigates both spatial and temporal vulnerabilities by binding stateless, object-granular data encryption in caches to CAs that are unique to each allocation.\n\n\nObject-Granular Cryptographic Isolation\n\nEach allocation is assigned a distinct Cryptographic Address (CA), which results in every allocation being uniquely encrypted. To understand how every allocation is distinguished spatially from all other simultaneously-valid allocations, it is helpful to think of each CA effectively defining a naturally-aligned power-of-two slot that contains the allocation in its entirety as depicted in Figure 2. Allocations do not need to be aligned to a power-of-two, i.e. there is no requirement for an allocation to fill its assigned slot.\n\nTo ensure that each allocation is assigned to a distinct slot, a \"best-fit\" criterion should be used to select the smallest slot that completely contains a given allocation, which will have the minimum space in the slot that is outside of the actual allocation. Consider that every allocation will then cross the midpoint of its assigned allocation slot. Only a single allocation can cross any particular slot's midpoint. If the allocation fits within some slot, but it does not cross that slot's midpoint, then it must fit more tightly in some smaller slot, and hence the best-fit algorithm would have selected that smaller slot. Therefore, for a given spatial memory layout, only a single allocation can be assigned to any slot.\n\nThe memory layout of allocations is not disrupted. The best-fit power-of-two slot of a particular allocation can overlap with other allocations, as we don't require padding to fill the slot. Even in this case, the data for the separate allocations remains cryptographically isolated due to the allocations each being assigned unique CAs to which the data encryption is bound. Using a pointer to an allocation in some slot to read or overwrite a different allocation within the bounds of the same slot results in the data for the second allocation being garbled. This preserves the confidentiality of that data and makes data corruption unpredictable to adversaries. Figure 3 shows how the flow of processing for C 3 mitigates covered memory safety violations. Examples of how OOB and UAF vulnerabilities are mitigated by the object-granular cryptographic isolation in C 3 are shown in Figure 4. Example (a) shows a pointer overflowing Allocation 1 into Allocation 2. Example (b) shows a pointer skipping from Allocation 1 all the way into Allocation 3. Allocation 3 has the same radix (64) as Allocation 1, but it has a different value for its least-significant radix-64 digit. Example (c) shows a stale pointer to Allocation 1 after it has been freed being used when the same underlying linear memory has been reused for Allocation 4. Note that Allocation 4 crosses a radix-64 boundary, so it requires a radix-128 slot. Since that is a different radix than was used for Allocation 1, they are cryptographically isolated even though the linear memory for Allocation 1 is reused in Allocation 4. In all of these cases, data will be garbled. Example (b) may generate an exception even before the data can be accessed, as will be explained below.\n\nFurthermore, data encryption is distinctly well-suited to comprehensively mitigating uninitialized use throughout an entire allocation. C 3 breaks adversaries' control over uninitialized data values by encrypting stale data from previous allocations when read through a fresh CA with a different radix or version. This applies separately to every byte of the allocation, such that even a single remaining uninitialized byte is still mitigated by C 3 . In contrast, the overheads of per-byte initialization metadata would be prohibitive.\n\nNote that pointer authentication or encryption alone [? ? ? ] is unable to mitigate some of the types of vulnerabilities addressed by C 3 , which additionally entangles data encryption with unique, per-allocation CAs. For example, Heartbleed illustrates this benefit of C 3 , since it only performs OOB reads that disclose data without corrupting pointers [? ]. Fundamentally, the limitation of prior approaches based solely on pointer authentication or encryption is that unencrypted data in memory remains accessible.\n\nIn contrast, when a C 3 pointer is dereferenced that is corrupted, stale, or references an uninitialized allocation, the data will be garbled with high probability if the decrypted pointer even references accessible memory in the first place. We compare the types of violations that can be mitigated by C 3 and closely related memory safety mechanisms in Table 1. The \"Physical\" column represents threats to data confidentiality and pointer integrity from physical attacks and erroneous or compromised IP. C 3 can detect certain physical pointer corruptions and provides data confidentiality via encryption. \n\n\nDESIGN\n\nThis section describes how C 3 mitigates both spatial and temporal vulnerabilities by binding stateless, object-granular data encryption in caches to CAs that are unique to each allocation.\n\n\nObject-Granular Cryptographic Isolation\n\nEach allocation is assigned a distinct Cryptographic Address (CA), which results in every allocation being uniquely encrypted. To understand how every allocation is distinguished spatially from all other simultaneously-valid allocations, it is helpful to think of each CA effectively defining a naturally-aligned power-of-two slot that contains the allocation in its entirety as depicted in Figure 2. Allocations do not need to be aligned to a power-of-two, i.e. there is no requirement for an allocation to fill its assigned slot.\n\nTo ensure that each allocation is assigned to a distinct slot, a \"best-fit\" criterion should be used to select the smallest slot that completely contains a given allocation, which will have the minimum space in the slot that is outside of the actual allocation. Consider that every allocation will then cross the midpoint of its assigned allocation slot. Only a single allocation can cross any particular slot's midpoint. If the allocation fits within some slot, but it does not cross that slot's midpoint, then it must fit more tightly in some smaller slot, and hence the best-fit algorithm would have selected that smaller slot. Therefore, for a given spatial memory layout, only a single allocation can be assigned to any slot.\n\nThe memory layout of allocations is not disrupted. The best-fit power-of-two slot of a particular allocation can overlap with other allocations, as we don't require padding to fill the slot. Even in this case, the data for the separate allocations remains cryptographically isolated due to the allocations each being assigned unique CAs to which the data encryption is bound. Using a pointer to an allocation in some slot to read or overwrite a different allocation within the bounds of the same slot results in the data for the second allocation being garbled. This preserves the confidentiality of that data and makes data corruption unpredictable to adversaries. Figure 3 shows how the flow of processing for C 3 mitigates covered memory safety violations. Examples of how OOB and UAF vulnerabilities are mitig by the object-granular cryptographic isolation in C 3 are sho in Figure 4. Example (a) shows a pointer overflowing Alloca 1 into Allocation 2. Example (b) shows a pointer skipping f Allocation 1 all the way into Allocation 3. Allocation 3 has same radix (64) as Allocation 1, but it has a different value fo least-significant radix-64 digit. Example (c) shows a stale poi to Allocation 1 after it has been freed being used when the s underlying linear memory has been reused for Allocation 4. N that Allocation 4 crosses a radix-64 boundary, so it requires a ra 128 slot. Since that is a different radix than was used for Allocati they are cryptographically isolated even though the linear mem for Allocation 1 is reused in Allocation 4. In all of these cases, will be garbled. Example (b) may generate an exception even be the data can be accessed, as will be explained below.\n\nFurthermore, data encryption is distinctly well-suited to com hensively mitigating uninitialized use throughout an entire all tion. C 3 breaks adversaries' control over uninitialized data value encrypting stale data from previous allocations when read thro a fresh CA with a different radix or version. This applies separa to every byte of the allocation, such that even a single remain uninitialized byte is still mitigated by C 3 . In contrast, the overh of per-byte initialization metadata would be prohibitive.\n\nNote that pointer authentication or encryption alone [? ? ? unable to mitigate some of the types of vulnerabilities addre by C 3 , which additionally entangles data encryption with uni per-allocation CAs. For example, Heartbleed illustrates this ben of C 3 , since it only performs OOB reads that disclose data with corrupting pointers [? ]. Fundamentally, the limitation of p approaches based solely on pointer authentication or encryptio that unencrypted data in memory remains accessible.\n\nIn contrast, when a C 3 pointer is dereferenced that is corrup stale, or references an uninitialized allocation, the data will be bled with high probability if the decrypted pointer even refere accessible memory in the first place. We compare the types o olations that can be mitigated by C 3 and closely related mem safety mechanisms in Table 1. The \"Physical\" column repres threats to data confidentiality and pointer integrity from phys attacks and erroneous or compromised IP. C 3 can detect cer physical pointer corruptions and provides data confidentiality encryption. \n\n\nDESIGN\n\nThis section describes how C 3 mitigates both spatial and temporal vulnerabilities by binding stateless, object-granular data encryption in caches to CAs that are unique to each allocation.\n\n\nObject-Granular Cryptographic Isolation\n\nEach allocation is assigned a distinct Cryptographic Address (CA), which results in every allocation being uniquely encrypted. To understand how every allocation is distinguished spatially from all other simultaneously-valid allocations, it is helpful to think of each CA effectively defining a naturally-aligned power-of-two slot that contains the allocation in its entirety as depicted in Figure 2. Allocations do not need to be aligned to a power-of-two, i.e. there is no requirement for an allocation to fill its assigned slot.\n\nTo ensure that each allocation is assigned to a distinct slot, a \"best-fit\" criterion should be used to select the smallest slot that completely contains a given allocation, which will have the minimum space in the slot that is outside of the actual allocation. Consider that every allocation will then cross the midpoint of its assigned allocation slot. Only a single allocation can cross any particular slot's midpoint. If the allocation fits within some slot, but it does not cross that slot's midpoint, then it must fit more tightly in some smaller slot, and hence the best-fit algorithm would have selected that smaller slot. Therefore, for a given spatial memory layout, only a single allocation can be assigned to any slot.\n\nThe memory layout of allocations is not disrupted. The best-fit power-of-two slot of a particular allocation can overlap with other allocations, as we don't require padding to fill the slot. Even in this case, the data for the separate allocations remains cryptographically isolated due to the allocations each being assigned unique CAs to which the data encryption is bound. Using a pointer to an allocation in some slot to read or overwrite a different allocation within the bounds of the same slot results in the data for the second allocation being garbled. This preserves the confidentiality of that data and makes data corruption unpredictable to adversaries. Figure 3 shows how the flow of processing for C 3 mitigates covered memory safety violations. Examples of how OOB and UAF vulner by the object-granular cryptographic isola in Figure 4. Example (a) shows a pointer o 1 into Allocation 2. Example (b) shows a p Allocation 1 all the way into Allocation 3 same radix (64) as Allocation 1, but it has a least-significant radix-64 digit. Example (c) to Allocation 1 after it has been freed being underlying linear memory has been reused that Allocation 4 crosses a radix-64 boundary 128 slot. Since that is a different radix than wa they are cryptographically isolated even tho for Allocation 1 is reused in Allocation 4. In will be garbled. Example (b) may generate an the data can be accessed, as will be explaine Furthermore, data encryption is distinctly hensively mitigating uninitialized use throu tion. C 3 breaks adversaries' control over unin encrypting stale data from previous allocatio a fresh CA with a different radix or version. to every byte of the allocation, such that ev uninitialized byte is still mitigated by C 3 . In c of per-byte initialization metadata would be Note that pointer authentication or encr unable to mitigate some of the types of vul by C 3 , which additionally entangles data en per-allocation CAs. For example, Heartbleed of C 3 , since it only performs OOB reads tha corrupting pointers [? ]. Fundamentally, t approaches based solely on pointer authenti that unencrypted data in memory remains a In contrast, when a C 3 pointer is derefere stale, or references an uninitialized allocatio bled with high probability if the decrypted p accessible memory in the first place. We co olations that can be mitigated by C 3 and cl safety mechanisms in Table 1. The \"Physic threats to data confidentiality and pointer i attacks and erroneous or compromised IP. physical pointer corruptions and provides d encryption.\n\nExamples of how OOB and UAF vulnerabilities are mitigated by the object-granular cryptographic isolation in C 3 are shown in Figure 4. Example (a) shows a pointer overflowing Allocation 1 into Allocation 2. Example (b) shows a pointer skipping from Allocation 1 all the way into Allocation 3. Allocation 3 has the same radix (64) as Allocation 1, but it has a different value for its least-significant radix-64 digit. Example (c) shows a stale pointer to Allocation 1 after it has been freed being used when the same underlying linear memory has been reused for Allocation 4. Note that Allocation 4 crosses a radix-64 boundary, so it requires a radix-128 slot. Since that is a different radix than was used for Allocation 1, they are cryptographically isolated even though the linear memory for Allocation 1 is reused in Allocation 4. In all of these cases, data will be garbled. Example (b) may generate an exception even before the data can be accessed, as will be explained below.\n\nFurthermore, data encryption is distinctly well-suited to comprehensively mitigating uninitialized use throughout an entire allocation. C 3 breaks adversaries' control over uninitialized data values by encrypting stale data from previous allocations when read through a fresh CA with a different radix or version. This applies separately to every byte of the allocation, such that even a single remaining uninitialized byte is still mitigated by C 3 . In contrast, the overheads of per-byte initialization metadata would be prohibitive.\n\nNote that pointer authentication or encryption alone [9,33,51] is unable to mitigate some of the types of vulnerabilities addressed by C 3 , which additionally entangles data encryption with unique, per-allocation CAs. For example, Heartbleed illustrates this benefit of C 3 , since it only performs OOB reads that disclose data without corrupting pointers [17]. Fundamentally, the limitation of prior approaches based solely on pointer authentication or encryption is that unencrypted data in memory remains accessible.\n\nIn contrast, when a C 3 pointer is dereferenced that is corrupted, stale, or references an uninitialized allocation, the data will be garbled with high probability if the decrypted pointer even references accessible memory in the first place. We compare the types of violations that can be mitigated by C 3 and closely related memory safety mechanisms in Table 1. The \"Physical\" column represents threats to data confidentiality and pointer integrity from physical attacks and erroneous or compromised IP. C 3 can detect certain physical pointer corruptions and provides data confidentiality via encryption.  Figure 3: The flow of processing for C 3 includes CA decryption ( \u00a74.3) to obtain the Linear Address (LA) followed by data encryption or decryption based on a generated keystream ( \u00a74.4). In-scope memory safety violations result in garbled encryption or decryption with high probability. This enforces cryptographic isolation between different allocations both spatially and temporally, even within overlapping slots. Additionally, OOB accesses outside of the authorized slot for the pointer or other pointer corruption or forgery result in garbled linear addresses. This will secondarily generate a page fault with high probability assuming a sparse address space, hence leading to detection of the violation.  : Examples of how object-granular cryptographic isolation in C 3 mitigates attempts to corrupt a pointer for OOB accesses (a and b) or to reuse it after the linear memory for its authorized allocation has been reallocated (c). The linear memory layout is completely unchanged by C 3 . Only the radix-specific slot boundaries that are relevant to these examples are illustrated.\n\n\nAllocation 2 Slot\n\n\nType of violation\n\n\nSpatial safety violations\n\n\nTemporal safety violation\n\n\nPointer Encoding\n\nC 3 preserves the 64-bit pointer width and ordinary pointer arithmetic support, although any pointer size may be supported. Each pointer is divided into distinct fields as illustrated in Figure 5 to represent a CA in a binary encoding.\n\nThe power field specifies the offset field width, with the value of all zeroes reserved to represent unencoded userspace pointers that point to unencrypted data. Even single-byte slots can be specified, which would impose too much overhead for memory tagging approaches that need to duplicate the tag for every granule (e.g. four tag bits per one-byte data granule would impose 50% memory overhead). Power binds the pointer to an object of a particular memory slot with the corresponding power-of-two size. The object is not required to completely fill the slot, so there is no requirement for padding.\n\nThe optional version field can be assigned randomly or in sequence for a given power-of-two slot as the slot is reused to prevent the encrypted data from being bound to the same CA across distinct allocations for temporal safety. Alternatively, the allocator could seek to avoid reusing linear memory with identical radixes while still permitting the memory to be reused and assigned different radixes so that there is no wasted memory. However, that may introduce more allocator complexity. The decrypted version field is ignored by the processor.\n\nBoth the encrypted address bits and the fixed address bits are immutable. If software attempts to change any of them or to forge a pointer, that will be detected with high probability when the corrupted pointer is used in a memory access. A change to an encrypted address bit is likely to change half of the decrypted bits of the decrypted address slice due to the diffusion property of the pointer encryption cipher as will be explained below. This incorrect decryption is likely to point to an unmapped or inaccessible page, generating a page fault, or to some uncontrollable page address. Certain paging modes treat some of the address bits in the encrypted address field as reserved, which causes them to serve as an implicit authentication code by being required to have some predictable value, e.g. all zeroes. Keep in mind that C 3 preserves object-granular Version 54 57 Encrypted address 53 34 33 Fixed address Power Offset Power-1 0\n\nEncrypted [24 bits] Figure 5: CA encrypted pointer format. \"Power\" is an exponent encoding the power-of-two radix/slot size that best fits the allocation the pointer is authorized to reference. Optional \"Version\" introduces cryptographic diversity, but an alternative is to avoid reusing a given power-of-two slot by changing the power used for the same underlying linear memory (i.e. no wasted memory). \"Encrypted addr. (address)\" contains the upper address bits that are both immutable and within the encrypted portion of the pointer. \"Fixed address\" contains plaintext bits indicating which slot with the specified power best fits the allocation. \"Offset\" bits are also plaintext, and software can modify them to point to different portions of the referenced allocation.\n\ncryptographic isolation even when pointer corruption or forgery does not generate an exception.\n\nSince the pointer bits are encrypted rather than being authenticated, the values of the underlying pointer bits can be recovered by decrypting the pointer. In contrast, pointer authentication as used in some previous approaches prevents the pointer bits containing the authentication code from being used for addressing [25,33].\n\nTo detect changes to the fixed address bits, C 3 incorporates them as a tweak during pointer encryption. We describe the details of this below. Briefly, an identical tweak must be supplied during decryption as was supplied during encryption, or the decryption will be incorrect with a resulting random value with a high probability. We also incorporate the power bits in the tweak to detect unauthorized modifications of those fields.\n\nSoftware is free to modify the offset bits. Since the supported radixes are all powers of two, the least-significant address digit of the specified radix can be represented as the corresponding number of offset bits.\n\nIf there are any allocations that do not fit into a 16GiB-aligned slot, they can be left unencrypted. The source of the 16GiB limit is that the offset field covering the allocation must be kept as plaintext. Thus, 34 plaintext pointer bits can represent at most an 16GiBaligned slot. The fixed address bits field will not be present when the pointer refers to a 16GiB slot, since the entire 34 plaintext bits will be used as the offset.\n\nFurthermore, a special power field value can be designated that represents 16GiB adjusted slots that are offset by 8GiB from 16GiB alignment boundaries, i.e. are shifted by half of their width. This can accommodate allocations spanning 16GiB alignment boundaries. Although the radix for such adjusted slots would match that for maximally-sized unadjusted slots, those would still effectively reside in separate, isolated cryptographic address spaces.\n\nUnencoded pointers indicate to the processor that the access should be performed with data encryption and decryption disabled. Unencoded pointers can be detected in constant time, since the equivalent bit locations for the power field will be set to all zeroes or ones for userspace or supervisor pointers, respectively, to match K-cipher Figure 6: Flow for generating a CA given a plaintext input pointer and object context. Object context specifies the power-of-two slot fitting the object and its version to distinguish it from other allocations occupying the same slot at different times.\n\nconventional address formats. Those power field values are not used for encoded pointers. Unencrypted accesses can be restricted to particular address ranges, e.g. using page table entry bits.\n\n\nPointer Encryption\n\nC 3 encrypts pointers using a tweakable block cipher that provides diffusion and confusion and is resistant to known ciphertext attacks. It is named \"K-cipher\" [27]. No small block ciphers are currently standardized, although several are being considered for a standard.\n\nOther suitable small block ciphers with the same or different block sizes can be used in place of K-cipher. For example, 32-bit SIMON could be used if C 3 encrypted 32 pointer bits [2]. Existing stateof-the-art industry solutions like ARM\u00ae Pointer Authentication (PAuth) also use non-standard small block ciphers. Other prior arts incorporate this as well. For example, AOS uses a 16-bit Pointer Authentication Code (PAC), which is weaker than the 24-bit encrypted pointer slice in C 3 . Known ciphertext resistance makes K-cipher adequate for our threat model, since we assume that adversaries are constrained to be unable to generate or decrypt arbitrary encrypted pointers. They are only able to observe the encrypted pointers returned by the allocator in response to allocation requests. Those pointers do not reveal the underlying upper address bits, since those bits are encrypted.\n\nThe procedure for generating a CA is illustrated in Figure 6. It has the following inputs: 1) Plaintext input pointer, 2) Pointer encryption key, and 3) Object context operand specifying the following information: (a) Power indicating the exponent for the power-oftwo-aligned slot containing the allocation, and (b) Optional version field.\n\nThe pointer encoding algorithm may be implemented by a software routine or as a new instruction. Implementing it as an instruction enables the processor to protect the pointer encryption key by storing it in a register inaccessible from untrusted software (e.g. a write-only MSR) and enables hardware optimization of the pointer encoding algorithm.\n\nIf implemented as an instruction, the instruction may accept the plaintext input pointer and the object context operand as explicit instruction operands. It will also implicitly load the pointer  : Data decryption during load execution of C 3 with parallel keystream generation to avoid delays. Data encryption during stores is similar, except that the flow of data through the XOR operation is reversed. Every allocation is uniquely encrypted due to each allocation being assigned a unique CA. The 64-bit CA itself is the only access-specific security input; no additional metadata is needed.\n\nencryption key from the register that contains it. The OS would initialize the pointer encryption key register with a per-process key analogous to a per-process PAuth key. Other key management mechanisms may be employed to support various threat models.\n\nThe tweak input to the pointer encryption comprises all of the plaintext pointer components that need to be protected from being modified by the software. The fixed address bits field from the plaintext input pointer is padded to always have a width of 34 bits and to maintain the relative positions of each bit in the padded field (i.e. padding on the right). An XOR fold operation (or some other more sophisticated approach such as a lightweight permutation) for generating the tweak is needed due to the input fields being wider (40 bits) than the 24-bit block size of the pointer encryption cipher.\n\nThe pointer decode flow is the reverse of the pointer encode flow with the requirement that the same tweak value be supplied. Decoding also drops the optional version field, since it does not affect the generated linear address.\n\n\nData Encryption\n\nWe investigated cryptographic literature to identify minimal latency keystream generation techniques. An implementation analysis for Gimli reported a fully unrolled permutation with a 715.9 psec critical path, which results in a depth-4 pipeline that supports up to a 4.5Ghz clock [21]. We have implemented a similar keystream generator to minimize the cryptographic load and store latency and hence minimize overall performance overhead of the proposed C 3 technique. Other candidates from the NIST Lightweight Cryptography project [41] could similarly be used, e.g. Subterranean or Xoodyak [12,13].\n\nFor a load, the keystream generation is started as soon as the Address Generation Unit (AGU) generates the CA for the instruction. In other words, a load execution pipeline and respective keystream generation pipeline proceed in parallel. Once both pipelines finish, the encrypted data fetched from the data-cache gets XORed with the keystream and returned to the respective load port as depicted in Figure 7. This avoids delays in the critical load path. Each process is assigned a unique data encryption key analogous to a per-process PAuth key.\n\nOne extra XOR latency in 7 nm FinFET is 4.5ps [49], which should fit in the final data cycle of L1 hit that typically just has data rotation. If there is a timing issue there, the extra XOR can be absorbed in the bypass network (before data is given to the consumers by the load). We are hence confident that this will not increase L1 latency. However, in case there are designs that cannot absorb this latency, an extra cycle would be needed on the L1 hit data-path for encrypted loads. We evaluate this possibility in \u00a75.2.\n\n\nMitigation Strength\n\nThe 24-bit encrypted slice in the pointer provides a great deal more potential variation between pointers than is possible with the fourbit tag in MTE, for example, which strengthens UAF mitigation. This results in 1M times as many possible pointer encodings for the encrypted pointer slice compared to the tag value that serves the analogous role of mitigating UAF in MTE. Even within a given slot, the version field can provide cryptographic diversity. Furthermore, the allocator can make slot assignments unpredictable. The pointer encoding is unpredictable even if the slot location and version are known, since the pointer key may be assigned fresh for each process.\n\nThe strength of MTE to mitigate non-adjacent overflows drops back to the basic probability of guessing the tag for the targeted memory. In this instance as well, C 3 offers much greater strength due to its larger encrypted pointer slice.\n\nThis fundamental advantage of C 3 compared to MTE extends to other types of vulnerabilities such as pointer forgery and physical attacks.\n\n\nMicroarchitecture\n\nIn this section, we describe the microarchitecture to support the C 3 security capability in a performant manner within state-ofthe-art processor designs. C 3 enforces temporally and spatially unique encryption of pointers and therefore the memory engine receives encrypted addresses for the load/store operations. Since the load/store pipeline and the cache hierarchy addressing circuitry is unmodified in C 3 and operates on plaintext addresses, it necessitates timely pointer decryption by the memory engine. In addition to pointer encryption, C 3 also enables data encryption. Therefore, during a load operation, the encrypted data needs to be decrypted before the write-back into the registers. Similarly, plaintext data from the core needs to be encrypted before being stored in the caches. We describe how the load and store pipelines are architected to induct C 3 in modern microprocessors.\n\n\nLoad pipeline.\n\nPipeline stages. Figure 8 illustrates the common pipeline stages for a load operation found ubiquitously in modern out-of-order processors [10,23]. Firstly, the address generation unit (AGU) computes the virtual address (VA) of the load operation. Secondly, the translation-lookaside-buffer (TLB) is looked up for translating the virtual to physical address. Most processors use virtually-indexed and physical-tagged (VIPT) data caches, since it allows the L1 cache set read to be done in parallel to TLB lookup [31,34,58] Figure 8: The load pipeline of the unsecure baseline, C 3 without PredTLB, and C 3 with PredTLB.\n\nwe have the L1 cache hit/miss decision, depending on the physical address provided by the TLB (on a TLB hit). Fourthly, on a L1 cache hit, the data is read out from the selected way in the set-associative L1 cache and the data is written back to the required consumers of the load.\n\nTLB does not store cryptographic address translation. With C 3 enabled in a system, the AGU performs arithmetic on pointers in the same format used by software, i.e. as Cryptographic Addresses (CAs) for encrypted allocations and as unencoded pointers otherwise. However, the rest of the load pipeline works on plaintext addresses. The TLB does not store address translations for CA for the following reasons: (i) The TLB caches the page table entries, which are in turn populated by the OS; hence page tables are left in plaintext for legacy compatibility. (ii) A page may be shared between 2 different allocations. Since the CAs for these 2 allocations are different, we would need to allocate 2 separate TLB entries for the same translation. This would incur high TLB overhead which is difficult to accommodate since TLBs employ areaand power-hungry CAMs.\n\nPredictive TLB lookup. The load pipeline in the presence of C 3 requires decryption of the CAs before the TLB lookup. The K-cipher, which is used for pointer encryption, is also used for pointer decryption. Decryption of CA introduces a 3 cycle K-cipher latency between the AGU and the TLB lookup directly on the critical path of the load pipeline. This additional latency incurs a significant 5% performance loss over our considered evaluation configuration (refer to Section 5.2). To mitigate this performance loss, we use a Predictive TLB (PredTLB) lookup which removes the constant decryption latency from the critical path to improve performance.\n\nPredTLB is based on the insight that bits 33:0, i.e., the lower 34 bits of the CA are actually in plaintext, which can be used for partial TLB lookup. With a page size of 4KiB, bits 11:0 denote the page offset of the address. PredTLB looks up the TLB structure with bits 33:12 (i.e., 22 bits) of the CA, which are in plaintext, and performs a partial tag match. PredTLB predicts a TLB hit if any entry has a tag whose lower 22 bits match with bits 33:12 of the CA and provides the physical page number stored in that TLB entry as the corresponding translation. The L1 cache tag match uses this translation for hit/miss decisions and data lookup.\n\nSince PredTLB does not wait for pointer decryption before TLB lookup, it completely bypasses the constant 3 cycle decryption latency from the critical path. However, PredTLB predicts a TLB hit/miss based on partial tag match, and it can result in a misprediction due to aliasing between 2 different virtual page numbers (VPNs) which have the same lower 22 bits. The result of the prediction from PredTLB is known after the decryption is completed, i.e., before the data writeback. On a PredTLB misprediction, we cancel the load operation and re-dispatch it through the load pipeline. During this second try, the decrypted address is already available from the first pipeline dispatch of the load, and hence, the load proceeds through the pipeline and completes successfully. Therefore, a PredTLB misprediction incurs the latency of a useless pipepass. From our evaluations, we observe that PredTLB has a high successful prediction rate of 99.85% (refer Figure 10(b)), thereby enabling C 3 to bypass the constant decryption latency for 99.85% of the loads.\n\nNo performance overhead for data decryption. Since all the inputs for data keystream generation including the encrypted pointer are available right after the AGU, the generation is initiated after the AGU pipeline stage and happens in parallel with rest of the load pipeline. The keystream generation completes at the end of the write-back stage, when data is actually written back to the registers. The generated keystream is XORed with the encrypted data fetched from the L1 cache before the write-back. Essentially, the data decryption latency during a load operation is overlapped with the load pipeline, rendering no performance impact. 4.6.2 Store pipeline. All modern out-of-order processors split the store instruction into 2 independent sub-operations: store address (SA) and store data (SD); this split enables parallel/OoO execution of SA and SD, presenting performance improvement.\n\nWith C 3 , the SA sub-operation gets a CA from the AGU. The SA needs to perform a TLB lookup to retrieve the physical address for the VA, which is encrypted. Therefore, we have a situation similar to the load pipeline, and we employ PredTLB for SA as well in order to prevent the addition of a constant decryption latency before the TLB lookup. The data to be stored also needs encryption. Hence, the keystream generation is started as soon as the CA is available and XORed with the data in the store-buffer (if available). In case the data is not present, the keystream is kept in the space of data, and XORed with the incoming data, when available. Similar to loads, the decryption is overlapped with the SA/SD pipelines and has no performance impact. 4.6.3 Memory engine microarchitecture. In this section, we describe the overall microarchitecture of the memory engine to support C 3 . Addresses output by the AGU in CA format are decoded by the Pointer Decryption module. The CA is also used by the Data Keystream module to generate the keystream for data decryption (during loads) or encryption (during stores). The plaintext address is stored in the Load Buffer (LB) and Store Buffer (SB). The LB and SB entries are extended in C 3 to store the 24 bits of encrypted slice from the CA; these 24 bits can be concatenated with the lower 34 bits of the plaintext address to re-create the CA. This is especially necessary for timely load/store forwarding and memory disambiguation decisions. Either the load or store might not have the plaintext address available during the address comparisons.  Figure 9: Overview of the C 3 memory engine microarchitecture.\n\nHence, we can perform the address comparisons on the CAs for the corresponding load/store pair. On a load, the L1 data cache returns encrypted data stored in the cache which is XORed with the already generated data keystream for retrieving the plaintext data. The forwarded data from a store to a younger load is encrypted, which is decrypted with the same data keystream. On a store, the store address operation provides the CA, which is used to generate the keystream for encrypting the data to be stored in cache. If the keystream is generated before the data is available (due to OoO execution of SA before SD), it is stored in place of the data in SB. Each SB entry is also extended to include a Keystream Available (KeyAv) bit which denotes whether the keystream is stored in the space for data. When the data is available, if KeyAv=1, it is XORed with the available keystream to generate the encrypted data, and stored in the L1 cache.\n\n\nEVALUATION 5.1 Legacy Compatibility\n\nWe verified legacy compatibility with Simics\u00ae, which is a functional full-system simulator [36]. We used the instrumentation API of the Quick-Start Platform for x86 (QSP-x86) CPU model to functionally simulate handling of encoded addresses and encryption of data in memory.\n\nThe C 3 Simics\u00ae model intercepts load and store instructions and decrypts encrypted virtual addresses before the address translation. In addition, the model generates a keystream for the data by using the CA as input. Once the data is written to (read from) memory, it is XORed with the keystream to perform encryption (decryption). Loads and stores using an unencoded address bypass this instrumentation.\n\nOn top of the C 3 Simics\u00ae hardware model, we run an unmodified Clear Linux OS. To enable C 3 support in software, we modified the glibc v2.30 heap memory allocator to encrypt heap pointers before they are returned to the user application, while the actual memory management code is unchanged. In addition, realloc() and free() are modified to decrypt encrypted pointers provided as input. An application linked to such a library receives encrypted pointers upon dynamic memory allocation (e.g., malloc()) and can perform regular pointer arithmetic on them as if they were legacy pointers (e.g., array indexing).\n\nMoreover, we modified system calls in glibc that use pointers as input arguments, e.g. pointers to buffers for exchanging data between the application and the kernel. An analogous challenge arose in the context of MTE, and various possible approaches for handling it have been proposed [26]. Since the application may provide a CA as input to a system call and the kernel only accepts addresses in the conventional (i.e. unencoded) format via system calls, we allocate an unencrypted buffer to serve as an interface between the application and the kernel. Before a system call, data is copied (with implicit decryption) into the temporary buffer and the pointer to the buffer is passed down to the system call. After returning from the system call, the data is copied back to the application's buffer, which encrypts the data if the application references that buffer using a CA.\n\nSeveral memory and string routines, such as memcpy, strlen(), and strcmp(), needed to be adjusted to prevent benign OOB violations. Such functions are typically optimized to process strings in blocks using SIMD instructions, resulting in fetching data beyond the allocated region. We replaced these functions with an alternative implementation that avoids looking ahead beyond the allocation bounds in string buffers. Google\u00ae LLC observed a fundamentally similar challenge with MTE, which motivated them to modify various routines in the Android C library as well [8].\n\nWe used SPEC CPU2006 C and C++ workloads to verify the functionality of the model. The FORTAN-based workloads were excluded from this experiment, since they do not use the memory allocator in the C standard library. We compiled the unmodified workloads, linked them with the modified glibc shared library and executed the workloads inside the Simics\u00ae simulation.\n\nIn addition, we generated traces from the workloads running inside Simics\u00ae for an in-house, cycle-accurate simulator for performance evaluation.\n\n\nPerformance\n\nIn this section, we discuss the evaluation methodology and contrast microarchitectural simulation results for C 3 with state-of-the-art solutions like MTE and AOS. MTE has not yet been released in any processor implementations, so we are making assumptions about how metadata is stored, accessed, and cached in our model that may not correspond to future MTE releases.\n\nWe have done an optimistic evaluation of the prior work AOS, with geomean overheads lower than the 8.4% reported in the original AOS paper. Our core configuration is deeper than in the original AOS paper [25], reflecting current commercial processors. The bounds table resizing operation, which increases associativity, incurs no latency overhead. Similarly, searching each way, which may span multiple cachelines, is executed with zero latency overhead.\n\n\nEvaluation Methodology.\n\nWe simulate an x86 core using a cycle-accurate simulator that models a dynamically-scheduled OoO core clocked at 4GHz. The core parameters in our model are set to be similar to the Intel\u00ae Ice Lake processor [55]. We performed Front End 4GHz, 5-wide fetch+decode, TAGE/ITAGE branch predictors [47], 32KiB, 8-way L1 instruction cache, 5-wide rename into OoO with macro and micro fusion.\n\nExecution 384 ROB entries, 128 Load Queue entries, 72 Store Queue entries and 168 Issue Queue entries. 8 Execution units (ports) including 2 load ports, 2 store address ports, 2 store-data port, 4 ALU ports, 3 FP/AVX ports, 2 branch ports. 8 wide retire and full support for bypass. Aggressive memory disambiguation predictor. Out of order load scheduling to L1.\n\nCaches 48KiB, 12-way L1 data caches with 5 cycles latency, 512KiB 16-way L2 cache (private) with round-trip latency of 17 cycles. 8 MB, 16-way shared LLC with 47 cycles round-trip latency. Aggressive multistream prefetching into L2 and LLC. PC based stride prefetcher at L1. The TLB configuration follows Ice Lake TLB configuration [11].\n\n\nMemory\n\nTwo DDR4-2133 channels, two ranks per channel, eight banks per rank, 64 bits data-width per channel. 15-15-15-36 (tCAS-tRCD-tRP-tRAS) timing. these simulations in April 2021, reflecting the best known Ice Lake configuration. The primary core parameters are tabulated in Table 2. AOS mentions using an L1 bounds cache, i.e. basically a separate cache at L1 for metadata (L1-M). Since C 3 does not store/access any additional metadata, we first evaluate the proposals without an L1-M, and then discuss the impact of a separate L1-M on MTE and AOS. MTE imposes additional allocator overheads for updating duplicated, stateful tag metadata that this evaluation does not capture, which results in that aspect of our MTE evaluation being optimistic. We show our microarchitecture evaluations on all C/C++ workloads in the SPEC CPU2006 suite.\n\n\n5.2.2\n\nPerformance impact of C 3 . We first discuss the performance overhead of C 3 , as shown in Figure 10(a) with and without PredTLB to illustrate its effectiveness. The average (GeoMean) performance overhead of C 3 over all workloads is 4.9% without the PredTLB optimization. This is primarily because C 3 inserts a constant decryption latency in the load pipeline, delaying the writeback of critical data to the core and stalling all dependent instructions. A successful prediction from PredTLB means the partial tag match by PredTLB will give the correct hit/miss decision and translation, i.e., same as a full tag match in the baseline. Due to a high successful prediction ratio of 99.85% over all workloads, as shown in Figure 10(b), PredTLB is able to overlap this pointer decryption delay with the load pipeline for a majority of the loads. Across all workloads, we observed a negligible performance overhead of 0.01%. PredTLB enables providing the superior security guarantees of C 3 with negligible performance overhead. Figure 10(a) also illustrates the performance overheads of C 3 +PredTLB with an extra delay cycle on the L1 hit data-path for the XOR. The overheads are 0.7% with no large outlier workloads. However, we are confident that will not be needed as we explained in \u00a74.  Figure 10: (a) Simulated performance overhead of C 3 without and with PredTLB. PredTLB reduces the performance overhead of C 3 significantly. Lower (i.e. more negative) percentages indicate more overhead. We evaluated an extra cycle of L1 latency to accommodate the XOR between the data and keystream for completeness, but it is unlikely to be needed. (b) The prediction success ratio of PredTLB. A higher success ratio means lower load/store cancellation and re-dispatching, resulting in lower performance impact.\n\n\nComparison against MTE/AOS without L1-M.\n\nWe compare the performance overhead of C 3 +PredTLB against competing memory safety proposals like MTE and AOS. Both MTE and AOS store and access required metadata at a separate physical address space than the data and require an additional metadata load for any memory access to the protected address regions in memory. Whereas the additional metadata address space needs to be cached in the data caches during execution, the additional metadata loads consume critical L1 cache bandwidth. Therefore, MTE and AOS performance is dependent on the metadata hit rate and available L1 bandwidth. C 3 offers a significant contrast to MTE and AOS since it neither stores metadata in a separate physical address space, nor does it need to spawn additional loads to fetch and verify this metadata. Figure 11 illustrates the difference in performance overhead of C 3 , MTE, and AOS. Whereas C 3 shows negligible performance overhead for all workloads, MTE and AOS have an average overhead of 7% and 3.6%, respectively, which are significantly high. Furthermore, MTE and AOS have large outliers. The performance overheads from existing security solutions are clearly extremely costly. On the contrary C 3 has negligible overheads, making it an even more attractive security solution. Blue line almost merged with x-axis shows negligible C 3 w/ PredTLB overheads for all workloads Figure 11: Simulated performance overhead comparisons of C 3 with PredTLB against MTE and AOS, without a dedicated metadata cache. Lower (i.e. more negative) percentages indicate more overhead. Since AOS has lower metadata footprint than MTE, it achieves higher metadata hit rates in the data cache, rendering its performance better than MTE. This is especially evident in 470.lbm, 462.libquantum, 433.milc.\n\n\nComparison against MTE/AOS with L1-M.\n\nWe evaluate the performance overhead of MTE and AOS in the presence of a dedicated metadata cache, called L1-M cache. L1-M shifts the metadata caching out of the data caches into the L1-M, providing better metadata hit rates and additional bandwidth at the L1 level to serve metadata loads. However, these benefits are obtained by incurring the area/power overhead of an additional cache. Since C 3 does not store metadata, it does not need a costly metadata cache. Figure 12 illustrates the performance overheads of MTE and AOS with an 8KB L1-M are 6.5% and 2.9%, respectively. 456.hmmer in particular gains significantly with L1-M primarily because its baseline is bandwidth constrained, and therefore L1-M alleviates the bandwidth pressure by providing additional metadata bandwidth. Further, increasing L1-M even to 32KB improves metadata hit rates only by 1.5% with no tangible performance improvements. In conclusion, even with an L1-M, the performance overheads of MTE and AOS are significantly higher than C 3 .\n\n\nEfficacy\n\nThe NIST Juliet Test Suite for C/C++ contains 28,881 test case pairs of good and bad program behavior organized under 118 respective Common Weakness Enumerations (CWEs) [4]. These CWEs are subdivided in Common Vulnerabilities and Exposures (CVE) Variants. Each CVE variant is a unique behavior that is duplicated dozens of times with increasing levels of obfuscation towards static analysis tools. The test suite is designed to test static analysis tools; however, portions of Juliet still provide a reasonable evaluation of runtime defenses. We evaluated C 3 using tests for two relevant CWEs: CWE 122 \"Heap Based Buffer Overflow\" and CWE 416 \"Use After Free\". The object-granular cryptographic isolation provided by C 3 mitigates all of the relevant sample vulnerabilities in Juliet for these two CWEs. We will now describe our evaluation methodology and show detailed results.\n\n\nHeap Buffer Overflow Evaluation Methodology.\n\nWe separately report two possible types of overrun protection, either of which is an effective mitigation for each sample vulnerability: 1) exceptions generated due to detection of corrupted addresses, and 2) silent prevention of plaintext access via data encryption. The first type of protection is apparent when running the test, and we determined when the second type of protection is applicable via source code review of each CVE variant. Note that the second type of protection is adequate for effectively mitigating a vulnerability even if C 3 does not generate an exception. The cryptographic isolation between allocations still protects the data. A CVE variant is listed as detected (i.e. via an exception being generated) if and only if all of the workloads within it are detected. The results are shown in Figure 13a.\n\nAs Juliet was designed for static analysis, not every test case is applicable for testing a runtime defense. Some only generate memory unsafe behavior during an unpredictable subset of runs, and others never actually generate memory unsafe behavior on the heap at runtime. Intra-object overflows are out-of-scope for many memory safety mechanisms, including C 3 , since the entire struct is allocated using one malloc(). These overflows only account for 1% of actual observed vulnerabilities reported in a recent analysis and are hard to exploit [24]. We filtered out such inapplicable test cases.\n\n6.9% of the buffer overrun workloads already crash due to memory corruption even without C 3 . Adding C 3 raised this crash/detection rate to 87.2%. Source code review concluded that 100% of in-scope variants are protected with the added consideration of data encryption.\n\n\nHeap UAF Evaluation\n\nMethodology. The crucial property for mitigating UAF is actually to prevent access to a region of memory via a dangling pointer after the region has been reallocated [3]. However, all UAF tests in Juliet follow the pattern malloc() \u2192 write some data \u2192 free() \u2192 print the data \u2192 exit(), which only accesses a dangling pointer without ever reallocating the memory. We focused our analysis on what would happen if Juliet were to exhibit behavior more like realistic exploits by reallocating memory and then accessing a dangling pointer. Source code review determined that C 3 would mitigate this in all cases by allocating data with varying slots or versions. The results are shown in Figure 13b.  \n\n\nRELATED WORK\n\nThis paper has mostly focused on comparing C 3 to past memory tagging approaches and AOS. Tagging associates a tag with each granule of memory, e.g. each 16-byte-aligned region [44,46]. This tag duplication leads to high memory and performance overheads. AOS uses an authentication code of heap allocation base addresses as a hash key into a table of bounds, and that metadata access also leads to performance overheads [25]. The overheads for these approaches were analyzed in detail in earlier sections. C 3 completely avoids overheads due to metadata tables and introduces negligible cryptographic overheads instead.\n\nWe will now compare C 3 to other memory safety mechanisms besides MTE and AOS. Unless otherwise noted, this related work covers stack, heap, and globals, whereas per-allocation stack and global protection using C 3 is future work.\n\nPointer Authentication, Encryption, and Tagging. Some prior mechanisms authenticate pointers (e.g. PARTS [33]) or encrypt pointers (e.g. PointGuard [9,51]) without relying on separate bounds metadata, but they only mitigate indirect effects of a limited subset of memory safety violations that happen to corrupt pointers used later as discussed in \u00a74.1 with reference to Table 1. C 3 entangles data encryption with unique, per-allocation CAs to directly protect data confidentiality.\n\nPARTS imposes 19.5% performance overhead and no memory overhead [33]. PointGuard pointer encryption imposes \u223c2% performance overhead in hardware and no memory overhead [51]. Pointer Tagging relies on tag bits rather than pointer authentication to detect pointer corruption [6].\n\nPTAuth precedes each allocation with an ID incorporated as context when authenticating data pointers to enforce temporal safety with performance overhead of 26.5% (generating PACs in software) and memory overhead of 2% [18]. To support pointer offsets when checking accesses, it searches backwards for some distance until it finds a candidate ID that results in successful pointer authentication. This introduces non-constant overhead, whereas C 3 introduces no new metadata in memory.\n\nAddress Sanitizer. Address Sanitizer (ASan) associates a bit with each byte of memory indicating whether it is currently valid [45]. ASan inserts redzones marked as invalid to enforce spatial safety. To enforce temporal safety, ASan quarantines memory from freed allocations. However, ASan exhibits high memory (3.4X total) and performance (73% average) overheads with poor locality, and the lack of a tag value weakens its strength against non-adjacent overflows and pointer forgery. C 3 offers stronger protection than ASan by virtue of its large, encrypted pointer slice unforgeable within cryptographic limits to which data encryption is bound, and it avoids introducing costly metadata.\n\nMetadata Tables Indexed by Storage Location of Pointer. Intel\u00ae MPX stores a 256-bit bounds table entry for every pointer, even when many pointers reference the same allocation. A previous analysis showed that this resulted in substantial performance overheads and an average 1.9-2.1X memory overhead [42]. Associating a separate bounds table entry with each pointer prevents direct temporal memory safety enforcement, since it is not feasible to directly identify all pointers that reference an allocation being freed. Subsequent work has shown that temporal safety can be enforced indirectly by unmapping some portions of the bounds table [57], but with overheads of 60% for performance and 36% for memory. BOGO does not enforce temporal safety on the stack. HardBound is another approach that uses a table of bounds to enforce spatial safety, although it also uses a compressed representation when possible, even inlining the bounds in some pointers [14]. C 3 avoids the memory and performance overheads due to storing metadata in memory and it directly enforces temporal safety.\n\nSoftBound+CETS is a combined approach for enforcing spatial and temporal safety in software with a performance overhead of 116% [39]. It uses a bounds table analogously to MPX with an additional level of indirection through the bounds table entries to a slot containing a value that is shared across all copies of pointers to a particular allocation. Watchdog used the same fundamental approach for storing and checking metadata, but it extended hardware to reduce the performance overhead to 24% [38]. The indirection in these approaches further increases overhead, whereas C 3 enforces both spatial and temporal safety without relying on metadata stored in memory.\n\nMetadata Tables with Index Embedded in Pointer. CUP places a bounds table index in upper pointer bits, which avoids duplicating bounds table entries and supports direct temporal safety enforcement with a performance overhead of 1.58X [5]. The use of a separate table has poor cache locality, especially in comparison to C 3 that does not rely on metadata in memory.\n\nCapabilities with Metadata Embedded in Pointer. Capabilities allow software to prove its authorization by providing an unforgeable token to that effect [32]. The ability to cover an entire allocation using a single capability rather than requiring a copy of the tag for each granule of memory makes it more feasible to encode expressive security policies into capabilities, e.g. deterministically checked bounds that are byte-granular for many allocations, permissions, type specifiers, etc.\n\nNumerous capability machine architectures have been implemented over several decades [32], and CHERI is one recent example with 128-bit pointers [54]. For pointer-intensive software, even doubling the pointer size can impose substantial memory and performance overheads, and it is incompatible with legacy binary code. Furthermore, indicating for each word of memory and register whether it contains a capability or ordinary data (i.e. using a tag bit) imposes additional overhead in memory and elsewhere in the design as well as extra software enabling burden.\n\nIt is difficult to revoke tagged capabilities to freed allocations, since the capabilities may be scattered widely. For example, this may involve quarantining freed heap allocations until they can be swept up, e.g. as in CHERIvoke and Cornucopia [20,56]. Those impose added overheads on performance (additional 4.7% and 5.8%, respectively) and heap memory usage (e.g. additional 33%), which C 3 avoids.\n\nApproaches that do not expand the pointers trade off expressiveness and flexibility, e.g. by requiring even moderately-sized allocations to be aligned to coarse-grained boundaries and limiting address space size [29].\n\nCHEx86 hybridizes capabilities and bounds tables, and it maintains the bounds tables for heap allocations beneath the ISA layer to obviate the need for recompilation [48]. This introduces substantial processor complexity, as well as the overheads from separate bounds tables that C 3 avoids by not relying on metadata in memory. CHEx86 imposes 14% performance overhead and 38% memory overhead.\n\nTripwires. Tripwire mitigations place special markers within memory regions that should never be accessed.\n\nREST inserts a relatively large tripwire at the L2 level and deeper in aligned memory regions and tags corresponding regions at the L1 level [50]. There is a tension between memory overheads from large tripwires and an increased probability of a legitimate data value colliding with a small tripwire.\n\nCaliforms uses an inline header specifying such \"dead\" memory regions with byte-granularity, but it requires even more tag bits at the L1 level and even a per-cacheline tag bit at L2 and deeper levels as well as recompilation [43]. The primary limitation of tripwire approaches is that exploits may bypass tripwires. Recall that non-adjacent overflows have become more common than adjacent overflows [37]. C 3 cryptographically isolates allocations to mitigate both adjacent and non-adjacent overflows.\n\nMemTracker associates metadata with each word of memory, as does MTE, but MemTracker is not a memory tagging mechanism [53]. MemTracker stores metadata in a linearly-mapped table. A variety of state machines can be programmed, e.g. to enforce heap spatial safety by marking chunk headers delimiting heap allocations as tripwires. This imposes an average performance overhead of 1.4% for SPEC CPU2000 with one bit of memory overhead per eight-byte word of data, 1.6%. C 3 provides stronger protections than MemTracker by mitigating non-adjacent buffer overflows and UAF.\n\n\nTemporal Safety Mechanisms Inspired by Garbage Collection.\n\nMarkUs sweeps memory to identify dangling heap pointers, and it prevents freeing memory referenced by dangling pointers [1]. It imposes 10% performance overhead and 16% memory overhead. pSweeper sweeps memory concurrently, with performance overheads of 12.5% and memory overheads of 112.5% when sweeping is performed continuously on spare cores [35]. False negatives can occur in either approach when dangling pointers are hidden, whereas C 3 would still mitigate UAF in such scenarios.\n\nOther Memory Safety Mechanisms. The CheckedPtr3 approach for Chromium places metadata just prior to each allocation and encodes the distance from metadata into the pointer [22]. However, the distance field can overflow rendering memory safety checks impossible. The field also needs to be separately updated each time the pointer is updated, whereas the upper encoded portions of C 3 pointers remain constant.\n\nDuck et al. showed how address bits can be overloaded to encode sizes for enforcing spatial safety, but that imposes a rigid layout in the linear address space [15,16]. C 3 directly mitigates UAF without needing to track object relationships unlike DangNull and DangSan [30,52].\n\n\nLIMITATIONS AND FUTURE WORK\n\nWe are now investigating how to implement C 3 in actual processors. Other potential areas of future work are described below, as well as limitations. C 3 can be paired with compiler enhancements to harden stack and global variables. The enhanced compiler can insert instructions to encrypt pointers to those variables.\n\nThe current lack of encryption for shared data and IO buffers limits mitigating vulnerabilities involving that memory. However, C 3 surpasses prior approaches by encrypting process private memory to help address threats from untrusted processes and accelerators.\n\nFuture work can support key sharing for those regions across contexts and with accelerators. For example, C 3 can extend to accelerators to provide a unified cryptographic addressing layer to enforce memory safety atop Shared Virtual Memory (SVM).\n\n\nCONCLUSION\n\nC 3 is the first stateless technique to enforce memory safety without requiring any additional metadata or memory layout changes. It binds data encryption to a cryptographically protected, radix-bound pointer encoding that is unique to each allocation. The use of lowlatency ciphers replaces computationally expensive and storagehungry metadata checks with efficient cryptographic computations. The encrypted pointer format mitigates pointer corruption and forgery without consuming large numbers of pointer bits, in contrast to pointer authentication approaches. C 3 strongly mitigates prevalent categories of vulnerabilities, and it can be extended to mitigate even more with a unified cryptographic approach. C 3 , by encrypting pointers and data, goes further by fundamentally extending protections against even physical adversaries and vulnerabilities in hardware by exposing only ciphertext across caches and memory. Detailed performance evaluation shows that C 3 can be implemented in modern high performance processors with negligible performance overheads.\n\n( 3 )\n3Microarchitectural optimizations for hiding the latency of pointer decryption, resulting in negligible 0.01% geomean overhead on a simulated subset of SPEC CPU2006. (4) Legacy compatibility with no requirement for recompilation or kernel changes as demonstrated by running all 19 simulated C/C++ SPEC CPU2006 workloads on a Simics\u00ae-based functional simulator. (5) Validated against relevant tests in the NIST Juliet suite, demonstrating the security efficacy of C 3 .\n\nFigure 2 :\n2Best-fit assignment of allocations to power-of-twoaligned slots. Each radix implies a distinct set of naturallyaligned power-of-two slot boundaries to be used throughout the linear address space. Every slot is encrypted uniquely to isolate all allocations, even if they overlap in the linear space. C3 does not disrupt the memory layout; allocations do not need to be padded to fill slots.\n\n\nRakshit, Deutsch, and Durham, et al.\n\nFigure 2 :\n2Best-fit assignment of allocations to power-of-twoaligned slots. Each radix implies a distinct set of naturallyaligned power-of-two slot boundaries to be used throughout the linear address space. Every slot is encrypted uniquely to isolate all allocations, even if they overlap in the linear space. C3 does not disrupt the memory layout; allocations do not need to be padded to fill slots.\n\nFigure 2 :\n2Best-fit assignment of allocations to power-of-twoaligned slots. Each radix implies a distinct set of naturallyaligned power-of-two slot boundaries to be used throughout the linear address space. Every slot is encrypted uniquely to isolate all allocations, even if they overlap in the linear space. C3 does not disrupt the memory layout; allocations do not need to be padded to fill slots.\n\nFigure 2 :\n2Best-fit assignment of allocations to power-of-twoaligned slots. Each radix implies a distinct set of naturallyaligned power-of-two slot boundaries to be used throughout the linear address space. Every slot is encrypted uniquely to isolate all allocations, even if they overlap in the linear space. C3 does not disrupt the memory layout; allocations do not need to be padded to fill slots.\n\nFigure 2 :\n2Best-fit assignment of allocations to power-of-twoaligned slots. Each radix implies a distinct set of naturallyaligned power-of-two slot boundaries to be used throughout the linear address space. Every slot is encrypted uniquely to isolate all allocations, even if they overlap in the linear space. C3 does not disrupt the memory layout; allocations do not need to be padded to fill slots.\n\nFigure 2 :\n2Best-fit assignment of allocations to power-of-twoaligned slots. Each radix implies a distinct set of naturallyaligned power-of-two slot boundaries to be used throughout the linear address space. Every slot is encrypted uniquely to isolate all allocations, even if they overlap in the linear space. C3 does not disrupt the memory layout; allocations do not need to be padded to fill slots.\n\nFigure 2 :\n2Best-fit assignment of allocations to power-of-twoaligned slots. Each radix implies a distinct set of naturallyaligned power-of-two slot boundaries to be used throughout the linear address space. Every slot is encrypted uniquely to isolate all allocations, even if they overlap in the linear space. C3 does not disrupt the memory layout; allocations do not need to be padded to fill slots.\n\nFigure 2 :\n2Best-fit assignment of allocations to power-of-twoaligned slots. Each radix implies a distinct set of naturallyaligned power-of-two slot boundaries to be used throughout the linear address space. Every slot is encrypted uniquely to isolate all allocations, even if they overlap in the linear space. C3 does not disrupt the memory layout; allocations do not need to be padded to fill slots.\n\nFigure 2 :\n2Best-fit assignment of allocations to power-of-twoaligned slots. Each radix implies a distinct set of naturallyaligned power-of-two slot boundaries to be used throughout the linear address space. Every slot is encrypted uniquely to isolate all allocations, even if they overlap in the linear space. C3 does not disrupt the memory layout; allocations do not need to be padded to fill slots.\n\nFigure 2 :\n2Best-fit assignment of allocations to power-of-twoaligned slots. Each radix implies a distinct set of naturallyaligned power-of-two slot boundaries to be used throughout the linear address space. Every slot is encrypted uniquely to isolate all allocations, even if they overlap in the linear space. C3 does not disrupt the memory layout; allocations do not need to be padded to fill slots.\n\n)\nBlocked, since more than just the leastsignificant Radix-64 address digit changed (b) Blocked, since Alloc. 2 has a different radix than Alloc. Blocked, since Alloc. 4 has a different radix than Alloc. 1 Stale pointer originally generated for Allocation 1Allocations 1, 2, and 3 freed; Allocation 4 created\n\nFigure 4\n4Figure 4: Examples of how object-granular cryptographic isolation in C 3 mitigates attempts to corrupt a pointer for OOB accesses (a and b) or to reuse it after the linear memory for its authorized allocation has been reallocated (c). The linear memory layout is completely unchanged by C 3 . Only the radix-specific slot boundaries that are relevant to these examples are illustrated.\n\nFigure 7\n7Figure 7: Data decryption during load execution of C 3 with parallel keystream generation to avoid delays. Data encryption during stores is similar, except that the flow of data through the XOR operation is reversed. Every allocation is uniquely encrypted due to each allocation being assigned a unique CA. The 64-bit CA itself is the only access-specific security input; no additional metadata is needed.\n\nFigure 12 :\n12Simulated performance overhead comparisons of MTE and AOS with a dedicated metadata cache. Even with an L1-M, MTE and AOS have significant performance overhead. Lower (i.e. more negative) percentages indicate more overhead.\n\nFigure 13 :\n13Efficacy of C 3 on NIST Juliet tests for CWEs 122 and 416.\n\nTable 1 :\n1Comparison of mitigation levels provided by Point-Guard\n\nTable 1 :\n1Comparison of mitigation levels provided by Point-Guard [? ? ], PARTS [? ], MTE [? ], AOS [? ], and C 3 . Legend: \n: Unmitigated, : Mitigated with detection iff a corrupted \npointer is used later, : Mitigated with detection, : Crypto-\ngraphic mitigation plus possible detection. \n\nMechanism OOB UAF Uninitialized use Physical \n\nPointGuard \nPARTS \nMTE \nAOS \nC 3 \n\n\n\nTable 1 :\n1Comparison of mitigation levels provided by Po \nGuard [? ? ], PARTS [? ], MTE [? ], AOS [? ], and C 3 . Leg \n: Unmitigated, : Mitigated with detection iff a corrup \npointer is used later, : Mitigated with detection, : Cry \ngraphic mitigation plus possible detection. \n\nMechanism OOB UAF Uninitialized use Physical \n\nPointGuard \nPARTS \nMTE \nAOS \nC 3 \n\n\n\nTable 1 :\n1Comparison of mitigation levels provided by Point-\nGuard [? ? ], PARTS [? ], MTE [? ], AOS [? ], and C 3 . Legend: \n: Unmitigated, : Mitigated with detection iff a corrupted \npointer is used later, : Mitigated with detection, : Crypto-\ngraphic mitigation plus possible detection. \n\nMechanism OOB UAF Uninitialized use Physical \n\nPointGuard \nPARTS \nMTE \nAOS \nC 3 \n\n\n\nTable 1 :\n1Comparison of mitigation levels provided by Point-Guard [? ? ], PARTS [? ], MTE [? ], AOS [? ], and C 3 \n. Legend: \n: Unmitigated, : Mitigated with detection iff a corrupted \npointer is used later, \n: Mitigated with detection, : Crypto-\ngraphic mitigation plus possible detection. \n\nMechanism OOB UAF Uninitialized use Physical \n\nPointGuard \nPARTS \nMTE \nAOS \nC 3 \n\n\n\nTable 1 :\n1Comparison of mitigation levels provided by Po Guard [? ? ], PARTS [? ], MTE [? ], AOS [? ], and C 3. Lege \n\n\nTable 1 :\n1Comparison of mitigation levels provided by Point-\nGuard [? ? ], PARTS [? ], MTE [? ], AOS [? ], and C 3 \n. Legend: \n: Unmitigated, : Mitigated with detection iff a corrupted \npointer is used later, \n: Mitigated with detection, : Crypto-\ngraphic mitigation plus possible detection. \n\nMechanism OOB UAF Uninitialized use Physical \n\nPointGuard \nPARTS \nMTE \nAOS \nC 3 \n\n\n\nTable 1 :\n1Comparison of mitigation levels provided Guard [? ? ], PARTS [? ], MTE [? ], AOS [? ], and C 3 : Unmitigated, : Mitigated with detection iff a c pointer is used later, : Mitigated with detection, graphic mitigation plus possible detection.Mechanism OOB UAF Uninitialized use Phys \n\nPointGuard \nPARTS \nMTE \nAOS \nC 3 \n\n\n\nTable 1 :\n1Comparison of mitigation levels provided by Point-Guard [? ? ], PARTS [? ], MTE [? ], AOS [? ], and C 3 . Legend: : Unmitigated, : Mitigated with detection iff a corrupted pointer is used later, : Mitigated with detection, : Cryptographic mitigation plus possible detection.Mechanism OOB UAF Uninitialized use Physical \n\nPointGuard \nPARTS \nMTE \nAOS \nC 3 \n\n\n\nTable 1 :\n1Comparison of mitigation levels provided by Po Guard [? ? ], PARTS [? ], MTE [? ], AOS [? ], and C 3 . Lege : Unmitigated, : Mitigated with detection iff a corrup pointer is used later, : Mitigated with detection, : Cryp graphic mitigation plus possible detection.Mechanism OOB UAF Uninitialized use Physical \n\nPointGuard \nPARTS \nMTE \nAOS \nC 3 \n\n\n\n1 ,\n1October 18-22, 2021, Athens, Greece LeMay, Rakshit, Deutsch, and Durham, et al.... \n8 (256B): \n7 (128B): \n6 (64B): \n5 (32B): \n\n#1: 32B \n\nallocation \nnd sizes*: \n\n#2: 56B \n#3: 48B \n\n#4: 32B ... \n*Memory layout completely unchanged by C 3 \n\n34 (2 34 \nB): \n\n\n\nTable 1 :\n1Comparison of mitigation levels provided by Point-Guard [? ? ], PARTS [? ], MTE [? ], AOS [? ], and C 3 . Legend: : Unmitigated, : Mitigated with detection iff a corrupted pointer is used later, : Mitigated with detection, : Cryptographic mitigation plus possible detection.Mechanism OOB UAF Uninitialized use Physical \n\nPointGuard \nPARTS \nMTE \nAOS \nC 3 \n\n\n\nTable 1 :\n1Comparison of mitigation levels provided Guard [? ? ], PARTS [? ], MTE [? ], AOS [? ], and C 3 : Unmitigated, : Mitigated with detection iff a c pointer is used later, : Mitigated with detection, graphic mitigation plus possible detection.Mechanism OOB UAF Uninitialized use Phys \n\nPointGuard \nPARTS \nMTE \nAOS \nC 3 \n\n\n\nTable 1 :\n1Comparison of mitigation levels provided by Point-\nGuard [? ? ], PARTS [? ], MTE [? ], AOS [? ], and C 3 \n. Legend: \n: Unmitigated, : Mitigated with detection iff a corrupted \npointer is used later, \n: Mitigated with detection, : Crypto-\ngraphic mitigation plus possible detection. \n\nMechanism OOB UAF Uninitialized use Physical \n\nPointGuard \nPARTS \nMTE \nAOS \nC 3 \n\n\n\nTable 1 :\n1Comparison of mitigation levels provided by P \nGuard [? ? ], PARTS [? ], MTE [? ], AOS [? ], and C 3 \n. Leg \n: Unmitigated, : Mitigated with detection iff a corru \npointer is used later, \n: Mitigated with detection, : Cr \ngraphic mitigation plus possible detection. \n\nMechanism OOB UAF Uninitialized use Physical \n\nPointGuard \nPARTS \nMTE \nAOS \nC 3 \n\n\n\nTable 1 :\n1Comparison of mitigation levels provided by Point-\nGuard [? ? ], PARTS [? ], MTE [? ], AOS [? ], and C 3 \n. Legend: \n: Unmitigated, : Mitigated with detection iff a corrupted \npointer is used later, \n: Mitigated with detection, : Crypto-\ngraphic mitigation plus possible detection. \n\nMechanism OOB UAF Uninitialized use Physical \n\nPointGuard \nPARTS \nMTE \nAOS \nC 3 \n\n\n\nTable 1 :\n1Comparison of mitigation levels provided Guard [? ? ], PARTS [? ], MTE [? ], AOS [? ], and C 3: Unmitigated, : Mitigated with detection iff a c \npointer is used later, \n: Mitigated with detection, \ngraphic mitigation plus possible detection. \n\nMechanism OOB UAF Uninitialized use Phys \n\nPointGuard \nPARTS \nMTE \nAOS \nC 3 \n\n\n\nTable 1 :\n1Comparison of mitigation levels provided by Point-\nGuard [? ? ], PARTS [? ], MTE [? ], AOS [? ], and C 3 \n. Legend: \n: Unmitigated, : Mitigated with detection iff a corrupted \npointer is used later, \n: Mitigated with detection, : Crypto-\ngraphic mitigation plus possible detection. \n\nMechanism OOB UAF Uninitialized use Physical \n\nPointGuard \nPARTS \nMTE \nAOS \nC 3 \n\n\n\nTable 1 :\n1Comparison of mitigation levels provided by P \nGuard [? ? ], PARTS [? ], MTE [? ], AOS [? ], and C 3 \n. Leg \n: Unmitigated, : Mitigated with detection iff a corru \npointer is used later, \n: Mitigated with detection, : Cr \ngraphic mitigation plus possible detection. \n\nMechanism OOB UAF Uninitialized use Physical \n\nPointGuard \nPARTS \nMTE \nAOS \nC 3 \n\n\n\nTable 1 :\n1Comparison of mitigation levels provided by Point-\nGuard [? ? ], PARTS [? ], MTE [? ], AOS [? ], and C 3 \n. Legend: \n: Unmitigated, : Mitigated with detection iff a corrupted \npointer is used later, \n: Mitigated with detection, : Crypto-\ngraphic mitigation plus possible detection. \n\nMechanism OOB UAF Uninitialized use Physical \n\nPointGuard \nPARTS \nMTE \nAOS \nC 3 \n\n\n\nTable 1 :\n1Comparison of mitigation levels provided Guard [? ? ], PARTS [? ], MTE [? ], AOS [? ], and C 3: Unmitigated, : Mitigated with detection iff a c \npointer is used later, \n: Mitigated with detection, \ngraphic mitigation plus possible detection. \n\nMechanism OOB UAF Uninitialized use Phys \n\nPointGuard \nPARTS \nMTE \nAOS \nC 3 \n\n\n\nTable 1 :\n1Comparison of mitigation levels provided by Point-Guard [? ? ], PARTS [? ], MTE [? ], AOS [? ], and C 3 . Legend: : Unmitigated, : Mitigated with detection iff a corrupted pointer is used later, : Mitigated with detection, : Cryptographic mitigation plus possible detection.Mechanism OOB UAF Uninitialized use Physical \n\nPointGuard \nPARTS \nMTE \nAOS \nC 3 \n\n\n\nTable 1 :\n1Comparison of mitigation levels provided by Point-Guard [? ? ], PARTS [? ], MTE [? ], AOS [? ], and C 3 . Legend: : Unmitigated, : Mitigated with detection iff a corrupted pointer is used later, : Mitigated with detection, : Cryptographic mitigation plus possible detection.Mechanism OOB UAF Uninitialized use Physical \n\nPointGuard \nPARTS \nMTE \nAOS \nC 3 \n\n\n\nTable 1 :\n1Comparison of mitigation levels provided by PoGuard [? ? ], PARTS [? ], MTE [? ], AOS [? ], and C 3 \n. Leg \n: Unmitigated, : Mitigated with detection iff a corrup \npointer is used later, \n: Mitigated with detection, : Cry \ngraphic mitigation plus possible detection. \n\nMechanism OOB UAF Uninitialized use Physical \n\nPointGuard \nPARTS \nMTE \nAOS \nC 3 \n\n\n\nTable 1 :\n1Comparison of mitigation level \nGuard [? ? ], PARTS [? ], MTE [? ], AOS \n: Unmitigated, : Mitigated with dete \npointer is used later, \n: Mitigated with d \ngraphic mitigation plus possible detecti \n\nMechanism OOB UAF Uninitialized \n\nPointGuard \nPARTS \nMTE \nAOS \nC 3 \n\n\n\n\nPower Version Encrypted address Fixed address OffsetUpper address \nFixed address Offset \nSign extension \n\nKey \n\nPlaintext \n\nCiphertext \nTweak \nPointer \nkey \n\nVersion \n\nPower Padded fixed address [24 bits] \n\n[24 bits] \n\n\n\n\n. Thirdly, TLB Lookup L1$ hit/miss Data Rd. + Writeback AGU TLB Lookup L1$ hit/missAGU \n\nTLB Lookup L1$ hit/miss \nAGU \n\nAddress decryption \nLatency: 3 cycles \n\nPredTLB \nCheck \nprediction \n\nWrong \nCorrect \n\nUnsecure \nBaseline \n\nC 3 w/o \nPredTLB \n\nC 3 with \nPredTLB \n\nData Rd. + WB \n\nData Rd. + Writeback \n\nData keystream generation (aligned with pipeline) \n\n\n\nTable 2 :\n2Core parameters used in our simulator.\n\n\n(a) CWE 122: Heap buffer overrun detection and protection rates. The 6 variants not detected in the final row are all cases where the overflow amount is so small that it stays within the alignment boundary of eight bytes imposed by the glibc allocator. Thus, those overflows never cross a slot boundary. This also means that no other data can be allocated in the locations accessed by the overflow, so it is not an actual security vulnerability.Protected with Varying Slot or Version(b) CWE 416: Heap UAF protection rates.Workloads \n2104 146 6.9% 1834 87.2% 2104 100.0% \nCVE Variants \n46 \n0 \n0% \n40 87.0% \n46 \n100.0% \n\nTotal \nCount \n\nCrash/Detect Count \nProtected with \nData Encryption \nwithout CC \nwith CC \n\nTotal Count \nWorkloads \n520 \n520 \n100.0% \nCVE Variants \n21 \n21 \n100.0% \n\n\nmitigates both spatial and temporal teless, object-granular data encryption ique to each allocation.\nMICRO'21, October 18-22, 2021, Athens, Greece LeMay, Rakshit, Deutsch, and Durham, et al.\nACKNOWLEDGMENTSWe appreciate the feedback from the anonymous shepherd and other reviewers, Anjo Vahldiek-Oberwagner, and Lauren Biernacki.\nMarkUs: Drop-in use-after-free prevention for low-level languages. Sam Ainsworth, Timothy M Jones, 10.1109/SP40000.2020.00058Proceedings of the 2020 IEEE Symposium on Security and Privacy. the 2020 IEEE Symposium on Security and PrivacySam Ainsworth and Timothy M. Jones. 2020. MarkUs: Drop-in use-after-free prevention for low-level languages. In Proceedings of the 2020 IEEE Symposium on Security and Privacy. 578-591. https://doi.org/10.1109/SP40000.2020.00058\n\nThe SIMON and SPECK Families of Lightweight Block Ciphers. Ray Beaulieu, Douglas Shors, Jason Smith, Stefan Treatman-Clark, Bryan Weeks, Louis Wingers, 10.1109/SP40000.2020.00058Cryptology ePrint Archive. ReportRay Beaulieu, Douglas Shors, Jason Smith, Stefan Treatman-Clark, Bryan Weeks, and Louis Wingers. 2013. The SIMON and SPECK Families of Lightweight Block Ciphers. Cryptology ePrint Archive, Report 2013/404. https://eprint.iacr.org/ 2013/404.\n\nSecurity Analysis of Memory Tagging. Joe Bialek, Ken Johnson, Matt Miller, Tony Chen, Technical ReportMicrosoftJoe Bialek, Ken Johnson, Matt Miller, and Tony Chen. 2020. Se- curity Analysis of Memory Tagging. Technical Report. Microsoft.\n\nJuliet 1.1 C/C++ and Java Test Suite. Tim Boland, Paul E Black, Computer. 45Tim Boland and Paul E. Black. 2012. Juliet 1.1 C/C++ and Java Test Suite. Computer 45, 10 (2012), 88-90.\n\nCUP: Comprehensive User-Space Protection for C/C++. Nathan Burow, Derrick Mckee, Scott A Carr, Mathias Payer, 10.1145/3196494.3196540Proceedings of the 2018 Asia Conference on Computer and Communications Security (ASIACCS '18). the 2018 Asia Conference on Computer and Communications Security (ASIACCS '18)Incheon, Republic of KoreaNathan Burow, Derrick McKee, Scott A. Carr, and Mathias Payer. 2018. CUP: Comprehensive User-Space Protection for C/C++. In Proceedings of the 2018 Asia Conference on Computer and Communications Security (ASIACCS '18). Incheon, Republic of Korea, 381-392. https://doi.org/10.1145/3196494.3196540\n\nPointer Tagging for Memory Safety. Tony Chen, David Chisnall, 10.1145/3196494.3196540Technical ReportTony Chen and David Chisnall. 2019. Pointer Tagging for Memory Safety. Tech- nical Report. Microsoft. 23 pages. https://www.microsoft.com/en-us/research/ uploads/prod/2019/07/Pointer-Tagging-for-Memory-Safety.pdf\n\nChromium Project. 2020. Memory safety -The Chromium Projects. Chromium Project. 2020. Memory safety -The Chromium Projects. https: //www.chromium.org/Home/chromium-security/memory-safety\n\nAdd arm64 string.h function implementations for use with hardware supporting MTE. Peter Collingbourne, Peter Collingbourne. 2019. Add arm64 string.h function implementations for use with hardware supporting MTE. https://android.googlesource.com/platform/ bionic/+/900d07d6a1f3e1eca8cdbb3b1db1ceeec0acc9e2\n\nPoint-GuardTM: Protecting Pointers From Buffer Overflow Vulnerabilities. Crispin Cowan, Steve Beattie, John Johansen, Perry Wagle, Proceedings of the 12th USENIX Security Symposium. the 12th USENIX Security SymposiumWashington, DC, USACrispin Cowan, Steve Beattie, John Johansen, and Perry Wagle. 2003. Point- GuardTM: Protecting Pointers From Buffer Overflow Vulnerabilities. In Proceed- ings of the 12th USENIX Security Symposium. Washington, DC, USA. https: //www.usenix.org/legacy/event/sec03/tech/full_papers/cowan/cowan_html/\n\nExamining Intel's Ice Lake Processors: Taking a Bite of the Sunny Cove Microarchitecture. Ian Cutress, AnandTech. Ian Cutress. 2019. Examining Intel's Ice Lake Processors: Taking a Bite of the Sunny Cove Microarchitecture. AnandTech (July 2019).\n\nThe Ice Lake Benchmark Preview: Inside Intel's 10nm. AnandTech. Ian Cutress, Ian Cutress. 2019. The Ice Lake Benchmark Preview: Inside Intel's 10nm. AnandTech (Aug. 2019). https://www.anandtech.com/show/14664/testing-intel- ice-lake-10nm/2\n\nXoodyak, a lightweight cryptographic scheme. Joan Daemen, Seth Hoffert, Micha\u00ebl Peeters, Gilles Van Assche, Ronny Van Keer, NIST Lightweight Cryptography Project. Joan Daemen, Seth Hoffert, Micha\u00ebl Peeters, Gilles Van Assche, and Ronny Van Keer. 2019. Xoodyak, a lightweight cryptographic scheme. In NIST Lightweight Cryptography Project. https://csrc.nist.gov/CSRC/media/Projects/ lightweight-cryptography/documents/round-2/spec-doc-rnd2/Xoodyak-spec- round2.pdf\n\nThe Subterranean 2.0 cipher suite. Joan Daemen, Pedro Maat Costa Massolino, Yann Rotella, NIST Lightweight Cryptography Project. Joan Daemen, Pedro Maat Costa Massolino, and Yann Rotella. 2019. The Subterranean 2.0 cipher suite. In NIST Lightweight Cryptography Project. https://csrc.nist.gov/CSRC/media/Projects/lightweight-cryptography/ documents/round-2/spec-doc-rnd2/subterranean-spec-round2.pdf\n\nHardbound: Architectural Support for Spatial Safety of the C Programming Language. Joe Devietti, Colin Blundell, Milo M K Martin, Steve Zdancewic, 10.1145/1346281.1346295Proceedings of the 13th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS XIII). the 13th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS XIII)New York, NY, USAJoe Devietti, Colin Blundell, Milo M. K. Martin, and Steve Zdancewic. 2008. Hardbound: Architectural Support for Spatial Safety of the C Programming Language. In Proceedings of the 13th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS XIII). New York, NY, USA, 103-114. https://doi.org/10.1145/1346281.1346295\n\nHeap Bounds Protection with Low Fat Pointers. J Gregory, Duck, H C Roland, Yap, 10.1145/2892208.2892212Proceedings of the 25th International Conference on Compiler Construction (CC '16). the 25th International Conference on Compiler Construction (CC '16)New York, NY, USAACMGregory J. Duck and Roland H. C. Yap. 2016. Heap Bounds Protection with Low Fat Pointers. In Proceedings of the 25th International Conference on Compiler Construction (CC '16). ACM, New York, NY, USA, 132-142. https://doi.org/10. 1145/2892208.2892212\n\nStack Bounds Protection with Low Fat Pointers. Gregory J Duck, H C Roland, Lorenzo Yap, Cavallaro, 10.14722/ndss.2017.23287Proceedings of the NDSS Symposium. the NDSS SymposiumGregory J. Duck, Roland H. C. Yap, and Lorenzo Cavallaro. 2017. Stack Bounds Protection with Low Fat Pointers. In Proceedings of the NDSS Symposium 2017. https://doi.org/10.14722/ndss.2017.23287\n\nThe Matter of Heartbleed. Zakir Durumeric, Frank Li, James Kasten, Johanna Amann, Jethro Beekman, Mathias Payer, Nicolas Weaver, David Adrian, Vern Paxson, Michael Bailey, J Alex Halderman, 10.14722/ndss.2017.23287Proceedings of the. theZakir Durumeric, Frank Li, James Kasten, Johanna Amann, Jethro Beekman, Mathias Payer, Nicolas Weaver, David Adrian, Vern Paxson, Michael Bailey, and J. Alex Halderman. 2014. The Matter of Heartbleed. In Proceedings of the 2014\n\nAssociation for Computing Machinery. 10.1145/2663716.2663755Internet Measurement Conference (IMC '14). New York, NY, USAInternet Measurement Conference (IMC '14). Association for Computing Machinery, New York, NY, USA, 475-488. https://doi.org/10.1145/2663716.2663755\n\nPTAuth: Temporal Memory Safety via Robust Points-to Authentication. Mansour Reza Mirzazade Farkhani, Long Ahmadi, Lu, 10.1145/2663716.2663755Proceedings of the 30th USENIX Security Symposium. the 30th USENIX Security SymposiumReza Mirzazade Farkhani, Mansour Ahmadi, and Long Lu. 2021. PTAuth: Tem- poral Memory Safety via Robust Points-to Authentication. In Proceedings of the 30th USENIX Security Symposium. https://www.usenix.org/conference/ usenixsecurity21/presentation/mirzazade\n\nMeasuring HTTPS adoption on the web. Adrienne Porter Felt, Richard Barnes, April King, Chris Palmer, Chris Bentzel, Parisa Tabriz, Proceedings of the 26th USENIX Conference on Security Symposium (SEC'17. the 26th USENIX Conference on Security Symposium (SEC'17USAAdrienne Porter Felt, Richard Barnes, April King, Chris Palmer, Chris Bentzel, and Parisa Tabriz. 2017. Measuring HTTPS adoption on the web. In Proceedings of the 26th USENIX Conference on Security Symposium (SEC'17). USA, 1323-1338.\n\n. Nathaniel Wesley Filardo, Brett F Gutstein, Jonathan Woodruff, Sam Ainsworth, Lucian Paul-Trifu, Brooks Davis, Hongyan Xia, Edward Tomasz Napierala, Alexander Richardson, John Baldwin, David Chisnall, Jessica Clarke, Khilan Gudka, Alexandre Joannou, A Theodore Markettos, Alfredo Mazzinghi, Robert M Norton, Michael Roe, Peter Sewell, Stacey Son, Timothy M Jones, W Simon, Nathaniel Wesley Filardo, Brett F. Gutstein, Jonathan Woodruff, Sam Ainsworth, Lucian Paul-Trifu, Brooks Davis, Hongyan Xia, Edward Tomasz Napierala, Alexander Richardson, John Baldwin, David Chisnall, Jessica Clarke, Khilan Gudka, Alexandre Joannou, A. Theodore Markettos, Alfredo Mazzinghi, Robert M. Norton, Michael Roe, Peter Sewell, Stacey Son, Timothy M. Jones, Simon W.\n\nCornucopia: Temporal Safety for CHERI Heaps. Peter G Moore, Robert N M Neumann, Watson, Proceedings of the 2020 IEEE Symposium on Security and Privacy. the 2020 IEEE Symposium on Security and PrivacyMoore, Peter G. Neumann, and Robert N. M. Watson. 2020. Cornucopia: Tem- poral Safety for CHERI Heaps. In Proceedings of the 2020 IEEE Symposium on Security and Privacy.\n\nGimli Encryption in 715.9 psec. Cryptology ePrint Archive. Santosh Ghosh, Michael Kounavis, Sergej Deutsch, 2020/336ReportSantosh Ghosh, Michael Kounavis, and Sergej Deutsch. 2020. Gimli Encryption in 715.9 psec. Cryptology ePrint Archive, Report 2020/336. https://eprint.iacr. org/2020/336\n\nCheckedPtr2 and CheckedPtr3. haraken. 2020. CheckedPtr2 and CheckedPtr3. https://docs.google.com/ document/d/14TsvTgswPUOQuQoI9TmkFQnuSaFD8ZLHRvzapNwl5vs\n\nComputer architecture: a quantitative approach. L John, David A Hennessy, Patterson, ElsevierJohn L Hennessy and David A Patterson. 2011. Computer architecture: a quanti- tative approach. Elsevier.\n\n. Nicolas Joly, SECURITY ANALYSIS OF CHERI ISASaif Elsherei, SECURITY ANALYSIS OF CHERI ISASaar Amar, SECURITY ANALYSIS OF CHERI ISATechnical ReportNicolas Joly, Saif ElSherei, and Saar Amar. 2020. SECURITY ANALYSIS OF CHERI ISA. Technical Report. Microsoft. https://github.com/microsoft/MSRC-Security- Research/blob/master/papers/2020/Security%20analysis%20of%20CHERI% 20ISA.pdf\n\nHardware-based Always-On Heap Memory Safety. Y Kim, J Lee, H Kim, 10.1109/MICRO50266.2020.0009553rd Annual IEEE/ACM International Symposium on Microarchitecture (MICRO '20). Los Alamitos, CA, USAY. Kim, J. Lee, and H. Kim. 2020. Hardware-based Always-On Heap Memory Safety. In 53rd Annual IEEE/ACM International Symposium on Microarchitec- ture (MICRO '20). Los Alamitos, CA, USA, 1153-1166. https://doi.org/10.1109/ MICRO50266.2020.00095\n\nLKML: Andrey Konovalov. Andrey Konovalov, PATCH v19 00/15] arm64: untag user pointers passed to the kernelAndrey Konovalov. 2019. LKML: Andrey Konovalov: [PATCH v19 00/15] arm64: untag user pointers passed to the kernel. https://lkml.org/lkml/2019/7/23/728\n\n2020. K-Cipher: A Low Latency, Bit Length Parameterizable Cipher. M Kounavis, S Deutsch, S Ghosh, D Durham, 10.1109/ISCC50000.2020.92195822020 IEEE Symposium on Computers and Communications (ISCC '20. M. Kounavis, S. Deutsch, S. Ghosh, and D. Durham. 2020. K-Cipher: A Low La- tency, Bit Length Parameterizable Cipher. In 2020 IEEE Symposium on Computers and Communications (ISCC '20). https://doi.org/10.1109/ISCC50000.2020.9219582 ISSN: 2642-7389.\n\nEncrypting the internet. Michael E Kounavis, Xiaozhu Kang, Ken Grewal, Mathew Eszenyi, Shay Gueron, David Durham, 10.1145/1851275.1851200ACM SIGCOMM Computer Communication Review. 40Michael E. Kounavis, Xiaozhu Kang, Ken Grewal, Mathew Eszenyi, Shay Gueron, and David Durham. 2010. Encrypting the internet. ACM SIGCOMM Computer Communication Review 40, 4 (Aug. 2010), 135-146. https://doi.org/10.1145/ 1851275.1851200\n\nLow-fat Pointers: Compact Encoding and Efficient Gatelevel Implementation of Fat Pointers for Spatial Safety and Capability-based Security. Albert Kwon, Udit Dhawan, Jonathan M Smith, Thomas F Knight, Jr , Andre Dehon, 10.1145/2508859.2516713Proceedings of the 2013 ACM SIGSAC Conference on Computer & Communications Security (CCS '13). the 2013 ACM SIGSAC Conference on Computer & Communications Security (CCS '13)New York, NY, USAAlbert Kwon, Udit Dhawan, Jonathan M. Smith, Thomas F. Knight, Jr., and Andre DeHon. 2013. Low-fat Pointers: Compact Encoding and Efficient Gate- level Implementation of Fat Pointers for Spatial Safety and Capability-based Security. In Proceedings of the 2013 ACM SIGSAC Conference on Computer & Communications Security (CCS '13). New York, NY, USA, 721-732. https: //doi.org/10.1145/2508859.2516713\n\nPreventing Use-after-free with Dangling Pointers Nullification. Byoungyoung Lee, Chengyu Song, Yeongjin Jang, Tielei Wang, Taesoo Kim, Long Lu, Wenke Lee, 10.1145/2508859.2516713Proceedings of the NDSS Symposium. the NDSS SymposiumByoungyoung Lee, Chengyu Song, Yeongjin Jang, Tielei Wang, Taesoo Kim, Long Lu, and Wenke Lee. 2015. Preventing Use-after-free with Dan- gling Pointers Nullification. In Proceedings of the NDSS Symposium 2015. ISOC. https://www.ndss-symposium.org/ndss2015/ndss-2015-programme/ preventing-use-after-free-dangling-pointers-nullification/\n\nAdopting TLB index-based tagging to data caches for tag energy reduction. Jongmin Lee, Soontae Kim, Proceedings of the 2012 ACM/IEEE International Symposium on Low Power Electronics and Design. the 2012 ACM/IEEE International Symposium on Low Power Electronics and DesignJongmin Lee and Soontae Kim. 2012. Adopting TLB index-based tagging to data caches for tag energy reduction. In Proceedings of the 2012 ACM/IEEE International Symposium on Low Power Electronics and Design. 231-236.\n\nCapability-based Computer Systems. Henry M Levy, Digital PressHenry M. Levy. 1984. Capability-based Computer Systems. Digital Press. https: //homes.cs.washington.edu/~levy/capabook/\n\nPAC it up: Towards Pointer Integrity using ARM Pointer Authentication. Hans Liljestrand, Thomas Nyman, Kui Wang, Carlos Chinea Perez, Jan-Erik Ekberg, N Asokan, Proceedings of the 28th USENIX Security Symposium. the 28th USENIX Security SymposiumHans Liljestrand, Thomas Nyman, Kui Wang, Carlos Chinea Perez, Jan-Erik Ekberg, and N. Asokan. 2019. PAC it up: Towards Pointer Integrity using ARM Pointer Authentication. In Proceedings of the 28th USENIX Security Symposium. 177-194. https://www.usenix.org/conference/usenixsecurity19/presentation/ liljestrand\n\nTake A Way: Exploring the Security Implications of AMD's Cache Way Predictors. Moritz Lipp, Vedad Ha\u017ei\u0107, Michael Schwarz, Arthur Perais, Cl\u00e9mentine Maurice, Daniel Gruss, Proceedings of the 15th ACM Asia Conference on Computer and Communications Security. the 15th ACM Asia Conference on Computer and Communications SecurityMoritz Lipp, Vedad Ha\u017ei\u0107, Michael Schwarz, Arthur Perais, Cl\u00e9mentine Maurice, and Daniel Gruss. 2020. Take A Way: Exploring the Security Implications of AMD's Cache Way Predictors. In Proceedings of the 15th ACM Asia Conference on Computer and Communications Security. 813-825.\n\nA Robust and Efficient Defense against Use-after-Free Exploits via Concurrent Pointer Sweeping. Daiping Liu, Mingwei Zhang, Haining Wang, 10.1145/3243734.3243826Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security (CCS '18). the 2018 ACM SIGSAC Conference on Computer and Communications Security (CCS '18)Toronto, CanadaDaiping Liu, Mingwei Zhang, and Haining Wang. 2018. A Robust and Efficient Defense against Use-after-Free Exploits via Concurrent Pointer Sweeping. In Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security (CCS '18). Toronto, Canada, 1635-1648. https://doi.org/10.1145/3243734. 3243826\n\nSimics: A full system simulation platform. Peter S Magnusson, Magnus Christensson, Jesper Eskilson, Daniel Forsgren, Gustav H\u00e5llberg, Johan H\u00f6gberg, Fredrik Larsson, Andreas Moestedt, Bengt Werner, 10.1109/2.982916Computer. 35Peter S. Magnusson, Magnus Christensson, Jesper Eskilson, Daniel Forsgren, Gustav H\u00e5llberg, Johan H\u00f6gberg, Fredrik Larsson, Andreas Moestedt, and Bengt Werner. 2002. Simics: A full system simulation platform. Computer 35, 2 (Feb. 2002), 50-58. https://doi.org/10.1109/2.982916\n\nMatt Miller, 10.1109/2.982916Trends, Challenges, and Strategic Shifts in the Software Vulnerability Mitigation Landscape. Matt Miller. 2019. Trends, Challenges, and Strategic Shifts in the Software Vulner- ability Mitigation Landscape. https://www.youtube.com/watch?v=PjbGojjnBZQ.\n\nWatchdog: hardware for safe and secure manual memory management and full memory safety. Santosh Nagarakatte, M K Milo, Steve Martin, Zdancewic, 10.1145/2366231.2337181SIGARCH Comput. Archit. News. 403Santosh Nagarakatte, Milo M. K. Martin, and Steve Zdancewic. 2012. Watchdog: hardware for safe and secure manual memory management and full memory safety. SIGARCH Comput. Archit. News 40, 3 (June 2012), 189-200. https://doi. org/10.1145/2366231.2337181\n\nCETS: Compiler Enforced Temporal Safety for C. Jianzhou Santosh Nagarakatte, Milo M K Zhao, Steve Martin, Zdancewic, 10.1145/1806651.1806657Proceedings of the 2010 International Symposium on Memory Management (ISMM '10). the 2010 International Symposium on Memory Management (ISMM '10)New York, NY, USASantosh Nagarakatte, Jianzhou Zhao, Milo M.K. Martin, and Steve Zdancewic. 2010. CETS: Compiler Enforced Temporal Safety for C. In Proceedings of the 2010 International Symposium on Memory Management (ISMM '10). New York, NY, USA, 31-40. https://doi.org/10.1145/1806651.1806657\n\nIntel Launches World's Best Processor for Thin-and-Light Laptops: 11th Gen Intel Core. Intel\u00ae Newsroom, 10.1145/1806651.1806657Intel\u00ae Newsroom. 2020. Intel Launches World's Best Processor for Thin-and- Light Laptops: 11th Gen Intel Core. https://newsroom.intel.com/news-releases/ 11th-gen-tiger-lake-evo/\n\nLightweight Cryptography. NIST Information Technology Laboratory Computer Security Resource Centern. d.NIST Information Technology Laboratory Computer Security Resource Center. [n. d.]. Lightweight Cryptography. https://csrc.nist.gov/projects/lightweight- cryptography\n\nIntel MPX Explained: A Cross-Layer Analysis of the Intel MPX Cryptographic Capability Computing MICRO'21. Oleksii Oleksenko, Dmitrii Kuvaiskii, Pramod Bhatotia, Pascal Felber, Christof Fetzer, Athens, GreeceOleksii Oleksenko, Dmitrii Kuvaiskii, Pramod Bhatotia, Pascal Felber, and Christof Fetzer. 2018. Intel MPX Explained: A Cross-Layer Analysis of the Intel MPX Cryptographic Capability Computing MICRO'21, October 18-22, 2021, Athens, Greece\n\n10.1145/3224423Proceedings of the ACM on Measurement and Analysis of Computing Systems 2, 2, Article. the ACM on Measurement and Analysis of Computing Systems 2, 2, Article28System Stack. Proceedings of the ACM on Measurement and Analysis of Computing Systems 2, 2, Article 28 (June 2018). https://doi.org/10.1145/3224423\n\nPractical Byte-Granular Memory Blacklisting using Califorms. Hiroshi Sasaki, Miguel A Arroyo, M Tarek Ibn Ziad, Koustubha Bhat, Kanad Sinha, Simha Sethumadhavan, 10.1145/3352460.3358299Proceedings of the 52nd Annual IEEE/ACM International Symposium on Microarchitecture. the 52nd Annual IEEE/ACM International Symposium on MicroarchitectureColumbus OH USAHiroshi Sasaki, Miguel A. Arroyo, M. Tarek Ibn Ziad, Koustubha Bhat, Kanad Sinha, and Simha Sethumadhavan. 2019. Practical Byte-Granular Memory Blacklisting using Califorms. In Proceedings of the 52nd Annual IEEE/ACM International Symposium on Microarchitecture. Columbus OH USA, 558-571. https://doi.org/10.1145/3352460.3358299\n\nARM Memory Tagging Extension and How It Improves C/C++ Memory Safety. USENIX ;login: 44. Kostya Serebryany, 10.1145/3352460.33582992Kostya Serebryany. 2019. ARM Memory Tagging Extension and How It Improves C/C++ Memory Safety. USENIX ;login: 44, 2 (2019), 5. https://www.usenix.org/ publications/login/summer2019/serebryany\n\nAddressSanitizer: A Fast Address Sanity Checker. Konstantin Serebryany, Derek Bruening, Alexander Potapenko, Dmitriy Vyukov, Proceedings of the 2012 USENIX Annual Technical Conference (USENIX ATC '12). the 2012 USENIX Annual Technical Conference (USENIX ATC '12)Boston, MAKonstantin Serebryany, Derek Bruening, Alexander Potapenko, and Dmitriy Vyukov. 2012. AddressSanitizer: A Fast Address Sanity Checker. In Proceedings of the 2012 USENIX Annual Technical Conference (USENIX ATC '12). Boston, MA, 309- 318. https://www.usenix.org/conference/atc12/technical-sessions/presentation/ serebryany\n\nKostya Serebryany, Evgenii Stepanov, Aleksey Shlyapnikov, Vlad Tsyrklevich, Dmitry Vyukov, Memory Tagging and how it improves C/C++ memory safety. arXiv (Feb. Kostya Serebryany, Evgenii Stepanov, Aleksey Shlyapnikov, Vlad Tsyrklevich, and Dmitry Vyukov. 2018. Memory Tagging and how it improves C/C++ memory safety. arXiv (Feb. 2018). http://arxiv.org/abs/1802.09517\n\nA new case for the TAGE branch predictor. Andr\u00e9 Seznec, Proceedings of the 44th Annual IEEE/ACM International Symposium on Microarchitecture. the 44th Annual IEEE/ACM International Symposium on MicroarchitectureAndr\u00e9 Seznec. 2011. A new case for the TAGE branch predictor. In Proceedings of the 44th Annual IEEE/ACM International Symposium on Microarchitecture. 117- 127.\n\nCHEx86: Context-Sensitive Enforcement of Memory Safety via Microcode-Enabled Capabilities. Rasool Sharifi, Ashish Venkat, 10.1109/ISCA45697.2020.00068ACM/IEEE 47th Annual International Symposium on Computer Architecture (ISCA). Valencia, SpainRasool Sharifi and Ashish Venkat. 2020. CHEx86: Context-Sensitive Enforcement of Memory Safety via Microcode-Enabled Capabilities. In ACM/IEEE 47th Annual International Symposium on Computer Architecture (ISCA). Valencia, Spain, 762- 775. https://doi.org/10.1109/ISCA45697.2020.00068\n\nIntroducing 7-nm FinFET technology in Microwind. Etienne Sicard, 10.1109/ISCA45697.2020.00068Etienne Sicard. 2017. Introducing 7-nm FinFET technology in Microwind. https: //hal.archives-ouvertes.fr/hal-01558775\n\nPractical Memory Safety with REST. K Sinha, S Sethumadhavan, 10.1109/ISCA.2018.00056ACM/IEEE 45th Annual International Symposium on Computer Architecture (ISCA). K. Sinha and S. Sethumadhavan. 2018. Practical Memory Safety with REST. In ACM/IEEE 45th Annual International Symposium on Computer Architecture (ISCA). 600-611. https://doi.org/10.1109/ISCA.2018.00056\n\nHardware and Binary Modification Support for Code Pointer Protection From Buffer Overflow. Nathan Tuck, Brad Calder, George Varghese, 10.1109/MICRO.2004.2037th International Symposium on Microarchitecture. MICRO-37Nathan Tuck, Brad Calder, and George Varghese. 2004. Hardware and Binary Modification Support for Code Pointer Protection From Buffer Overflow. In 37th International Symposium on Microarchitecture (MICRO-37). 209-220. https: //doi.org/10.1109/MICRO.2004.20 ISSN: 1072-4451.\n\nDangSan: Scalable Use-after-free Detection. Erik Van Der Kouwe, Vinod Nigade, Cristiano Giuffrida, 10.1145/3064176.3064211Proceedings of the Twelfth European Conference on Computer Systems (EuroSys '17). the Twelfth European Conference on Computer Systems (EuroSys '17)Belgrade, SerbiaErik van der Kouwe, Vinod Nigade, and Cristiano Giuffrida. 2017. DangSan: Scalable Use-after-free Detection. In Proceedings of the Twelfth European Con- ference on Computer Systems (EuroSys '17). Belgrade, Serbia, 405-419. https: //doi.org/10.1145/3064176.3064211\n\nMemTracker: Efficient and Programmable Support for Memory Access Monitoring and Debugging. G Venkataramani, B Roemer, Y Solihin, M Prvulovic, 10.1109/HPCA.2007.346205IEEE 13th International Symposium on High Performance Computer Architecture (HPCA). G. Venkataramani, B. Roemer, Y. Solihin, and M. Prvulovic. 2007. MemTracker: Efficient and Programmable Support for Memory Access Monitoring and De- bugging. In IEEE 13th International Symposium on High Performance Computer Architecture (HPCA). http://dx.doi.org/10.1109/HPCA.2007.346205\n\nCheri: A hybrid capability-system architecture for scalable software compartmentalization. N M Robert, Jonathan Watson, Peter G Woodruff, Simon W Neumann, Jonathan Moore, David Anderson, Nirav Chisnall, Brooks Dave, Khilan Davis, Gudka, 10.1109/HPCA.2007.346205IEEE Symposium on Security and Privacy. Ben LaurieRobert NM Watson, Jonathan Woodruff, Peter G. Neumann, Simon W. Moore, Jonathan Anderson, David Chisnall, Nirav Dave, Brooks Davis, Khilan Gudka, Ben Laurie, and others. 2015. Cheri: A hybrid capability-system architecture for scalable software compartmentalization. In IEEE Symposium on Security and Privacy. https://www.ieee-security.org/TC/SP2015/papers/6949a020.pdf\n\nIce Lake (client) -Microarchitectures -Intel. Wikichip, n. d.WikiChip [n. d.]. Ice Lake (client) -Microarchitectures -Intel. WikiChip. https: //en.wikichip.org/wiki/intel/microarchitectures/sunny_cove\n\nCHERIvoke: Characterising Pointer Revocation using CHERI Capabilities for Temporal Memory Safety. Hongyan Xia, Jonathan Woodruff, Sam Ainsworth, Nathaniel W Filardo, Michael Roe, Alexander Richardson, Peter Rugg, Peter G Neumann, Simon W Moore, N M Robert, Timothy M Watson, Jones, 10.1145/3352460.3358288Proceedings of the 52nd Annual IEEE/ACM International Symposium on Microarchitecture. the 52nd Annual IEEE/ACM International Symposium on MicroarchitectureColumbus OH USAHongyan Xia, Jonathan Woodruff, Sam Ainsworth, Nathaniel W. Filardo, Michael Roe, Alexander Richardson, Peter Rugg, Peter G. Neumann, Simon W. Moore, Robert N. M. Watson, and Timothy M. Jones. 2019. CHERIvoke: Characterising Pointer Revocation using CHERI Capabilities for Temporal Memory Safety. In Proceedings of the 52nd Annual IEEE/ACM International Symposium on Microarchi- tecture. Columbus OH USA, 545-557. https://doi.org/10.1145/3352460.3358288\n\nBOGO: Buy Spatial Memory Safety, Get Temporal Memory Safety (Almost) Free. Tong Zhang, Dongyoon Lee, Changhee Jung, 10.1145/3297858.3304017Proceedings of the Twenty-Fourth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS '19). the Twenty-Fourth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS '19)Providence, RI, USATong Zhang, Dongyoon Lee, and Changhee Jung. 2019. BOGO: Buy Spatial Memory Safety, Get Temporal Memory Safety (Almost) Free. In Proceedings of the Twenty-Fourth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS '19). Providence, RI, USA, 631-644. https://doi.org/10.1145/3297858.3304017\n\nSIPT: Speculatively indexed, physically tagged caches. Tianhao Zheng, Haishan Zhu, Mattan Erez, 10.1145/3297858.33040172018 IEEE International Symposium on High Performance Computer Architecture (HPCA). IEEETianhao Zheng, Haishan Zhu, and Mattan Erez. 2018. SIPT: Speculatively in- dexed, physically tagged caches. In 2018 IEEE International Symposium on High Performance Computer Architecture (HPCA). IEEE, 118-130.\n", "annotations": {"author": "[{\"end\":135,\"start\":121},{\"end\":152,\"start\":136},{\"end\":168,\"start\":153},{\"end\":184,\"start\":169},{\"end\":199,\"start\":185},{\"end\":211,\"start\":200},{\"end\":224,\"start\":212},{\"end\":239,\"start\":225},{\"end\":256,\"start\":240},{\"end\":278,\"start\":257},{\"end\":293,\"start\":279},{\"end\":310,\"start\":294},{\"end\":326,\"start\":311},{\"end\":342,\"start\":327},{\"end\":357,\"start\":343},{\"end\":369,\"start\":358},{\"end\":382,\"start\":370},{\"end\":397,\"start\":383},{\"end\":413,\"start\":398},{\"end\":430,\"start\":414},{\"end\":452,\"start\":431},{\"end\":469,\"start\":453},{\"end\":488,\"start\":470},{\"end\":505,\"start\":489},{\"end\":522,\"start\":506},{\"end\":539,\"start\":523},{\"end\":558,\"start\":540},{\"end\":577,\"start\":559},{\"end\":594,\"start\":578},{\"end\":611,\"start\":595},{\"end\":630,\"start\":612}]", "publisher": "[{\"end\":50,\"start\":37},{\"end\":791,\"start\":778}]", "author_last_name": "[{\"end\":134,\"start\":129},{\"end\":151,\"start\":144},{\"end\":167,\"start\":160},{\"end\":183,\"start\":177},{\"end\":198,\"start\":193},{\"end\":210,\"start\":206},{\"end\":223,\"start\":219},{\"end\":238,\"start\":232},{\"end\":255,\"start\":249},{\"end\":277,\"start\":267},{\"end\":292,\"start\":287},{\"end\":309,\"start\":302},{\"end\":325,\"start\":318},{\"end\":341,\"start\":335},{\"end\":356,\"start\":351},{\"end\":368,\"start\":364},{\"end\":381,\"start\":377},{\"end\":396,\"start\":390},{\"end\":412,\"start\":405},{\"end\":429,\"start\":423},{\"end\":451,\"start\":441}]", "author_first_name": "[{\"end\":128,\"start\":121},{\"end\":143,\"start\":136},{\"end\":159,\"start\":153},{\"end\":174,\"start\":169},{\"end\":176,\"start\":175},{\"end\":192,\"start\":185},{\"end\":205,\"start\":200},{\"end\":218,\"start\":212},{\"end\":231,\"start\":225},{\"end\":248,\"start\":240},{\"end\":266,\"start\":257},{\"end\":286,\"start\":279},{\"end\":301,\"start\":294},{\"end\":317,\"start\":311},{\"end\":332,\"start\":327},{\"end\":334,\"start\":333},{\"end\":350,\"start\":343},{\"end\":363,\"start\":358},{\"end\":376,\"start\":370},{\"end\":389,\"start\":383},{\"end\":404,\"start\":398},{\"end\":422,\"start\":414},{\"end\":440,\"start\":431}]", "author_affiliation": "[{\"end\":468,\"start\":454},{\"end\":487,\"start\":471},{\"end\":504,\"start\":490},{\"end\":521,\"start\":507},{\"end\":538,\"start\":524},{\"end\":557,\"start\":541},{\"end\":576,\"start\":560},{\"end\":593,\"start\":579},{\"end\":610,\"start\":596},{\"end\":629,\"start\":613}]", "title": "[{\"end\":36,\"start\":1},{\"end\":666,\"start\":631}]", "venue": "[{\"end\":755,\"start\":668}]", "abstract": "[{\"end\":2860,\"start\":1343}]", "bib_ref": "[{\"attributes\":{\"ref_id\":\"b38\"},\"end\":2994,\"start\":2990},{\"attributes\":{\"ref_id\":\"b39\"},\"end\":3818,\"start\":3814},{\"attributes\":{\"ref_id\":\"b56\"},\"end\":3821,\"start\":3818},{\"attributes\":{\"ref_id\":\"b46\"},\"end\":4038,\"start\":4034},{\"attributes\":{\"ref_id\":\"b48\"},\"end\":4041,\"start\":4038},{\"attributes\":{\"ref_id\":\"b43\"},\"end\":4223,\"start\":4219},{\"attributes\":{\"ref_id\":\"b59\"},\"end\":4226,\"start\":4223},{\"attributes\":{\"ref_id\":\"b8\"},\"end\":4400,\"start\":4397},{\"attributes\":{\"ref_id\":\"b34\"},\"end\":4403,\"start\":4400},{\"attributes\":{\"ref_id\":\"b16\"},\"end\":4488,\"start\":4484},{\"attributes\":{\"ref_id\":\"b26\"},\"end\":4749,\"start\":4745},{\"attributes\":{\"ref_id\":\"b6\"},\"end\":9021,\"start\":9018},{\"attributes\":{\"ref_id\":\"b38\"},\"end\":9024,\"start\":9021},{\"attributes\":{\"ref_id\":\"b38\"},\"end\":10181,\"start\":10177},{\"attributes\":{\"ref_id\":\"b38\"},\"end\":11061,\"start\":11057},{\"attributes\":{\"ref_id\":\"b19\"},\"end\":11960,\"start\":11956},{\"attributes\":{\"ref_id\":\"b29\"},\"end\":11963,\"start\":11960},{\"attributes\":{\"ref_id\":\"b41\"},\"end\":12292,\"start\":12288},{\"attributes\":{\"ref_id\":\"b8\"},\"end\":12695,\"start\":12692},{\"attributes\":{\"ref_id\":\"b53\"},\"end\":12698,\"start\":12695},{\"attributes\":{\"ref_id\":\"b34\"},\"end\":12791,\"start\":12787},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":14627,\"start\":14624},{\"attributes\":{\"ref_id\":\"b8\"},\"end\":18474,\"start\":18471},{\"attributes\":{\"ref_id\":\"b53\"},\"end\":18477,\"start\":18474},{\"attributes\":{\"ref_id\":\"b34\"},\"end\":18489,\"start\":18485},{\"attributes\":{\"ref_id\":\"b46\"},\"end\":18499,\"start\":18495},{\"attributes\":{\"ref_id\":\"b26\"},\"end\":18509,\"start\":18505},{\"end\":21869,\"start\":21865},{\"end\":27097,\"start\":27093},{\"end\":32111,\"start\":32107},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":33003,\"start\":33002},{\"end\":36950,\"start\":36946},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":38005,\"start\":38004},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":38122,\"start\":38121},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":40115,\"start\":40114},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":41438,\"start\":41437},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":41664,\"start\":41663},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":41800,\"start\":41799},{\"end\":41887,\"start\":41883},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":42354,\"start\":42353},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":42486,\"start\":42485},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":44609,\"start\":44608},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":45879,\"start\":45878},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":46094,\"start\":46093},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":46223,\"start\":46222},{\"end\":46307,\"start\":46303},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":46757,\"start\":46756},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":47221,\"start\":47220},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":49132,\"start\":49131},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":50455,\"start\":50454},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":50681,\"start\":50680},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":50817,\"start\":50816},{\"end\":50904,\"start\":50900},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":51371,\"start\":51370},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":51503,\"start\":51502},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":54753,\"start\":54752},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":54945,\"start\":54944},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":55060,\"start\":55059},{\"end\":55137,\"start\":55133},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":55543,\"start\":55542},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":55900,\"start\":55899},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":56017,\"start\":56016},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":57944,\"start\":57943},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":59267,\"start\":59266},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":59493,\"start\":59492},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":59629,\"start\":59628},{\"end\":59716,\"start\":59712},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":60183,\"start\":60182},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":60252,\"start\":60251},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":62305,\"start\":62304},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":63575,\"start\":63574},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":63790,\"start\":63789},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":63919,\"start\":63918},{\"end\":64003,\"start\":63999},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":64453,\"start\":64452},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":64856,\"start\":64855},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":66704,\"start\":66703},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":68027,\"start\":68026},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":68253,\"start\":68252},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":68389,\"start\":68388},{\"end\":68476,\"start\":68472},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":68943,\"start\":68942},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":69012,\"start\":69011},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":72192,\"start\":72191},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":72384,\"start\":72383},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":72499,\"start\":72498},{\"end\":72576,\"start\":72572},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":72982,\"start\":72981},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":73265,\"start\":73264},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":73373,\"start\":73372},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":75197,\"start\":75196},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":76520,\"start\":76519},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":76746,\"start\":76745},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":76882,\"start\":76881},{\"end\":76969,\"start\":76965},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":77436,\"start\":77435},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":77884,\"start\":77883},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":79878,\"start\":79877},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":81109,\"start\":81108},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":81319,\"start\":81318},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":81445,\"start\":81444},{\"end\":81527,\"start\":81523},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":81963,\"start\":81962},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":82365,\"start\":82364},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":84213,\"start\":84212},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":85536,\"start\":85535},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":85762,\"start\":85761},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":85898,\"start\":85897},{\"end\":85985,\"start\":85981},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":86452,\"start\":86451},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":86521,\"start\":86520},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":89701,\"start\":89700},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":89893,\"start\":89892},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":90008,\"start\":90007},{\"end\":90085,\"start\":90081},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":90491,\"start\":90490},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":90774,\"start\":90773},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":90882,\"start\":90881},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":92646,\"start\":92645},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":93969,\"start\":93968},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":94195,\"start\":94194},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":94331,\"start\":94330},{\"end\":94418,\"start\":94414},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":95270,\"start\":95269},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":97199,\"start\":97198},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":98430,\"start\":98429},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":98640,\"start\":98639},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":98766,\"start\":98765},{\"end\":98848,\"start\":98844},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":99625,\"start\":99624},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":101413,\"start\":101412},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":102736,\"start\":102735},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":102962,\"start\":102961},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":103098,\"start\":103097},{\"end\":103185,\"start\":103181},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":103658,\"start\":103657},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":106770,\"start\":106769},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":106962,\"start\":106961},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":107077,\"start\":107076},{\"end\":107154,\"start\":107150},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":107564,\"start\":107563},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":109747,\"start\":109746},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":109903,\"start\":109902},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":111226,\"start\":111225},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":111452,\"start\":111451},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":111588,\"start\":111587},{\"end\":111675,\"start\":111671},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":112142,\"start\":112141},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":112345,\"start\":112344},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":112485,\"start\":112484},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":114668,\"start\":114667},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":114824,\"start\":114823},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":116147,\"start\":116146},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":116373,\"start\":116372},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":116509,\"start\":116508},{\"end\":116596,\"start\":116592},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":117063,\"start\":117062},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":117266,\"start\":117265},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":117406,\"start\":117405},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":119589,\"start\":119588},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":119741,\"start\":119740},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":120998,\"start\":120997},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":121211,\"start\":121210},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":121339,\"start\":121338},{\"end\":121423,\"start\":121419},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":121868,\"start\":121867},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":122060,\"start\":122059},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":122192,\"start\":122191},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":124375,\"start\":124374},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":125403,\"start\":125402},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":125547,\"start\":125546},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":125637,\"start\":125636},{\"end\":125701,\"start\":125697},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":126025,\"start\":126024},{\"attributes\":{\"ref_id\":\"b8\"},\"end\":127798,\"start\":127795},{\"attributes\":{\"ref_id\":\"b34\"},\"end\":127801,\"start\":127798},{\"attributes\":{\"ref_id\":\"b53\"},\"end\":127804,\"start\":127801},{\"attributes\":{\"ref_id\":\"b16\"},\"end\":128103,\"start\":128099},{\"end\":132348,\"start\":132343},{\"attributes\":{\"ref_id\":\"b55\"},\"end\":132369,\"start\":132367},{\"end\":132375,\"start\":132370},{\"attributes\":{\"ref_id\":\"b26\"},\"end\":133610,\"start\":133606},{\"attributes\":{\"ref_id\":\"b34\"},\"end\":133613,\"start\":133610},{\"attributes\":{\"ref_id\":\"b28\"},\"end\":136133,\"start\":136129},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":136425,\"start\":136422},{\"attributes\":{\"ref_id\":\"b22\"},\"end\":139808,\"start\":139804},{\"attributes\":{\"ref_id\":\"b42\"},\"end\":140060,\"start\":140056},{\"attributes\":{\"ref_id\":\"b11\"},\"end\":140119,\"start\":140115},{\"attributes\":{\"ref_id\":\"b12\"},\"end\":140122,\"start\":140119},{\"attributes\":{\"ref_id\":\"b51\"},\"end\":140724,\"start\":140720},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":143354,\"start\":143350},{\"attributes\":{\"ref_id\":\"b24\"},\"end\":143357,\"start\":143354},{\"attributes\":{\"ref_id\":\"b32\"},\"end\":143727,\"start\":143723},{\"attributes\":{\"ref_id\":\"b35\"},\"end\":143730,\"start\":143727},{\"attributes\":{\"ref_id\":\"b60\"},\"end\":143733,\"start\":143730},{\"attributes\":{\"ref_id\":\"b37\"},\"end\":150966,\"start\":150962},{\"attributes\":{\"ref_id\":\"b27\"},\"end\":152456,\"start\":152452},{\"attributes\":{\"ref_id\":\"b7\"},\"end\":153614,\"start\":153611},{\"attributes\":{\"ref_id\":\"b26\"},\"end\":154719,\"start\":154715},{\"attributes\":{\"ref_id\":\"b57\"},\"end\":155204,\"start\":155200},{\"attributes\":{\"ref_id\":\"b49\"},\"end\":155289,\"start\":155285},{\"attributes\":{\"ref_id\":\"b10\"},\"end\":156079,\"start\":156075},{\"attributes\":{\"ref_id\":\"b3\"},\"end\":161808,\"start\":161805},{\"attributes\":{\"ref_id\":\"b25\"},\"end\":163943,\"start\":163939},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":164456,\"start\":164453},{\"attributes\":{\"ref_id\":\"b46\"},\"end\":165180,\"start\":165176},{\"attributes\":{\"ref_id\":\"b48\"},\"end\":165183,\"start\":165180},{\"attributes\":{\"ref_id\":\"b26\"},\"end\":165423,\"start\":165419},{\"attributes\":{\"ref_id\":\"b34\"},\"end\":165961,\"start\":165957},{\"attributes\":{\"ref_id\":\"b8\"},\"end\":166003,\"start\":166000},{\"attributes\":{\"ref_id\":\"b53\"},\"end\":166006,\"start\":166003},{\"attributes\":{\"ref_id\":\"b34\"},\"end\":166405,\"start\":166401},{\"attributes\":{\"ref_id\":\"b53\"},\"end\":166509,\"start\":166505},{\"attributes\":{\"ref_id\":\"b5\"},\"end\":166613,\"start\":166610},{\"attributes\":{\"ref_id\":\"b18\"},\"end\":166839,\"start\":166835},{\"attributes\":{\"ref_id\":\"b47\"},\"end\":167234,\"start\":167230},{\"attributes\":{\"ref_id\":\"b43\"},\"end\":168100,\"start\":168096},{\"attributes\":{\"ref_id\":\"b59\"},\"end\":168440,\"start\":168436},{\"attributes\":{\"ref_id\":\"b13\"},\"end\":168752,\"start\":168748},{\"attributes\":{\"ref_id\":\"b40\"},\"end\":169011,\"start\":169007},{\"attributes\":{\"ref_id\":\"b39\"},\"end\":169380,\"start\":169376},{\"attributes\":{\"ref_id\":\"b4\"},\"end\":169784,\"start\":169781},{\"attributes\":{\"ref_id\":\"b33\"},\"end\":170070,\"start\":170066},{\"attributes\":{\"ref_id\":\"b33\"},\"end\":170496,\"start\":170492},{\"attributes\":{\"ref_id\":\"b56\"},\"end\":170556,\"start\":170552},{\"attributes\":{\"ref_id\":\"b20\"},\"end\":171220,\"start\":171216},{\"attributes\":{\"ref_id\":\"b58\"},\"end\":171223,\"start\":171220},{\"attributes\":{\"ref_id\":\"b30\"},\"end\":171590,\"start\":171586},{\"attributes\":{\"ref_id\":\"b50\"},\"end\":171763,\"start\":171759},{\"attributes\":{\"ref_id\":\"b52\"},\"end\":172241,\"start\":172237},{\"attributes\":{\"ref_id\":\"b45\"},\"end\":172628,\"start\":172624},{\"attributes\":{\"ref_id\":\"b38\"},\"end\":172802,\"start\":172798},{\"attributes\":{\"ref_id\":\"b55\"},\"end\":173025,\"start\":173021},{\"attributes\":{\"ref_id\":\"b0\"},\"end\":173657,\"start\":173654},{\"attributes\":{\"ref_id\":\"b36\"},\"end\":173883,\"start\":173879},{\"attributes\":{\"ref_id\":\"b23\"},\"end\":174198,\"start\":174194},{\"attributes\":{\"ref_id\":\"b14\"},\"end\":174597,\"start\":174593},{\"attributes\":{\"ref_id\":\"b15\"},\"end\":174600,\"start\":174597},{\"attributes\":{\"ref_id\":\"b31\"},\"end\":174707,\"start\":174703},{\"attributes\":{\"ref_id\":\"b54\"},\"end\":174710,\"start\":174707},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":177445,\"start\":177444},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":177887,\"start\":177886},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":178290,\"start\":178289},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":178693,\"start\":178692},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":179096,\"start\":179095},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":179499,\"start\":179498},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":179902,\"start\":179901},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":180305,\"start\":180304},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":180708,\"start\":180707},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":181111,\"start\":181110},{\"attributes\":{\"ref_id\":\"b43\"},\"end\":185783,\"start\":185764}]", "figure": "[{\"attributes\":{\"id\":\"fig_0\"},\"end\":177130,\"start\":176655},{\"attributes\":{\"id\":\"fig_4\"},\"end\":177533,\"start\":177131},{\"attributes\":{\"id\":\"fig_5\"},\"end\":177572,\"start\":177534},{\"attributes\":{\"id\":\"fig_7\"},\"end\":177975,\"start\":177573},{\"attributes\":{\"id\":\"fig_9\"},\"end\":178378,\"start\":177976},{\"attributes\":{\"id\":\"fig_10\"},\"end\":178781,\"start\":178379},{\"attributes\":{\"id\":\"fig_12\"},\"end\":179184,\"start\":178782},{\"attributes\":{\"id\":\"fig_16\"},\"end\":179587,\"start\":179185},{\"attributes\":{\"id\":\"fig_17\"},\"end\":179990,\"start\":179588},{\"attributes\":{\"id\":\"fig_18\"},\"end\":180393,\"start\":179991},{\"attributes\":{\"id\":\"fig_19\"},\"end\":180796,\"start\":180394},{\"attributes\":{\"id\":\"fig_20\"},\"end\":181199,\"start\":180797},{\"attributes\":{\"id\":\"fig_21\"},\"end\":181509,\"start\":181200},{\"attributes\":{\"id\":\"fig_22\"},\"end\":181906,\"start\":181510},{\"attributes\":{\"id\":\"fig_25\"},\"end\":182323,\"start\":181907},{\"attributes\":{\"id\":\"fig_28\"},\"end\":182562,\"start\":182324},{\"attributes\":{\"id\":\"fig_29\"},\"end\":182636,\"start\":182563},{\"attributes\":{\"id\":\"tab_0\",\"type\":\"table\"},\"end\":182704,\"start\":182637},{\"attributes\":{\"id\":\"tab_1\",\"type\":\"table\"},\"end\":183080,\"start\":182705},{\"attributes\":{\"id\":\"tab_3\",\"type\":\"table\"},\"end\":183444,\"start\":183081},{\"attributes\":{\"id\":\"tab_7\",\"type\":\"table\"},\"end\":183821,\"start\":183445},{\"attributes\":{\"id\":\"tab_8\",\"type\":\"table\"},\"end\":184199,\"start\":183822},{\"attributes\":{\"id\":\"tab_9\",\"type\":\"table\"},\"end\":184320,\"start\":184200},{\"attributes\":{\"id\":\"tab_10\",\"type\":\"table\"},\"end\":184699,\"start\":184321},{\"attributes\":{\"id\":\"tab_11\",\"type\":\"table\"},\"end\":185029,\"start\":184700},{\"attributes\":{\"id\":\"tab_12\",\"type\":\"table\"},\"end\":185398,\"start\":185030},{\"attributes\":{\"id\":\"tab_13\",\"type\":\"table\"},\"end\":185757,\"start\":185399},{\"attributes\":{\"id\":\"tab_14\",\"type\":\"table\"},\"end\":186019,\"start\":185758},{\"attributes\":{\"id\":\"tab_15\",\"type\":\"table\"},\"end\":186388,\"start\":186020},{\"attributes\":{\"id\":\"tab_16\",\"type\":\"table\"},\"end\":186718,\"start\":186389},{\"attributes\":{\"id\":\"tab_18\",\"type\":\"table\"},\"end\":187097,\"start\":186719},{\"attributes\":{\"id\":\"tab_20\",\"type\":\"table\"},\"end\":187460,\"start\":187098},{\"attributes\":{\"id\":\"tab_21\",\"type\":\"table\"},\"end\":187839,\"start\":187461},{\"attributes\":{\"id\":\"tab_22\",\"type\":\"table\"},\"end\":188174,\"start\":187840},{\"attributes\":{\"id\":\"tab_23\",\"type\":\"table\"},\"end\":188553,\"start\":188175},{\"attributes\":{\"id\":\"tab_24\",\"type\":\"table\"},\"end\":188916,\"start\":188554},{\"attributes\":{\"id\":\"tab_25\",\"type\":\"table\"},\"end\":189295,\"start\":188917},{\"attributes\":{\"id\":\"tab_26\",\"type\":\"table\"},\"end\":189630,\"start\":189296},{\"attributes\":{\"id\":\"tab_27\",\"type\":\"table\"},\"end\":189999,\"start\":189631},{\"attributes\":{\"id\":\"tab_28\",\"type\":\"table\"},\"end\":190368,\"start\":190000},{\"attributes\":{\"id\":\"tab_29\",\"type\":\"table\"},\"end\":190732,\"start\":190369},{\"attributes\":{\"id\":\"tab_30\",\"type\":\"table\"},\"end\":191012,\"start\":190733},{\"attributes\":{\"id\":\"tab_32\",\"type\":\"table\"},\"end\":191234,\"start\":191013},{\"attributes\":{\"id\":\"tab_33\",\"type\":\"table\"},\"end\":191594,\"start\":191235},{\"attributes\":{\"id\":\"tab_35\",\"type\":\"table\"},\"end\":191645,\"start\":191595},{\"attributes\":{\"id\":\"tab_36\",\"type\":\"table\"},\"end\":192430,\"start\":191646}]", "paragraph": "[{\"end\":3329,\"start\":2876},{\"end\":4227,\"start\":3331},{\"end\":4814,\"start\":4229},{\"end\":4994,\"start\":4816},{\"end\":5409,\"start\":4996},{\"end\":6525,\"start\":5411},{\"end\":6949,\"start\":6527},{\"end\":7290,\"start\":6951},{\"end\":7829,\"start\":7292},{\"end\":7953,\"start\":7831},{\"end\":8001,\"start\":7955},{\"end\":8760,\"start\":8003},{\"end\":9125,\"start\":8793},{\"end\":9777,\"start\":9127},{\"end\":10304,\"start\":9779},{\"end\":11170,\"start\":10306},{\"end\":11414,\"start\":11172},{\"end\":11672,\"start\":11416},{\"end\":12792,\"start\":11725},{\"end\":13146,\"start\":12794},{\"end\":13621,\"start\":13148},{\"end\":14284,\"start\":13623},{\"end\":14435,\"start\":14318},{\"end\":15197,\"start\":14437},{\"end\":15421,\"start\":15199},{\"end\":15640,\"start\":15423},{\"end\":16201,\"start\":15642},{\"end\":16401,\"start\":16212},{\"end\":16976,\"start\":16445},{\"end\":17708,\"start\":16978},{\"end\":18528,\"start\":17710},{\"end\":20969,\"start\":18530},{\"end\":21507,\"start\":20971},{\"end\":22028,\"start\":21509},{\"end\":23039,\"start\":22030},{\"end\":23239,\"start\":23050},{\"end\":23683,\"start\":23283},{\"end\":23815,\"start\":23685},{\"end\":24547,\"start\":23817},{\"end\":26240,\"start\":24549},{\"end\":26755,\"start\":26242},{\"end\":27248,\"start\":26757},{\"end\":27823,\"start\":27250},{\"end\":28292,\"start\":27825},{\"end\":28492,\"start\":28303},{\"end\":28936,\"start\":28536},{\"end\":29068,\"start\":28938},{\"end\":29800,\"start\":29070},{\"end\":31369,\"start\":29802},{\"end\":33254,\"start\":31371},{\"end\":36050,\"start\":33297},{\"end\":36588,\"start\":36052},{\"end\":37109,\"start\":36590},{\"end\":38272,\"start\":37111},{\"end\":40987,\"start\":38316},{\"end\":41525,\"start\":40989},{\"end\":42046,\"start\":41527},{\"end\":42445,\"start\":42048},{\"end\":42645,\"start\":42456},{\"end\":43220,\"start\":42689},{\"end\":43952,\"start\":43222},{\"end\":45442,\"start\":43954},{\"end\":45963,\"start\":45444},{\"end\":46459,\"start\":45965},{\"end\":47366,\"start\":46461},{\"end\":50004,\"start\":47409},{\"end\":50542,\"start\":50006},{\"end\":51063,\"start\":50544},{\"end\":51462,\"start\":51065},{\"end\":51662,\"start\":51473},{\"end\":52237,\"start\":51706},{\"end\":52969,\"start\":52239},{\"end\":54362,\"start\":52971},{\"end\":55275,\"start\":54364},{\"end\":56167,\"start\":55277},{\"end\":58816,\"start\":56211},{\"end\":59354,\"start\":58818},{\"end\":59875,\"start\":59356},{\"end\":60211,\"start\":59877},{\"end\":60411,\"start\":60222},{\"end\":60986,\"start\":60455},{\"end\":61718,\"start\":60988},{\"end\":63138,\"start\":61720},{\"end\":63659,\"start\":63140},{\"end\":64155,\"start\":63661},{\"end\":65001,\"start\":64157},{\"end\":67576,\"start\":65044},{\"end\":68114,\"start\":67578},{\"end\":68635,\"start\":68116},{\"end\":68971,\"start\":68637},{\"end\":69171,\"start\":68982},{\"end\":69746,\"start\":69215},{\"end\":70478,\"start\":69748},{\"end\":71801,\"start\":70480},{\"end\":72714,\"start\":71803},{\"end\":73516,\"start\":72716},{\"end\":76069,\"start\":73559},{\"end\":76607,\"start\":76071},{\"end\":77128,\"start\":76609},{\"end\":78038,\"start\":77130},{\"end\":80684,\"start\":78040},{\"end\":81192,\"start\":80686},{\"end\":81674,\"start\":81194},{\"end\":82510,\"start\":81676},{\"end\":85085,\"start\":82553},{\"end\":85623,\"start\":85087},{\"end\":86144,\"start\":85625},{\"end\":86480,\"start\":86146},{\"end\":86680,\"start\":86491},{\"end\":87255,\"start\":86724},{\"end\":87987,\"start\":87257},{\"end\":89310,\"start\":87989},{\"end\":90223,\"start\":89312},{\"end\":91025,\"start\":90225},{\"end\":93518,\"start\":91068},{\"end\":94056,\"start\":93520},{\"end\":94577,\"start\":94058},{\"end\":95424,\"start\":94579},{\"end\":98005,\"start\":95468},{\"end\":98513,\"start\":98007},{\"end\":98995,\"start\":98515},{\"end\":99770,\"start\":98997},{\"end\":102285,\"start\":99813},{\"end\":102823,\"start\":102287},{\"end\":103344,\"start\":102825},{\"end\":103617,\"start\":103346},{\"end\":103817,\"start\":103628},{\"end\":104392,\"start\":103861},{\"end\":105124,\"start\":104394},{\"end\":106379,\"start\":105126},{\"end\":107292,\"start\":106381},{\"end\":107523,\"start\":107294},{\"end\":107723,\"start\":107534},{\"end\":108298,\"start\":107767},{\"end\":109030,\"start\":108300},{\"end\":110775,\"start\":109032},{\"end\":111313,\"start\":110777},{\"end\":111834,\"start\":111315},{\"end\":112444,\"start\":111836},{\"end\":112644,\"start\":112455},{\"end\":113219,\"start\":112688},{\"end\":113951,\"start\":113221},{\"end\":115696,\"start\":113953},{\"end\":116234,\"start\":115698},{\"end\":116755,\"start\":116236},{\"end\":117365,\"start\":116757},{\"end\":117565,\"start\":117376},{\"end\":118140,\"start\":117609},{\"end\":118872,\"start\":118142},{\"end\":120565,\"start\":118874},{\"end\":121081,\"start\":120567},{\"end\":121574,\"start\":121083},{\"end\":122151,\"start\":121576},{\"end\":122351,\"start\":122162},{\"end\":122926,\"start\":122395},{\"end\":123658,\"start\":122928},{\"end\":126217,\"start\":123660},{\"end\":127202,\"start\":126219},{\"end\":127740,\"start\":127204},{\"end\":128262,\"start\":127742},{\"end\":129962,\"start\":128264},{\"end\":130314,\"start\":130079},{\"end\":130918,\"start\":130316},{\"end\":131468,\"start\":130920},{\"end\":132412,\"start\":131470},{\"end\":133187,\"start\":132414},{\"end\":133284,\"start\":133189},{\"end\":133614,\"start\":133286},{\"end\":134050,\"start\":133616},{\"end\":134268,\"start\":134052},{\"end\":134706,\"start\":134270},{\"end\":135158,\"start\":134708},{\"end\":135752,\"start\":135160},{\"end\":135946,\"start\":135754},{\"end\":136239,\"start\":135969},{\"end\":137128,\"start\":136241},{\"end\":137469,\"start\":137130},{\"end\":137819,\"start\":137471},{\"end\":138414,\"start\":137821},{\"end\":138669,\"start\":138416},{\"end\":139273,\"start\":138671},{\"end\":139503,\"start\":139275},{\"end\":140123,\"start\":139523},{\"end\":140672,\"start\":140125},{\"end\":141199,\"start\":140674},{\"end\":141894,\"start\":141223},{\"end\":142133,\"start\":141896},{\"end\":142272,\"start\":142135},{\"end\":143192,\"start\":142294},{\"end\":143830,\"start\":143211},{\"end\":144113,\"start\":143832},{\"end\":144972,\"start\":144115},{\"end\":145625,\"start\":144974},{\"end\":146272,\"start\":145627},{\"end\":147329,\"start\":146274},{\"end\":148224,\"start\":147331},{\"end\":149887,\"start\":148226},{\"end\":150831,\"start\":149889},{\"end\":151144,\"start\":150871},{\"end\":151551,\"start\":151146},{\"end\":152164,\"start\":151553},{\"end\":153045,\"start\":152166},{\"end\":153615,\"start\":153047},{\"end\":153979,\"start\":153617},{\"end\":154125,\"start\":153981},{\"end\":154509,\"start\":154141},{\"end\":154965,\"start\":154511},{\"end\":155377,\"start\":154993},{\"end\":155741,\"start\":155379},{\"end\":156080,\"start\":155743},{\"end\":156926,\"start\":156091},{\"end\":158741,\"start\":156936},{\"end\":160562,\"start\":158786},{\"end\":161623,\"start\":160604},{\"end\":162515,\"start\":161636},{\"end\":163391,\"start\":162564},{\"end\":163990,\"start\":163393},{\"end\":164263,\"start\":163992},{\"end\":164982,\"start\":164287},{\"end\":165618,\"start\":164999},{\"end\":165850,\"start\":165620},{\"end\":166335,\"start\":165852},{\"end\":166614,\"start\":166337},{\"end\":167101,\"start\":166616},{\"end\":167794,\"start\":167103},{\"end\":168877,\"start\":167796},{\"end\":169545,\"start\":168879},{\"end\":169912,\"start\":169547},{\"end\":170405,\"start\":169914},{\"end\":170968,\"start\":170407},{\"end\":171372,\"start\":170970},{\"end\":171591,\"start\":171374},{\"end\":171986,\"start\":171593},{\"end\":172094,\"start\":171988},{\"end\":172396,\"start\":172096},{\"end\":172900,\"start\":172398},{\"end\":173471,\"start\":172902},{\"end\":174020,\"start\":173534},{\"end\":174431,\"start\":174022},{\"end\":174711,\"start\":174433},{\"end\":175061,\"start\":174743},{\"end\":175325,\"start\":175063},{\"end\":175574,\"start\":175327},{\"end\":176654,\"start\":175589}]", "formula": null, "table_ref": "[{\"attributes\":{\"ref_id\":\"tab_0\"},\"end\":22392,\"start\":22385},{\"attributes\":{\"ref_id\":\"tab_0\"},\"end\":27595,\"start\":27588},{\"attributes\":{\"ref_id\":\"tab_0\"},\"end\":32544,\"start\":32537},{\"attributes\":{\"ref_id\":\"tab_0\"},\"end\":37473,\"start\":37466},{\"attributes\":{\"ref_id\":\"tab_0\"},\"end\":42410,\"start\":42403},{\"attributes\":{\"ref_id\":\"tab_0\"},\"end\":46810,\"start\":46803},{\"attributes\":{\"ref_id\":\"tab_0\"},\"end\":51427,\"start\":51420},{\"attributes\":{\"ref_id\":\"tab_0\"},\"end\":55591,\"start\":55584},{\"attributes\":{\"ref_id\":\"tab_0\"},\"end\":112198,\"start\":112191},{\"attributes\":{\"ref_id\":\"tab_0\"},\"end\":117119,\"start\":117112},{\"attributes\":{\"ref_id\":\"tab_0\"},\"end\":121921,\"start\":121914},{\"attributes\":{\"ref_id\":\"tab_0\"},\"end\":126061,\"start\":126054},{\"attributes\":{\"ref_id\":\"tab_0\"},\"end\":128626,\"start\":128619},{\"attributes\":{\"ref_id\":\"tab_35\"},\"end\":156368,\"start\":156361},{\"attributes\":{\"ref_id\":\"tab_0\"},\"end\":166230,\"start\":166223}]", "section_header": "[{\"attributes\":{\"n\":\"1\"},\"end\":2874,\"start\":2862},{\"attributes\":{\"n\":\"2\"},\"end\":8791,\"start\":8763},{\"attributes\":{\"n\":\"2.2\"},\"end\":11723,\"start\":11675},{\"attributes\":{\"n\":\"3\"},\"end\":14316,\"start\":14287},{\"attributes\":{\"n\":\"4\"},\"end\":16210,\"start\":16204},{\"attributes\":{\"n\":\"4.1\"},\"end\":16443,\"start\":16404},{\"attributes\":{\"n\":\"4\"},\"end\":23048,\"start\":23042},{\"attributes\":{\"n\":\"4.1\"},\"end\":23281,\"start\":23242},{\"attributes\":{\"n\":\"4\"},\"end\":28301,\"start\":28295},{\"attributes\":{\"n\":\"4.1\"},\"end\":28534,\"start\":28495},{\"end\":33295,\"start\":33257},{\"end\":38314,\"start\":38275},{\"attributes\":{\"n\":\"4\"},\"end\":42454,\"start\":42448},{\"attributes\":{\"n\":\"4.1\"},\"end\":42687,\"start\":42648},{\"end\":47407,\"start\":47369},{\"attributes\":{\"n\":\"4\"},\"end\":51471,\"start\":51465},{\"attributes\":{\"n\":\"4.1\"},\"end\":51704,\"start\":51665},{\"end\":56209,\"start\":56170},{\"attributes\":{\"n\":\"4\"},\"end\":60220,\"start\":60214},{\"attributes\":{\"n\":\"4.1\"},\"end\":60453,\"start\":60414},{\"end\":65042,\"start\":65004},{\"attributes\":{\"n\":\"4\"},\"end\":68980,\"start\":68974},{\"attributes\":{\"n\":\"4.1\"},\"end\":69213,\"start\":69174},{\"end\":73557,\"start\":73519},{\"end\":82551,\"start\":82513},{\"attributes\":{\"n\":\"4\"},\"end\":86489,\"start\":86483},{\"attributes\":{\"n\":\"4.1\"},\"end\":86722,\"start\":86683},{\"end\":91066,\"start\":91028},{\"attributes\":{\"n\":\"1\"},\"end\":95466,\"start\":95427},{\"end\":99811,\"start\":99773},{\"attributes\":{\"n\":\"4\"},\"end\":103626,\"start\":103620},{\"attributes\":{\"n\":\"4.1\"},\"end\":103859,\"start\":103820},{\"attributes\":{\"n\":\"4\"},\"end\":107532,\"start\":107526},{\"attributes\":{\"n\":\"4.1\"},\"end\":107765,\"start\":107726},{\"attributes\":{\"n\":\"4\"},\"end\":112453,\"start\":112447},{\"attributes\":{\"n\":\"4.1\"},\"end\":112686,\"start\":112647},{\"attributes\":{\"n\":\"4\"},\"end\":117374,\"start\":117368},{\"attributes\":{\"n\":\"4.1\"},\"end\":117607,\"start\":117568},{\"attributes\":{\"n\":\"4\"},\"end\":122160,\"start\":122154},{\"attributes\":{\"n\":\"4.1\"},\"end\":122393,\"start\":122354},{\"end\":129982,\"start\":129965},{\"end\":130002,\"start\":129985},{\"end\":130030,\"start\":130005},{\"end\":130058,\"start\":130033},{\"attributes\":{\"n\":\"4.2\"},\"end\":130077,\"start\":130061},{\"attributes\":{\"n\":\"4.3\"},\"end\":135967,\"start\":135949},{\"attributes\":{\"n\":\"4.4\"},\"end\":139521,\"start\":139506},{\"attributes\":{\"n\":\"4.5\"},\"end\":141221,\"start\":141202},{\"attributes\":{\"n\":\"4.6\"},\"end\":142292,\"start\":142275},{\"attributes\":{\"n\":\"4.6.1\"},\"end\":143209,\"start\":143195},{\"attributes\":{\"n\":\"5\"},\"end\":150869,\"start\":150834},{\"attributes\":{\"n\":\"5.2\"},\"end\":154139,\"start\":154128},{\"attributes\":{\"n\":\"5.2.1\"},\"end\":154991,\"start\":154968},{\"end\":156089,\"start\":156083},{\"end\":156934,\"start\":156929},{\"attributes\":{\"n\":\"5.2.3\"},\"end\":158784,\"start\":158744},{\"attributes\":{\"n\":\"5.2.4\"},\"end\":160602,\"start\":160565},{\"attributes\":{\"n\":\"5.3\"},\"end\":161634,\"start\":161626},{\"attributes\":{\"n\":\"5.3.1\"},\"end\":162562,\"start\":162518},{\"attributes\":{\"n\":\"5.3.2\"},\"end\":164285,\"start\":164266},{\"attributes\":{\"n\":\"6\"},\"end\":164997,\"start\":164985},{\"end\":173532,\"start\":173474},{\"attributes\":{\"n\":\"7\"},\"end\":174741,\"start\":174714},{\"attributes\":{\"n\":\"8\"},\"end\":175587,\"start\":175577},{\"end\":176661,\"start\":176656},{\"end\":177142,\"start\":177132},{\"end\":177584,\"start\":177574},{\"end\":177987,\"start\":177977},{\"end\":178390,\"start\":178380},{\"end\":178793,\"start\":178783},{\"end\":179196,\"start\":179186},{\"end\":179599,\"start\":179589},{\"end\":180002,\"start\":179992},{\"end\":180405,\"start\":180395},{\"end\":180808,\"start\":180798},{\"end\":181202,\"start\":181201},{\"end\":181519,\"start\":181511},{\"end\":181916,\"start\":181908},{\"end\":182336,\"start\":182325},{\"end\":182575,\"start\":182564},{\"end\":182647,\"start\":182638},{\"end\":182715,\"start\":182706},{\"end\":183091,\"start\":183082},{\"end\":183455,\"start\":183446},{\"end\":183832,\"start\":183823},{\"end\":184210,\"start\":184201},{\"end\":184331,\"start\":184322},{\"end\":184710,\"start\":184701},{\"end\":185040,\"start\":185031},{\"end\":185409,\"start\":185400},{\"end\":185762,\"start\":185759},{\"end\":186030,\"start\":186021},{\"end\":186399,\"start\":186390},{\"end\":186729,\"start\":186720},{\"end\":187108,\"start\":187099},{\"end\":187471,\"start\":187462},{\"end\":187850,\"start\":187841},{\"end\":188185,\"start\":188176},{\"end\":188564,\"start\":188555},{\"end\":188927,\"start\":188918},{\"end\":189306,\"start\":189297},{\"end\":189641,\"start\":189632},{\"end\":190010,\"start\":190001},{\"end\":190379,\"start\":190370},{\"end\":190743,\"start\":190734},{\"end\":191605,\"start\":191596}]", "table": "[{\"end\":183080,\"start\":182767},{\"end\":183444,\"start\":183093},{\"end\":183821,\"start\":183457},{\"end\":184199,\"start\":183884},{\"end\":184320,\"start\":184312},{\"end\":184699,\"start\":184333},{\"end\":185029,\"start\":184951},{\"end\":185398,\"start\":185316},{\"end\":185757,\"start\":185675},{\"end\":186019,\"start\":185843},{\"end\":186388,\"start\":186306},{\"end\":186718,\"start\":186640},{\"end\":187097,\"start\":186731},{\"end\":187460,\"start\":187110},{\"end\":187839,\"start\":187473},{\"end\":188174,\"start\":187946},{\"end\":188553,\"start\":188187},{\"end\":188916,\"start\":188566},{\"end\":189295,\"start\":188929},{\"end\":189630,\"start\":189402},{\"end\":189999,\"start\":189917},{\"end\":190368,\"start\":190286},{\"end\":190732,\"start\":190427},{\"end\":191012,\"start\":190745},{\"end\":191234,\"start\":191067},{\"end\":191594,\"start\":191320},{\"end\":192430,\"start\":192170}]", "figure_caption": "[{\"end\":177130,\"start\":176663},{\"end\":177533,\"start\":177144},{\"end\":177572,\"start\":177536},{\"end\":177975,\"start\":177586},{\"end\":178378,\"start\":177989},{\"end\":178781,\"start\":178392},{\"end\":179184,\"start\":178795},{\"end\":179587,\"start\":179198},{\"end\":179990,\"start\":179601},{\"end\":180393,\"start\":180004},{\"end\":180796,\"start\":180407},{\"end\":181199,\"start\":180810},{\"end\":181509,\"start\":181203},{\"end\":181906,\"start\":181521},{\"end\":182323,\"start\":181918},{\"end\":182562,\"start\":182339},{\"end\":182636,\"start\":182578},{\"end\":182704,\"start\":182649},{\"end\":182767,\"start\":182717},{\"end\":183884,\"start\":183834},{\"end\":184312,\"start\":184212},{\"end\":184951,\"start\":184712},{\"end\":185316,\"start\":185042},{\"end\":185675,\"start\":185411},{\"end\":185843,\"start\":185764},{\"end\":186306,\"start\":186032},{\"end\":186640,\"start\":186401},{\"end\":187946,\"start\":187852},{\"end\":189402,\"start\":189308},{\"end\":189917,\"start\":189643},{\"end\":190286,\"start\":190012},{\"end\":190427,\"start\":190381},{\"end\":191067,\"start\":191015},{\"end\":191320,\"start\":191237},{\"end\":191645,\"start\":191607},{\"end\":192170,\"start\":191648}]", "figure_ref": "[{\"end\":5607,\"start\":5599},{\"attributes\":{\"ref_id\":\"fig_4\"},\"end\":15809,\"start\":15801},{\"attributes\":{\"ref_id\":\"fig_4\"},\"end\":16844,\"start\":16836},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":18384,\"start\":18376},{\"attributes\":{\"ref_id\":\"fig_4\"},\"end\":19059,\"start\":19051},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":19940,\"start\":19932},{\"attributes\":{\"ref_id\":\"fig_22\"},\"end\":20119,\"start\":20111},{\"attributes\":{\"ref_id\":\"fig_4\"},\"end\":22647,\"start\":22639},{\"attributes\":{\"ref_id\":\"fig_4\"},\"end\":23682,\"start\":23674},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":25223,\"start\":25215},{\"attributes\":{\"ref_id\":\"fig_22\"},\"end\":25436,\"start\":25428},{\"attributes\":{\"ref_id\":\"fig_4\"},\"end\":27900,\"start\":27892},{\"attributes\":{\"ref_id\":\"fig_4\"},\"end\":28935,\"start\":28927},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":30476,\"start\":30468},{\"attributes\":{\"ref_id\":\"fig_22\"},\"end\":30671,\"start\":30663},{\"attributes\":{\"ref_id\":\"fig_4\"},\"end\":33648,\"start\":33640},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":34998,\"start\":34990},{\"attributes\":{\"ref_id\":\"fig_22\"},\"end\":35200,\"start\":35192},{\"attributes\":{\"ref_id\":\"fig_4\"},\"end\":38687,\"start\":38679},{\"attributes\":{\"ref_id\":\"fig_22\"},\"end\":40137,\"start\":40129},{\"attributes\":{\"ref_id\":\"fig_4\"},\"end\":43088,\"start\":43080},{\"attributes\":{\"ref_id\":\"fig_22\"},\"end\":44629,\"start\":44621},{\"attributes\":{\"ref_id\":\"fig_4\"},\"end\":47766,\"start\":47758},{\"attributes\":{\"ref_id\":\"fig_22\"},\"end\":49154,\"start\":49146},{\"attributes\":{\"ref_id\":\"fig_4\"},\"end\":52105,\"start\":52097},{\"attributes\":{\"ref_id\":\"fig_22\"},\"end\":53633,\"start\":53625},{\"attributes\":{\"ref_id\":\"fig_4\"},\"end\":56582,\"start\":56574},{\"attributes\":{\"ref_id\":\"fig_22\"},\"end\":57966,\"start\":57958},{\"attributes\":{\"ref_id\":\"fig_4\"},\"end\":60854,\"start\":60846},{\"attributes\":{\"ref_id\":\"fig_22\"},\"end\":62325,\"start\":62317},{\"attributes\":{\"ref_id\":\"fig_4\"},\"end\":65401,\"start\":65393},{\"attributes\":{\"ref_id\":\"fig_22\"},\"end\":66726,\"start\":66718},{\"attributes\":{\"ref_id\":\"fig_4\"},\"end\":69614,\"start\":69606},{\"attributes\":{\"ref_id\":\"fig_22\"},\"end\":71072,\"start\":71064},{\"attributes\":{\"ref_id\":\"fig_4\"},\"end\":73910,\"start\":73902},{\"attributes\":{\"ref_id\":\"fig_22\"},\"end\":75219,\"start\":75211},{\"attributes\":{\"ref_id\":\"fig_4\"},\"end\":78470,\"start\":78462},{\"attributes\":{\"ref_id\":\"fig_22\"},\"end\":79897,\"start\":79889},{\"attributes\":{\"ref_id\":\"fig_4\"},\"end\":82910,\"start\":82902},{\"attributes\":{\"ref_id\":\"fig_22\"},\"end\":84235,\"start\":84227},{\"attributes\":{\"ref_id\":\"fig_4\"},\"end\":87123,\"start\":87115},{\"attributes\":{\"ref_id\":\"fig_22\"},\"end\":88581,\"start\":88573},{\"attributes\":{\"ref_id\":\"fig_4\"},\"end\":91419,\"start\":91411},{\"attributes\":{\"ref_id\":\"fig_22\"},\"end\":92668,\"start\":92660},{\"attributes\":{\"ref_id\":\"fig_4\"},\"end\":95856,\"start\":95848},{\"attributes\":{\"ref_id\":\"fig_22\"},\"end\":97218,\"start\":97210},{\"attributes\":{\"ref_id\":\"fig_4\"},\"end\":100170,\"start\":100162},{\"attributes\":{\"ref_id\":\"fig_22\"},\"end\":101435,\"start\":101427},{\"attributes\":{\"ref_id\":\"fig_4\"},\"end\":104260,\"start\":104252},{\"attributes\":{\"ref_id\":\"fig_22\"},\"end\":105650,\"start\":105642},{\"attributes\":{\"ref_id\":\"fig_4\"},\"end\":108166,\"start\":108158},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":109706,\"start\":109698},{\"attributes\":{\"ref_id\":\"fig_22\"},\"end\":109925,\"start\":109917},{\"attributes\":{\"ref_id\":\"fig_4\"},\"end\":113087,\"start\":113079},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":114627,\"start\":114619},{\"attributes\":{\"ref_id\":\"fig_22\"},\"end\":114846,\"start\":114838},{\"attributes\":{\"ref_id\":\"fig_4\"},\"end\":118008,\"start\":118000},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":119548,\"start\":119540},{\"attributes\":{\"ref_id\":\"fig_22\"},\"end\":119761,\"start\":119753},{\"attributes\":{\"ref_id\":\"fig_4\"},\"end\":122794,\"start\":122786},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":124334,\"start\":124326},{\"attributes\":{\"ref_id\":\"fig_22\"},\"end\":124509,\"start\":124501},{\"attributes\":{\"ref_id\":\"fig_22\"},\"end\":126352,\"start\":126344},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":128881,\"start\":128873},{\"end\":130274,\"start\":130266},{\"end\":132442,\"start\":132434},{\"end\":135507,\"start\":135499},{\"end\":137190,\"start\":137182},{\"attributes\":{\"ref_id\":\"fig_25\"},\"end\":140533,\"start\":140525},{\"end\":143236,\"start\":143228},{\"end\":143742,\"start\":143734},{\"end\":147239,\"start\":147227},{\"end\":149833,\"start\":149825},{\"end\":157036,\"start\":157027},{\"end\":157666,\"start\":157657},{\"end\":157971,\"start\":157962},{\"end\":158236,\"start\":158227},{\"end\":159584,\"start\":159575},{\"end\":160164,\"start\":160155},{\"attributes\":{\"ref_id\":\"fig_4\"},\"end\":161079,\"start\":161070},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":163390,\"start\":163380},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":164979,\"start\":164969}]", "bib_author_first_name": "[{\"end\":192831,\"start\":192828},{\"end\":192850,\"start\":192843},{\"end\":192852,\"start\":192851},{\"end\":193288,\"start\":193285},{\"end\":193306,\"start\":193299},{\"end\":193319,\"start\":193314},{\"end\":193333,\"start\":193327},{\"end\":193355,\"start\":193350},{\"end\":193368,\"start\":193363},{\"end\":193719,\"start\":193716},{\"end\":193731,\"start\":193728},{\"end\":193745,\"start\":193741},{\"end\":193758,\"start\":193754},{\"end\":193959,\"start\":193956},{\"end\":193972,\"start\":193968},{\"end\":193974,\"start\":193973},{\"end\":194158,\"start\":194152},{\"end\":194173,\"start\":194166},{\"end\":194186,\"start\":194181},{\"end\":194188,\"start\":194187},{\"end\":194202,\"start\":194195},{\"end\":194768,\"start\":194764},{\"end\":194780,\"start\":194775},{\"end\":195618,\"start\":195611},{\"end\":195631,\"start\":195626},{\"end\":195645,\"start\":195641},{\"end\":195661,\"start\":195656},{\"end\":196164,\"start\":196161},{\"end\":196385,\"start\":196382},{\"end\":196608,\"start\":196604},{\"end\":196621,\"start\":196617},{\"end\":196638,\"start\":196631},{\"end\":196654,\"start\":196648},{\"end\":196672,\"start\":196667},{\"end\":196676,\"start\":196673},{\"end\":197063,\"start\":197059},{\"end\":197088,\"start\":197072},{\"end\":197104,\"start\":197100},{\"end\":197511,\"start\":197508},{\"end\":197527,\"start\":197522},{\"end\":197542,\"start\":197538},{\"end\":197546,\"start\":197543},{\"end\":197560,\"start\":197555},{\"end\":198284,\"start\":198283},{\"end\":198301,\"start\":198300},{\"end\":198303,\"start\":198302},{\"end\":198817,\"start\":198810},{\"end\":198819,\"start\":198818},{\"end\":198827,\"start\":198826},{\"end\":198829,\"start\":198828},{\"end\":198845,\"start\":198838},{\"end\":199166,\"start\":199161},{\"end\":199183,\"start\":199178},{\"end\":199193,\"start\":199188},{\"end\":199209,\"start\":199202},{\"end\":199223,\"start\":199217},{\"end\":199240,\"start\":199233},{\"end\":199255,\"start\":199248},{\"end\":199269,\"start\":199264},{\"end\":199282,\"start\":199278},{\"end\":199298,\"start\":199291},{\"end\":199308,\"start\":199307},{\"end\":199313,\"start\":199309},{\"end\":199945,\"start\":199938},{\"end\":199975,\"start\":199971},{\"end\":200401,\"start\":200393},{\"end\":200408,\"start\":200402},{\"end\":200422,\"start\":200415},{\"end\":200436,\"start\":200431},{\"end\":200448,\"start\":200443},{\"end\":200462,\"start\":200457},{\"end\":200478,\"start\":200472},{\"end\":200865,\"start\":200856},{\"end\":200872,\"start\":200866},{\"end\":200887,\"start\":200882},{\"end\":200889,\"start\":200888},{\"end\":200908,\"start\":200900},{\"end\":200922,\"start\":200919},{\"end\":200940,\"start\":200934},{\"end\":200959,\"start\":200953},{\"end\":200974,\"start\":200967},{\"end\":200986,\"start\":200980},{\"end\":200993,\"start\":200987},{\"end\":201014,\"start\":201005},{\"end\":201031,\"start\":201027},{\"end\":201046,\"start\":201041},{\"end\":201064,\"start\":201057},{\"end\":201079,\"start\":201073},{\"end\":201096,\"start\":201087},{\"end\":201107,\"start\":201106},{\"end\":201116,\"start\":201108},{\"end\":201135,\"start\":201128},{\"end\":201153,\"start\":201147},{\"end\":201155,\"start\":201154},{\"end\":201171,\"start\":201164},{\"end\":201182,\"start\":201177},{\"end\":201197,\"start\":201191},{\"end\":201210,\"start\":201203},{\"end\":201212,\"start\":201211},{\"end\":201221,\"start\":201220},{\"end\":201657,\"start\":201652},{\"end\":201659,\"start\":201658},{\"end\":201673,\"start\":201667},{\"end\":201677,\"start\":201674},{\"end\":202043,\"start\":202036},{\"end\":202058,\"start\":202051},{\"end\":202075,\"start\":202069},{\"end\":202473,\"start\":202472},{\"end\":202487,\"start\":202480},{\"end\":202632,\"start\":202625},{\"end\":202673,\"start\":202669},{\"end\":202718,\"start\":202714},{\"end\":203050,\"start\":203049},{\"end\":203057,\"start\":203056},{\"end\":203064,\"start\":203063},{\"end\":203474,\"start\":203468},{\"end\":203769,\"start\":203768},{\"end\":203781,\"start\":203780},{\"end\":203792,\"start\":203791},{\"end\":203801,\"start\":203800},{\"end\":204185,\"start\":204178},{\"end\":204187,\"start\":204186},{\"end\":204205,\"start\":204198},{\"end\":204215,\"start\":204212},{\"end\":204230,\"start\":204224},{\"end\":204244,\"start\":204240},{\"end\":204258,\"start\":204253},{\"end\":204718,\"start\":204712},{\"end\":204729,\"start\":204725},{\"end\":204746,\"start\":204738},{\"end\":204748,\"start\":204747},{\"end\":204762,\"start\":204756},{\"end\":204764,\"start\":204763},{\"end\":204775,\"start\":204773},{\"end\":204783,\"start\":204778},{\"end\":205480,\"start\":205469},{\"end\":205493,\"start\":205486},{\"end\":205508,\"start\":205500},{\"end\":205521,\"start\":205515},{\"end\":205534,\"start\":205528},{\"end\":205544,\"start\":205540},{\"end\":205554,\"start\":205549},{\"end\":206054,\"start\":206047},{\"end\":206067,\"start\":206060},{\"end\":206500,\"start\":206495},{\"end\":206502,\"start\":206501},{\"end\":206718,\"start\":206714},{\"end\":206738,\"start\":206732},{\"end\":206749,\"start\":206746},{\"end\":206762,\"start\":206756},{\"end\":206769,\"start\":206763},{\"end\":206785,\"start\":206777},{\"end\":206795,\"start\":206794},{\"end\":207287,\"start\":207281},{\"end\":207299,\"start\":207294},{\"end\":207314,\"start\":207307},{\"end\":207330,\"start\":207324},{\"end\":207349,\"start\":207339},{\"end\":207365,\"start\":207359},{\"end\":207908,\"start\":207901},{\"end\":207921,\"start\":207914},{\"end\":207936,\"start\":207929},{\"end\":208524,\"start\":208519},{\"end\":208526,\"start\":208525},{\"end\":208544,\"start\":208538},{\"end\":208565,\"start\":208559},{\"end\":208582,\"start\":208576},{\"end\":208599,\"start\":208593},{\"end\":208615,\"start\":208610},{\"end\":208632,\"start\":208625},{\"end\":208649,\"start\":208642},{\"end\":208665,\"start\":208660},{\"end\":208984,\"start\":208980},{\"end\":209357,\"start\":209350},{\"end\":209372,\"start\":209371},{\"end\":209374,\"start\":209373},{\"end\":209386,\"start\":209381},{\"end\":209771,\"start\":209763},{\"end\":209797,\"start\":209793},{\"end\":209801,\"start\":209798},{\"end\":209813,\"start\":209808},{\"end\":210390,\"start\":210384},{\"end\":210986,\"start\":210979},{\"end\":211005,\"start\":210998},{\"end\":211023,\"start\":211017},{\"end\":211040,\"start\":211034},{\"end\":211057,\"start\":211049},{\"end\":211711,\"start\":211704},{\"end\":211726,\"start\":211720},{\"end\":211728,\"start\":211727},{\"end\":211738,\"start\":211737},{\"end\":211764,\"start\":211755},{\"end\":211776,\"start\":211771},{\"end\":211789,\"start\":211784},{\"end\":212423,\"start\":212417},{\"end\":212712,\"start\":212702},{\"end\":212730,\"start\":212725},{\"end\":212750,\"start\":212741},{\"end\":212769,\"start\":212762},{\"end\":213253,\"start\":213247},{\"end\":213273,\"start\":213266},{\"end\":213291,\"start\":213284},{\"end\":213309,\"start\":213305},{\"end\":213329,\"start\":213323},{\"end\":213662,\"start\":213657},{\"end\":214085,\"start\":214079},{\"end\":214101,\"start\":214095},{\"end\":214572,\"start\":214565},{\"end\":214764,\"start\":214763},{\"end\":214773,\"start\":214772},{\"end\":215190,\"start\":215184},{\"end\":215201,\"start\":215197},{\"end\":215216,\"start\":215210},{\"end\":215630,\"start\":215626},{\"end\":215651,\"start\":215646},{\"end\":215669,\"start\":215660},{\"end\":216224,\"start\":216223},{\"end\":216241,\"start\":216240},{\"end\":216251,\"start\":216250},{\"end\":216262,\"start\":216261},{\"end\":216763,\"start\":216762},{\"end\":216765,\"start\":216764},{\"end\":216782,\"start\":216774},{\"end\":216796,\"start\":216791},{\"end\":216798,\"start\":216797},{\"end\":216814,\"start\":216809},{\"end\":216816,\"start\":216815},{\"end\":216834,\"start\":216826},{\"end\":216847,\"start\":216842},{\"end\":216863,\"start\":216858},{\"end\":216880,\"start\":216874},{\"end\":216893,\"start\":216887},{\"end\":217660,\"start\":217653},{\"end\":217674,\"start\":217666},{\"end\":217688,\"start\":217685},{\"end\":217709,\"start\":217700},{\"end\":217711,\"start\":217710},{\"end\":217728,\"start\":217721},{\"end\":217743,\"start\":217734},{\"end\":217761,\"start\":217756},{\"end\":217773,\"start\":217768},{\"end\":217775,\"start\":217774},{\"end\":217790,\"start\":217785},{\"end\":217792,\"start\":217791},{\"end\":217801,\"start\":217800},{\"end\":217803,\"start\":217802},{\"end\":217819,\"start\":217812},{\"end\":217821,\"start\":217820},{\"end\":218564,\"start\":218560},{\"end\":218580,\"start\":218572},{\"end\":218594,\"start\":218586},{\"end\":219323,\"start\":219316},{\"end\":219338,\"start\":219331},{\"end\":219350,\"start\":219344}]", "bib_author_last_name": "[{\"end\":192841,\"start\":192832},{\"end\":192858,\"start\":192853},{\"end\":193297,\"start\":193289},{\"end\":193312,\"start\":193307},{\"end\":193325,\"start\":193320},{\"end\":193348,\"start\":193334},{\"end\":193361,\"start\":193356},{\"end\":193376,\"start\":193369},{\"end\":193726,\"start\":193720},{\"end\":193739,\"start\":193732},{\"end\":193752,\"start\":193746},{\"end\":193763,\"start\":193759},{\"end\":193966,\"start\":193960},{\"end\":193980,\"start\":193975},{\"end\":194164,\"start\":194159},{\"end\":194179,\"start\":194174},{\"end\":194193,\"start\":194189},{\"end\":194208,\"start\":194203},{\"end\":194773,\"start\":194769},{\"end\":194789,\"start\":194781},{\"end\":195333,\"start\":195314},{\"end\":195624,\"start\":195619},{\"end\":195639,\"start\":195632},{\"end\":195654,\"start\":195646},{\"end\":195667,\"start\":195662},{\"end\":196172,\"start\":196165},{\"end\":196393,\"start\":196386},{\"end\":196615,\"start\":196609},{\"end\":196629,\"start\":196622},{\"end\":196646,\"start\":196639},{\"end\":196665,\"start\":196655},{\"end\":196681,\"start\":196677},{\"end\":197070,\"start\":197064},{\"end\":197098,\"start\":197089},{\"end\":197112,\"start\":197105},{\"end\":197520,\"start\":197512},{\"end\":197536,\"start\":197528},{\"end\":197553,\"start\":197547},{\"end\":197570,\"start\":197561},{\"end\":198292,\"start\":198285},{\"end\":198298,\"start\":198294},{\"end\":198310,\"start\":198304},{\"end\":198315,\"start\":198312},{\"end\":198824,\"start\":198820},{\"end\":198836,\"start\":198830},{\"end\":198849,\"start\":198846},{\"end\":198860,\"start\":198851},{\"end\":199176,\"start\":199167},{\"end\":199186,\"start\":199184},{\"end\":199200,\"start\":199194},{\"end\":199215,\"start\":199210},{\"end\":199231,\"start\":199224},{\"end\":199246,\"start\":199241},{\"end\":199262,\"start\":199256},{\"end\":199276,\"start\":199270},{\"end\":199289,\"start\":199283},{\"end\":199305,\"start\":199299},{\"end\":199323,\"start\":199314},{\"end\":199969,\"start\":199946},{\"end\":199982,\"start\":199976},{\"end\":199986,\"start\":199984},{\"end\":200413,\"start\":200409},{\"end\":200429,\"start\":200423},{\"end\":200441,\"start\":200437},{\"end\":200455,\"start\":200449},{\"end\":200470,\"start\":200463},{\"end\":200485,\"start\":200479},{\"end\":200880,\"start\":200873},{\"end\":200898,\"start\":200890},{\"end\":200917,\"start\":200909},{\"end\":200932,\"start\":200923},{\"end\":200951,\"start\":200941},{\"end\":200965,\"start\":200960},{\"end\":200978,\"start\":200975},{\"end\":201003,\"start\":200994},{\"end\":201025,\"start\":201015},{\"end\":201039,\"start\":201032},{\"end\":201055,\"start\":201047},{\"end\":201071,\"start\":201065},{\"end\":201085,\"start\":201080},{\"end\":201104,\"start\":201097},{\"end\":201126,\"start\":201117},{\"end\":201145,\"start\":201136},{\"end\":201162,\"start\":201156},{\"end\":201175,\"start\":201172},{\"end\":201189,\"start\":201183},{\"end\":201201,\"start\":201198},{\"end\":201218,\"start\":201213},{\"end\":201227,\"start\":201222},{\"end\":201665,\"start\":201660},{\"end\":201685,\"start\":201678},{\"end\":201693,\"start\":201687},{\"end\":202049,\"start\":202044},{\"end\":202067,\"start\":202059},{\"end\":202083,\"start\":202076},{\"end\":202478,\"start\":202474},{\"end\":202496,\"start\":202488},{\"end\":202507,\"start\":202498},{\"end\":202637,\"start\":202633},{\"end\":202682,\"start\":202674},{\"end\":202723,\"start\":202719},{\"end\":203054,\"start\":203051},{\"end\":203061,\"start\":203058},{\"end\":203068,\"start\":203065},{\"end\":203484,\"start\":203475},{\"end\":203778,\"start\":203770},{\"end\":203789,\"start\":203782},{\"end\":203798,\"start\":203793},{\"end\":203808,\"start\":203802},{\"end\":204196,\"start\":204188},{\"end\":204210,\"start\":204206},{\"end\":204222,\"start\":204216},{\"end\":204238,\"start\":204231},{\"end\":204251,\"start\":204245},{\"end\":204265,\"start\":204259},{\"end\":204723,\"start\":204719},{\"end\":204736,\"start\":204730},{\"end\":204754,\"start\":204749},{\"end\":204771,\"start\":204765},{\"end\":204789,\"start\":204784},{\"end\":205484,\"start\":205481},{\"end\":205498,\"start\":205494},{\"end\":205513,\"start\":205509},{\"end\":205526,\"start\":205522},{\"end\":205538,\"start\":205535},{\"end\":205547,\"start\":205545},{\"end\":205558,\"start\":205555},{\"end\":206058,\"start\":206055},{\"end\":206071,\"start\":206068},{\"end\":206507,\"start\":206503},{\"end\":206730,\"start\":206719},{\"end\":206744,\"start\":206739},{\"end\":206754,\"start\":206750},{\"end\":206775,\"start\":206770},{\"end\":206792,\"start\":206786},{\"end\":206802,\"start\":206796},{\"end\":207292,\"start\":207288},{\"end\":207305,\"start\":207300},{\"end\":207322,\"start\":207315},{\"end\":207337,\"start\":207331},{\"end\":207357,\"start\":207350},{\"end\":207371,\"start\":207366},{\"end\":207912,\"start\":207909},{\"end\":207927,\"start\":207922},{\"end\":207941,\"start\":207937},{\"end\":208536,\"start\":208527},{\"end\":208557,\"start\":208545},{\"end\":208574,\"start\":208566},{\"end\":208591,\"start\":208583},{\"end\":208608,\"start\":208600},{\"end\":208623,\"start\":208616},{\"end\":208640,\"start\":208633},{\"end\":208658,\"start\":208650},{\"end\":208672,\"start\":208666},{\"end\":208991,\"start\":208985},{\"end\":209369,\"start\":209358},{\"end\":209379,\"start\":209375},{\"end\":209393,\"start\":209387},{\"end\":209404,\"start\":209395},{\"end\":209791,\"start\":209772},{\"end\":209806,\"start\":209802},{\"end\":209820,\"start\":209814},{\"end\":209831,\"start\":209822},{\"end\":210399,\"start\":210391},{\"end\":210996,\"start\":210987},{\"end\":211015,\"start\":211006},{\"end\":211032,\"start\":211024},{\"end\":211047,\"start\":211041},{\"end\":211064,\"start\":211058},{\"end\":211718,\"start\":211712},{\"end\":211735,\"start\":211729},{\"end\":211753,\"start\":211739},{\"end\":211769,\"start\":211765},{\"end\":211782,\"start\":211777},{\"end\":211803,\"start\":211790},{\"end\":212434,\"start\":212424},{\"end\":212723,\"start\":212713},{\"end\":212739,\"start\":212731},{\"end\":212760,\"start\":212751},{\"end\":212776,\"start\":212770},{\"end\":213264,\"start\":213254},{\"end\":213282,\"start\":213274},{\"end\":213303,\"start\":213292},{\"end\":213321,\"start\":213310},{\"end\":213336,\"start\":213330},{\"end\":213669,\"start\":213663},{\"end\":214093,\"start\":214086},{\"end\":214108,\"start\":214102},{\"end\":214579,\"start\":214573},{\"end\":214770,\"start\":214765},{\"end\":214787,\"start\":214774},{\"end\":215195,\"start\":215191},{\"end\":215208,\"start\":215202},{\"end\":215225,\"start\":215217},{\"end\":215644,\"start\":215631},{\"end\":215658,\"start\":215652},{\"end\":215679,\"start\":215670},{\"end\":216238,\"start\":216225},{\"end\":216248,\"start\":216242},{\"end\":216259,\"start\":216252},{\"end\":216272,\"start\":216263},{\"end\":216772,\"start\":216766},{\"end\":216789,\"start\":216783},{\"end\":216807,\"start\":216799},{\"end\":216824,\"start\":216817},{\"end\":216840,\"start\":216835},{\"end\":216856,\"start\":216848},{\"end\":216872,\"start\":216864},{\"end\":216885,\"start\":216881},{\"end\":216899,\"start\":216894},{\"end\":216906,\"start\":216901},{\"end\":217407,\"start\":217399},{\"end\":217664,\"start\":217661},{\"end\":217683,\"start\":217675},{\"end\":217698,\"start\":217689},{\"end\":217719,\"start\":217712},{\"end\":217732,\"start\":217729},{\"end\":217754,\"start\":217744},{\"end\":217766,\"start\":217762},{\"end\":217783,\"start\":217776},{\"end\":217798,\"start\":217793},{\"end\":217810,\"start\":217804},{\"end\":217828,\"start\":217822},{\"end\":217835,\"start\":217830},{\"end\":218570,\"start\":218565},{\"end\":218584,\"start\":218581},{\"end\":218599,\"start\":218595},{\"end\":219329,\"start\":219324},{\"end\":219342,\"start\":219339},{\"end\":219355,\"start\":219351}]", "bib_entry": "[{\"attributes\":{\"doi\":\"10.1109/SP40000.2020.00058\",\"id\":\"b0\",\"matched_paper_id\":212425000},\"end\":193224,\"start\":192761},{\"attributes\":{\"doi\":\"10.1109/SP40000.2020.00058\",\"id\":\"b1\",\"matched_paper_id\":33828767},\"end\":193677,\"start\":193226},{\"attributes\":{\"id\":\"b2\"},\"end\":193916,\"start\":193679},{\"attributes\":{\"id\":\"b3\",\"matched_paper_id\":27188334},\"end\":194098,\"start\":193918},{\"attributes\":{\"doi\":\"10.1145/3196494.3196540\",\"id\":\"b4\",\"matched_paper_id\":4655395},\"end\":194727,\"start\":194100},{\"attributes\":{\"doi\":\"10.1145/3196494.3196540\",\"id\":\"b5\"},\"end\":195042,\"start\":194729},{\"attributes\":{\"id\":\"b6\"},\"end\":195230,\"start\":195044},{\"attributes\":{\"id\":\"b7\"},\"end\":195536,\"start\":195232},{\"attributes\":{\"id\":\"b8\",\"matched_paper_id\":11106583},\"end\":196069,\"start\":195538},{\"attributes\":{\"id\":\"b9\"},\"end\":196316,\"start\":196071},{\"attributes\":{\"id\":\"b10\"},\"end\":196557,\"start\":196318},{\"attributes\":{\"id\":\"b11\",\"matched_paper_id\":128354071},\"end\":197022,\"start\":196559},{\"attributes\":{\"id\":\"b12\",\"matched_paper_id\":204893515},\"end\":197423,\"start\":197024},{\"attributes\":{\"doi\":\"10.1145/1346281.1346295\",\"id\":\"b13\",\"matched_paper_id\":8254904},\"end\":198235,\"start\":197425},{\"attributes\":{\"doi\":\"10.1145/2892208.2892212\",\"id\":\"b14\",\"matched_paper_id\":15649474},\"end\":198761,\"start\":198237},{\"attributes\":{\"doi\":\"10.14722/ndss.2017.23287\",\"id\":\"b15\",\"matched_paper_id\":4960605},\"end\":199133,\"start\":198763},{\"attributes\":{\"doi\":\"10.14722/ndss.2017.23287\",\"id\":\"b16\",\"matched_paper_id\":142767},\"end\":199599,\"start\":199135},{\"attributes\":{\"doi\":\"10.1145/2663716.2663755\",\"id\":\"b17\",\"matched_paper_id\":889967},\"end\":199868,\"start\":199601},{\"attributes\":{\"doi\":\"10.1145/2663716.2663755\",\"id\":\"b18\",\"matched_paper_id\":211171916},\"end\":200354,\"start\":199870},{\"attributes\":{\"id\":\"b19\",\"matched_paper_id\":33312514},\"end\":200852,\"start\":200356},{\"attributes\":{\"id\":\"b20\"},\"end\":201605,\"start\":200854},{\"attributes\":{\"id\":\"b21\",\"matched_paper_id\":215807339},\"end\":201975,\"start\":201607},{\"attributes\":{\"doi\":\"2020/336\",\"id\":\"b22\"},\"end\":202267,\"start\":201977},{\"attributes\":{\"id\":\"b23\"},\"end\":202422,\"start\":202269},{\"attributes\":{\"id\":\"b24\"},\"end\":202621,\"start\":202424},{\"attributes\":{\"id\":\"b25\"},\"end\":203002,\"start\":202623},{\"attributes\":{\"doi\":\"10.1109/MICRO50266.2020.00095\",\"id\":\"b26\",\"matched_paper_id\":222331525},\"end\":203442,\"start\":203004},{\"attributes\":{\"id\":\"b27\"},\"end\":203700,\"start\":203444},{\"attributes\":{\"doi\":\"10.1109/ISCC50000.2020.9219582\",\"id\":\"b28\",\"matched_paper_id\":210707207},\"end\":204151,\"start\":203702},{\"attributes\":{\"doi\":\"10.1145/1851275.1851200\",\"id\":\"b29\",\"matched_paper_id\":3096687},\"end\":204570,\"start\":204153},{\"attributes\":{\"doi\":\"10.1145/2508859.2516713\",\"id\":\"b30\",\"matched_paper_id\":14648609},\"end\":205403,\"start\":204572},{\"attributes\":{\"doi\":\"10.1145/2508859.2516713\",\"id\":\"b31\",\"matched_paper_id\":6119920},\"end\":205971,\"start\":205405},{\"attributes\":{\"id\":\"b32\",\"matched_paper_id\":17420157},\"end\":206458,\"start\":205973},{\"attributes\":{\"id\":\"b33\"},\"end\":206641,\"start\":206460},{\"attributes\":{\"id\":\"b34\",\"matched_paper_id\":53721743},\"end\":207200,\"start\":206643},{\"attributes\":{\"id\":\"b35\",\"matched_paper_id\":212626414},\"end\":207803,\"start\":207202},{\"attributes\":{\"doi\":\"10.1145/3243734.3243826\",\"id\":\"b36\",\"matched_paper_id\":53110794},\"end\":208474,\"start\":207805},{\"attributes\":{\"doi\":\"10.1109/2.982916\",\"id\":\"b37\",\"matched_paper_id\":172246},\"end\":208978,\"start\":208476},{\"attributes\":{\"doi\":\"10.1109/2.982916\",\"id\":\"b38\"},\"end\":209260,\"start\":208980},{\"attributes\":{\"doi\":\"10.1145/2366231.2337181\",\"id\":\"b39\",\"matched_paper_id\":2215568},\"end\":209714,\"start\":209262},{\"attributes\":{\"doi\":\"10.1145/1806651.1806657\",\"id\":\"b40\",\"matched_paper_id\":914358},\"end\":210295,\"start\":209716},{\"attributes\":{\"doi\":\"10.1145/1806651.1806657\",\"id\":\"b41\"},\"end\":210601,\"start\":210297},{\"attributes\":{\"id\":\"b42\"},\"end\":210871,\"start\":210603},{\"attributes\":{\"id\":\"b43\"},\"end\":211318,\"start\":210873},{\"attributes\":{\"doi\":\"10.1145/3224423\",\"id\":\"b44\"},\"end\":211641,\"start\":211320},{\"attributes\":{\"doi\":\"10.1145/3352460.3358299\",\"id\":\"b45\",\"matched_paper_id\":174799235},\"end\":212326,\"start\":211643},{\"attributes\":{\"doi\":\"10.1145/3352460.3358299\",\"id\":\"b46\"},\"end\":212651,\"start\":212328},{\"attributes\":{\"id\":\"b47\",\"matched_paper_id\":11024896},\"end\":213245,\"start\":212653},{\"attributes\":{\"id\":\"b48\"},\"end\":213613,\"start\":213247},{\"attributes\":{\"id\":\"b49\",\"matched_paper_id\":14698843},\"end\":213986,\"start\":213615},{\"attributes\":{\"doi\":\"10.1109/ISCA45697.2020.00068\",\"id\":\"b50\",\"matched_paper_id\":218537479},\"end\":214514,\"start\":213988},{\"attributes\":{\"doi\":\"10.1109/ISCA45697.2020.00068\",\"id\":\"b51\"},\"end\":214726,\"start\":214516},{\"attributes\":{\"doi\":\"10.1109/ISCA.2018.00056\",\"id\":\"b52\",\"matched_paper_id\":19177604},\"end\":215091,\"start\":214728},{\"attributes\":{\"doi\":\"10.1109/MICRO.2004.20\",\"id\":\"b53\",\"matched_paper_id\":876310},\"end\":215580,\"start\":215093},{\"attributes\":{\"doi\":\"10.1145/3064176.3064211\",\"id\":\"b54\",\"matched_paper_id\":15587583},\"end\":216130,\"start\":215582},{\"attributes\":{\"doi\":\"10.1109/HPCA.2007.346205\",\"id\":\"b55\",\"matched_paper_id\":6126356},\"end\":216669,\"start\":216132},{\"attributes\":{\"doi\":\"10.1109/HPCA.2007.346205\",\"id\":\"b56\",\"matched_paper_id\":7346980},\"end\":217351,\"start\":216671},{\"attributes\":{\"id\":\"b57\"},\"end\":217553,\"start\":217353},{\"attributes\":{\"doi\":\"10.1145/3352460.3358288\",\"id\":\"b58\",\"matched_paper_id\":202726723},\"end\":218483,\"start\":217555},{\"attributes\":{\"doi\":\"10.1145/3297858.3304017\",\"id\":\"b59\",\"matched_paper_id\":102347768},\"end\":219259,\"start\":218485},{\"attributes\":{\"doi\":\"10.1145/3297858.3304017\",\"id\":\"b60\",\"matched_paper_id\":4570557},\"end\":219677,\"start\":219261}]", "bib_title": "[{\"end\":192826,\"start\":192761},{\"end\":193283,\"start\":193226},{\"end\":193954,\"start\":193918},{\"end\":194150,\"start\":194100},{\"end\":195609,\"start\":195538},{\"end\":196159,\"start\":196071},{\"end\":196602,\"start\":196559},{\"end\":197057,\"start\":197024},{\"end\":197506,\"start\":197425},{\"end\":198281,\"start\":198237},{\"end\":198808,\"start\":198763},{\"end\":199159,\"start\":199135},{\"end\":199636,\"start\":199601},{\"end\":199936,\"start\":199870},{\"end\":200391,\"start\":200356},{\"end\":201650,\"start\":201607},{\"end\":203047,\"start\":203004},{\"end\":203766,\"start\":203702},{\"end\":204176,\"start\":204153},{\"end\":204710,\"start\":204572},{\"end\":205467,\"start\":205405},{\"end\":206045,\"start\":205973},{\"end\":206712,\"start\":206643},{\"end\":207279,\"start\":207202},{\"end\":207899,\"start\":207805},{\"end\":208517,\"start\":208476},{\"end\":209348,\"start\":209262},{\"end\":209761,\"start\":209716},{\"end\":211702,\"start\":211643},{\"end\":212700,\"start\":212653},{\"end\":213655,\"start\":213615},{\"end\":214077,\"start\":213988},{\"end\":214761,\"start\":214728},{\"end\":215182,\"start\":215093},{\"end\":215624,\"start\":215582},{\"end\":216221,\"start\":216132},{\"end\":216760,\"start\":216671},{\"end\":217651,\"start\":217555},{\"end\":218558,\"start\":218485},{\"end\":219314,\"start\":219261}]", "bib_author": "[{\"end\":192843,\"start\":192828},{\"end\":192860,\"start\":192843},{\"end\":193299,\"start\":193285},{\"end\":193314,\"start\":193299},{\"end\":193327,\"start\":193314},{\"end\":193350,\"start\":193327},{\"end\":193363,\"start\":193350},{\"end\":193378,\"start\":193363},{\"end\":193728,\"start\":193716},{\"end\":193741,\"start\":193728},{\"end\":193754,\"start\":193741},{\"end\":193765,\"start\":193754},{\"end\":193968,\"start\":193956},{\"end\":193982,\"start\":193968},{\"end\":194166,\"start\":194152},{\"end\":194181,\"start\":194166},{\"end\":194195,\"start\":194181},{\"end\":194210,\"start\":194195},{\"end\":194775,\"start\":194764},{\"end\":194791,\"start\":194775},{\"end\":195335,\"start\":195314},{\"end\":195626,\"start\":195611},{\"end\":195641,\"start\":195626},{\"end\":195656,\"start\":195641},{\"end\":195669,\"start\":195656},{\"end\":196174,\"start\":196161},{\"end\":196395,\"start\":196382},{\"end\":196617,\"start\":196604},{\"end\":196631,\"start\":196617},{\"end\":196648,\"start\":196631},{\"end\":196667,\"start\":196648},{\"end\":196683,\"start\":196667},{\"end\":197072,\"start\":197059},{\"end\":197100,\"start\":197072},{\"end\":197114,\"start\":197100},{\"end\":197522,\"start\":197508},{\"end\":197538,\"start\":197522},{\"end\":197555,\"start\":197538},{\"end\":197572,\"start\":197555},{\"end\":198294,\"start\":198283},{\"end\":198300,\"start\":198294},{\"end\":198312,\"start\":198300},{\"end\":198317,\"start\":198312},{\"end\":198826,\"start\":198810},{\"end\":198838,\"start\":198826},{\"end\":198851,\"start\":198838},{\"end\":198862,\"start\":198851},{\"end\":199178,\"start\":199161},{\"end\":199188,\"start\":199178},{\"end\":199202,\"start\":199188},{\"end\":199217,\"start\":199202},{\"end\":199233,\"start\":199217},{\"end\":199248,\"start\":199233},{\"end\":199264,\"start\":199248},{\"end\":199278,\"start\":199264},{\"end\":199291,\"start\":199278},{\"end\":199307,\"start\":199291},{\"end\":199325,\"start\":199307},{\"end\":199971,\"start\":199938},{\"end\":199984,\"start\":199971},{\"end\":199988,\"start\":199984},{\"end\":200415,\"start\":200393},{\"end\":200431,\"start\":200415},{\"end\":200443,\"start\":200431},{\"end\":200457,\"start\":200443},{\"end\":200472,\"start\":200457},{\"end\":200487,\"start\":200472},{\"end\":200882,\"start\":200856},{\"end\":200900,\"start\":200882},{\"end\":200919,\"start\":200900},{\"end\":200934,\"start\":200919},{\"end\":200953,\"start\":200934},{\"end\":200967,\"start\":200953},{\"end\":200980,\"start\":200967},{\"end\":201005,\"start\":200980},{\"end\":201027,\"start\":201005},{\"end\":201041,\"start\":201027},{\"end\":201057,\"start\":201041},{\"end\":201073,\"start\":201057},{\"end\":201087,\"start\":201073},{\"end\":201106,\"start\":201087},{\"end\":201128,\"start\":201106},{\"end\":201147,\"start\":201128},{\"end\":201164,\"start\":201147},{\"end\":201177,\"start\":201164},{\"end\":201191,\"start\":201177},{\"end\":201203,\"start\":201191},{\"end\":201220,\"start\":201203},{\"end\":201229,\"start\":201220},{\"end\":201667,\"start\":201652},{\"end\":201687,\"start\":201667},{\"end\":201695,\"start\":201687},{\"end\":202051,\"start\":202036},{\"end\":202069,\"start\":202051},{\"end\":202085,\"start\":202069},{\"end\":202480,\"start\":202472},{\"end\":202498,\"start\":202480},{\"end\":202509,\"start\":202498},{\"end\":202669,\"start\":202625},{\"end\":202714,\"start\":202669},{\"end\":202755,\"start\":202714},{\"end\":203056,\"start\":203049},{\"end\":203063,\"start\":203056},{\"end\":203070,\"start\":203063},{\"end\":203486,\"start\":203468},{\"end\":203780,\"start\":203768},{\"end\":203791,\"start\":203780},{\"end\":203800,\"start\":203791},{\"end\":203810,\"start\":203800},{\"end\":204198,\"start\":204178},{\"end\":204212,\"start\":204198},{\"end\":204224,\"start\":204212},{\"end\":204240,\"start\":204224},{\"end\":204253,\"start\":204240},{\"end\":204267,\"start\":204253},{\"end\":204725,\"start\":204712},{\"end\":204738,\"start\":204725},{\"end\":204756,\"start\":204738},{\"end\":204773,\"start\":204756},{\"end\":204778,\"start\":204773},{\"end\":204791,\"start\":204778},{\"end\":205486,\"start\":205469},{\"end\":205500,\"start\":205486},{\"end\":205515,\"start\":205500},{\"end\":205528,\"start\":205515},{\"end\":205540,\"start\":205528},{\"end\":205549,\"start\":205540},{\"end\":205560,\"start\":205549},{\"end\":206060,\"start\":206047},{\"end\":206073,\"start\":206060},{\"end\":206509,\"start\":206495},{\"end\":206732,\"start\":206714},{\"end\":206746,\"start\":206732},{\"end\":206756,\"start\":206746},{\"end\":206777,\"start\":206756},{\"end\":206794,\"start\":206777},{\"end\":206804,\"start\":206794},{\"end\":207294,\"start\":207281},{\"end\":207307,\"start\":207294},{\"end\":207324,\"start\":207307},{\"end\":207339,\"start\":207324},{\"end\":207359,\"start\":207339},{\"end\":207373,\"start\":207359},{\"end\":207914,\"start\":207901},{\"end\":207929,\"start\":207914},{\"end\":207943,\"start\":207929},{\"end\":208538,\"start\":208519},{\"end\":208559,\"start\":208538},{\"end\":208576,\"start\":208559},{\"end\":208593,\"start\":208576},{\"end\":208610,\"start\":208593},{\"end\":208625,\"start\":208610},{\"end\":208642,\"start\":208625},{\"end\":208660,\"start\":208642},{\"end\":208674,\"start\":208660},{\"end\":208993,\"start\":208980},{\"end\":209371,\"start\":209350},{\"end\":209381,\"start\":209371},{\"end\":209395,\"start\":209381},{\"end\":209406,\"start\":209395},{\"end\":209793,\"start\":209763},{\"end\":209808,\"start\":209793},{\"end\":209822,\"start\":209808},{\"end\":209833,\"start\":209822},{\"end\":210401,\"start\":210384},{\"end\":210998,\"start\":210979},{\"end\":211017,\"start\":210998},{\"end\":211034,\"start\":211017},{\"end\":211049,\"start\":211034},{\"end\":211066,\"start\":211049},{\"end\":211720,\"start\":211704},{\"end\":211737,\"start\":211720},{\"end\":211755,\"start\":211737},{\"end\":211771,\"start\":211755},{\"end\":211784,\"start\":211771},{\"end\":211805,\"start\":211784},{\"end\":212436,\"start\":212417},{\"end\":212725,\"start\":212702},{\"end\":212741,\"start\":212725},{\"end\":212762,\"start\":212741},{\"end\":212778,\"start\":212762},{\"end\":213266,\"start\":213247},{\"end\":213284,\"start\":213266},{\"end\":213305,\"start\":213284},{\"end\":213323,\"start\":213305},{\"end\":213338,\"start\":213323},{\"end\":213671,\"start\":213657},{\"end\":214095,\"start\":214079},{\"end\":214110,\"start\":214095},{\"end\":214581,\"start\":214565},{\"end\":214772,\"start\":214763},{\"end\":214789,\"start\":214772},{\"end\":215197,\"start\":215184},{\"end\":215210,\"start\":215197},{\"end\":215227,\"start\":215210},{\"end\":215646,\"start\":215626},{\"end\":215660,\"start\":215646},{\"end\":215681,\"start\":215660},{\"end\":216240,\"start\":216223},{\"end\":216250,\"start\":216240},{\"end\":216261,\"start\":216250},{\"end\":216274,\"start\":216261},{\"end\":216774,\"start\":216762},{\"end\":216791,\"start\":216774},{\"end\":216809,\"start\":216791},{\"end\":216826,\"start\":216809},{\"end\":216842,\"start\":216826},{\"end\":216858,\"start\":216842},{\"end\":216874,\"start\":216858},{\"end\":216887,\"start\":216874},{\"end\":216901,\"start\":216887},{\"end\":216908,\"start\":216901},{\"end\":217409,\"start\":217399},{\"end\":217666,\"start\":217653},{\"end\":217685,\"start\":217666},{\"end\":217700,\"start\":217685},{\"end\":217721,\"start\":217700},{\"end\":217734,\"start\":217721},{\"end\":217756,\"start\":217734},{\"end\":217768,\"start\":217756},{\"end\":217785,\"start\":217768},{\"end\":217800,\"start\":217785},{\"end\":217812,\"start\":217800},{\"end\":217830,\"start\":217812},{\"end\":217837,\"start\":217830},{\"end\":218572,\"start\":218560},{\"end\":218586,\"start\":218572},{\"end\":218601,\"start\":218586},{\"end\":219331,\"start\":219316},{\"end\":219344,\"start\":219331},{\"end\":219357,\"start\":219344}]", "bib_venue": "[{\"end\":192997,\"start\":192950},{\"end\":194432,\"start\":194328},{\"end\":195773,\"start\":195720},{\"end\":197869,\"start\":197732},{\"end\":198508,\"start\":198424},{\"end\":198939,\"start\":198921},{\"end\":199372,\"start\":199369},{\"end\":199721,\"start\":199704},{\"end\":200096,\"start\":200062},{\"end\":200619,\"start\":200560},{\"end\":201806,\"start\":201759},{\"end\":203199,\"start\":203178},{\"end\":205004,\"start\":204909},{\"end\":205636,\"start\":205618},{\"end\":206244,\"start\":206167},{\"end\":206889,\"start\":206855},{\"end\":207526,\"start\":207458},{\"end\":208158,\"start\":208063},{\"end\":210018,\"start\":209937},{\"end\":211492,\"start\":211422},{\"end\":211998,\"start\":211914},{\"end\":212925,\"start\":212855},{\"end\":213826,\"start\":213757},{\"end\":214231,\"start\":214216},{\"end\":215867,\"start\":215786},{\"end\":216982,\"start\":216972},{\"end\":218030,\"start\":217946},{\"end\":218916,\"start\":218769},{\"end\":192948,\"start\":192886},{\"end\":193429,\"start\":193404},{\"end\":193714,\"start\":193679},{\"end\":193990,\"start\":193982},{\"end\":194326,\"start\":194233},{\"end\":194762,\"start\":194729},{\"end\":195104,\"start\":195044},{\"end\":195312,\"start\":195232},{\"end\":195718,\"start\":195669},{\"end\":196183,\"start\":196174},{\"end\":196380,\"start\":196318},{\"end\":196720,\"start\":196683},{\"end\":197151,\"start\":197114},{\"end\":197730,\"start\":197595},{\"end\":198422,\"start\":198340},{\"end\":198919,\"start\":198886},{\"end\":199367,\"start\":199349},{\"end\":199702,\"start\":199661},{\"end\":200060,\"start\":200011},{\"end\":200558,\"start\":200487},{\"end\":201757,\"start\":201695},{\"end\":202034,\"start\":201977},{\"end\":202296,\"start\":202269},{\"end\":202470,\"start\":202424},{\"end\":203176,\"start\":203099},{\"end\":203466,\"start\":203444},{\"end\":203901,\"start\":203840},{\"end\":204331,\"start\":204290},{\"end\":204907,\"start\":204814},{\"end\":205616,\"start\":205583},{\"end\":206165,\"start\":206073},{\"end\":206493,\"start\":206460},{\"end\":206853,\"start\":206804},{\"end\":207456,\"start\":207373},{\"end\":208061,\"start\":207966},{\"end\":208698,\"start\":208690},{\"end\":209100,\"start\":209009},{\"end\":209457,\"start\":209429},{\"end\":209935,\"start\":209856},{\"end\":210382,\"start\":210297},{\"end\":210627,\"start\":210603},{\"end\":210977,\"start\":210873},{\"end\":211420,\"start\":211335},{\"end\":211912,\"start\":211828},{\"end\":212415,\"start\":212328},{\"end\":212853,\"start\":212778},{\"end\":213404,\"start\":213338},{\"end\":213755,\"start\":213671},{\"end\":214214,\"start\":214138},{\"end\":214563,\"start\":214516},{\"end\":214888,\"start\":214812},{\"end\":215297,\"start\":215248},{\"end\":215784,\"start\":215704},{\"end\":216380,\"start\":216298},{\"end\":216970,\"start\":216932},{\"end\":217397,\"start\":217353},{\"end\":217944,\"start\":217860},{\"end\":218767,\"start\":218624},{\"end\":219462,\"start\":219380}]"}}}, "year": 2023, "month": 12, "day": 17}