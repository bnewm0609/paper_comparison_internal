{"id": 50768744, "updated": "2022-03-01 19:57:05.77", "metadata": {"title": "A search-based approach for accurate identification of log message formats", "authors": "[{\"first\":\"Salma\",\"last\":\"Messaoudi\",\"middle\":[]},{\"first\":\"Annibale\",\"last\":\"Panichella\",\"middle\":[]},{\"first\":\"Domenico\",\"last\":\"Bianculli\",\"middle\":[]},{\"first\":\"Lionel\",\"last\":\"Briand\",\"middle\":[]},{\"first\":\"Raimondas\",\"last\":\"Sasnauskas\",\"middle\":[]}]", "venue": null, "journal": "Proceedings of the 26th Conference on Program Comprehension", "publication_date": {"year": 2018, "month": null, "day": null}, "abstract": "Many software engineering activities process the events contained in log files. However, before performing any processing activity, it is necessary to parse the entries in a log file, to retrieve the actual events recorded in the log. Each event is denoted by a log message, which is composed of a fixed part---called (event) template---that is the same for all occurrences of the same event type, and a variable part, which may vary with each event occurrence. The formats of log messages, in complex and evolving systems, have numerous variations, are typically not entirely known, and change on a frequent basis; therefore, they need to be identified automatically. The log message format identification problem deals with the identification of the different templates used in the messages of a log. Any solution to this problem has to generate templates that meet two main goals: generating templates that are not too general, so as to distinguish different events, but also not too specific, so as not to consider different occurrences of the same event as following different templates; however, these goals are conflicting. In this paper, we present the MoLFI approach, which recasts the log message identification problem as a multi-objective problem. MoLFI uses an evolutionary approach to solve this problem, by tailoring the NSGA-II algorithm to search the space of solutions for a Pareto optimal set of message templates. We have implemented MoLFI in a tool, which we have evaluated on six real-world datasets, containing log files with a number of entries ranging from 2K to 300K. The experiments results show that MoLFI extracts by far the highest number of correct log message templates, significantly outperforming two state-of-the-art approaches on all datasets.", "fields_of_study": "[\"Computer Science\"]", "external_ids": {"arxiv": null, "mag": "2792207129", "acl": null, "pubmed": null, "pubmedcentral": null, "dblp": "conf/iwpc/MessaoudiPBBS18", "doi": "10.1145/3196321.3196340"}}, "content": {"source": {"pdf_hash": "4dc55862f1dbfd057727ce9bb7351ce1a724a679", "pdf_src": "ACM", "pdf_uri": null, "oa_url_match": false, "oa_info": {"license": null, "open_access_url": "https://repository.tudelft.nl/islandora/object/uuid:a73fb4d3-8e99-49f0-83b2-c2e361773c34/datastream/OBJ/download", "status": "GREEN"}}, "grobid": {"id": "ee96da41fbce8517330d70565fcb55662c4c3df1", "type": "plain-text", "url": "s3://ai2-s2-pdf-extraction-prod/parse-results/s2orc_worker/4dc55862f1dbfd057727ce9bb7351ce1a724a679.txt", "contents": "\nA Search-based Approach for Accurate Identification of Log Message Formats KEYWORDS log parsing, log analysis, log message format, NSGA-II ACM Reference Format\nMay 27-28. 2018\n\nSalma Messaoudi salma.messaoudi@uni.lu \nAnnibale Panichella a.panichella@tudelft.nl \nDomenico Bianculli domenico.bianculli@uni.lu \nLionel Briand lionel.briand@uni.lu \nRaimondas Sasnauskas raimondas.sasnauskas@ses.com \nSalma Messaoudi \nAnnibale Panichella \nDomenico Bianculli \nLionel Briand \n\nUniversity of Luxembourg\nLuxembourg\n\n\nUniversity of Luxembourg\nLuxembourg\n\n\nUniversity of Luxembourg\nLuxembourg\n\n\nUniversity of Luxembourg\nLuxembourg\n\n\nSES\nLuxembourg\n\nA Search-based Approach for Accurate Identification of Log Message Formats KEYWORDS log parsing, log analysis, log message format, NSGA-II ACM Reference Format\n\nICPC '18\nGothenburg, SwedenMay 27-28. 201810.1145/3196321.3196340/18/05. . . $15.00 and Raimondas Sasnauskas. 2018. A Search-based Approach for Accurate Identification of Log Message Formats. In Proceedings of ICPC '18: 26th IEEE/ACM International Conference on Program Comprehension (ICPC '18). ACM, New York, NY, USA, 11 pages. https://\nMany software engineering activities process the events contained in log files. However, before performing any processing activity, it is necessary to parse the entries in a log file, to retrieve the actual events recorded in the log. Each event is denoted by a log message, which is composed of a fixed part-called (event) template-that is the same for all occurrences of the same event type, and a variable part, which may vary with each event occurrence. The formats of log messages, in complex and evolving systems, have numerous variations, are typically not entirely known, and change on a frequent basis; therefore, they need to be identified automatically.The log message format identification problem deals with the identification of the different templates used in the messages of a log. Any solution to this problem has to generate templates that meet two main goals: generating templates that are not too general, so as to distinguish different events, but also not too specific, so as not to consider different occurrences of the same event as following different templates; however, these goals are conflicting.In this paper, we present the MoLFI approach, which recasts the log message identification problem as a multi-objective problem. MoLFI uses an evolutionary approach to solve this problem, by tailoring the NSGA-II algorithm to search the space of solutions for a Pareto optimal set of message templates. We have implemented MoLFI in a tool, which we have evaluated on six real-world datasets, containing log files with a number of entries ranging from 2K to 300K. The experiments results show that MoLFI extracts by far the highest number of correct log message templates, significantly outperforming two state-of-the-art approaches on all datasets.CCS CONCEPTS\u2022 Software and its engineering \u2192 Search-based software engineering;\n\nINTRODUCTION\n\nLogging is a programming practice that is used for gathering runtime information of a software system. Developers carry out logging by inserting into the source code of an application statements that specify which messages and which run-time information to print into the entries of log files.\n\nLogging is a pervasive activity: recent studies [35,36] show that between 1/30 and 1/58 of the lines of code in large software systems correspond to logging statements. Furthermore, the importance of logging is also recognized by developers: a recent survey reported that 96% of a group of experienced developers from a leading software company \"strongly agree/agree that logging statements are important in system development and maintenance\" [13]. Indeed, the information contained in log files can be used for a variety of purposes, such as process mining [15,30], anomaly detection [4,12,14], behavioral differencing [14], fault localization [33], invariant inference [5], performance diagnosis [21], and offline trace checking [3].\n\nAll these activities carry out some sort of log analysis, which processes the events corresponding to the entries contained in the log files. Before performing any processing activity, it is necessary to parse the log entries, to retrieve the actual events recorded in the log. A log entry typically includes a timestamp (which records the time at which the logged event occurred) and the actual log message (containing run-time information associated with the logged event). An example of log entry is the following: 20050605-06.45.36 send RST CORE to addr 0x0000df30\n\nThe log message part of a log entry (e.g., the block \"send RST CORE to addr 0x0000df30\" in the above example) is a block of free-form text, which poses a challenge to parsing because it does not have a structured format. More specifically, a log message is composed of two parts: 1) a fixed part, also called (event) template 1 , which is the same for all occurrences of the same event type; 2) a variable part, which may vary with each event occurrence, containing tokens filled at run time with dynamic information. In the above example, the template contains the fixed words \"send\", \"to\", \"addr\", while \"RST\", \"CORE\" and \"0x0000df30\" are variable tokens. A template is represented as \"send * * to address *\", where the asterisks indicate placeholders for tokens of the variable part.\n\nThe lack of a structured format for log messages leads to the definition of the log message format identification 2 problem: given a log file, we want to identify the different templates used in the log messages contained in the log in order to enable automated data extraction and analysis on a large scale.\n\nSolving this problem for complex and evolving systems requires to tackle several challenging issues. First, in these systems log message formats are numerous, changing on a frequent basis (e.g., in Google systems hundreds of new logging statements are added every month [34]), and are typically not entirely known by those who need to analyze log files.\n\nSecond, these systems can produce around 120-200 million log entries per hour [20]. Therefore, log message formats need to be identified automatically and in a scalable way.\n\nSuch requirements rule out the use of regular expressions for extracting the templates, since it would still require a manual effort, to create and update regular expressions based on the logging statements contained in the source code of the application. Manual creation and update of regular expressions would be a tedious and error-prone task, given the number of logging statements and the fast pace of their updates [34]. Another strategy would be to statically analyze the application source code, locate logging statements, and extract the templates from the print operations. However, the definition of the static analysis would be tedious and require an extensive knowledge of logging techniques, since logging statements can take different forms in different programming languages and logging frameworks. Furthermore, both strategies outlined above would require to access the source code, which is not always possible, especially in the case of complex software systems that rely on 3rd-party components.\n\nTo overcome these limitations, some approaches [11,12,17,19] adopt a black-box strategy that relies on a combination of clustering and heuristic rules to group words into templates, based on their similarity and the frequency within log message blocks. However, our experience on real-world logs shows that these approaches yield low accuracy, as demonstrated by the empirical results reported in this paper. Furthermore, their parameters (e.g., text similarity) need to be fine-tuned for each log to analyze, usually following a trial-and-error process; these requirements make such approaches neither scalable nor effective.\n\nIndependently from the specific strategy adopted, any technique for extracting message templates from logs ought to meet two objectives: the generated templates should 1) match as many log messages as possible (i.e., achieve high frequency in matching log messages); 2) correspond to the largest extent possible to a particular type of event (i.e., achieve high specificity). However, these two objectives-high frequency and high specificity-are conflicting. A template achieving high frequency will contain many tokens in the variable part (to match many log messages), but will be too generic (i.e., it will match messages corresponding to different events); on the other hand, a template achieving high specificity will have a few or no tokens in the variable part (to be able to distinguish between different event types), but it will match only few messages.\n\nGiven the presence of conflicting objectives and the limitations of existing solutions [11,12,17,19], in this paper we propose to recast the log message format identification problem as a multi-objective optimization problem, where frequency and specificity are explicitly considered as two competing objectives to optimize simultaneously. Our approach, named MoLFI (Multi-objective Log message Format Identification), leverages an evolutionary approach to solve this problem. MoLFI applies the Non-dominated Sorting Genetic Algorithm II (NSGA-II [10]) on a given log file to search the space of solutions for a Pareto optimal set of message templates. The two main strong points of MoLFI are: 1) it does not require access to the source code of the application producing the log(s) being analyzed, since it is a black-box technique that works only on the log files; 2) different from existing approaches, it does not require any parameter tuning before its execution.\n\nWe implemented MoLFI in a prototype tool. We evaluated the accuracy and efficiency of MoLFI on one proprietary and five publiclyavailable real-world datasets, containing log files with a number of entries ranging from 2K to 300K; we also compared our approach with IPLoM [19] and Drain [17], two state-of-the-art approaches. The results show that MoLFI achieves by far the highest precision and recall, outperforming the other approaches with substantial improvements in both precision (ranging between +14 pp and +86 pp, with pp=percentage points) and recall (ranging between +25 pp and +75 pp) on all datasets, while keeping a running time of less than 126 s when analyzing the largest dataset. A higher accuracy in the identification of log message formats usually has practical implications, in terms of effectiveness, in the log analysis tasks that rely on log message format identification. For example, in the context of anomaly detection-the original motivation for existing work [12,17]-log analysis is effective only when the parsing accuracy is high enough [16].\n\nTo summarize, the main contributions of this paper are: 1) the formulation of the log message format identification problem as a multi-objective optimization problem; 2) the MoLFI approach for the solution of this problem, based on the NSGA-II algorithm; 3) a publicly-available implementation of MoLFI 3 ; 4) the empirical evaluation, in terms of accuracy and efficiency, of the implementation of MoLFI and its comparison with two state-of-the-art approaches.\n\nThe rest of the paper is organized as follows. Section 2 gives an overview of multi-objective optimization and genetic algorithms. Section 3 illustrates the problem of log message format identification with an example. Section 4 describes how MoLFI tailors NSGA-II to solve the log message identification problem. Section 5 reports on the evaluation of MoLFI. Section 6 discusses practical implications, alternative solutions, and limitations of our approach. Section 7 examines related work. Section 8 concludes the paper and gives directions for future work.\n\n\nBACKGROUND\n\nThis section summarizes basic concepts of multi-objective optimization and briefly describes NSGA-II [10].\n\n\nMulti-objective optimization problems\n\nA multi-objective problem is an optimization problem that involves multiple objective functions.\n\nLet S be the space (set) of all feasible solutions and F be a vector-valued objective function F : S \u2192 R k composed of k realvalued objective functions F = (f 1 , . . . , f k ), where f i : S \u2192 R for j = 1, . . . , k; a multi-objective optimization problem is defined as max(f 1 (x), . . . , f k (x)) subject to X \u2286 S. In other words, the problem consists in finding a set of feasible solutions that maximize the objective functions in F .\n\nThe goodness of a solution in a multi-objective optimization problem is defined in terms of the dominance relation and Pareto optimality. More precisely, a solution X is said to dominate another solution Y , denoted as X \u227a Y , if and only if for\nall indices i \u2208 {1, . . . , k }, f i (X ) \u2265 f i (Y ) and f j (X ) > f j (Y ) for at least one index j \u2208 {1, . . . , k}.\nA solution X is called Pareto optimal if there does not exist another solution in the search space that dominates it. The set of all Pareto optimal solutions of a given problem is called Pareto front. The Pareto front can be used to decide which solution to select, according to the preferences of a decision maker.\n\n\nNSGA-II\n\nThe Non-dominated Sorting Genetic Algorithm II (NSGA-II) [10] is a well-known and efficient technique to solve multi-objective problems. NSGA-II is a multi-objective genetic algorithm (GA) that provides well-distributed Pareto fronts and good performance when dealing with up to three objectives [10,18]; it has been widely used in software engineering to solve problems involving multiple objectives [32] and with chromosome representations that require complex data structures (as in our case, see Section 4.2.2).\n\nIn NSGA-II (and GAs in general), the candidate solutions to a problem are called chromosomes. The encoding of a chromosome depends on the type of problem to solve. GAs refine and evolve randomly-generated chromosomes through subsequent iterations (called generations), mimicking selection and reproduction mechanisms in nature.\n\nNSGA-II starts with a pool of randomly generated chromosomes (i.e., population). In each generation, the algorithm evaluates the goodness of a chromosome in the current population based on the objectives to optimize. Chromosomes dominating other chromosomes are considered as fitter solutions and therefore have higher chances to be selected for reproduction (i.e., for generating new chromosomes). NSGA-II selects the best solutions (parents) within the current population by using binary tournament selection [10]. Reproduction is performed by combining pairs of parents to form new chromosomes (called offsprings) using two operators: crossover and mutation. The crossover operator generates two offsprings by exchanging some chromosome parts between the two parents. The mutation operator applies small changes to each offspring to get a more diverse solution. Notice that the implementation of mutation and crossover depends on the problem to solve. The new population for the next generation is formed by selecting the fittest individuals among parents and offsprings according to the dominance relation (non-dominated ranking) and crowding distance (to promote diversity) [10]. The process of selecting and recombining chromosomes is repeated multiple times, once for each generation. It terminates either when a given amount of generations is reached or when a time-out occurs. The non-dominated solutions contained in the population of the last iteration represent the final Pareto front.\n\n\nTHE PROBLEM OF LOG MESSAGE FORMAT IDENTIFICATION\n\nWe illustrate the problem of log message format identification through the example in Figure 1, which provides a simplified excerpt of log entries extracted from an open dataset of logs collected from a BlueGene/L supercomputer system at Lawrence Livermore National Labs.\n\nOne can see that the log messages of the first three entries in the example log correspond to the same event type. This event type could be matched with the template INFO generating core * , where the variable part contains one token (indicated with the placeholder *). Similarly, entries of log messages at lines 4-5 could be matched with the template FATAL instruction address * .\n\nHowever, one could define other templates for the log messages considered above. For example, another template that could match the messages at lines 4-5 would be FATAL * * * , with three tokens in the variable part. Notice that this template is more general than the previous one, since it matches two different types of event (one type associated with messages at lines 4-5, and another type associated with the message at line 13). Another possible template would be FATAL * address 0x0000df30 , which is too specific because it matches only the log message at line 4 and misses the message at line 5, even if it is of the same event type.\n\nThese examples show that two distinct objectives must be met when identifying message templates:\n\n\u2022 maximizing the number of log messages matched by each template, i.e., maximizing the frequency of message matches; \u2022 maximizing the specificity of a template to a particular type of event.\n\nThese two goals are conflicting: to maximize frequency, templates should contain many tokens in the variable part (to match many log messages); however, such templates would have a low specificity (i.e., they would be too generic), matching messages corresponding to different events. On the other hand, to maximize specificity, templates should contain only a few or no tokens in the variable part (to be able to distinguish between different event types); however, they would match only few messages. Any method proposed to solve the log message format identification problem has to deal with the trade-off between these two conflicting goals.\n\n\nLOG MESSAGE FORMAT IDENTIFICATION AS A MULTI-OBJECTIVE OPTIMIZATION PROBLEM\n\nIn this section, we illustrate how log message format identification can be recast as a multi-objective optimization problem and present our approach MoLFI for the solution of this problem, based on NSGA-II.\n\n\nProblem Formulation\n\nAs discussed in section 3, we consider frequency and specificity as objective functions to optimize simultaneously. The multi-objective optimization formulation of the log message format identification problem entails that we find, from the set S of all feasible solutions, a set of templates X = {\u03c4 1 , . . . , \u03c4 n }, X \u2286 S, such that each template \u03c4 i \u2208 X with i = 1, . . . , n, matches as many log messages as possible (high frequency) and contains as few variable tokens as possible (high specificity). More formally, the objective functions are the frequency:\nFreq(X ) = n i=1 |match(\u03c4 i , M)| n \u00d7 |M | , and the specificity: Spec(X ) = n i=1 fixed(\u03c4 i ) n \u00d7 tok(\u03c4 i )\n, where n is the number of templates in X , M is a list of log messages, match(\u03c4 , M) denotes the list of log messages in M that match a template \u03c4 , fixed(\u03c4 ) denotes the number of tokens in the fixed part of \u03c4 , tok(\u03c4 ) denotes the total number of tokens in \u03c4 . When determining a solution to this problem, there are two important aspects to assess. First, the templates contained in a (Pareto optimal) solution may not match all the log messages in M. For example, the solution X = { FATAL instruction address 0x0000df30 , INFO generating core 135 } is Pareto optimal for the log messages in Figure 1, since it has the highest possible specificity (Spec(X ) = 1). However, the templates in X match only two out of the 15 log messages (Freq(X ) = 2 15 ). Second, two different templates \u03c4 1 and \u03c4 2 in the same solution X may match the same log messages, i.e., match(\u03c4 1 , M) \u2229 match(\u03c4 2 , M) \u2205. To avoid this type of solutions, we introduce two additional constraints to the optimization problem to determine the set of feasible solutions S. More specifically, a solution X = {\u03c4 1 , . . . , \u03c4 n } \u2286 S is feasible if it satisfies the following constraints:\nn i=1 match(\u03c4 i , M) = M (1) match(\u03c4 i , M) \u2229 match(\u03c4 j , M) = \u2205 for all \u03c4 i , \u03c4 j \u2208 X , \u03c4 i \u03c4 j (2)\n\nMoLFI\n\nTo solve the multi-objective optimization formulation of the log message format identification problem, we introduce our approach, named MoLFI, which tailors the standard NSGA-II to our context. In particular, we detail the encoding schema and the genetic operators (i.e., crossover and mutation) we use, the pre-and post-processing procedures we apply, and the procedure we follow to select one solution from the Pareto front.\n\n\nPre-processing.\n\nBefore starting the search process, we first pre-process the log messages to improve the accuracy of the process; we follow the guidelines by He et al. [16,17]. We first use regular expressions to identify trivial variable parts within the log messages based on domain knowledge, e.g., numbers, memory and IP addresses. Strings in the log messages matching these regular expressions are replaced with a special variable token #spec# that cannot be mutated in the later stages of the search. To reduce the computation cost of the template identification process, we filter out duplicated log messages, reducing the number of messages to consider for generating templates. The messages are then tokenized, using blanks, parentheses and punctuation characters as word-separators. Finally, messages are grouped into buckets, with each bucket containing messages that have the same number of tokens; we denote with M L the bucket/group containing messages with exactly L tokens.\n\n\nEncoding Schema.\n\nIn our context, a solution is a set of templates X = {\u03c4 1 , . . . , \u03c4 n } where each template \u03c4 i corresponds to a group of pre-processed log messages having the same length and sharing all fixed tokens in \u03c4 i . Therefore, each template \u03c4 i is a list of tokens, where each token can be either variable (denoted by the symbols * or #spec#) or fixed (i.e., the tokens identified during the pre-processing step).\n\nAlthough very intuitive, this encoding schema is not efficient for computing the log messages being matched by each template. Indeed, this procedure requires comparing every template against all log messages even if most of them have a number of tokens not compatible with what is prescribed by the template. To speedup the matching process, we design a two-level encoding schema: a chromosome C is a set of groups C = {G 1 , . . . ,G max }, where each group G L = {\u03c4 1 , . . . , \u03c4 k } is a set of templates having the same number of tokens L. This encoding schema guarantees that the matching procedure is applied only for messages and templates of the same length. Figure 2 shows an example of chromosome for the log messages in Figure 1 based on our encoding schema. It has four groups of templates with lengths 4, 5, 6, and 12; it also satisfies the constraints for feasible solutions.\n\n\nInitial Population.\n\nMoLFI uses the algorithm InitialPopulation (Algorithm 1) for generating the initial population. The algorithm takes as input a set of pre-processed log messages M, the population size N ; it returns a population P. Each chromosome is randomly generated inside the loop at lines 4-16: after initializing the chromosome C (line 4), it is iteratively filled with groups of templates (lines 5-15), one group of templates G L for each group of pre-processed log messages M L \u2208 M with the same length L.  \nL=6 \u23a7 \u23aa \u23aa \u23aa \u23a8 \u23aa \u23aa \u23aa \u23a9 FATAL * input interrupt enable *11 index \u2190 random integer \u2208 [1; L] 12 \u03c4 [index] \u2190 \"*\" 13 G L \u2190 G L {\u03c4 } 14 unmatched \u2190 unmatched \\ match(\u03c4 , M L ) 15 C \u2190 C {G L } 16 P \u2190 P {C }\nFor each group of messages M L \u2208 M, the algorithm creates a corresponding group of templates G L (line 6). Initially, the group G L is empty and therefore it does not match any log message. The algorithm keeps track of the unmatched messages in the set unmatched, initialized with M L (line 7). Then, a log message is randomly selected from unmatched (line 9) and used to generate a template \u03c4 (lines [10][11][12]. Template \u03c4 is a copy of the original log message with the exception of one single token (randomly selected at line 11), which is replaced with the variable token \"*\" (line 12). The newly generated template is then added to the group G L and used to update the set of unmatched log messages (line 14). The loop at lines 8-14 terminates when the templates composing the group G L match all log messages in M L (i.e., when the set unmatched is empty). Since this condition has to be satisfied for each group of messages M L \u2208 M, the chromosome C is a feasible solution. Therefore, Algorithm 1 guarantees that all chromosomes in the initial population satisfy our constraints.\n\n\nCrossover.\n\nWe implemented the uniform crossover, which is one of the most popular crossover operators [26,27]. It generates two offsprings by shuffling the different characteristics (groups of templates in our case) of the parents. Let A = {A 1 , . . . , A max } and B = {B 1 , . . . , B max } be the two selected parents where each pair of groups A L \u2208 A and B L \u2208 B matches the same pre-processed log messages M L \u2208 M with length L. The uniform crossover first generates a random binary vector \u03b2 (called the crossover mask) with a length equal to the number of groups in A and B. Then, the two offsprings O 1 and O 2 are obtained as follows: when the binary element in \u03b2 for the group with length L is zero, offspring\nO 1 inherits group A L while O 2 inherits group B L ; otherwise, O 1 inherits group B L while O 2 inherits group A L .\nNotice that this crossover operator swaps groups of templates between the two parents without changing the set of templates composing each group. Therefore, it generates offsprings that are feasible solutions: each group A L \u2208 A and B L \u2208 B covers all preprocessed log messages M L \u2208 M and they do not contain overlapping templates (i.e., templates that match the same log messages). Since A L and B L are not modified by our crossover, the properties above are preserved independently from which offspring inherits the two groups.\n\n\nMutation.\n\nAfter crossover, offsprings are mutated using the mutation operator to randomly change the generated templates. Given a chromosome to mutate C = {G 1 , . . . ,G max }, each group G L = {\u03c4 1 , . . . , \u03c4 k } is mutated with probability 1 max . A group G L is mutated by changing one of its templates; the template is mutated by adding or removing variable tokens. In particular, let \u03c4 = [token 1 , . . . , token n ] be the template to mutate; each token is mutated with probability 1 n . The token token i is mutated as follows: if it is a fixed one, it is replaced by the variable token \"*\"; if it is a variable token, it is replaced by a fixed token, which is randomly selected among all fixed tokens in position i of the log messages that match \u03c4 ; if it is the special token #spec# added during the pre-processing, it is not mutated. Therefore, our mutation operator either increases or reduces the number of variable tokens in \u03c4 . In the former scenario, it likely increases the frequency of the original template \u03c4 ; in the latter case it increases its specificity.\n\nDifferent from the crossover, the mutation operator changes the templates within the chromosome's groups. Therefore, it does not guarantee that the mutated chromosomes satisfy the feasible solution constraints. For this reason, we developed a correction operator that (i) removes overlapping templates (i.e., two or more templates matching the same pre-processed log messages), and (ii) adds randomly generated templates if a mutated group G L does not match all messages in M L . Random templates are added following the same procedure used at lines 7-14 of Algorithm 1. Notice that the correction operator is applied after the mutation operator and it is applied only to the mutated chromosome's groups.\n\n\n4.2.6\n\nPost-processing. At the end of the search, NSGA-II returns a set of feasible solutions that are Pareto optimal, i.e., representing optimal trade-off between frequency and specificity. Due to the random nature of NSGA-II, Pareto optimal solutions may contain log message templates with spurious variable tokens, i.e., variable tokens that have been inserted by mutation across the generations but that do not contribute to match more pre-processed log messages. For this reason, MoLFI post-processes the templates in each Pareto optimal chromosome with a greedy procedure, which iteratively removes all variable tokens that do not affect the frequency scores. In other words, given a template \u03c4 to post-process, the procedure temporarily removes one of its variable tokens and checks whether the set of log messages matched by \u03c4 remains unchanged. If the applied change affects the set of matched log messages, the change is reverted; otherwise it is maintained. The post-processing procedure ends once all variable tokens in \u03c4 have been verified.\n\n\nChoosing a Pareto optimal solution.\n\nIf the number of solutions in the generated Pareto front is large it may be difficult to choose one solution (best trade-off) among the different alternatives. For this reason, researchers proposed various guidelines to find and suggest points of interest in the Pareto front, such as the knee points [6], mid points [22], or the best point (corner) for each objective [23].\n\nAccording to Branke et al. [6], the most interesting Pareto optimal solution is the knee point because any other solution in the front leading to a small improvement in one of the two objectives (e.g., Freq) would lead to a large deterioration in the other objective (e.g., Spec). To provide a graphical interpretation of the knee point, Figure 3 depicts an example of Pareto front for the log message format identification problem. The Pareto front is composed of seven non-dominated solutions: points A and B are the corner solutions of the front while the other solutions represent intermediate tradeoffs. Point C can be considered as a knee point since any marginal improvement to Freq will correspond to a large deterioration in Spec, and vice versa. Therefore, the knee point leads to the lowest loss in both objectives.\n\nTo identify the knee point, we measure the distance of each Pareto optimal solution from the ideal point [26]. The coordinates of the ideal point correspond to the maximum objective values among all solutions in the Pareto front, considering each objective function separately. For example, for the Pareto front in Figure 3, the ideal point has the coordinates (F max , S max ), where F max = 0.85 (from point A) and S max = 0.9 (from point B). More formally, given a Pareto front P = C 1 , . . . ,C p , the knee point C k \u2208 P is the solution minimizing the distance (F max \u2212 Freq(C i )) 2 + (S max \u2212 Spec(C i )) 2 , for all C i \u2208 P.\n\n\nEVALUATION\n\nWe have implemented the MoLFI approach as a Python program. In this section we report on the evaluation of the effectiveness of the MoLFI implementation in identifying accurate log message formats.\n\nFirst, we want to assess the performance of MoLFI in comparison with state-of-the-art techniques, in terms of accuracy and efficiency. Second, there are various factors that may influence the effectiveness of MoLFI, such as (1) the number of templates to identify, (2) the population size in NSGA-II; (3) the removal of duplicate messages from the log file to analyze, performed as part of the pre-processing step; we want to understand whether and to what extent these factors affect the effectiveness of MoLFI. Last, in MoLFI we choose the knee point as most valuable solution from the Pareto front, following the general guidelines by Branke et al. [6]. However, different trade-offs in the Pareto front may provide equal or better results in our context; hence, we want to assess whether the knee point is the best Pareto optimal solution for the log message format identification problem.\n\nSumming up, we investigate the following research questions: RQ1: How does MoLFI perform when compared to state-of-the-art techniques for the log message format identification problem? RQ2: Which factors impact the effectiveness of MoLFI? RQ3: Is the knee point the best solution to choose from the Pareto front?\n\n\nBenchmark\n\nTo evaluate MoLFI, we used a benchmark composed of six different datasets: five datasets are publicly available and have been used in previous work on the log message format identification problem [16,17], while the last one is industrial and proprietary. The five public datasets are HDFS, BGL, HPC, Zookeeper (shortened to \"ZK\") and Proxifier (shortened to \"PRX\"). HDFS consists of logs from the Hadoop file system that were collected from a 203node cluster on the Amazon EC2 platform [16]. BGL contains logs generated from the Blue Gene/L (BGL) supercomputer, collected by the Lawrence Livermore National Labs (LLNL) [16]. The logs contained in the HPC dataset were collected from a high-performance cluster with 49 nodes and thousands of cores [16]. The logs in ZK were collected by He et al. [16,17] from a 32-node cluster. PRX consists of logs generated by a standalone software [16].\n\nThe proprietary dataset (named PR) has been provided by one of our industrial partners, active in the aerospace industry; it contains logs produced by a complex system with more than 20 distributed processes.\n\nAll datasets contain log files of various size. For the HDFS, BGL, HPC, ZK, and PRX datasets, we used the same samples of 2K log entries used in previous studies [16,17]. In addition, we also selected a sample of 100K log entries from BGL and a sample of 60K log entries from HDFS. As for the proprietary dataset, we considered three different log files, generated by three different sub-systems, containing 2K, 20K, and 300K log entries.\n\nGround truth definition. In the case of the log message format identification problem, the ground truth is represented by the actual log message templates. For our evaluation, we established the ground truth as follows.\n\nFor the log files with 2K log entries of the public datasets, we used the ground truth defined by He et al. [16,17] and publicly available from their replication package. In the case of the BGL and HPC datasets, the original set of correct templates contains some mistakes, e.g., templates with unbalanced parentheses and missing punctuation marks. Therefore, we manually validated and fixed them before performing our evaluation.\n\nNo ground truth is available for the proprietary logs, the 100K log file from BGL, and the 60K log file from HDFS. Therefore, we had to manually establish the ground truth. Two validators independently inspected each log file and extracted the corresponding templates. Then, the two sets of templates independently extracted by the two validators were merged into a single ground truth set, by including only the templates extracted by both validators. Templates identified by only one of the two validators were discussed and further added to the ground truth only upon agreement between the validators. At the end of the validation process, we also verified that no log message in our datasets could be matched by more than one single template in the ground truth. In total, 486K log messages were manually inspected to establish the ground truth. The number of log message templates in each log file ranges from 13 (PRX) to 394 (PR with 20K messages).\n\n\nEffectiveness of MoLFI\n\nTo answer RQ1, we assess the performance of MoLFI, in terms of accuracy and efficiency, in comparison with DRAIN [17] and IPLoM [19], which are the two most recent and effective tools for the log message format identification problem [16,17]. We use the implementation of DRAIN available in [17] and the one of IPLoM available in [16].\n\n\nMethodology.\n\nThe NSGA-II algorithm used in MoLFI requires to set four parameters: crossover probability, mutation probability, population size, and stopping condition. To set these parameters, we followed the guidelines proposed in the literature. More specifically, Arcuri and Fraser [1] and Sayyad et al. [25] have empirically demonstrated that the benefits of fine-tuning the parameters of search-based algorithms often do not compensate for the required overhead; both studies recommend to use the default parameters values, since they provide competitive results.\n\nWe set the NSGA-II parameters as follows:\n\n\u2022 crossover probability p c = 0.70, since the recommended values are within the interval 0.45 \u2264 p c \u2264 0.95 [7,8]; \u2022 the mutation probability p m is proportional to the length of the chromosome (see section 4.2.5), as recommended in the related literature [10]; \u2022 the population size is set to 20 individuals; according to our preliminary experiments (see section 5.3.2), this small value corresponds to the best compromise between accuracy and efficiency; \u2022 the stopping condition is set to 200 generations [10].\n\nAs selection operator, we used binary tournament selection [10], which is based on dominance and crowding distance.\n\nFor DRAIN, in the case of the public datasets, we used the same parameters values used in [17]; in the case of our proprietary dataset, we used the default parameter values: depth = 4, similarity = 0.5. We also pre-processed the logs, as suggested in [17], to identify trivial variable parts within the log messages based on domain knowledge.\n\nFor IPLoM, we used the default parameter values used in [19]: file support threshold = 0, partition support threshold = 0, upper bound = 0.9, lower bound = 0.25, and cluster goodness threshold = 0.35.\n\nWe ran the three tools on each log file in our benchmark and collected the generated log message templates. We measured the accuracy of each tool by comparing the set of generated templates with the ground truth. Furthermore, we measured the wall-clock time for executing the complete program (including pre-and postprocessing tasks for MoLFI). To measure the accuracy, we used the metrics used in previous studies [16,17], i.e., Precision =\n|CRT \u2229GEN | |GEN | , Recall = |CRT \u2229GEN | |CRT |\n, and F -measure = 2 \u00d7 Precision\u00d7Recall Precision+Recall , where GEN denotes the set of templates generated by a tool and CRT denotes the set of templates generated by a tool which are correct, i.e., conform to the ground truth.\n\nTo account for the random nature of NGSA-II, we executed MoLFI 50 times on each log and computed the median and standard deviation of the effectiveness metrics; DRAIN and IPLoM were executed only once due to their deterministic nature. However, DRAIN generated duplicated templates, i.e., multiple templates having exactly the same fixed and variable tokens. To avoid any bias due to duplicated templates, we detected and removed them before computing the various effectiveness metrics.\n\nFurthermore, we used the Welch's t-test to verify whether the F-measure scores achieved by MoLFI are significantly higher than those achieved by the alternative tools. The Welch's t-test is a test for statistical significance suitable for distributions with different variance. In our case, the variance for DRAIN and IPLoM is zero as they are deterministic; MoLFI may return a non-zero variance due to NSGA-II. For this test, we consider a level of significance \u03b1=0.05. Other than simply testing the statistical significance, we estimated the magnitude of the differences (effect size) using the Vargha-Delaney (\u00c2 12 ) statistic [31].\u00c2 12 takes values in [0; 1];\u00c2 12 > 0.50 values indicate that MoLFI outperforms the alternative tool while for\u00c2 12 < 0.50 the contrary is true.\u00c2 12 = 0.50 if the two tools are equivalent. Table 1 shows the results of the three tools, grouped by dataset and log file size. Column \"#T\" indicates the number of templates in a file; column \"NTT\" indicates the percentage of templates with more than one variable token in a file; columns \"Prec\", \"Rec\", \"F-m\", \"T\" indicate, respectively, the precision, recall, F-measure, and the execution time in seconds. For MoLFI, the table reports the median results achieved across the 50 runs as well as the corresponding standard deviation values.\n\n\nResults.\n\nAccording to our results, MoLFI obtains, on all the log files in the benchmark, a better F-measure than both DRAIN and IPLoM.\n\nWe compared the effectiveness of our approach with the two state-of-the-art tools and we present the differences in percentage points (pp). The difference between MoLFI and DRAIN in terms of F-measure ranges between +13 pp and +36 pp. The values for the difference are always statistically significant according to the Welch's t-test (all p-values are lower than 0.01) and the effect size is always large (i.e.,\u00c2 12 \u2248 1). This difference is due both to better precision and to better recall. We also remark that DRAIN crashed  The difference between MoLFI and IPLoM in terms of F-measure ranges between +20 pp and +81 pp. For all logs in our study, the differences are statistically significant (p-values are always lower than 0.01) with a large effect size (\u00c2 12 \u2248 1). Also in this case, the better F-measure is ascribable to the substantial improvements in both precision (ranging between +14 pp and +86 pp) and recall (ranging between +25 pp and +75 pp). An interesting case is represented by the 300K log from the proprietary dataset: MoLFI generates very accurate templates achieving an F-measure of 0.91 while IPLoM obtains a very low F-measure of 0.1. Figure 4 shows an example of the Pareto front generated by MoLFI for the dataset HPC on one single run. It also displays the knee point (red point) and two further points (in black color) corresponding to the frequency and specificity values of the templates generated by DRAIN and IPLoM. The knee point dominates the templates produced by IPloM, meaning that MoLFI generates templates having both better frequency and better specificity. Instead, the templates produced by DRAIN are non-dominated neither by the knee point nor by the other Pareto optimal solutions. Indeed, their objective scores are located in one of the corners of the Pareto front, meaning that their specificity is very high (few variable tokens) but their frequency is very low. Similar results are obtained also for the other logs in the benchmark. To sum up, both IPLoM and DRAIN are not able to provide optimal compromises between the two objective functions.\n\nIn terms of efficiency, MoLFI is the slowest technique; this can be explained because of the usage of NSGA-II, which is an iterative algorithm. The fastest technique is IPLoM, which, however, is also the one with the lowest F-measure values. DRAIN is faster than MoLFI in all the cases with the only exception of the 100K log from the BGL dataset: for this file DRAIN takes 32.89 s while MoLFI takes only 10.91 s. Although MoLFI takes longer to converge than state-of-the-art tools, the increment of the running time has no practical implications since it took less than 126 s when analyzing the largest dataset.\n\n\nFactors influencing the effectiveness of MoLFI\n\nTo answer RQ2, we investigate the effect of the following three factors on the effectiveness of MoLFI: (1) the number of templates to identify in a log file, (2) the population size in NSGA-II; (3) the removal of duplicate messages from the log file to analyze, performed as part of the pre-processing step. In the following, we illustrate the evaluation methodology and the results for each of these factors.\n\n\nNumber of templates.\n\nTo test the effect of this factor, we used the one-way permutation test [2] to assess whether the number of templates to identify in a log file statistically interacts with the F-measure scores achieved by MoLFI. The permutation test is a non-parametric test and therefore it does not assume that the data are normally distributed. We ran this test with a very large number of iterations (i.e., 10 8 ), as suggested in the literature [2].\n\nAccording to the one-way permutation test, there is no interaction between the number of templates to be identified in a log file and the F-measure values obtained by MoLFI (p-value=0.08). This means that our technique yields high F-measure scores both with log files containing a low number of templates (e.g., see the 2K log from PRX in Table 1) and with log files containing a high number of templates (e.g., see the 20K log from PR in Table 1).\n\n\nPopulation size.\n\nGiven the nature of NSGA-II, using a large population size may significantly increase the execution time for finding the best solutions; however, using a population with few individuals may yield poor results. We test the effect of this factor by running MoLFI (on each log file of the benchmark) with a population size of 40 and 80 individuals. We repeated each run ten times and computed the median F-measure and execution time. We compared these results with those obtained by the baseline (with a population of 20 individuals, see Table 1). Table 2 shows the results of this comparison. Column \"T\" indicates the median execution time in seconds; column \"R\" is the ratio between the execution time achieved by the new configurations and the baseline; column \"F-m\" is the median F-measure; column \"\u0394 F-m \" indicates the difference, in percentage points, between the F-measure achieved by the new configurations and the baseline. All these values are shown for the columns labeled \"pop=40\" and \"pop=80\" of Table 2.\n\nIn terms of F-measure, MoLFI performs almost equivalently for the three configurations, with an increase for the majority of log files reaching 4 pp for the 2K log file from BGL. We remark two exceptions where the F-measure decreased with a population size of 80: the 300K log file from PR (-5 pp) and the BGL log file of size 100K (-1 pp).\n\nExecution time sharply increases as the population size grows. This is to be expected since a larger population size entails more fitness computations for NSGA-II.\n\n\nRemoval of duplicate messages.\n\nIn the pre-processing step presented in section 4.2.1, we filter out duplicated log messages, to reduce the number of log messages to consider for generating templates. However, such a reduction may also directly affect the value of one of our two objective functions, frequency, which could be further reflected in changes to the shape of the Pareto front and to its knee point.\n\nTo test the effect of this factor, we ran MoLFI by disabling the routine responsible for removing duplicated log messages in the pre-processing step. As above, each run was repeated ten times and we computed the median F-measure and execution time, as well as the ratio between execution times and the difference in percentage points of the F-measure. The results are shown in the column \"no filtering\" of Table 2. No data are reported for the 300K log from the PR dataset, since it timed-out (> 3 hours) when completing the first generation of NSGA-II.\n\nWe compare these effectiveness scores with those reported in Table 1 (i.e., with filtering enabled). We observe that the F-measure scores obtained by the two configurations are the same for all log files, with only 1 pp increase for the BGL dataset. These results show that filtering out duplicated log messages during pre-processing does not significantly alter the final F-measure. However, it results in a substantial reduction of the execution time. For example, when the filter is enabled, MoLFI requires 126 s to converge for the largest Table 2: Comparison between three different configurations of MoLFI: with population size of 40 (column \"pop=40\") and 80 (column \"pop=80\") individuals, and without filtering the duplicated log messages (column \"no filtering\"). \"T\": median execution time in seconds, \"R\": ratio of execution time values, \"F-m\": median F-measure, \u0394 F-m : difference of F-measure in percentage points Dataset Size pop=40 pop=80 no filtering \nT R F-m \u0394 F-m T R F-m \u0394 F-m T R F-m \u0394 F-m (s)(\n\nIs the knee point the best solution?\n\nTo answer RQ3, we analyze, over the entire benchmark, the Fmeasure scores achieved by all solutions in the Pareto front. This means comparing the F-measure of the knee point with the scores achieved by the other Pareto optimal solutions. For the sake of analysis, for each log, we selected one single Pareto front among those obtained with 50 independent runs. For the selection, we first computed the F-measure for the knee point generated in each run; then, we selected the knee point having the median F-measure across the runs and its corresponding Pareto front. Figure 5 shows, for all the log files in our benchmark, the Fmeasure of the knee points (indicated with red points) when compared with all the Pareto optimal solutions (represented by the boxplots). One can see that, in all cases, the F-measure score of the knee point is located at the very top of the boxplot. This confirms our conjecture that, in the context of the log message format identification problem, the knee point is the best solution to choose from the Pareto front.\n\n\nDISCUSSION\n\nPractical implications. As discussed in Section 5.2, MoLFI achieves a substantial higher accuracy than alternative algorithms. Such improvements in accuracy represent a considerable reduction in the time needed by analysts to inspect the generated templates, validate them and eventually modify the incorrect ones. For example, MoLFI generates 62 templates for HDFS with the 60K log; on average across runs, 60 templates are correct (as they match the ground truth). One incorrect template is T = PacketResponder * for block * * , which is too general as it matches log messages belonging to two different log events: (i) when the PacketResponder for a given block terminated correctly and (ii) when it has been interrupted. The log messages for these two log events are very similar as they Since T matches only those two log events, fixing it is trivial.\nB G L -2 K B G L -1 0 0 K H D F S -2 K H D F S -6 0 K H P C -2 K P R X -2 K Z K -2 K P R -2 K P R -2 0 K P R\nSum-scalarization vs. multi-objective search. An alternative searchbased solution to solve our multi-objective problem would be applying sum scalarization [9]. Such a strategy combines the objectives to optimize into one single function by using the sum operator and thus enabling the use of a single-objective genetic algorithm to optimize the aggregated function. In our case, the aggregation function combines frequency and specificity, i.e., f (X ) = Freq(X ) + Spec(X ). To assess this alternative search strategy, we ran a classical genetic algorithm to optimize the function f (X ) mentioned above on HDFS with the 60K log. The median F-measure obtained over 10 independent runs is 0.65 (\u00b1 0.02), which is statistically significantly lower than the value achieved by MoLFI (i.e., NSGA-II and the knee point), which is 0.94. Note that for the single-objective genetic algorithm we use the same parameter values as for NSGA-II.\n\nThe role of constraints. In our problem formulation, we consider two constraints: (i) each log message has to be matched by only one template in a solution X ; and (ii) the templates in X have to match all log messages (100% coverage). The former constraint is straightforward since templates in a given solution X should not overlap; the latter is less intuitive but analysts, for some specific applications, could be interested in solutions not covering all log messages. However, we observed that the solutions obtained when removing the coverage constraint have only one single template. For example, if we run MoLFI on HDFS with 60K logs by disabling the coverage constraint, NSGA-II returns a knee point which is a solution with only one template having one variable token and 12 fixed tokens. Such a template has high frequency (Freq=0.06) and high specificity (Spec=12/13=0.94). No other template is included in the solution because adding any other template would penalize both frequency and specificity.\n\nLimitations. Our approach may produce incorrect results because of the method we use to group messages. In particular, log messages whose variable part has a variable composition (e.g., because of a variable-length argument list), could lead to different templates even if they have the same fixed part.\n\n\nRELATED WORK\n\nResearchers have proposed various black-box techniques for the log message format identification problem. These techniques rely on clustering [12,28], heuristics [19,29], longest common sequence method [11], and textual similarities [17]. Recently, He et al. [16] carried-out an empirical study comparing four techniques for the log message format identification problem: SLCT [29], LKE [12], LogSig [28], and IPLoM [19]. The results of this study revealed that (i) IPLoM produces the most accurate templates, and (ii) log pre-processing (like the one applied in MoLFI) is very critical to achieving good clustering performance. In a later study, He et al. [17] introduced DRAIN, a novel technique that processes the log messages through a fixed-depth parse tree. Their empirical study showed that DRAIN generates more correct templates than IPLoM.\n\nOne limitation of the two best techniques (DRAIN and IPLoM) is that they require their parameters to be tuned for each log file. Such parameters, if not chosen carefully, will significantly affect the performance of the tool. Different from state-of-the-art techniques, our approach MoLFI uses an automated heuristic to automatically choose the best compromise between the two objectives of the log message format identification problem (frequency and specificity) without using a priori, user-defined thresholds. Our evaluation results show that MoLFI significantly outperforms both IPLoM and DRAIN, both in precision and in recall.\n\n\nCONCLUSION AND FUTURE WORK\n\nThe log message format identification problem deals with the identification of the different templates used in the log messages. In this paper, we formulated this problem as a multi-objective optimization one, where the goal is to generate log message templates with high frequency (i.e., they match as many log entries as possible) and high specificity (i.e., specific for each log event). To tackle the problem, we introduced MoLFI, a tool implementing a search-based approach based on a multi-objective genetic algorithm and trade-off analysis.\n\nAn empirical study involving six real-world datasets (five publiclyavailable and one proprietary) showed that MoLFI (i) achieved significantly higher accuracy than DRAIN and IPLoM, two stateof-the-art tools; (ii) is highly scalable to large logs since it requires slightly above two minutes to analyze hundreds of thousands of messages.\n\nAs part of future work, we plan to improve the effectiveness of MoLFI by investigating other encoding schemas, experimenting with other formulations of the problem (e.g., by introducing the coverage of log messages as another optimization objective), and by handling semantically equivalent templates. We also plan to assess the use of MoLFI for supporting various software maintenance and testing activities, such as boosting test case generation techniques through the definition of new seeding strategies [24] based on input and output values (variable parts) observed in the logs. \n\nFigure 1 :\n1Excerpt (simplified) of real-world log entries\n\nFATALFigure 2 :\n2floating point instr enabled * FATAL rts panic -stopping execution L=12 FATAL problem state ( * = sup , * = usr ) An example of chromosome for the log messages in figure 1. Algorithm 1: InitialPopulation Input: Set of pre-processed log messages M Population size N Result: Initial population P group M L \u2208 M do 6 G L \u2190 create an empty group for templates with length L 7 unmatched \u2190 M L 8 while |unmatched | > 0 do 9 log_message \u2190 randomly select one message from unmatched 10 \u03c4 \u2190 copy(log_message)\n\nFigure 3 :\n3The concepts of Pareto front and knee point.\n\n1 :Figure 4 :\n14Precision (Prec), recall (Rec), F-measure (F-m), and execution time (T(s)) of the three approaches. \u00b10.03 0.86 \u00b10.03 0.84 \u00b10.03 17.38 \u00b10.32 100K 57 22% 0.60 0.74 0.66 32.89 0.42 0.53 0.47 5.76 0.83 \u00b10.03 0.78 \u00b10.04 0.80 \u00b10.03 10.91 \u00b10.\u00b10.04 0.82 \u00b10.03 0.79 \u00b10.03 36.80 \u00b10.65 20K 394 17% 0.61 0.57 0.59 1.51 0.54 0.47 0.50 2.38 0.71 \u00b10.03 0.82 \u00b10.02 0.76 \u00b10.02 79.59 \u00b12.Pareto front generated by MoLFI and the objectives scores of the templates generated by DRAIN and IPLoM on the 300K log from the proprietary dataset, without yielding any message template.\n\nFigure 5 :\n5Comparisons between the knee-point and other Pareto front solutions in terms of F-measurediffer only by one single token. Fixing this template would need to create two templates, each one with an additional fixed token.\n\nACKNOWLEDGMENTS\nThis work has received funding from the European Research Council under the European Union's Horizon 2020 research and innovation programme (grant agreement No 694277), from the Luxembourg National Research Fund (FNR) under grant agreement No C-PPP17/IS/11602677, and from a research grant by SES.\n\nTable\n\n\n\nlog file (the 300K log file from the PR dataset), while it times out (after three hours) for the same log file when the filter is disabled.pp) \n(s) \n(pp) \n( s ) \n( pp) \n\nBGL \n2K 35.84 2.06 0.86 2 \n70.97 4.08 0.88 4 \n25.80 1.48 0.85 1 \n100K 17.88 1.64 0.80 0 \n31.90 2.92 0.79 \u22121 397.76 36.46 0.81 1 \n\nHDFS \n2K 6.36 1.89 1.00 0 \n12.48 3.71 1.00 0 \n13.21 3.93 1.00 0 \n60K 18.26 1.77 0.94 0 \n34.32 3.33 0.94 0 175.09 16.97 0.94 0 \n\nHPC \n2K 15.33 2.03 0.90 0 \n29.75 3.94 0.92 2 \n15.43 2.04 0.90 0 \n\nPR \n\n2K 75.44 2.05 0.80 1 162.37 4.41 0.79 0 \n45.39 1.23 0.79 0 \n20K 157.88 1.98 0.78 2 315.11 3.96 0.76 0 217.43 2.73 0.76 0 \n300K 155.58 1.24 0.91 0 235.69 1.87 0.86 \u22125 \n>3h \u2212 \n\u2212 \u2212 \n\nPRX \n2K 6.55 1.89 0.77 0 \n12.88 3.72 0.77 0 \n14.47 4.18 0.77 0 \n\nZK \n2K 13.86 2.00 0.90 0 \n26.56 3.83 0.90 0 \n15.05 2.17 0.90 0 \n\n\nAdditional names used in the literature for denoting the fixed part of a log message are \"line pattern\", \"log key\", and \"message signature\".2 This problem is often called \"log parsing\" in the literature; we believe \"log message format identification\" is a more specific term, since \"log parsing\" includes also parsing more structured elements like timestamps and log verbosity levels.\nThe evaluation artifacts are available from the following links: \u2022 tool https://github.com/SalmaMessaoudi/MoLFI.git; \u2022 log files https://github.com/SalmaMessaoudi/ICPC-2018-Artifacts.git.\n\n36 FATAL instruction address 0 x0000f450 6 20050605 -06.45.36 FATAL machine state register 0 x00003000 7 20050605 -06.45.36 FATAL wait state enable 0 8 20050605 -06.45.36 FATAL critical input interrupt enable 0 9 20050605 -06.45.36 FATAL external input interrupt enable 0 10 20050605 -06.45.36 FATAL problem state (0= sup ,1= usr ) 11 20050605 -06.45.36 FATAL floating point instr. core 135 2 20050605 -06.45.36 INFO generating core 198 3 20050605 -06.45.36 INFO generating core 199 4 20050605 -06.45.36 FATAL instruction address 0 x0000df30 5 20050605 -06.45enabled 1 12 20050605 -06.45.36 FATAL machine check enable 1 13 20050605 -06.45.37 FATAL rts internal error 14 20050605 -06.45.37 FATAL rts panic -stopping execution 15 20050605 -06.59.14 FATAL data TLB error interruptcore 135 2 20050605 -06.45.36 INFO generating core 198 3 20050605 -06.45.36 INFO generating core 199 4 20050605 -06.45.36 FATAL instruction address 0 x0000df30 5 20050605 -06.45.36 FATAL instruction address 0 x0000f450 6 20050605 -06.45.36 FATAL machine state register 0 x00003000 7 20050605 -06.45.36 FATAL wait state enable 0 8 20050605 -06.45.36 FATAL critical input interrupt enable 0 9 20050605 -06.45.36 FATAL external input interrupt enable 0 10 20050605 -06.45.36 FATAL problem state (0= sup ,1= usr ) 11 20050605 -06.45.36 FATAL floating point instr . enabled 1 12 20050605 -06.45.36 FATAL machine check enable 1 13 20050605 -06.45.37 FATAL rts internal error 14 20050605 -06.45.37 FATAL rts panic -stopping execution 15 20050605 -06.59.14 FATAL data TLB error interrupt\n\nParameter Tuning or Default Values? An Empirical Investigation in Search-Based Software Engineering. Andrea Arcuri, Gordon Fraser, Empirical Software Engineering. 18Andrea Arcuri and Gordon Fraser. 2013. Parameter Tuning or Default Values? An Empirical Investigation in Search-Based Software Engineering. Empirical Software Engineering 18, 3 (2013), 594-623.\n\nModern Permutation Test Software. D Rose, Baker, Randomization Tests, Third Edition. Marcel Dekker. New York, NY, USARose D. Baker. 1995. Modern Permutation Test Software. In Randomization Tests, Third Edition. Marcel Dekker, New York, NY, USA, 391-401.\n\nScalable Offline Monitoring. David Basin, Germano Caronni, Sarah Ereth, Mat\u00fa\u0161 Harvan, Felix Klaedtke, Heiko Mantel, Proceedings of the 5th International Conference on Runtime Verification (RV 2014). the 5th International Conference on Runtime Verification (RV 2014)Cham, SwitzerlandSpringer8734David Basin, Germano Caronni, Sarah Ereth, Mat\u00fa\u0161 Harvan, Felix Klaedtke, and Heiko Mantel. 2014. Scalable Offline Monitoring. In Proceedings of the 5th International Conference on Runtime Verification (RV 2014) (LNCS), Vol. 8734. Springer, Cham, Switzerland, 31-47.\n\nExperience Report: Log Mining using Natural Language Processing and Application to Anomaly Detection. Christophe Bertero, Matthieu Roy, Carla Sauvanaud, Gilles Tr\u00e9dan, Proceedings of the 28th International Symposium on Software Reliability Engineering. the 28th International Symposium on Software Reliability EngineeringPiscataway, NJ, USAIEEEChristophe Bertero, Matthieu Roy, Carla Sauvanaud, and Gilles Tr\u00e9dan. 2017. Experience Report: Log Mining using Natural Language Processing and Applica- tion to Anomaly Detection. In Proceedings of the 28th International Symposium on Software Reliability Engineering (ISSRE 2017). IEEE, Piscataway, NJ, USA, 351-360.\n\nLeveraging Existing Instrumentation to Automatically Infer Invariantconstrained Models. Ivan Beschastnikh, Yuriy Brun, Sigurd Schneider, Michael Sloan, Michael D Ernst, Proceedings of the 19th ACM SIGSOFT Symposium and the 13th European Conference on Foundations of Software Engineering. the 19th ACM SIGSOFT Symposium and the 13th European Conference on Foundations of Software EngineeringNew York, NY, USAACMIvan Beschastnikh, Yuriy Brun, Sigurd Schneider, Michael Sloan, and Michael D. Ernst. 2011. Leveraging Existing Instrumentation to Automatically Infer Invariant- constrained Models. In Proceedings of the 19th ACM SIGSOFT Symposium and the 13th European Conference on Foundations of Software Engineering (ESEC/FSE 2011). ACM, New York, NY, USA, 267-277.\n\nFinding Knees in Multi-objective Optimization. J\u00fcrgen Branke, Kalyanmoy Deb, Henning Dierolf, Matthias Osswald, Proceedings of the 8th International Parallel Problem Solving from Nature (PPSN 2004). the 8th International Parallel Problem Solving from Nature (PPSN 2004)Berlin, HeidelbergSpringer3242J\u00fcrgen Branke, Kalyanmoy Deb, Henning Dierolf, and Matthias Osswald. 2004. Finding Knees in Multi-objective Optimization. In Proceedings of the 8th Inter- national Parallel Problem Solving from Nature (PPSN 2004) (LNCS), Vol. 3242. Springer, Berlin, Heidelberg, 722-731.\n\nUsing Genetic Algorithms for Early Schedulability Analysis and Stress Testing in Real-time Systems. Lionel C Briand, Yvan Labiche, Marwa Shousha, Genetic Programming and Evolvable Machines. 7Lionel C. Briand, Yvan Labiche, and Marwa Shousha. 2006. Using Genetic Algo- rithms for Early Schedulability Analysis and Stress Testing in Real-time Systems. Genetic Programming and Evolvable Machines 7, 2 (2006), 145-170.\n\nGenetic Algorithms for Tracking Changing Environments. Helen G Cobb, John J Grefenstette, Proceedings of the 5th International Conference on Genetic Algorithms (ICGA. the 5th International Conference on Genetic Algorithms (ICGASan Francisco, CA, USAMorgan Kaufmann PublishersHelen G. Cobb and John J. Grefenstette. 1993. Genetic Algorithms for Tracking Changing Environments. In Proceedings of the 5th International Conference on Genetic Algorithms (ICGA 1993). Morgan Kaufmann Publishers, San Francisco, CA, USA, 523-530.\n\nMulti-objective Optimization. Kalyanmoy Deb, Search Methodologies: Introductory Tutorials in Optimization and Decision Support Techniques. New York, NY, USASpringerSecond EditionKalyanmoy Deb. 2014. Multi-objective Optimization. In Search Methodologies: Introductory Tutorials in Optimization and Decision Support Techniques, Second Edition. Springer, New York, NY, USA, 403-449.\n\nA Fast and Elitist Multiobjective Genetic Algorithm: NSGA-II. Kalyanmoy Deb, Amrit Pratap, Sameer Agarwal, Tamt Meyarivan, IEEE Transactions on Evolutionary Computation. 6Kalyanmoy Deb, Amrit Pratap, Sameer Agarwal, and TAMT Meyarivan. 2002. A Fast and Elitist Multiobjective Genetic Algorithm: NSGA-II. IEEE Transactions on Evolutionary Computation 6, 2 (2002), 182-197.\n\nSpell: Streaming Parsing of System Event Logs. Min Du, Feifei Li, Proceedings of the16th IEEE International Conference on Data Mining (ICDM. the16th IEEE International Conference on Data Mining (ICDMMin Du and Feifei Li. 2016. Spell: Streaming Parsing of System Event Logs. In Proceedings of the16th IEEE International Conference on Data Mining (ICDM 2016).\n\n. Piscataway Ieee, Nj, Usa, IEEE, Piscataway, NJ, USA, 859-864.\n\nExecution Anomaly Detection in Distributed Systems through Unstructured Log Analysis. Qiang Fu, Jian-Guang Lou, Yi Wang, Jiang Li, Proceedings of the 9th IEEE International Conference on Data Mining (ICDM. the 9th IEEE International Conference on Data Mining (ICDMLos Alamitos, CA, USAIEEE Computer SocietyQiang Fu, Jian-Guang Lou, Yi Wang, and Jiang Li. 2009. Execution Anomaly Detection in Distributed Systems through Unstructured Log Analysis. In Proceed- ings of the 9th IEEE International Conference on Data Mining (ICDM 2009). IEEE Computer Society, Los Alamitos, CA, USA, 149-158.\n\nWhere Do Developers Log? An Empirical Study on Logging Practices in Industry. Qiang Fu, Jieming Zhu, Wenlu Hu, Jian-Guang Lou, Rui Ding, Qingwei Lin, Dongmei Zhang, Tao Xie, Proceedings of the 36th International Conference on Software Engineering (ICSE Companion. the 36th International Conference on Software Engineering (ICSE CompanionNew York, NY, USAACMQiang Fu, Jieming Zhu, Wenlu Hu, Jian-Guang Lou, Rui Ding, Qingwei Lin, Dongmei Zhang, and Tao Xie. 2014. Where Do Developers Log? An Empirical Study on Logging Practices in Industry. In Proceedings of the 36th International Conference on Software Engineering (ICSE Companion 2014). ACM, New York, NY, USA, 24-33.\n\nExperience Report: Log-Based Behavioral Differencing. Maayan Goldstein, Danny Raz, Itai Segall, Proceedings of the 28th International Symposium on Software Reliability Engineering. the 28th International Symposium on Software Reliability EngineeringPiscataway, NJ, USAIEEEMaayan Goldstein, Danny Raz, and Itai Segall. 2017. Experience Report: Log- Based Behavioral Differencing. In Proceedings of the 28th International Symposium on Software Reliability Engineering (ISSRE 2017). IEEE, Piscataway, NJ, USA, 282- 293.\n\nFuzzy Mining-adaptive Process Simplification based on Multi-perspective Metrics. W Christian, G\u00fcnther, M P Wil, Van Der Aalst, Proceedings of the 5th International Conference on Business Process Management (BPM 2007). the 5th International Conference on Business Process Management (BPM 2007)Berlin, HeidelbergSpringer4714Christian W. G\u00fcnther and Wil M. P. van der Aalst. 2007. Fuzzy Mining-adaptive Process Simplification based on Multi-perspective Metrics. In Proceedings of the 5th International Conference on Business Process Management (BPM 2007) (LNCS), Vol. 4714. Springer, Berlin, Heidelberg, 328-343.\n\nAn Evaluation Study on Log Parsing and Its Use in Log Mining. Pinjia He, Jieming Zhu, Shilin He, Jian Li, Michael R Lyu, Proceedings of the 46th Annual IEEE/IFIP International Conference on Dependable Systems and Networks. the 46th Annual IEEE/IFIP International Conference on Dependable Systems and NetworksPiscataway, NJ, USAIEEEPinjia He, Jieming Zhu, Shilin He, Jian Li, and Michael R. Lyu. 2016. An Evaluation Study on Log Parsing and Its Use in Log Mining. In Proceedings of the 46th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN 2016). IEEE, Piscataway, NJ, USA, 654-661.\n\nDrain: An Online Log Parsing Approach with Fixed Depth Tree. Pinjia He, Jieming Zhu, Zibin Zheng, Michael R Lyu, Proceedings of the International Conference on Web Services. the International Conference on Web ServicesPiscataway, NJ, USAIEEEPinjia He, Jieming Zhu, Zibin Zheng, and Michael R. Lyu. 2017. Drain: An Online Log Parsing Approach with Fixed Depth Tree. In Proceedings of the International Conference on Web Services (ICWS 2017). IEEE, Piscataway, NJ, USA, 33-40.\n\nPerformance Scaling of Multiobjective Evolutionary Algorithms. Xin Vineet Khare, Kalyanmoy Yao, Deb, Proceedings of the 2nd International Conference on Evolutionary Multi-criterion Optimization (EMO 2003). the 2nd International Conference on Evolutionary Multi-criterion Optimization (EMO 2003)Berlin, HeidelbergSpringer-Verlag2632Vineet Khare, Xin Yao, and Kalyanmoy Deb. 2003. Performance Scaling of Multi- objective Evolutionary Algorithms. In Proceedings of the 2nd International Confer- ence on Evolutionary Multi-criterion Optimization (EMO 2003) (LNCS), Vol. 2632. Springer-Verlag, Berlin, Heidelberg, 376-390.\n\nA Lightweight Algorithm for Message Type Extraction in System Application Logs. Adetokunbo Makanju, A Zincir-Heywood, Evangelos E Milios, IEEE Transactions on Knowledge and Data Engineering. 24Adetokunbo Makanju, A. Nur Zincir-Heywood, and Evangelos E. Milios. 2012. A Lightweight Algorithm for Message Type Extraction in System Application Logs. IEEE Transactions on Knowledge and Data Engineering 24, 11 (2012), 1921-1936.\n\nToward Fine-Grained, Unsupervised, Scalable Performance Diagnosis for Production Cloud Computing Systems. Haibo Mi, Huaimin Wang, Yangfan Zhou, Michael R Lyu, Hua Cai, IEEE Transactions on Parallel and Distributed Systems. 24Haibo Mi, Huaimin Wang, Yangfan Zhou, Michael R. Lyu, and Hua Cai. 2013. Toward Fine-Grained, Unsupervised, Scalable Performance Diagnosis for Pro- duction Cloud Computing Systems. IEEE Transactions on Parallel and Distributed Systems 24, 6 (2013), 1245-1255.\n\nStructured Comparative Analysis of Systems Logs to Diagnose Performance Problems. Karthik Nagaraj, Charles Killian, Jennifer Neville, Proceedings of the 9th USENIX Conference on Networked Systems Design and Implementation (NSDI 2012). USENIX Association. the 9th USENIX Conference on Networked Systems Design and Implementation (NSDI 2012). USENIX AssociationBerkeley, CA, USAKarthik Nagaraj, Charles Killian, and Jennifer Neville. 2012. Structured Compara- tive Analysis of Systems Logs to Diagnose Performance Problems. In Proceedings of the 9th USENIX Conference on Networked Systems Design and Implementation (NSDI 2012). USENIX Association, Berkeley, CA, USA, 26-26.\n\nLorenz Equilibrium: Equitability in Non-cooperative Games. R\u00e9ka Nagy, A Mihai, Dumitru Suciu, Dumitrescu, Proceedings of the 14th Annual Conference on Genetic and Evolutionary Computation. the 14th Annual Conference on Genetic and Evolutionary ComputationNew York, NY, USAACMR\u00e9ka Nagy, Mihai A. Suciu, and Dumitru Dumitrescu. 2012. Lorenz Equilibrium: Equitability in Non-cooperative Games. In Proceedings of the 14th Annual Confer- ence on Genetic and Evolutionary Computation (GECCO 2012). ACM, New York, NY, USA, 489-496.\n\nReformulating Branch Coverage as a Many-objective Optimization Problem. Annibale Panichella, M Fitsum, Paolo Kifetew, Tonella, Proceedings of the 8th IEEE International Conference on Software Testing, Verification and Validation. the 8th IEEE International Conference on Software Testing, Verification and ValidationPiscataway, NJ, USAIEEEAnnibale Panichella, Fitsum M. Kifetew, and Paolo Tonella. 2015. Reformulating Branch Coverage as a Many-objective Optimization Problem. In Proceedings of the 8th IEEE International Conference on Software Testing, Verification and Validation (ICST 2015). IEEE, Piscataway, NJ, USA, 1-10.\n\nSeeding Strategies in Search-based Unit Test Generation. Software Testing, Verification and Reliability. Miguel Jos\u00e9, Gordon Rojas, Andrea Fraser, Arcuri, 26Jos\u00e9 Miguel Rojas, Gordon Fraser, and Andrea Arcuri. 2016. Seeding Strategies in Search-based Unit Test Generation. Software Testing, Verification and Reliability 26, 5 (2016), 366-401.\n\nOn Parameter Tuning in Search Based Software Engineering: A Replicated Empirical Study. Abdel Salam Sayyad, Katerina Goseva-Popstojanova, Tim Menzies, Hany Ammar, Proceedings of the 3rd International Workshop on Replication in Empirical Software Engineering Research. the 3rd International Workshop on Replication in Empirical Software Engineering ResearchWashington, DC, USAIEEE Computer SocietyAbdel Salam Sayyad, Katerina Goseva-Popstojanova, Tim Menzies, and Hany Ammar. 2013. On Parameter Tuning in Search Based Software Engineering: A Replicated Empirical Study. In Proceedings of the 3rd International Workshop on Replication in Empirical Software Engineering Research (RESER 2013). IEEE Computer Society, Washington, DC, USA, 84-90.\n\nIntroduction to Genetic Algorithms. S N Sivanandam, S N Deepa, SpringerBerlin, HeidelbergS.N. Sivanandam and S.N. Deepa. 2008. Introduction to Genetic Algorithms. Springer, Berlin, Heidelberg.\n\nUniform Crossover in Genetic Algorithms. Gilbert Syswerda, Proceedings of the 3rd International Conference on Genetic Algorithms. the 3rd International Conference on Genetic AlgorithmsSan Francisco, CA, USAMorgan Kaufmann PublishersICGA 1989Gilbert Syswerda. 1989. Uniform Crossover in Genetic Algorithms. In Proceedings of the 3rd International Conference on Genetic Algorithms (ICGA 1989). Morgan Kaufmann Publishers, San Francisco, CA, USA, 2-9.\n\nLogSig: Generating System Events from Raw Textual Logs. Liang Tang, Tao Li, Chang-Shing Perng, Proceedings of the 20th ACM International Conference on Information and Knowledge Management. the 20th ACM International Conference on Information and Knowledge ManagementNew York, NY, USAACMLiang Tang, Tao Li, and Chang-Shing Perng. 2011. LogSig: Generating System Events from Raw Textual Logs. In Proceedings of the 20th ACM International Conference on Information and Knowledge Management (CIKM 2011). ACM, New York, NY, USA, 785-794.\n\nA Data Clustering Algorithm for Mining Patterns from Event Logs. Risto Vaarandi, Proceedings of the 3rd IEEE Workshop on IP Operations & Management (IPOM. the 3rd IEEE Workshop on IP Operations & Management (IPOMPiscataway, NJ, USAIEEERisto Vaarandi. 2003. A Data Clustering Algorithm for Mining Patterns from Event Logs. In Proceedings of the 3rd IEEE Workshop on IP Operations & Manage- ment (IPOM 2003). IEEE, Piscataway, NJ, USA, 119-126.\n\nProcess Discovery Using Integer Linear Programming. M E M Jan, Van Der Werf, F Boudewijn, Van Dongen, A J Cor, Alexander Hurkens, Serebrenik, Proceedings of the 29th International Conference on Applications and Theory of Petri Nets (PETRI NETS 2008). the 29th International Conference on Applications and Theory of Petri Nets (PETRI NETS 2008)BerlinSpringer5062HeidelbergJan M. E. M. van der Werf, Boudewijn F. van Dongen, Cor A. J. Hurkens, and Alexander Serebrenik. 2008. Process Discovery Using Integer Linear Program- ming. In Proceedings of the 29th International Conference on Applications and Theory of Petri Nets (PETRI NETS 2008) (LNCS), Vol. 5062. Springer, Berlin, Hei- delberg, 368-387.\n\nA Critique and Improvement of the CL Common Language Effect Size Statistics of McGraw and Wong. Andr\u00e1s Vargha, D Harold, Delaney, Journal of Educational and Behavioral Statistics. 25Andr\u00e1s Vargha and Harold D. Delaney. 2000. A Critique and Improvement of the CL Common Language Effect Size Statistics of McGraw and Wong. Journal of Educational and Behavioral Statistics 25, 2 (2000), 101-132.\n\nA Practical Guide to Select Quality Indicators for Assessing Pareto-based Search Algorithms in Search-based Software Engineering. Shuai Wang, Shaukat Ali, Tao Yue, Yan Li, Marius Liaaen, Proceedings of the 38th International Conference on Software Engineering. the 38th International Conference on Software EngineeringNew York, NY, USAACMShuai Wang, Shaukat Ali, Tao Yue, Yan Li, and Marius Liaaen. 2016. A Practical Guide to Select Quality Indicators for Assessing Pareto-based Search Algorithms in Search-based Software Engineering. In Proceedings of the 38th International Conference on Software Engineering (ICSE 2016). ACM, New York, NY, USA, 631- 642.\n\nEffective Software Fault Localization Using an RBF Neural Network. W Eric Wong, Vidroha Debroy, Richard Golden, Xiaofeng Xu, Bhavani Thuraisingham, IEEE Transactions on Reliability. 61W. Eric Wong, Vidroha Debroy, Richard Golden, Xiaofeng Xu, and Bhavani Thuraisingham. 2012. Effective Software Fault Localization Using an RBF Neural Network. IEEE Transactions on Reliability 61, 1 (2012), 149-169.\n\nSystem Problem Detection by Mining Console Logs. Ph.D. Dissertation. Wei Xu, University of California BerkeleyWei Xu. 2010. System Problem Detection by Mining Console Logs. Ph.D. Disserta- tion. University of California Berkeley.\n\nCharacterizing Logging Practices in Open-source Software. Ding Yuan, Soyeon Park, Yuanyuan Zhou, Proceedings of the 34th International Conference on Software Engineering. the 34th International Conference on Software EngineeringPiscataway, NJ, USAIEEEDing Yuan, Soyeon Park, and Yuanyuan Zhou. 2012. Characterizing Logging Prac- tices in Open-source Software. In Proceedings of the 34th International Conference on Software Engineering (ICSE 2012). IEEE, Piscataway, NJ, USA, 102-112.\n\nLearning to Log: Helping Developers Make Informed Logging Decisions. Jieming Zhu, Pinjia He, Qiang Fu, Hongyu Zhang, Michael R Lyu, Dongmei Zhang, Proceedings of the 37th International Conference on Software Engineering. the 37th International Conference on Software EngineeringPiscataway, NJ, USAIEEEJieming Zhu, Pinjia He, Qiang Fu, Hongyu Zhang, Michael R. Lyu, and Dongmei Zhang. 2015. Learning to Log: Helping Developers Make Informed Logging Deci- sions. In Proceedings of the 37th International Conference on Software Engineering (ICSE 2015). IEEE, Piscataway, NJ, USA, 415-425.\n", "annotations": {"author": "[{\"end\":217,\"start\":178},{\"end\":262,\"start\":218},{\"end\":308,\"start\":263},{\"end\":344,\"start\":309},{\"end\":395,\"start\":345},{\"end\":412,\"start\":396},{\"end\":433,\"start\":413},{\"end\":453,\"start\":434},{\"end\":468,\"start\":454},{\"end\":506,\"start\":469},{\"end\":544,\"start\":507},{\"end\":582,\"start\":545},{\"end\":620,\"start\":583},{\"end\":637,\"start\":621}]", "publisher": null, "author_last_name": "[{\"end\":193,\"start\":184},{\"end\":237,\"start\":227},{\"end\":281,\"start\":272},{\"end\":322,\"start\":316},{\"end\":365,\"start\":355},{\"end\":411,\"start\":402},{\"end\":432,\"start\":422},{\"end\":452,\"start\":443},{\"end\":467,\"start\":461}]", "author_first_name": "[{\"end\":183,\"start\":178},{\"end\":226,\"start\":218},{\"end\":271,\"start\":263},{\"end\":315,\"start\":309},{\"end\":354,\"start\":345},{\"end\":401,\"start\":396},{\"end\":421,\"start\":413},{\"end\":442,\"start\":434},{\"end\":460,\"start\":454}]", "author_affiliation": "[{\"end\":505,\"start\":470},{\"end\":543,\"start\":508},{\"end\":581,\"start\":546},{\"end\":619,\"start\":584},{\"end\":636,\"start\":622}]", "title": "[{\"end\":160,\"start\":1},{\"end\":797,\"start\":638}]", "venue": "[{\"end\":807,\"start\":799}]", "abstract": "[{\"end\":2990,\"start\":1138}]", "bib_ref": "[{\"attributes\":{\"ref_id\":\"b36\"},\"end\":3353,\"start\":3349},{\"attributes\":{\"ref_id\":\"b37\"},\"end\":3356,\"start\":3353},{\"attributes\":{\"ref_id\":\"b14\"},\"end\":3749,\"start\":3745},{\"attributes\":{\"ref_id\":\"b16\"},\"end\":3864,\"start\":3860},{\"attributes\":{\"ref_id\":\"b31\"},\"end\":3867,\"start\":3864},{\"attributes\":{\"ref_id\":\"b4\"},\"end\":3890,\"start\":3887},{\"attributes\":{\"ref_id\":\"b13\"},\"end\":3893,\"start\":3890},{\"attributes\":{\"ref_id\":\"b15\"},\"end\":3896,\"start\":3893},{\"attributes\":{\"ref_id\":\"b15\"},\"end\":3926,\"start\":3922},{\"attributes\":{\"ref_id\":\"b34\"},\"end\":3951,\"start\":3947},{\"attributes\":{\"ref_id\":\"b5\"},\"end\":3976,\"start\":3973},{\"attributes\":{\"ref_id\":\"b22\"},\"end\":4004,\"start\":4000},{\"attributes\":{\"ref_id\":\"b3\"},\"end\":4036,\"start\":4033},{\"attributes\":{\"ref_id\":\"b35\"},\"end\":5981,\"start\":5977},{\"attributes\":{\"ref_id\":\"b21\"},\"end\":6144,\"start\":6140},{\"attributes\":{\"ref_id\":\"b35\"},\"end\":6662,\"start\":6658},{\"attributes\":{\"ref_id\":\"b11\"},\"end\":7305,\"start\":7301},{\"attributes\":{\"ref_id\":\"b13\"},\"end\":7308,\"start\":7305},{\"attributes\":{\"ref_id\":\"b18\"},\"end\":7311,\"start\":7308},{\"attributes\":{\"ref_id\":\"b20\"},\"end\":7313,\"start\":7311},{\"attributes\":{\"ref_id\":\"b11\"},\"end\":8838,\"start\":8834},{\"attributes\":{\"ref_id\":\"b13\"},\"end\":8841,\"start\":8838},{\"attributes\":{\"ref_id\":\"b18\"},\"end\":8844,\"start\":8841},{\"attributes\":{\"ref_id\":\"b20\"},\"end\":8847,\"start\":8844},{\"attributes\":{\"ref_id\":\"b10\"},\"end\":9298,\"start\":9294},{\"attributes\":{\"ref_id\":\"b20\"},\"end\":9992,\"start\":9988},{\"attributes\":{\"ref_id\":\"b18\"},\"end\":10007,\"start\":10003},{\"attributes\":{\"ref_id\":\"b13\"},\"end\":10709,\"start\":10705},{\"attributes\":{\"ref_id\":\"b18\"},\"end\":10712,\"start\":10709},{\"attributes\":{\"ref_id\":\"b17\"},\"end\":10789,\"start\":10785},{\"attributes\":{\"ref_id\":\"b10\"},\"end\":11934,\"start\":11930},{\"attributes\":{\"ref_id\":\"b10\"},\"end\":13270,\"start\":13266},{\"attributes\":{\"ref_id\":\"b10\"},\"end\":13509,\"start\":13505},{\"attributes\":{\"ref_id\":\"b19\"},\"end\":13512,\"start\":13509},{\"attributes\":{\"ref_id\":\"b33\"},\"end\":13614,\"start\":13610},{\"attributes\":{\"ref_id\":\"b10\"},\"end\":14570,\"start\":14566},{\"attributes\":{\"ref_id\":\"b10\"},\"end\":15238,\"start\":15234},{\"attributes\":{\"ref_id\":\"b17\"},\"end\":20697,\"start\":20693},{\"attributes\":{\"ref_id\":\"b18\"},\"end\":20700,\"start\":20697},{\"attributes\":{\"ref_id\":\"b10\"},\"end\":23963,\"start\":23959},{\"attributes\":{\"ref_id\":\"b11\"},\"end\":23967,\"start\":23963},{\"attributes\":{\"ref_id\":\"b13\"},\"end\":23971,\"start\":23967},{\"attributes\":{\"ref_id\":\"b27\"},\"end\":24755,\"start\":24751},{\"attributes\":{\"ref_id\":\"b28\"},\"end\":24758,\"start\":24755},{\"attributes\":{\"ref_id\":\"b6\"},\"end\":29209,\"start\":29206},{\"attributes\":{\"ref_id\":\"b23\"},\"end\":29226,\"start\":29222},{\"attributes\":{\"ref_id\":\"b24\"},\"end\":29278,\"start\":29274},{\"attributes\":{\"ref_id\":\"b6\"},\"end\":29311,\"start\":29308},{\"attributes\":{\"ref_id\":\"b27\"},\"end\":30218,\"start\":30214},{\"attributes\":{\"ref_id\":\"b6\"},\"end\":31611,\"start\":31608},{\"attributes\":{\"ref_id\":\"b17\"},\"end\":32378,\"start\":32374},{\"attributes\":{\"ref_id\":\"b18\"},\"end\":32381,\"start\":32378},{\"attributes\":{\"ref_id\":\"b17\"},\"end\":32668,\"start\":32664},{\"attributes\":{\"ref_id\":\"b17\"},\"end\":32801,\"start\":32797},{\"attributes\":{\"ref_id\":\"b17\"},\"end\":32929,\"start\":32925},{\"attributes\":{\"ref_id\":\"b17\"},\"end\":32978,\"start\":32974},{\"attributes\":{\"ref_id\":\"b18\"},\"end\":32981,\"start\":32978},{\"attributes\":{\"ref_id\":\"b17\"},\"end\":33066,\"start\":33062},{\"attributes\":{\"ref_id\":\"b17\"},\"end\":33445,\"start\":33441},{\"attributes\":{\"ref_id\":\"b18\"},\"end\":33448,\"start\":33445},{\"attributes\":{\"ref_id\":\"b17\"},\"end\":34052,\"start\":34048},{\"attributes\":{\"ref_id\":\"b18\"},\"end\":34055,\"start\":34052},{\"attributes\":{\"ref_id\":\"b18\"},\"end\":35470,\"start\":35466},{\"attributes\":{\"ref_id\":\"b20\"},\"end\":35485,\"start\":35481},{\"attributes\":{\"ref_id\":\"b17\"},\"end\":35591,\"start\":35587},{\"attributes\":{\"ref_id\":\"b18\"},\"end\":35594,\"start\":35591},{\"attributes\":{\"ref_id\":\"b18\"},\"end\":35648,\"start\":35644},{\"attributes\":{\"ref_id\":\"b17\"},\"end\":35687,\"start\":35683},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":35980,\"start\":35977},{\"attributes\":{\"ref_id\":\"b26\"},\"end\":36003,\"start\":35999},{\"attributes\":{\"ref_id\":\"b7\"},\"end\":36415,\"start\":36412},{\"attributes\":{\"ref_id\":\"b8\"},\"end\":36417,\"start\":36415},{\"attributes\":{\"ref_id\":\"b10\"},\"end\":36564,\"start\":36560},{\"attributes\":{\"ref_id\":\"b10\"},\"end\":36816,\"start\":36812},{\"attributes\":{\"ref_id\":\"b10\"},\"end\":36882,\"start\":36878},{\"attributes\":{\"ref_id\":\"b18\"},\"end\":37030,\"start\":37026},{\"attributes\":{\"ref_id\":\"b18\"},\"end\":37191,\"start\":37187},{\"attributes\":{\"ref_id\":\"b20\"},\"end\":37340,\"start\":37336},{\"attributes\":{\"ref_id\":\"b17\"},\"end\":37901,\"start\":37897},{\"attributes\":{\"ref_id\":\"b18\"},\"end\":37904,\"start\":37901},{\"attributes\":{\"ref_id\":\"b32\"},\"end\":39325,\"start\":39321},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":43416,\"start\":43413},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":43778,\"start\":43775},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":49981,\"start\":49978},{\"attributes\":{\"ref_id\":\"b13\"},\"end\":52238,\"start\":52234},{\"attributes\":{\"ref_id\":\"b29\"},\"end\":52241,\"start\":52238},{\"attributes\":{\"ref_id\":\"b20\"},\"end\":52258,\"start\":52254},{\"attributes\":{\"ref_id\":\"b30\"},\"end\":52261,\"start\":52258},{\"attributes\":{\"ref_id\":\"b11\"},\"end\":52298,\"start\":52294},{\"attributes\":{\"ref_id\":\"b18\"},\"end\":52329,\"start\":52325},{\"attributes\":{\"ref_id\":\"b17\"},\"end\":52355,\"start\":52351},{\"attributes\":{\"ref_id\":\"b30\"},\"end\":52473,\"start\":52469},{\"attributes\":{\"ref_id\":\"b13\"},\"end\":52483,\"start\":52479},{\"attributes\":{\"ref_id\":\"b29\"},\"end\":52496,\"start\":52492},{\"attributes\":{\"ref_id\":\"b20\"},\"end\":52512,\"start\":52508},{\"attributes\":{\"ref_id\":\"b18\"},\"end\":52753,\"start\":52749},{\"attributes\":{\"ref_id\":\"b25\"},\"end\":55005,\"start\":55001},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":57798,\"start\":57797}]", "figure": "[{\"attributes\":{\"id\":\"fig_0\"},\"end\":55138,\"start\":55079},{\"attributes\":{\"id\":\"fig_1\"},\"end\":55655,\"start\":55139},{\"attributes\":{\"id\":\"fig_2\"},\"end\":55713,\"start\":55656},{\"attributes\":{\"id\":\"fig_3\"},\"end\":56288,\"start\":55714},{\"attributes\":{\"id\":\"fig_4\"},\"end\":56521,\"start\":56289},{\"attributes\":{\"id\":\"fig_5\"},\"end\":56836,\"start\":56522},{\"attributes\":{\"id\":\"tab_1\",\"type\":\"table\"},\"end\":56844,\"start\":56837},{\"attributes\":{\"id\":\"tab_2\",\"type\":\"table\"},\"end\":57656,\"start\":56845}]", "paragraph": "[{\"end\":3299,\"start\":3006},{\"end\":4037,\"start\":3301},{\"end\":4607,\"start\":4039},{\"end\":5395,\"start\":4609},{\"end\":5705,\"start\":5397},{\"end\":6060,\"start\":5707},{\"end\":6235,\"start\":6062},{\"end\":7252,\"start\":6237},{\"end\":7880,\"start\":7254},{\"end\":8745,\"start\":7882},{\"end\":9715,\"start\":8747},{\"end\":10790,\"start\":9717},{\"end\":11252,\"start\":10792},{\"end\":11814,\"start\":11254},{\"end\":11935,\"start\":11829},{\"end\":12073,\"start\":11977},{\"end\":12514,\"start\":12075},{\"end\":12761,\"start\":12516},{\"end\":13197,\"start\":12882},{\"end\":13724,\"start\":13209},{\"end\":14053,\"start\":13726},{\"end\":15552,\"start\":14055},{\"end\":15876,\"start\":15605},{\"end\":16260,\"start\":15878},{\"end\":16904,\"start\":16262},{\"end\":17002,\"start\":16906},{\"end\":17194,\"start\":17004},{\"end\":17841,\"start\":17196},{\"end\":18128,\"start\":17921},{\"end\":18716,\"start\":18152},{\"end\":19984,\"start\":18826},{\"end\":20521,\"start\":20094},{\"end\":21514,\"start\":20541},{\"end\":21944,\"start\":21535},{\"end\":22835,\"start\":21946},{\"end\":23358,\"start\":22859},{\"end\":24645,\"start\":23558},{\"end\":25368,\"start\":24660},{\"end\":26019,\"start\":25488},{\"end\":27102,\"start\":26033},{\"end\":27809,\"start\":27104},{\"end\":28865,\"start\":27819},{\"end\":29279,\"start\":28905},{\"end\":30107,\"start\":29281},{\"end\":30742,\"start\":30109},{\"end\":30954,\"start\":30757},{\"end\":31849,\"start\":30956},{\"end\":32163,\"start\":31851},{\"end\":33067,\"start\":32177},{\"end\":33277,\"start\":33069},{\"end\":33717,\"start\":33279},{\"end\":33938,\"start\":33719},{\"end\":34370,\"start\":33940},{\"end\":35326,\"start\":34372},{\"end\":35688,\"start\":35353},{\"end\":36260,\"start\":35705},{\"end\":36303,\"start\":36262},{\"end\":36817,\"start\":36305},{\"end\":36934,\"start\":36819},{\"end\":37278,\"start\":36936},{\"end\":37480,\"start\":37280},{\"end\":37923,\"start\":37482},{\"end\":38201,\"start\":37973},{\"end\":38689,\"start\":38203},{\"end\":40008,\"start\":38691},{\"end\":40146,\"start\":40021},{\"end\":42242,\"start\":40148},{\"end\":42856,\"start\":42244},{\"end\":43316,\"start\":42907},{\"end\":43779,\"start\":43341},{\"end\":44229,\"start\":43781},{\"end\":45265,\"start\":44250},{\"end\":45607,\"start\":45267},{\"end\":45772,\"start\":45609},{\"end\":46186,\"start\":45807},{\"end\":46741,\"start\":46188},{\"end\":47708,\"start\":46743},{\"end\":48842,\"start\":47795},{\"end\":49713,\"start\":48857},{\"end\":50755,\"start\":49823},{\"end\":51770,\"start\":50757},{\"end\":52075,\"start\":51772},{\"end\":52940,\"start\":52092},{\"end\":53575,\"start\":52942},{\"end\":54153,\"start\":53606},{\"end\":54491,\"start\":54155},{\"end\":55078,\"start\":54493}]", "formula": "[{\"attributes\":{\"id\":\"formula_0\"},\"end\":12881,\"start\":12762},{\"attributes\":{\"id\":\"formula_1\"},\"end\":18825,\"start\":18717},{\"attributes\":{\"id\":\"formula_2\"},\"end\":20085,\"start\":19985},{\"attributes\":{\"id\":\"formula_3\"},\"end\":23413,\"start\":23359},{\"attributes\":{\"id\":\"formula_4\"},\"end\":23557,\"start\":23413},{\"attributes\":{\"id\":\"formula_5\"},\"end\":25487,\"start\":25369},{\"attributes\":{\"id\":\"formula_6\"},\"end\":37972,\"start\":37924},{\"attributes\":{\"id\":\"formula_7\"},\"end\":47755,\"start\":47709},{\"attributes\":{\"id\":\"formula_8\"},\"end\":49822,\"start\":49714}]", "table_ref": "[{\"end\":39520,\"start\":39513},{\"end\":44127,\"start\":44120},{\"end\":44227,\"start\":44220},{\"end\":44792,\"start\":44785},{\"end\":44802,\"start\":44795},{\"end\":45264,\"start\":45257},{\"end\":46601,\"start\":46594},{\"end\":46811,\"start\":46804},{\"end\":47294,\"start\":47287}]", "section_header": "[{\"attributes\":{\"n\":\"1\"},\"end\":3004,\"start\":2992},{\"attributes\":{\"n\":\"2\"},\"end\":11827,\"start\":11817},{\"attributes\":{\"n\":\"2.1\"},\"end\":11975,\"start\":11938},{\"attributes\":{\"n\":\"2.2\"},\"end\":13207,\"start\":13200},{\"attributes\":{\"n\":\"3\"},\"end\":15603,\"start\":15555},{\"attributes\":{\"n\":\"4\"},\"end\":17919,\"start\":17844},{\"attributes\":{\"n\":\"4.1\"},\"end\":18150,\"start\":18131},{\"attributes\":{\"n\":\"4.2\"},\"end\":20092,\"start\":20087},{\"attributes\":{\"n\":\"4.2.1\"},\"end\":20539,\"start\":20524},{\"attributes\":{\"n\":\"4.2.2\"},\"end\":21533,\"start\":21517},{\"attributes\":{\"n\":\"4.2.3\"},\"end\":22857,\"start\":22838},{\"attributes\":{\"n\":\"4.2.4\"},\"end\":24658,\"start\":24648},{\"attributes\":{\"n\":\"4.2.5\"},\"end\":26031,\"start\":26022},{\"end\":27817,\"start\":27812},{\"attributes\":{\"n\":\"4.2.7\"},\"end\":28903,\"start\":28868},{\"attributes\":{\"n\":\"5\"},\"end\":30755,\"start\":30745},{\"attributes\":{\"n\":\"5.1\"},\"end\":32175,\"start\":32166},{\"attributes\":{\"n\":\"5.2\"},\"end\":35351,\"start\":35329},{\"attributes\":{\"n\":\"5.2.1\"},\"end\":35703,\"start\":35691},{\"attributes\":{\"n\":\"5.2.2\"},\"end\":40019,\"start\":40011},{\"attributes\":{\"n\":\"5.3\"},\"end\":42905,\"start\":42859},{\"attributes\":{\"n\":\"5.3.1\"},\"end\":43339,\"start\":43319},{\"attributes\":{\"n\":\"5.3.2\"},\"end\":44248,\"start\":44232},{\"attributes\":{\"n\":\"5.3.3\"},\"end\":45805,\"start\":45775},{\"attributes\":{\"n\":\"5.4\"},\"end\":47793,\"start\":47757},{\"attributes\":{\"n\":\"6\"},\"end\":48855,\"start\":48845},{\"attributes\":{\"n\":\"7\"},\"end\":52090,\"start\":52078},{\"attributes\":{\"n\":\"8\"},\"end\":53604,\"start\":53578},{\"end\":55090,\"start\":55080},{\"end\":55155,\"start\":55140},{\"end\":55667,\"start\":55657},{\"end\":55728,\"start\":55715},{\"end\":56300,\"start\":56290},{\"end\":56538,\"start\":56523},{\"end\":56843,\"start\":56838}]", "table": "[{\"end\":57656,\"start\":56986}]", "figure_caption": "[{\"end\":55138,\"start\":55092},{\"end\":55655,\"start\":55157},{\"end\":55713,\"start\":55669},{\"end\":56288,\"start\":55731},{\"end\":56521,\"start\":56302},{\"end\":56836,\"start\":56539},{\"end\":56986,\"start\":56847}]", "figure_ref": "[{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":15699,\"start\":15691},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":19429,\"start\":19421},{\"attributes\":{\"ref_id\":\"fig_1\"},\"end\":22621,\"start\":22613},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":22685,\"start\":22677},{\"attributes\":{\"ref_id\":\"fig_2\"},\"end\":29627,\"start\":29619},{\"attributes\":{\"ref_id\":\"fig_2\"},\"end\":30432,\"start\":30424},{\"end\":41315,\"start\":41307},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":45606,\"start\":45599},{\"attributes\":{\"ref_id\":\"fig_4\"},\"end\":48370,\"start\":48362}]", "bib_author_first_name": "[{\"end\":59896,\"start\":59890},{\"end\":59911,\"start\":59905},{\"end\":60184,\"start\":60183},{\"end\":60438,\"start\":60433},{\"end\":60453,\"start\":60446},{\"end\":60468,\"start\":60463},{\"end\":60481,\"start\":60476},{\"end\":60495,\"start\":60490},{\"end\":60511,\"start\":60506},{\"end\":61077,\"start\":61067},{\"end\":61095,\"start\":61087},{\"end\":61106,\"start\":61101},{\"end\":61124,\"start\":61118},{\"end\":61719,\"start\":61715},{\"end\":61739,\"start\":61734},{\"end\":61752,\"start\":61746},{\"end\":61771,\"start\":61764},{\"end\":61786,\"start\":61779},{\"end\":61788,\"start\":61787},{\"end\":62444,\"start\":62438},{\"end\":62462,\"start\":62453},{\"end\":62475,\"start\":62468},{\"end\":62493,\"start\":62485},{\"end\":63068,\"start\":63062},{\"end\":63070,\"start\":63069},{\"end\":63083,\"start\":63079},{\"end\":63098,\"start\":63093},{\"end\":63438,\"start\":63433},{\"end\":63440,\"start\":63439},{\"end\":63451,\"start\":63447},{\"end\":63453,\"start\":63452},{\"end\":63941,\"start\":63932},{\"end\":64354,\"start\":64345},{\"end\":64365,\"start\":64360},{\"end\":64380,\"start\":64374},{\"end\":64394,\"start\":64390},{\"end\":64706,\"start\":64703},{\"end\":64717,\"start\":64711},{\"end\":65027,\"start\":65017},{\"end\":65171,\"start\":65166},{\"end\":65186,\"start\":65176},{\"end\":65194,\"start\":65192},{\"end\":65206,\"start\":65201},{\"end\":65752,\"start\":65747},{\"end\":65764,\"start\":65757},{\"end\":65775,\"start\":65770},{\"end\":65790,\"start\":65780},{\"end\":65799,\"start\":65796},{\"end\":65813,\"start\":65806},{\"end\":65826,\"start\":65819},{\"end\":65837,\"start\":65834},{\"end\":66401,\"start\":66395},{\"end\":66418,\"start\":66413},{\"end\":66428,\"start\":66424},{\"end\":66941,\"start\":66940},{\"end\":66963,\"start\":66962},{\"end\":66965,\"start\":66964},{\"end\":67538,\"start\":67532},{\"end\":67550,\"start\":67543},{\"end\":67562,\"start\":67556},{\"end\":67571,\"start\":67567},{\"end\":67583,\"start\":67576},{\"end\":67585,\"start\":67584},{\"end\":68153,\"start\":68147},{\"end\":68165,\"start\":68158},{\"end\":68176,\"start\":68171},{\"end\":68191,\"start\":68184},{\"end\":68193,\"start\":68192},{\"end\":68628,\"start\":68625},{\"end\":68652,\"start\":68643},{\"end\":69271,\"start\":69261},{\"end\":69282,\"start\":69281},{\"end\":69308,\"start\":69299},{\"end\":69310,\"start\":69309},{\"end\":69718,\"start\":69713},{\"end\":69730,\"start\":69723},{\"end\":69744,\"start\":69737},{\"end\":69758,\"start\":69751},{\"end\":69760,\"start\":69759},{\"end\":69769,\"start\":69766},{\"end\":70182,\"start\":70175},{\"end\":70199,\"start\":70192},{\"end\":70217,\"start\":70209},{\"end\":70829,\"start\":70825},{\"end\":70837,\"start\":70836},{\"end\":70852,\"start\":70845},{\"end\":71372,\"start\":71364},{\"end\":71386,\"start\":71385},{\"end\":71400,\"start\":71395},{\"end\":72031,\"start\":72025},{\"end\":72044,\"start\":72038},{\"end\":72058,\"start\":72052},{\"end\":72357,\"start\":72352},{\"end\":72380,\"start\":72372},{\"end\":72405,\"start\":72402},{\"end\":72419,\"start\":72415},{\"end\":73043,\"start\":73042},{\"end\":73045,\"start\":73044},{\"end\":73059,\"start\":73058},{\"end\":73061,\"start\":73060},{\"end\":73248,\"start\":73241},{\"end\":73711,\"start\":73706},{\"end\":73721,\"start\":73718},{\"end\":73737,\"start\":73726},{\"end\":74254,\"start\":74249},{\"end\":74681,\"start\":74680},{\"end\":74685,\"start\":74682},{\"end\":74706,\"start\":74705},{\"end\":74731,\"start\":74730},{\"end\":74733,\"start\":74732},{\"end\":74748,\"start\":74739},{\"end\":75430,\"start\":75424},{\"end\":75440,\"start\":75439},{\"end\":75857,\"start\":75852},{\"end\":75871,\"start\":75864},{\"end\":75880,\"start\":75877},{\"end\":75889,\"start\":75886},{\"end\":75900,\"start\":75894},{\"end\":76449,\"start\":76448},{\"end\":76454,\"start\":76450},{\"end\":76468,\"start\":76461},{\"end\":76484,\"start\":76477},{\"end\":76501,\"start\":76493},{\"end\":76513,\"start\":76506},{\"end\":76853,\"start\":76850},{\"end\":77074,\"start\":77070},{\"end\":77087,\"start\":77081},{\"end\":77102,\"start\":77094},{\"end\":77574,\"start\":77567},{\"end\":77586,\"start\":77580},{\"end\":77596,\"start\":77591},{\"end\":77607,\"start\":77601},{\"end\":77622,\"start\":77615},{\"end\":77624,\"start\":77623},{\"end\":77637,\"start\":77630}]", "bib_author_last_name": "[{\"end\":59903,\"start\":59897},{\"end\":59918,\"start\":59912},{\"end\":60189,\"start\":60185},{\"end\":60196,\"start\":60191},{\"end\":60444,\"start\":60439},{\"end\":60461,\"start\":60454},{\"end\":60474,\"start\":60469},{\"end\":60488,\"start\":60482},{\"end\":60504,\"start\":60496},{\"end\":60518,\"start\":60512},{\"end\":61085,\"start\":61078},{\"end\":61099,\"start\":61096},{\"end\":61116,\"start\":61107},{\"end\":61131,\"start\":61125},{\"end\":61732,\"start\":61720},{\"end\":61744,\"start\":61740},{\"end\":61762,\"start\":61753},{\"end\":61777,\"start\":61772},{\"end\":61794,\"start\":61789},{\"end\":62451,\"start\":62445},{\"end\":62466,\"start\":62463},{\"end\":62483,\"start\":62476},{\"end\":62501,\"start\":62494},{\"end\":63077,\"start\":63071},{\"end\":63091,\"start\":63084},{\"end\":63106,\"start\":63099},{\"end\":63445,\"start\":63441},{\"end\":63466,\"start\":63454},{\"end\":63945,\"start\":63942},{\"end\":64358,\"start\":64355},{\"end\":64372,\"start\":64366},{\"end\":64388,\"start\":64381},{\"end\":64404,\"start\":64395},{\"end\":64709,\"start\":64707},{\"end\":64720,\"start\":64718},{\"end\":65032,\"start\":65028},{\"end\":65036,\"start\":65034},{\"end\":65041,\"start\":65038},{\"end\":65174,\"start\":65172},{\"end\":65190,\"start\":65187},{\"end\":65199,\"start\":65195},{\"end\":65209,\"start\":65207},{\"end\":65755,\"start\":65753},{\"end\":65768,\"start\":65765},{\"end\":65778,\"start\":65776},{\"end\":65794,\"start\":65791},{\"end\":65804,\"start\":65800},{\"end\":65817,\"start\":65814},{\"end\":65832,\"start\":65827},{\"end\":65841,\"start\":65838},{\"end\":66411,\"start\":66402},{\"end\":66422,\"start\":66419},{\"end\":66435,\"start\":66429},{\"end\":66951,\"start\":66942},{\"end\":66960,\"start\":66953},{\"end\":66969,\"start\":66966},{\"end\":66984,\"start\":66971},{\"end\":67541,\"start\":67539},{\"end\":67554,\"start\":67551},{\"end\":67565,\"start\":67563},{\"end\":67574,\"start\":67572},{\"end\":67589,\"start\":67586},{\"end\":68156,\"start\":68154},{\"end\":68169,\"start\":68166},{\"end\":68182,\"start\":68177},{\"end\":68197,\"start\":68194},{\"end\":68641,\"start\":68629},{\"end\":68656,\"start\":68653},{\"end\":68661,\"start\":68658},{\"end\":69279,\"start\":69272},{\"end\":69297,\"start\":69283},{\"end\":69317,\"start\":69311},{\"end\":69721,\"start\":69719},{\"end\":69735,\"start\":69731},{\"end\":69749,\"start\":69745},{\"end\":69764,\"start\":69761},{\"end\":69773,\"start\":69770},{\"end\":70190,\"start\":70183},{\"end\":70207,\"start\":70200},{\"end\":70225,\"start\":70218},{\"end\":70834,\"start\":70830},{\"end\":70843,\"start\":70838},{\"end\":70858,\"start\":70853},{\"end\":70870,\"start\":70860},{\"end\":71383,\"start\":71373},{\"end\":71393,\"start\":71387},{\"end\":71408,\"start\":71401},{\"end\":71417,\"start\":71410},{\"end\":72036,\"start\":72032},{\"end\":72050,\"start\":72045},{\"end\":72065,\"start\":72059},{\"end\":72073,\"start\":72067},{\"end\":72370,\"start\":72358},{\"end\":72400,\"start\":72381},{\"end\":72413,\"start\":72406},{\"end\":72425,\"start\":72420},{\"end\":73056,\"start\":73046},{\"end\":73067,\"start\":73062},{\"end\":73257,\"start\":73249},{\"end\":73716,\"start\":73712},{\"end\":73724,\"start\":73722},{\"end\":73743,\"start\":73738},{\"end\":74263,\"start\":74255},{\"end\":74689,\"start\":74686},{\"end\":74703,\"start\":74691},{\"end\":74716,\"start\":74707},{\"end\":74728,\"start\":74718},{\"end\":74737,\"start\":74734},{\"end\":74756,\"start\":74749},{\"end\":74768,\"start\":74758},{\"end\":75437,\"start\":75431},{\"end\":75447,\"start\":75441},{\"end\":75456,\"start\":75449},{\"end\":75862,\"start\":75858},{\"end\":75875,\"start\":75872},{\"end\":75884,\"start\":75881},{\"end\":75892,\"start\":75890},{\"end\":75907,\"start\":75901},{\"end\":76459,\"start\":76455},{\"end\":76475,\"start\":76469},{\"end\":76491,\"start\":76485},{\"end\":76504,\"start\":76502},{\"end\":76527,\"start\":76514},{\"end\":76856,\"start\":76854},{\"end\":77079,\"start\":77075},{\"end\":77092,\"start\":77088},{\"end\":77107,\"start\":77103},{\"end\":77578,\"start\":77575},{\"end\":77589,\"start\":77587},{\"end\":77599,\"start\":77597},{\"end\":77613,\"start\":77608},{\"end\":77628,\"start\":77625},{\"end\":77643,\"start\":77638}]", "bib_entry": "[{\"attributes\":{\"doi\":\"core 135 2 20050605 -06.45.36 INFO generating core 198 3 20050605 -06.45.36 INFO generating core 199 4 20050605 -06.45.36 FATAL instruction address 0 x0000df30 5 20050605 -06.45\",\"id\":\"b0\"},\"end\":59787,\"start\":58231},{\"attributes\":{\"id\":\"b1\",\"matched_paper_id\":18284089},\"end\":60147,\"start\":59789},{\"attributes\":{\"id\":\"b2\"},\"end\":60402,\"start\":60149},{\"attributes\":{\"id\":\"b3\",\"matched_paper_id\":13602699},\"end\":60963,\"start\":60404},{\"attributes\":{\"id\":\"b4\",\"matched_paper_id\":217129885},\"end\":61625,\"start\":60965},{\"attributes\":{\"id\":\"b5\",\"matched_paper_id\":15088239},\"end\":62389,\"start\":61627},{\"attributes\":{\"id\":\"b6\",\"matched_paper_id\":9883277},\"end\":62960,\"start\":62391},{\"attributes\":{\"id\":\"b7\",\"matched_paper_id\":14799739},\"end\":63376,\"start\":62962},{\"attributes\":{\"id\":\"b8\",\"matched_paper_id\":13282951},\"end\":63900,\"start\":63378},{\"attributes\":{\"id\":\"b9\",\"matched_paper_id\":21438694},\"end\":64281,\"start\":63902},{\"attributes\":{\"id\":\"b10\",\"matched_paper_id\":9914171},\"end\":64654,\"start\":64283},{\"attributes\":{\"id\":\"b11\",\"matched_paper_id\":206784678},\"end\":65013,\"start\":64656},{\"attributes\":{\"id\":\"b12\"},\"end\":65078,\"start\":65015},{\"attributes\":{\"id\":\"b13\",\"matched_paper_id\":16707374},\"end\":65667,\"start\":65080},{\"attributes\":{\"id\":\"b14\",\"matched_paper_id\":1452863},\"end\":66339,\"start\":65669},{\"attributes\":{\"id\":\"b15\",\"matched_paper_id\":19474196},\"end\":66857,\"start\":66341},{\"attributes\":{\"id\":\"b16\",\"matched_paper_id\":18729886},\"end\":67468,\"start\":66859},{\"attributes\":{\"id\":\"b17\",\"matched_paper_id\":9995103},\"end\":68084,\"start\":67470},{\"attributes\":{\"id\":\"b18\",\"matched_paper_id\":4776668},\"end\":68560,\"start\":68086},{\"attributes\":{\"id\":\"b19\"},\"end\":69179,\"start\":68562},{\"attributes\":{\"id\":\"b20\",\"matched_paper_id\":7683158},\"end\":69605,\"start\":69181},{\"attributes\":{\"id\":\"b21\",\"matched_paper_id\":1027883},\"end\":70091,\"start\":69607},{\"attributes\":{\"id\":\"b22\",\"matched_paper_id\":4567225},\"end\":70764,\"start\":70093},{\"attributes\":{\"id\":\"b23\",\"matched_paper_id\":16800985},\"end\":71290,\"start\":70766},{\"attributes\":{\"id\":\"b24\",\"matched_paper_id\":15965879},\"end\":71918,\"start\":71292},{\"attributes\":{\"id\":\"b25\"},\"end\":72262,\"start\":71920},{\"attributes\":{\"id\":\"b26\",\"matched_paper_id\":15815306},\"end\":73004,\"start\":72264},{\"attributes\":{\"id\":\"b27\"},\"end\":73198,\"start\":73006},{\"attributes\":{\"id\":\"b28\",\"matched_paper_id\":5591871},\"end\":73648,\"start\":73200},{\"attributes\":{\"id\":\"b29\",\"matched_paper_id\":207191250},\"end\":74182,\"start\":73650},{\"attributes\":{\"id\":\"b30\",\"matched_paper_id\":17410492},\"end\":74626,\"start\":74184},{\"attributes\":{\"id\":\"b31\",\"matched_paper_id\":2333838},\"end\":75326,\"start\":74628},{\"attributes\":{\"id\":\"b32\",\"matched_paper_id\":120137017},\"end\":75720,\"start\":75328},{\"attributes\":{\"id\":\"b33\",\"matched_paper_id\":16616897},\"end\":76379,\"start\":75722},{\"attributes\":{\"id\":\"b34\",\"matched_paper_id\":3329645},\"end\":76779,\"start\":76381},{\"attributes\":{\"id\":\"b35\"},\"end\":77010,\"start\":76781},{\"attributes\":{\"id\":\"b36\",\"matched_paper_id\":14211994},\"end\":77496,\"start\":77012},{\"attributes\":{\"id\":\"b37\",\"matched_paper_id\":1817580},\"end\":78083,\"start\":77498}]", "bib_title": "[{\"end\":59888,\"start\":59789},{\"end\":60181,\"start\":60149},{\"end\":60431,\"start\":60404},{\"end\":61065,\"start\":60965},{\"end\":61713,\"start\":61627},{\"end\":62436,\"start\":62391},{\"end\":63060,\"start\":62962},{\"end\":63431,\"start\":63378},{\"end\":63930,\"start\":63902},{\"end\":64343,\"start\":64283},{\"end\":64701,\"start\":64656},{\"end\":65164,\"start\":65080},{\"end\":65745,\"start\":65669},{\"end\":66393,\"start\":66341},{\"end\":66938,\"start\":66859},{\"end\":67530,\"start\":67470},{\"end\":68145,\"start\":68086},{\"end\":68623,\"start\":68562},{\"end\":69259,\"start\":69181},{\"end\":69711,\"start\":69607},{\"end\":70173,\"start\":70093},{\"end\":70823,\"start\":70766},{\"end\":71362,\"start\":71292},{\"end\":72350,\"start\":72264},{\"end\":73239,\"start\":73200},{\"end\":73704,\"start\":73650},{\"end\":74247,\"start\":74184},{\"end\":74678,\"start\":74628},{\"end\":75422,\"start\":75328},{\"end\":75850,\"start\":75722},{\"end\":76446,\"start\":76381},{\"end\":77068,\"start\":77012},{\"end\":77565,\"start\":77498}]", "bib_author": "[{\"end\":59905,\"start\":59890},{\"end\":59920,\"start\":59905},{\"end\":60191,\"start\":60183},{\"end\":60198,\"start\":60191},{\"end\":60446,\"start\":60433},{\"end\":60463,\"start\":60446},{\"end\":60476,\"start\":60463},{\"end\":60490,\"start\":60476},{\"end\":60506,\"start\":60490},{\"end\":60520,\"start\":60506},{\"end\":61087,\"start\":61067},{\"end\":61101,\"start\":61087},{\"end\":61118,\"start\":61101},{\"end\":61133,\"start\":61118},{\"end\":61734,\"start\":61715},{\"end\":61746,\"start\":61734},{\"end\":61764,\"start\":61746},{\"end\":61779,\"start\":61764},{\"end\":61796,\"start\":61779},{\"end\":62453,\"start\":62438},{\"end\":62468,\"start\":62453},{\"end\":62485,\"start\":62468},{\"end\":62503,\"start\":62485},{\"end\":63079,\"start\":63062},{\"end\":63093,\"start\":63079},{\"end\":63108,\"start\":63093},{\"end\":63447,\"start\":63433},{\"end\":63468,\"start\":63447},{\"end\":63947,\"start\":63932},{\"end\":64360,\"start\":64345},{\"end\":64374,\"start\":64360},{\"end\":64390,\"start\":64374},{\"end\":64406,\"start\":64390},{\"end\":64711,\"start\":64703},{\"end\":64722,\"start\":64711},{\"end\":65034,\"start\":65017},{\"end\":65038,\"start\":65034},{\"end\":65043,\"start\":65038},{\"end\":65176,\"start\":65166},{\"end\":65192,\"start\":65176},{\"end\":65201,\"start\":65192},{\"end\":65211,\"start\":65201},{\"end\":65757,\"start\":65747},{\"end\":65770,\"start\":65757},{\"end\":65780,\"start\":65770},{\"end\":65796,\"start\":65780},{\"end\":65806,\"start\":65796},{\"end\":65819,\"start\":65806},{\"end\":65834,\"start\":65819},{\"end\":65843,\"start\":65834},{\"end\":66413,\"start\":66395},{\"end\":66424,\"start\":66413},{\"end\":66437,\"start\":66424},{\"end\":66953,\"start\":66940},{\"end\":66962,\"start\":66953},{\"end\":66971,\"start\":66962},{\"end\":66986,\"start\":66971},{\"end\":67543,\"start\":67532},{\"end\":67556,\"start\":67543},{\"end\":67567,\"start\":67556},{\"end\":67576,\"start\":67567},{\"end\":67591,\"start\":67576},{\"end\":68158,\"start\":68147},{\"end\":68171,\"start\":68158},{\"end\":68184,\"start\":68171},{\"end\":68199,\"start\":68184},{\"end\":68643,\"start\":68625},{\"end\":68658,\"start\":68643},{\"end\":68663,\"start\":68658},{\"end\":69281,\"start\":69261},{\"end\":69299,\"start\":69281},{\"end\":69319,\"start\":69299},{\"end\":69723,\"start\":69713},{\"end\":69737,\"start\":69723},{\"end\":69751,\"start\":69737},{\"end\":69766,\"start\":69751},{\"end\":69775,\"start\":69766},{\"end\":70192,\"start\":70175},{\"end\":70209,\"start\":70192},{\"end\":70227,\"start\":70209},{\"end\":70836,\"start\":70825},{\"end\":70845,\"start\":70836},{\"end\":70860,\"start\":70845},{\"end\":70872,\"start\":70860},{\"end\":71385,\"start\":71364},{\"end\":71395,\"start\":71385},{\"end\":71410,\"start\":71395},{\"end\":71419,\"start\":71410},{\"end\":72038,\"start\":72025},{\"end\":72052,\"start\":72038},{\"end\":72067,\"start\":72052},{\"end\":72075,\"start\":72067},{\"end\":72372,\"start\":72352},{\"end\":72402,\"start\":72372},{\"end\":72415,\"start\":72402},{\"end\":72427,\"start\":72415},{\"end\":73058,\"start\":73042},{\"end\":73069,\"start\":73058},{\"end\":73259,\"start\":73241},{\"end\":73718,\"start\":73706},{\"end\":73726,\"start\":73718},{\"end\":73745,\"start\":73726},{\"end\":74265,\"start\":74249},{\"end\":74691,\"start\":74680},{\"end\":74705,\"start\":74691},{\"end\":74718,\"start\":74705},{\"end\":74730,\"start\":74718},{\"end\":74739,\"start\":74730},{\"end\":74758,\"start\":74739},{\"end\":74770,\"start\":74758},{\"end\":75439,\"start\":75424},{\"end\":75449,\"start\":75439},{\"end\":75458,\"start\":75449},{\"end\":75864,\"start\":75852},{\"end\":75877,\"start\":75864},{\"end\":75886,\"start\":75877},{\"end\":75894,\"start\":75886},{\"end\":75909,\"start\":75894},{\"end\":76461,\"start\":76448},{\"end\":76477,\"start\":76461},{\"end\":76493,\"start\":76477},{\"end\":76506,\"start\":76493},{\"end\":76529,\"start\":76506},{\"end\":76858,\"start\":76850},{\"end\":77081,\"start\":77070},{\"end\":77094,\"start\":77081},{\"end\":77109,\"start\":77094},{\"end\":77580,\"start\":77567},{\"end\":77591,\"start\":77580},{\"end\":77601,\"start\":77591},{\"end\":77615,\"start\":77601},{\"end\":77630,\"start\":77615},{\"end\":77645,\"start\":77630}]", "bib_venue": "[{\"end\":58611,\"start\":58231},{\"end\":59950,\"start\":59920},{\"end\":60247,\"start\":60198},{\"end\":60601,\"start\":60520},{\"end\":61216,\"start\":61133},{\"end\":61913,\"start\":61796},{\"end\":62588,\"start\":62503},{\"end\":63150,\"start\":63108},{\"end\":63543,\"start\":63468},{\"end\":64039,\"start\":63947},{\"end\":64451,\"start\":64406},{\"end\":64795,\"start\":64722},{\"end\":65284,\"start\":65211},{\"end\":65931,\"start\":65843},{\"end\":66520,\"start\":66437},{\"end\":67075,\"start\":66986},{\"end\":67691,\"start\":67591},{\"end\":68258,\"start\":68199},{\"end\":68766,\"start\":68663},{\"end\":69370,\"start\":69319},{\"end\":69828,\"start\":69775},{\"end\":70346,\"start\":70227},{\"end\":70953,\"start\":70872},{\"end\":71520,\"start\":71419},{\"end\":72023,\"start\":71920},{\"end\":72530,\"start\":72427},{\"end\":73040,\"start\":73006},{\"end\":73328,\"start\":73259},{\"end\":73837,\"start\":73745},{\"end\":74337,\"start\":74265},{\"end\":74877,\"start\":74770},{\"end\":75506,\"start\":75458},{\"end\":75981,\"start\":75909},{\"end\":76561,\"start\":76529},{\"end\":76848,\"start\":76781},{\"end\":77181,\"start\":77109},{\"end\":77717,\"start\":77645},{\"end\":60266,\"start\":60249},{\"end\":60686,\"start\":60603},{\"end\":61305,\"start\":61218},{\"end\":62034,\"start\":61915},{\"end\":62678,\"start\":62590},{\"end\":63627,\"start\":63545},{\"end\":64058,\"start\":64041},{\"end\":64855,\"start\":64797},{\"end\":65365,\"start\":65286},{\"end\":66023,\"start\":65933},{\"end\":66609,\"start\":66522},{\"end\":67169,\"start\":67077},{\"end\":67797,\"start\":67693},{\"end\":68323,\"start\":68260},{\"end\":68874,\"start\":68768},{\"end\":70469,\"start\":70348},{\"end\":71038,\"start\":70955},{\"end\":71627,\"start\":71522},{\"end\":72639,\"start\":72532},{\"end\":73406,\"start\":73330},{\"end\":73933,\"start\":73839},{\"end\":74415,\"start\":74339},{\"end\":74977,\"start\":74879},{\"end\":76057,\"start\":75983},{\"end\":77259,\"start\":77183},{\"end\":77795,\"start\":77719}]"}}}, "year": 2023, "month": 12, "day": 17}