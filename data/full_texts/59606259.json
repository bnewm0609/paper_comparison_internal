{"id": 59606259, "updated": "2023-10-02 12:51:15.16", "metadata": {"title": "A Neural Model for Generating Natural Language Summaries of Program Subroutines", "authors": "[{\"first\":\"Alexander\",\"last\":\"LeClair\",\"middle\":[]},{\"first\":\"Siyuan\",\"last\":\"Jiang\",\"middle\":[]},{\"first\":\"Collin\",\"last\":\"McMillan\",\"middle\":[]}]", "venue": "2019 IEEE/ACM 41st International Conference on Software Engineering (ICSE)", "journal": "2019 IEEE/ACM 41st International Conference on Software Engineering (ICSE)", "publication_date": {"year": 2019, "month": 2, "day": 5}, "abstract": "Source code summarization -- creating natural language descriptions of source code behavior -- is a rapidly-growing research topic with applications to automatic documentation generation, program comprehension, and software maintenance. Traditional techniques relied on heuristics and templates built manually by human experts. Recently, data-driven approaches based on neural machine translation have largely overtaken template-based systems. But nearly all of these techniques rely almost entirely on programs having good internal documentation; without clear identifier names, the models fail to create good summaries. In this paper, we present a neural model that combines words from code with code structure from an AST. Unlike previous approaches, our model processes each data source as a separate input, which allows the model to learn code structure independent of the text in code. This process helps our approach provide coherent summaries in many cases even when zero internal documentation is provided. We evaluate our technique with a dataset we created from 2.1m Java methods. We find improvement over two baseline techniques from SE literature and one from NLP literature.", "fields_of_study": "[\"Computer Science\"]", "external_ids": {"arxiv": "1902.01954", "mag": "2964194820", "acl": null, "pubmed": null, "pubmedcentral": null, "dblp": "conf/icse/LeClairJM19", "doi": "10.1109/icse.2019.00087"}}, "content": {"source": {"pdf_hash": "44d5aac2abbd004208949ac5bfe118e5451a6bd3", "pdf_src": "Arxiv", "pdf_uri": "[\"https://arxiv.org/pdf/1902.01954v1.pdf\"]", "oa_url_match": true, "oa_info": {"license": null, "open_access_url": "http://arxiv.org/pdf/1902.01954", "status": "GREEN"}}, "grobid": {"id": "36aaa923d07a90c79e52773cee9b6571b815870b", "type": "plain-text", "url": "s3://ai2-s2-pdf-extraction-prod/parse-results/s2orc_worker/44d5aac2abbd004208949ac5bfe118e5451a6bd3.txt", "contents": "\nA Neural Model for Generating Natural Language Summaries of Program Subroutines\n\n\nAlexander Leclair aleclair@nd.edu \nSiyuan Jiang sjiang1@emich.edu \nDept. of Computer Science Eastern\nMichigan University Ypsilanti\nMIUSA\n\nCollin Mcmillan \n\nDept. of Computer Science and Engineering\nUniversity of Notre Dame Notre Dame\nINUSA\n\nA Neural Model for Generating Natural Language Summaries of Program Subroutines\nIndex Terms-automatic documentation generationsource code summarizationcode comment generation\nSource code summarization -creating natural language descriptions of source code behavior -is a rapidly-growing research topic with applications to automatic documentation generation, program comprehension, and software maintenance. Traditional techniques relied on heuristics and templates built manually by human experts. Recently, data-driven approaches based on neural machine translation have largely overtaken template-based systems. But nearly all of these techniques rely almost entirely on programs having good internal documentation; without clear identifier names, the models fail to create good summaries. In this paper, we present a neural model that combines words from code with code structure from an AST. Unlike previous approaches, our model processes each data source as a separate input, which allows the model to learn code structure independent of the text in code. This process helps our approach provide coherent summaries in many cases even when zero internal documentation is provided. We evaluate our technique with a dataset we created from 2.1m Java methods. We find improvement over two baseline techniques from SE literature and one from NLP literature.\n\nAbstract-Source code summarization -creating natural language descriptions of source code behavior -is a rapidly-growing research topic with applications to automatic documentation generation, program comprehension, and software maintenance. Traditional techniques relied on heuristics and templates built manually by human experts. Recently, data-driven approaches based on neural machine translation have largely overtaken template-based systems. But nearly all of these techniques rely almost entirely on programs having good internal documentation; without clear identifier names, the models fail to create good summaries. In this paper, we present a neural model that combines words from code with code structure from an AST. Unlike previous approaches, our model processes each data source as a separate input, which allows the model to learn code structure independent of the text in code. This process helps our approach provide coherent summaries in many cases even when zero internal documentation is provided. We evaluate our technique with a dataset we created from 2.1m Java methods. We find improvement over two baseline techniques from SE literature and one from NLP literature.\n\nIndex Terms-automatic documentation generation, source code summarization, code comment generation\n\n\nI. INTRODUCTION\n\nA \"summary\" of source code is a brief natural language description of that section of source code [1]. One of the most common targets for summarization are the subroutines in a program; for example, the one-sentence descriptions of Java methods widely used in automatically-formatted documentation e.g. JavaDocs [2]. These descriptions are useful because they help programmers understand the role that the subroutine plays in a program -empirical studies have repeatedly shown that understanding the role of the subroutines in a program is a crucial step to understanding the program's behavior overall [3]- [6]. Even a short summary of a subroutine e.g. \"returns the player's hitpoint count\" can tell a programmer a lot about that subroutine and the program as a whole.\n\nA holy grail of software engineering research has long been to generate these summaries automatically. technologies that improve automation of the documentation process,\" and \"that documentation tools should seek to better extract knowledge from core resources\", such as source code [7]. However, the state-of-the-practice has barely changed since that time for tool support for automated documentation generation. Tools such as JavaDoc [2] and Doxygen [8] automate the format and presentation of documentation, but still leave programmers with the most labor-intensive effort of writing the text and examples.\n\nResearch into generation of natural language descriptions of code has come to be known as \"source code summarization\" [9], with significant effort focused on generation of summaries of subroutines: For several years, significant progress was made based on content selection and sentence templates [1], [10]- [14] or even somewhat-idiosyncratic solutions such as mimicking human eye movements [15]. However, as in many research areas and as chronicled in a recent survey by Allamanis et al. [16], these techniques have largely given way to AI based on big data input.\n\nThe inspiration for a vast majority of efforts into AI-based code summarization originates in neural machine translation (NMT) from the natural language processing research community. An NMT system converts one natural language into another. It is typically thought of in terms of sequence to sequence (seq2seq) learning, in which an e.g. English sentence is one sequence and is converted into a equivalent target sequence representing a e.g. French sentence. In software engineering research, machine translation can be considered as a metaphor for source code summarization: the words and tokens in the body of a subroutine are one sequence, while the desired natural language summary is the target sequence. This application of NMT to code summarization has shown strong benefits in a variety of applications [17]- [22].\n\nHowever, an Achilles' heel to nearly all source code summarization techniques is a reliance on programmers having written high quality internal documentation in the form of identifier names or comments. In order to generate a meaningful summary, meaningful words must be observed in the body of the subroutine. In traditional NMT, this is accepted because a natural language input sentence will definitely have words related to the output target sentence. But in software, the words in code are not actually related to the behavior of that code. A subroutine's behavior is dictated by the structure of programming language keywords and tokens that define control flow, data flow, etc. These differences between code and natural language are a barrier to improving performance in several AI applications to software engineering, as Hellendoorn et al. [23] pointed out, to some controversy, at FSE'17.\n\nIn this paper, we present a neural model for summarizing subroutines. Our model combines two types of information about source code: 1) a word representation treating code as text, and 2) an abstract syntax tree (AST) representation. A distinguishing factor of our model compared to earlier approaches is that we treat both representations separately. Previous techniques have shown promise by annotating a word representation with AST information [22], but ultimately the annotated representation is sent as a single sequence through a standard seq2seq model. In contrast, our model accepts two inputs, one for the word representation and one for the AST. The advantage is that we are able to treat each input with differently, which increases the flexibility of our approach, as we will show in this paper.\n\nIn essense, the neural model we propose involves two unidirectional gated recurrent unit (GRU) layers: one to process the words from source code, and one to process the AST. We modify the SBT AST flattening procedure by Hu et al. [22] to represent the AST. We then use an attention mechanism to attend words in the output summary sentence to words in the code word representation, and a separate attention mechanism to attend the summary words to parts of the AST. We concatenate the vectors from each attention mechanism to create a context vector. Finally, we predict the summary one word at a time from the context vector, following what is typical in seq2seq models.\n\nWe evaluate our technique in two stages. First, we collect over 51m Java methods from the Sourcerer repository [24], and preprocess them to form a dataset of around 2.1m methods with suitable JavaDoc summary comments. We divide the dataset into training/validation/testing sets and perform a set of tests comparing results from our model to three competitive baselines. We call this the standard experiment, because it conforms to common practice in both SE and NLP venues.\n\nSecond, to evaluate the limits of our model in a scenario without words from source code, we repeat the standard experiment using only the AST for each Java method -in this study, we assume no code words are available, as in obfuscated code, poorly-written code, or situations in which there is only bytecode (from which an AST can be extracted but code words are likely to have been removed during compilation). This \"no code words\" experiment simulates a situation unique to the SE domain and, as we will show, is far more difficult than the standard application of NMT in which a programmer provides useful keywords. We call this the challenge experiment.\n\nOur results, in a nutshell, are: 1) In the standard experiment, our model and the competitive NLP baseline provide compara-ble performance but with orthogonal predictions, implying that they are good candidates for ensemble decoding. An ensemble provides state-of-the-art performance of 20.9 BLEU (an 8% improvement over the nearest baseline). 2) In the challenge experiment, our model achieves 9.5 BLEU, versus 0 for any baseline. This is a significant step forward in source code summarization, since it requires zero meaningful code words. We release all data, code, and implementation via our online appendix (see Section X).\n\n\nII. PROBLEM AND OVERVIEW\n\nWe target the problem of source code summarization of subroutines -automatic generation of natural language descriptions of subroutines. Specifically, we target summarization of Java methods, with the objective of creating method summaries like those used in JavaDocs. While we limit the scope of the experiments in this paper to a large Java dataset, in principle the techniques described in this paper are applicable to any programming language that has subroutines, from which an AST can be computed, and from which text e.g. identifier names can be extracted. Our scoping of our target problem is consistent with the problem definition in many papers on code summarization [1], [12], [13], [22], [25].\n\nA solution to this problem would have many practical applications. The primary practical application would be in automatic documentation generation, to help programmers write documentation more quickly, as well as understand code that has not been documented. Of the 51m Java methods we found in the Sourcerer dataset, only about 10% have any sort of method summary, and only about 4% contain summaries that met basic quality filters we define in Section V. In our view, it seems likely that more than 4% \"should\" be documented well, and an automatic summary generator would help improve the amount of code that could be documented.\n\nBut more generally, our goal for this paper is to also contribute to an ongoing academic debate about how to represent source code to solve software engineering problems using AI. As mentioned, there is reasonable doubt [23] that neural-based techniques are even appropriate for software engineering data; a recent workshop at AAAI'18 [26] focused heavily on this debate. Given the long history of AI use to solve SE problems [27], our sincere hope for this paper is to provide insight into ways to build neural models of SE data, even for researchers outside of the specific task of code summarization. We have made significant efforts to keep our data and techniques public and reproducible (see Section X) to help these other researchers as much as possible.\n\nAn overview of this paper is below. In the next section we cover background and related technologies. Then, we introduce our proposed neural model. We then describe how we obtained and processed the Java datasets we use. We conduct the standard and challenge experiments on the same set of Java methods. Finally, we spend significant space on examples and discussion. We feel an in-depth look at examples where the model worked and did not will provide key insights for improving or adapting the model in the future.\n\nIII. BACKGROUND AND RELATED WORK This section covers the supporting technologies behind our work, plus related work in source code summarization.\n\n\nA. Source Code Summarization\n\nRelated work in source code summarization can be broadly classified as either AI/data-driven or heuristic/template-driven.\n\n1) Data-driven: Among data-driven techniques, recent work by Hu et al. [22] is the most-closely related to this paper. That work proposes to use the AST to annotate the words in the source code, and then use the annotated representation as input to a seq2seq neural model. The model itself is an off-the-shelf encoder-decoder; the main advancement is the AST-annotated representation called Structurebased Traversal (SBT). SBT is essentially a technique for flattening the AST and ensuring that words in the code are associated with their AST node type. For example, the code request.remove(id) becomes:\n( MethodInvocation ( SimpleName_request ) SimpleName_request ( SimpleName_remove ) SimpleName_remove ( SimpleName_id ) SimpleName_id ) MethodInvocation\nThe intent is that the words \"request\", \"remove\", and \"id\" be associated with the context in which they appear. In this case, a MethodInvocation node. The SBT representation forms an important baseline for comparison in our experiments in later sections. A casual reader will note that SBT was shown in that paper to obtain remarkable performance of 38 BLEU, but we caution that this is not directly comparable to the results in our experiments. The reason is that in [22], the dataset was split by function, so the training, validation, and test sets contain random selections of functions in the entire dataset. In contrast, we split by project. In [22], functions from the same project can be in both the training and test sets. In our experiments, all methods from a project are either training, validation, or test. In addition, we performed other preprocessing such as autogenerated code removal (see Section V), to avoid situations where identical methods appear in both training and test sets. Taken together, we expect that the nominal performance scores for all approaches will be far lower in our experiments.\n\nOther related AI/data approaches in generating summaries of subroutines includes 1) work by Hu et al. [28] focusing on creating summaries from sequences of API calls, and 2) CODE-NN by Iyer et al. [19] which, similar to [22], creates a custom word representation of code which it then feeds to an off-the-shelf seq2seq model.\n\nThere is also related work outside the task of subroutine summaries. Jiang et al. [20] and Loyola et al. [29] generate descriptions of code changes (i.e. commit messages). Allamanis et al. [18] predict a name for a subroutine from the body of a subroutine. Oda et al. [17] create pseudocode from source code by adapting statistical machine translation. Yin et al. [21], Movshovitz et al. [30], and Allamanis et al. [31] target comments of short snippets of code, a task facilitated by public datasets [32]. Gu et al. [33] have demonstrated using a neural model for source code search, another task growing in popularity and facilitated by public datasets [34]. Of note is that the attentional encoder-decoder seq2seq model originally described by Bahdanau et al. [35] is at the core of many of these papers, as it provides strong baseline performance even for many software engineering tasks.\n\n2) Heuristic/Template-based: Haiduc et al. [11], [36] is often cited as the first attempt to create text summaries of code, and indeed is the first to introduce the term \"source code summarization.\" These early approaches create extractive summaries by calculating the top-n keywords with metrics such as TF/IDF. Shortly thereafter, work by Sridhara et al. [12], [37] adapted SWUM [10] (a technique for finding parts of speech of words in code) to create short summary phrases for source code using templates. Another template-based solution by McBurney et al. [1] also used SWUM, but summarized a subroutine's context (defined as the functions that call or are called by a method) in addition to the method context. Rodeghero et al. [15] made further improvements to content extraction for heuristic and template solutions by modifying the heuristics to mimic how human programmers read code with their eyes. As in other research areas related to natural language generation [38], data-driven techniques have largely supplanted template-based techniques due to a much higher degree of flexibility and reduced human effort in template creation. We direct readers to a comprehensive survey by Nazar et al. [39].\n\n\nB. Neural Machine Translation\n\nThe workhorse of most Neural Machine Translation (NMT) systems is the attentional encoder-decoder architecture [40]. This architecture originated in work by Bahdanau et al. [35] and is explained in great detail by a plethora of very highlyregarded sources [41]- [45]. In this section, we cover only the concepts necessary to understand our approach at a high level.\n\nIn an encoder-decoder architecture, there are a minimum of two recurrent neural networks (RNNs). The first, called the encoder, converts an arbitrary-length sequence into a single vector representation of a specified length. The second, called the decoder, converts the vector representation given by the encoder into another arbitrary-length sequence. The sequence inputted to the encoder is one language e.g. English, and the sequence from the decoder is another language e.g. French.\n\nEncoder-decoder architectures learn to predict sentences one word at a time -the decoder generally does not try to predict a whole sentence at once. The way this usually works is that during training, instead of sending the network: The network receives 1) the whole input sequence, 2) a sequence of output words so far, plus 3) the correct next word: During inference, the trained model is given an input sequence, which is used to predict the first word in the output sentence. Then the input sentence is sent to the model again, along with the first prediction. The decoder outputs a prediction for the second word in the sentence, and so on, until the decoder predicts an end-of-sentence token.\n[[\nThe problem with this strategy is that the encoder is burdened with creating a vector representation suitable for prediction at every output step. In reality, some words in the input sentence will be more important than others for a particular output. E.g., 'on' for 'sur'. This is the motivation for \"attentional\" encoder-decoder networks [35]. Essentially what happens is that instead of a single vector representation of the input sentence, an attention mechanism is placed between the encoder and decoder. That attention mechanism receives the encoder's state at every time step -in the example above, four vectors for each of the four positions in the sentence. The attention mechanism, in essence, selects which vector from the encoder to use, so that different decoder predictions receive input from different positions in the input sequence. Our work builds on the attentional encoder-decoder strategy in key ways that we describe in the next section.\n\n\nIV. OUR PROPOSED MODEL\n\nThis section describes our proposed neural model. The model assumes a typical NMT architecture in which the model is asked to predict one word at a time, as described in the previous section.\n\n\nA. Model Overview\n\nOur model is essentially an attentional encoder-decoder system, except with two encoders: one for code/text data and one for AST data. In the spirit of maintaining simplicity where possible, we used embedding and recurrent layers of equal size for the encoders. We concatenate the output of attention mechanisms for each encoder as depicted here:\n\nPrecedent for combining different data sources comes heavily from image captioning [46]- [49] (e.g. merging convolution image output with a list of tags). One aim in this paper is to demonstrate how a similar concept is beneficial for code summarization, in contrast to the usual seq2seq application to SE data in which all information is put into one sequence. We also hope to sow fertile ground for several areas of future work in creating unique processing techniques for each data type -treating software's text and structure differently has a long tradition [50].\n\n\nB. Model Details\n\nTo encourage reproducibility and for clarity, we explain our model as a walkthrough of our actual Keras implementation. The following starts at line 29 in models/ast_attendgru_xtra.py; all code is available for download from our online appendix (Section X). txt_input = Input(shape=(self.txtlen,)) com_input = Input(shape=(self.comlen,)) ast_input = Input(shape=(self.astlen,)) First, above, are three input layers corresponding to the code/text sequence, the comment sequence, and the flattened AST sequence. We chose the sequence lengths as a balance between model size and coverage of the dataset. The sequence sizes of 100 for code/text and AST, and 13 words for comment, each cover at least 80% of the training set. Shorter sequences are padded with zeros, and longer sequences are truncated. ee = Embedding(output_dim=self.embdims, input_dim=self.txtvocabsize)(txt_input) se = Embedding(output_dim=self.embdims, input_dim=self.astvocabsize)(ast_input)\n\nWe start with a fairly common encoding structure, including embedding layers for each of our encoded input types (code/text and AST). The embedding will output a shape of (batch_size, txtvocabsize, embdims). What this means is that for every batch, each word in the sequence has one vector of length embdims. For example, (200, 100, 100) means that for each of 200 examples in a batch, there are 100 words and each word is represented by a 100 length embedding vector. We found two separate embeddings to have better performance than a unified embedding space. ast_enc = CuDNNGRU(self.rnndims, return_state=True, return_sequences=False) astout, sa = ast_enc(se)\n\nNext is a GRU layer with rnndims units (we found 256 to provide good results without oversizing the model) to serve as the AST encoding. We used a CuDNNGRU to increase training speed, not for prediction performance. The return_state flag is necessary so that we get the final hidden state of the AST encoder. The return_sequences flag is necessary because we want the state at every cell instead just the final state. We need the state at every cell for the attention mechanism later. txt_enc = CuDNNGRU(self.rnndims, return_state=True, return_sequences=True) txtout, st = enc(ee, initial_state=sa)\n\nThe code/text encoder operates in nearly the same way as the AST encoder, except that we start the code/text GRU with the final state of the AST GRU. The effect is similar to if we had simply concatenated the inputs, except that 1) we keep separate embedding spaces, 2) we allow for attention to focus on each input differently rather than across input types, 3) we ensure that one input is not truncated by an excessively long sequence of the other input type, and 4) we \"keep the door open\" for further processing e.g. via convolution layers that would benefit one input type but not the other. As we show in our evaluation, this is an important point for future work.\n\nTensor txtout would normally have shape (batch_size, rnndims), an rnndims-length vector representation of every input in the batch. However, since we have return_sequences enabled, encout has the shape (batch_size, datvocabsize, rnndims), which is the rnndims-length vector at every time-step. That is, the rnndims-length vector at every word in the sequence. So we see the status of the output vector as it changes with each word in the sequence. We also have return_state enabled, which just means that we get st, the rnndims vector from the last cell. This is a GRU, so this st is the same as the output vector, but we get it here anyway for convenience, to use as the initial state in the decoder.\nde = Embedding(output_dim=self.embdims, input_dim=self.comvocabsize)(com_input) dec = CuDNNGRU(self.rnndims, return_sequences=True) decout = dec(de, initial_state=st)\nThe decoder is as described in many papers on NMT: a dedicated embedding space followed by a recurrent layer. We start the decoder with the final state of the code/text RNN. The next step is the code/text attention mechanism, with a design similar to that described by Luong et al. [40]. First, we take the dot product of the decoder and code/text encoder output. The output shape of decout is, e.g., (batch_size, 13, 256) and txtout is (batch_size, 100, 256).\n\nThe axis 2 of decout is 256 long. The axis 2 of txtout is also 256 long. So by computing the dot product along axis 2 in both, we get a tensor of shape (batch_size, 13, 100). For one example in the batch, we get decout of (13, 256) and txtout (256, 100). Where a is the dot product of vectors v1 and v3, and b is the dot product of v1 and v4, etc.\n\nThe result is that each of the 13 positions in the decoder sequence is now represented by a 100-length vector. Each value in the 100-length vector reflects the similarity between the element in the decoder sequence and the element in the encoder sequence. I.e. b above reflects how similar element 1 in the decoder sequence is similar to element 2 in the code/text encoder sequence. The 100-length vector for each of the 13 input positions reflects how much that a given input position is similar (should \"pay attention to\") a position in the output.\n\nThen we apply a softmax to each of the 13 (100-length) vectors. The effect is to exaggerate the \"most similar\" things, so that \"more attention\" will be paid to the more-similar input vectors -the network learns during training to make them more similar. Note that the dot product here is not normalized, so it is not necessarily equivalent to cosine similarity. Next, we make use of the attention vectors by using them to create the context vectors for the code/text input. To do that, we scale the encoder vectors by the attention vectors. This is how we \"pay attention\" to particular areas of input for specific outputs. The above line of code takes txt_attn, with shape (batch_size, 13, 100), and computes the dot product with txtout (batch_size, 100, 256). Recall that the encoder has txtvocabsize; 100 elements since it takes a sequence of 100 words. Axis 1 of this tensor means \"for each element of the input sequence.\"\n\nThe multiplication, for each sample in the batch, is: The result is a context matrix that has one context vector for each element in the output sequence. This is different than the vanilla sequence to sequence approach, which has only one context vector used for every output. Each output sequence location has its own context vector. This vector is created from the most attended-to part of the encoder sequence. But, we still need to combine the code/text and AST context with the decoder sequence information. This is important because we send each word one at a time, as noted in the previous section. The model gets to look at the previous words in the sentence in addition to the words in the encoder sequences. It does not have the burden of predicting the entire output sequence all at once. Technically, what we have here are two context matrices with shape (batch_size, 13, 256) and a decout with shape (batch_size, 13, 256). The default axis is -1, which means the last part of the shape (the 256 one in this case). This creates a tensor of shape (batch_size, 13, 768): one 768-length vector for each of the 13 input elements instead of three 256-length vectors. out = TimeDistributed(Dense(self.rnndims, activation=\"relu\"))(context)\n\nWe are nearing the point of predicting a next word. A TimeDistributed layer provides one dense layer per vector in the context matrix. The result is one rnndims-length vector for every element in the decoder sequence. For example, one 256-length vector for each of the 13 positions in the decoder sequence. Essentially, this creates one predictor for each of the 13 decoder positions. out = Flatten()(out) out = Dense(self.comvocabsize, activation=\"softmax\")(out)\n\nHowever, we are trying to output a single word, the next word in the sequence. Ultimately we need a single output vector of length comsvocabsize. So we first flatten the (13, 256) matrix into a single (3328) vector, then we use a dense output layer of length comsvocabsize, and apply softmax.\nmodel = Model(inputs=[txt_input, com_input, ast_input], outputs=out)\nThe result is a model with code/text, AST, and comment sequence inputs, and a predicted next word in the comment sequence as output.\n\n\nC. Hardware Details\n\nThe hardware on which we implemented, trained, and tested our model included one Xeon E5-1650v4 CPU, 64gb RAM, and two Quadro P5000 GPUs. It was necessary to train on GPUs with 16gb VRAM due to the large size of our model.\n\n\nV. CORPUS PREPARATION\n\nWe prepared a large corpus of Java methods from the Sourcerer repository provided by Lopes et al. [24]. The repository contains over 51 million Java methods from over 50000 projects. We considered updating the repository with new downloads from GitHub, but we found that the Sourcerer dataset was quite thorough, leading to a large amount of overlap with newer projects that could not be eliminated (due to name changes, code cloning, etc.). This overlap could lead to major validity problems for our experiments (e.g., if testing samples were inadvertently placed in the training set). We decided to use the Sourcerer projects exclusively.\n\nSignificant preparation was necessary to make the repository a suitable dataset for applications of NMT, and we view this preparation as an important contribution of this paper to the research field (unlike in the NMT research area, there are relatively few curated datasets for code summarization). After downloading the archives, we used a toolkit provided by McMillan et al. [51] to extract the Java methods and organize them into a SQL database. Then we filtered for methods that were preceded by JavaDoc comments (indicated by / * * ). We used only comments intended as JavaDocs, because there is an assumption that the first sentence in the comment will be a summary of the method's behavior [2]. Then we extracted the first sentence by looking for the first period, or the first newline if no period was present. Next we used the langdetect library to remove comments not in English. About 4m methods remained after these steps.\n\nA potential problem was auto-generated code. Autogenerated code is a problem because both the code and comments created by auto-generators tend to be very similar. If nearly-identical code is in the training and testing sets, the model will learn these cases easily, which could simultaneously reduce performance on the \"real\" examples while falsely inflating performance metrics such as BLEU, since the metrics would reward the model for correctly identifying the duplicate cases. Happily, the solution is fairly simple: we remove any methods from files that include phrases such as \"generated by\" suggested by Shimonaka et al. [52]. This filter is quite aggressive, as it reduced the dataset size to around 2m methods, and on manual inspection we found no cases of autogenerated code. In fact, a majority of the filtered methods were exact duplicates (around 100k unique examples out of \u223c2m removed methods). But because comments to auto-generated code are often still meaningful, we added one copy of each of the 100k unique examples back into the dataset, and ensured that they were in the training set only (so we did not attempt to test against auto-generated comments). The result is a dataset of around 2.1m methods.\n\nOur other preprocessing steps followed the practice of many software engineering papers. We split the code and comments on camel case and underscore, removed non-alpha characters, and set to lower case. We did not perform stemming.\n\nWe then split the dataset by project into training, validation, and test sets. By \"by project\" we mean that we randomly divided the projects into the three groups: 90% of projects into training, 5% into validation, and 5% into testing. Then all the methods from a project went into the group assigned to its project. A side effect is that since projects have different numbers of methods, 91% of methods are in training, 4.8% in validation, and 4.2% in testing. But this slight variation is necessary to maintain a realistic situation. As mentioned in Section III, we respectfully believe that not splitting by project and not removing auto-generated code are mistakes made by a vast majority of previous NMT applications to code summarization, and artificially inflates the reported scores (for example, SBT is reported to have 38 BLEU, versus 14 BLEU with the same technique in our evaluation).\n\nTo obtain the ASTs, we first used srcml [53] to extract an XML representation of each method. Then we built a tool to convert the XML representation into the flattened SBT representation, to generate SBT-formatted output described by Hu et al. [22]. Finally, we created our own modification of SBT in which all the code structure remained intact, but in which we replaced all words (except official Java API class names) in the code to a special <OTHER> token. We call this SBT-AO for SBT AST only. We use this modification to simulate the case when only an AST can be extracted.\n\nFrom this corpus of Java methods, we create two datasets:\n\n\u2022 The standard dataset contains three elements for each Java method: 1) the pre-processed Java source code for the method, 2) the pre-processed comment, and 3) the SBT-AO representation of the Java code.\n\n\u2022 The challenge dataset contains two elements for each method: 1) the pre-processed comment, and 2) the SBT-AO representation of the Java code.\n\nTechnically, we also have a third dataset containing the default SBT representation (with code words) and the preprocessed comment, which we use for experiments to compare our approach to the baselines. However, the standard and challenge datasets are our focus in this paper, intended to compare the case when internal documentation is available, and the much more difficult case with only an AST.\n\n\nVI. EVALUATION\n\nThis section covers our evaluation, comparing our approach to baselines over the standard and challenge datasets.\n\n\nA. Research Questions\n\nOur research objective is to determine the performance difference between our approach and competitive baseline approaches in two situations that we explore through these Research Questions (RQs): RQ 1 What is the difference in performance between our approach and competitive approaches in the \"standard\" situation, assuming internal documentation? RQ 2 What is performance of our approach in the \"challenge\" situation, assuming an AST only? The rationale for these RQs was largely covered in the Introduction and Background sections. Essentially, existing applications of NMT for the problem of code summarization almost entirely rely on the programmer writing meaningful internal documentation such as identifier names. As we will show, this assumption makes the problem \"easy\" for seq2seq NMT models, since many methods have internal documentation that is very similar to the summary comment (a phenomenon also observed by Tan et al. [54] and Louis et al. [55]). We ask RQ 1 in order to study the performance of our approach under this assumption.\n\nIn contrast, we ask RQ 2 because the assumption of internal documentation is often not valid. Very often, only the bytecode is available, or programmers neglect to write good internal documentation, or code has even been obfuscated deliberately. In these cases, it is usually still possible to extract an AST for a method, even if it contains no meaningful words. In principle, the structure of a program is all that is necessary to understand it, since ultimately that is what defines the behavior of the program. In practice, it is very difficult to connect structure directly to high-level concepts described in summaries. We seek to quantify a baseline performance level with our approach (since, to our knowledge, no published approach functions in this situation).\n\n\nB. Baselines\n\nTo answer RQ 1 (the standard experiment), we compare our approach to three baselines. One baseline (which we call attendgru) is a generic attentional encoder-decoder model, to represent an application of a strong off-the-shelf approach from the NLP research area. Note that there are a huge variety of NMT systems described in the NLP literature, but that a vast majority have an attentional encoder-decoder model at their heart (see Section III). To maintain an \"apples to apples\" comparison, the baseline is identical to the \"code/text\" encoder in our approach (the decoder is identical as well). In essence, the baseline is the same as our proposed approach, except without the AST encoder and associated concatenation. While we could have chosen any number of approaches from NLP literature, it is very difficult to say up front which will perform best for code summarization, and we needed to ensure minimal differences to maximize validity of our results. If, for example, we had used an architecture with an LSTM instead of a GRU in the encoder, we would have no way of knowing if the difference between our approach and the baseline were due to the AST information we added, or due to using an LSTM instead of a GRU.\n\nA second baseline is the SBT approach presented by Hu et al. [22]. This approach was presented at ICPC'18, and (at the time of writing) represents the latest publication about source code summarization in a software engineering venue. That paper used an LSTM-based encoder-decoder architecture based on a popular guide for building seq2seq NMT systems, but used their SBT representation of code instead of the source code only. For our baseline, we use their SBT representation, but use the same GRU-based encoder-decoder from our NLP baseline, also to ensure an \"apples to apples\" comparison. Since the model architecture is the same, we can safely attribute performance differences to the input format (e.g., SBT vs. code-only).\n\nA third baseline is codenn, presented by Iyer et al. [19]. Given the complexity of the approach, we used their publiclyavailable implementation. The original paper describes only applications to SQL and C#, but we noticed that their C# parser extracted common code features that are also available in Java. We made small modifications to the C# parser so that it would function equivalently for Java.\n\nWe call our approach ast-attendgru in our experiments. We used a greedy search algorithm for inference for all approaches, rather than beam search, to minimize the number of experimental variables and computation cost.\n\n\nC. Methodology\n\nOur methodology to answer both RQs is identical, and follows best practice established throughout the literature on NMT (see Section III): for RQ 1 , we train our approach and each baseline with the training set from the standard dataset for a total of 10 epochs. Then, for each approach, we computed performance metrics for the model after each epoch against the validation set. (In all cases, validation performance began to degrade after five or six epochs.) Next we chose the model after the epoch with the highest validation performance, and computed performance metrics for this model against the testing set. These testing results are the results we report in this paper. Our methodology to answer RQ 2 differs only in that we trained and tested using the challenge dataset.\n\nWe report the performance metric BLEU [56], also in keeping with standard practice in NMT. BLEU is a measure of the text similarity between predicted summaries and reference summaries. We report a composite BLEU score in addition to BLEU 1 through BLEU 4 (BLEU n is a measure of the similarity of n-length subsequences, versus entire summary sentences). Technically speaking, we used nltk.translate.bleu_score [57] in our implementation.\n\n\nD. Threats to Validity\n\nThe primary threats to validity to this evaluation include: 1) Our dataset. We use a very large dataset with millions of Java methods in order to maximize the generalizability of our results, but the possibility remains that we would obtain different results with a different dataset. And, 2) we did not perform cross-validation. We attempt to mitigate this risk by using random samples to split the training/validation/testing sets, a different split could result in different performance. This risk is common among NMT experiments due to very high training computation costs (4+ hours per epoch).\n\n\nVII. EVALUATION RESULTS\n\nThis section discusses our evaluation results and observations. After answering our research questions, we explore examples to give an insight into how the network functions and why it works. Note that we use these observations to build an ensemble method at the end of this paper.\n\n\nA. RQ 1 : Standard Experiment\n\nWe found in the standard experiment that ast-attendgru and attendgru obtain roughly equal performance in terms of BLEU score, but provide orthogonal results, as we will explain in this section and the example in subsection C.\n\nIn terms of BLEU score, ast-attendgru and attendgru are roughly equal in performance: 19.6 BLEU vs 19.4 BLEU. SBT is lower, at about 14 BLEU, and codenn is about 10 BLEU. Figure 1 includes a table with the full BLEU results for each result (and additional data in our online appendix). For SBT, the results conflicted with our expectations based on the presenting paper [22], in which SBT outperformed a standard seq2seq model like attendgru. We see two possible explanations: First, even though our seq2seq baseline implementation represents a standard approach, there are a few architectural differences from the paper by Hu et al. [22], such as different embedding vector sizes. While we did not observe major changes in the results from these architectural differences in our own pilot studies, it is possible that \"one's mileage may vary\" depending on the dataset. Second, as we note in Sections III and V, the previous study did not split by project, so methods in the same project will be in the training and test set. The very high reported BLEU scores in [22] could be explained by overloaded methods with very similar structure -SBT would detect a function in the test set with a very similar AST to an overloaded method in the same project in the training set.\n\nThe improvement by all approaches over codenn matches expectations from previous experiments. The codenn approach was intended as a versatile technique for both code search and summarization, and was a relatively early attempt at applying NMT to the code summarization problem. In addition, it was designed for C# and SQL datasets; we adapted it to Java as described in the previous section.\n\nA key observation of the standard experiment is that ast-attendgru and attendgru provide orthogonal predictions -there is a set of methods in which one performs better, and a different set in which the other has higher performance. While ast-attendgru is slightly ahead of attendgru, we do not view a 0.2 BLEU difference a major improvement in and of itself. Normally we would expect an approach to outperform a different approach by some margin across a majority of the examples (i.e. non-orthogonal performance), and this is indeed what we observe when comparing ast-attendgru to SBT, as shown on the left below (around 60k methods in which ast-attendgru performed better, vs. 20k for SBT):\n\nBut what we observe for ast-attendgru and attendgru is that there are two sets of roughly 33k methods in the 91k test set in which one or another approach has higher performance (above, right). In other words, among the predictions in which there was a difference between the approaches, ast-attendgru and gives better predictions (in terms of BLEU score) for about half, while attendgru performs better on about half. Orthogonal performance makes these two approaches a good candidate for ensemble prediction, which we further explain in subsection C and Section VIII.\n\n\nB. RQ 2 : Challenge Experiment\n\nWe obtain a BLEU score of about 9.5 for ast-attendgru in the challenge experiment. Note that the only difference between the standard and challenge experiments is that we trained and tested using the AST only, in the form of the SBT-AO representation fed to ast-attendgru. Technically, there are other configurations that would produce the same result, such as using SBT-AO as input to attendgru instead of the source code. Any of these configurations would meet our objective with this experiment of establishing performance for the scenario when only an AST is available.\n\n\nC. Explanation and Example\n\nMerely reporting BLEU scores leaves an open question as to what the scores mean in practice. Consider these two examples from the standard and challenge experiments (method IDs align with our downloadable dataset for reproducibility). We chose the following examples for illustrative purposes, and as an aid for explanation. While relatively short, we feel that these methods provide a useful insight into how the models operate. For a more in depth analysis, a human evaluation would be required, which is beyond the scope of this paper.\n\nExample 1 is one of the cases where ast-attendgru succeeds when attendgru fails. To understand why, recall that, in our model as with a majority of NMT systems, the system predicts a sentence one word at a time. For each word, the model receives information about the method (the code/text plus the AST for models that use it), along with each word that has been predicted so far. So to predict \"token\", Example 1, Method ID 49111725:\n\npublic Config tokenUrl(String tokenUrl) { this.tokenUrl = tokenUrl; return this; } reference sets the token url ast-attendgru sets the token url attendgru stan. returns the url of the token sbt sets the <UNK> ast-attendgru chal. sets the value of the <UNK> property Tokenized code/text input: <s> public config token url string token url this token url token url return this </s> SBT-AO input: ( unit ( function ( specifier ) specifier OTHER ( type ( name ) name OTHER ) type ( name ) name OTHER ( parameter list ( parameter ( decl ( type ( name ) name String ) type ( name ) name OTHER ) decl ) parameter ) parameter list ( block ( expr stmt ( expr ( name ( name ) name OTHER ( operator ) operator OTHER ( name ) name OTHER ) name ( operator ) operator OTHER ( name ) name OTHER ) expr ) expr stmt ( return ( expr ( name ) name OTHER ) expr ) return ) block ) function ) unit (a) attendgru (b) ast-attendgru Fig. 2: Heatmaps of the attention layer in (a) attendgru and (b) ast-attendgru for the code/text input for Example 1. The xaxis is the 13 positions in the summary input. The y-axis is the 100 positions in the code input. Images are truncated to code input length.\n\nast-attendgru would receive the code/text, the AST, and the phrase \"sets the\".In contrast, attendgru only receives the code/text and \"sets the\". To predict the first word, \"sets\", attendgru only knows that it is the start of the sentence (indicated by a start-of-sentence <s> token), and the code/text input. To help make the prediction attendgru is equipped with an attention layer learned during training to attend to certain parts of the input. That layer is depicted in Figure 2(a). Note that there is high activation (bright yellow) in position (14,1), indicating significant attention paid to location 14 in the code/text input: this is the word return. What has happened is that, during training, the model saw many examples of getter methods that were only a few lines and ended with a return.\n\nIn many cases, the model could rely on very explicit method names, such as getPlayerScore (method ID 38221679). attendgru performed remarkably well in these cases, as the situation is quite like natural language -it learns to align words in the input vocabulary to words in the target vocabulary, and where they belong in a sentence. However, in cases such as Example 1 where the method name does not clearly state what the method should do (the name tokenUrl is not obviously a setter), attendgru struggles to choose the right words, even if, as in Example 1, it correctly identifies the subject of the action (\"url of the token\").\n\nThese situations are where the AST is beneficial. The code/text activation layer for ast-attendgru attends heavily to the start of sentence token (note column 0 in Figure 2(b)), which, since <s> is the start of every sentence, probably acts like a \"not sure\" signal. But the model also has the AST input. Figure 3 shows the AST attention layer of ast-attendgru when trying to predict the first word. There are four areas of interest that help elucidate how the model processes the structure of the model, denoted A through D in the figure, and color-coded to the corresponding areas in the AST input. First, area A, is the portion of the method signature prior to the parameter. Recall that our AST representation is structure only, so almost all methods will start the same way. So as expected, the attention in area A is largely formless. The heatmap shows much more definition in area B. It is the parameter list, and the model has likely learned that short methods with parameter lists tend to be setters. The model activates very heavily at locations C and D, which are the start and end of the expr stmt AST node. A very common situation in the training set is that a short method with a parameter and an assignment is a setter. The model has learned this and chose \"sets\" as the first word.\n\nAll of the models with AST input correctly chose \"sets\". SBT found that the method is a setter, but could not determine what was being set -we attribute this behavior to the fact that the SBT representation blends the code/text and structural information into a single input, which creates a challenge for the model to learn orthogonal types of information in the same vector space (which work in other areas e.g. image captioning implies is not advisable [58]). While there is not space in this paper to explore fully, we note that even ast-attendgru during the challenge experiment correctly characterized the method as setting the value of a property, generating an unknown token when it could not determine which property. In fact, ast-attendgru correctly predicted the first word of the summary (which is usually a verb) 33% of the time during the challenge experiment, compared to 52% of the time in the standard experiment. Briefly consider Example 2: Example 2, Method ID 40490666: public void disconnect() { try { socket.flush(); socket.close(); connected = false; notifyDisconnect(); } catch (IOException ex) { ex.printStackTrace(); } } reference closes the socket for reconnection ast-attendgru disconnect from the server attendgru stan. disconnects from the server sbt disconnect from the server ast-attendgru chal. closes the connection All approaches performed well for this method, but for different reasons. attendgru linked the method name to the verb \"disconnects\". SBT relied more on later features such as the call to notifyDisconnect(). Most interestingly, ast-attendgru performed best in the challenge experiment. In exploring this result, we found a few methods with a similar AST (IDs 146827, 22838818, 28418561, 5785101). All of these had a few lines in a try block followed by a short catch block, and 2-3 method calls and assignments to null or false in the try. These methods had summaries like \"close the communication with the gps device\", \"stops the timer\", and \"disconnect from the current client\" -all these methods deal with close and cleanup behavior. The model probably learned this during training, and chose similar words for the summary.\n\nIn answering RQ 1 , we found that attendgru and ast-attendgru performed better on different sets of methods. While we are hesitant to overinterpret single examples, the examples in this section are consistent with numerous others in the dataset (we provide a script for randomly sampling examples called rand samples preds.py in our online appendix for interested readers). The examples are also consistent with the interpretation that the off-the-shelf NMT system (attendgru) performs quite well in cases where the summaries are clear from the method signature, and in these cases the AST may be superfluous. But, the model benefits from the AST in cases when words in the code/text input are not sufficient or clear.\n\nVIII. ENSEMBLE DECODING AND FUTURE WORK As a hint toward future work, we test a combination of the attendgru and ast-attendgru models using ensem-ble decoding. The combination itself is straightforward: we compute an element-wise mean of the output vector of each model (the same trained models used in our evaluation). The training and test procedure does not change, except that during prediction, we use the maximum value of the combined output vector, rather than just one output vector from one model. This is the same ensemble decoding procedure implemented by OpenNMT [59], and is one of the most common of several options described by literature on multi-source NMT [60].\n\nSince we are combining output vectors, the models \"work together\" during prediction of every word -it is not just choosing one model or another for the whole sentence. The idea is that one model may assign similar weights in the output vector to two or more words, in cases where it performs less well. And another model that performs better in that situation may assign more weight to a single word. In our system, the hope is that attendgru will contribute more when code/text words are clear, but ast-attendgru will contribute more when they are unclear.\n\nThe ensemble decoding procedure improves performance to 20.9 BLEU, from 19.6 for ast-attendgru and 19.4 for attendgru. This is more than a full BLEU point improvement, which is quite significant for a relatively simple procedure. This result points us to future work including more advanced ensemble decoding (e.g. predicting when to use one model or another), optimizations to the network (e.g. dropout, parameter tuning), and, critically, using different data processing techniques on each type of input.\n\n\nIX. CONCLUSION\n\nWe have presented a neural model for generating natural language descriptions of subroutines. We implement our model and evaluate it over a large dataset of Java methods. We demonstrate that our model ast-attendgru, in terms of BLEU score, outperforms baselines from SE literature and is slightly ahead of a strong off-the-shelf approach from NLP literature. We also demonstrate that and ensemble of our approach and the off-the-shelf NLP approach outperforms all other tested configurations. We provide a walkthrough example to provide insight into how the models work -we conclude that the default NMT system works well in situations where good internal documentation is provided, but less well when it is not provided, and that ast-attendgru assists in these cases. We demonstrate how ast-attendgru can produce coherent predictions even with zero internal documentation.\n\n\nX. REPRODUCIBILITY\n\nOur dataset, code, models, and results are available via: https://bit.ly/2MLSxFg\n\n\nForward et al. pointed out in 2002 that \"software professionals value This work is supported in part by NSF CCF-1452959, CCF-1717607, and CNS-1510329 grants.\n\n\ntxt_attn = dot([decout, txtout], axes=[2,2]) txt_attn = Activation('softmax')(txt_attn)\n\nFig. 3 :\n3Heatmap of the attention layer in ast-attendgru for the AST input for Example 1. The x-axis is the summary input and the y-axis is the AST (SBT-AO) input. High activation (more yellow) indicates more attention paid to e.g. position 48 of the AST input.\n\n\ncat on the table ] => [ chat sur la table ]\n\n\ntxt_context=dot([txt_attn, txtout],axes=[2, 1])\n\n\nWe perform the same attention operations to the AST encoding as we do for the code/text encoding.ast_attn = dot([astout, encout], axes=[2, 2]) \nast_attn = Activation('softmax')(ast_attn) \nast_context = \ndot([ast_attn, txtout], axes=[2, 1]) \n\ncontext = concatenate( \n[txt_context, ast_context, decout]) \n\n\nACKNOWLEDGMENT This work is supported in part by the NSF CCF-1452959, CCF-1717607, and CNS-1510329 grants. Any opinions, findings, and conclusions expressed herein are the authors and do not necessarily reflect those of the sponsors\nAutomatic source code summarization of context for java methods. P W Mcburney, C Mcmillan, IEEE Transactions on Software Engineering. 422P. W. McBurney and C. McMillan, \"Automatic source code summa- rization of context for java methods,\" IEEE Transactions on Software Engineering, vol. 42, no. 2, pp. 103-119, 2016.\n\nApi documentation from source code comments: a case study of javadoc. D Kramer, Proceedings of the 17th annual international conference on Computer documentation. the 17th annual international conference on Computer documentationACMD. Kramer, \"Api documentation from source code comments: a case study of javadoc,\" in Proceedings of the 17th annual international conference on Computer documentation. ACM, 1999, pp. 147-153.\n\nProgram comprehension during software maintenance and evolution. A , Von Mayrhauser, A M Vans, Computer. 8A. Von Mayrhauser and A. M. Vans, \"Program comprehension during software maintenance and evolution,\" Computer, no. 8, pp. 44-55, 1995.\n\nCognitive processes in program comprehension. S Letovsky, Journal of Systems and software. 74S. Letovsky, \"Cognitive processes in program comprehension,\" Journal of Systems and software, vol. 7, no. 4, pp. 325-339, 1987.\n\nA systematic survey of program comprehension through dynamic analysis. B Cornelissen, A Zaidman, A Van Deursen, L Moonen, R Koschke, IEEE Transactions on Software Engineering. 355B. Cornelissen, A. Zaidman, A. Van Deursen, L. Moonen, and R. Koschke, \"A systematic survey of program comprehension through dynamic analysis,\" IEEE Transactions on Software Engineering, vol. 35, no. 5, pp. 684-702, 2009.\n\nSupporting program comprehension using semantic and structural information. J I Maletic, A Marcus, Proceedings of the 23rd International Conference on Software Engineering. the 23rd International Conference on Software EngineeringIEEE Computer SocietyJ. I. Maletic and A. Marcus, \"Supporting program comprehension using semantic and structural information,\" in Proceedings of the 23rd International Conference on Software Engineering. IEEE Computer Society, 2001, pp. 103-112.\n\nThe relevance of software documentation, tools and technologies: a survey. A Forward, T C Lethbridge, Proceedings of the 2002 ACM symposium on Document engineering. the 2002 ACM symposium on Document engineeringACMA. Forward and T. C. Lethbridge, \"The relevance of software documen- tation, tools and technologies: a survey,\" in Proceedings of the 2002 ACM symposium on Document engineering. ACM, 2002, pp. 26-33.\n\nDoxygen website. D Van Heesch, D. van Heesch. (2018) Doxygen website. [Online]. Available: http://www.doxygen.org/\n\nEvaluating source code summarization techniques: Replication and expansion. B P Eddy, J A Robinson, N A Kraft, J C Carver, IEEE 21st International Conference on. IEEEProgram Comprehension (ICPC)B. P. Eddy, J. A. Robinson, N. A. Kraft, and J. C. Carver, \"Evaluating source code summarization techniques: Replication and expansion,\" in Program Comprehension (ICPC), 2013 IEEE 21st International Conference on. IEEE, 2013, pp. 13-22.\n\nAutomatically capturing source code context of nl-queries for software maintenance and reuse. E Hill, L Pollock, K Vijay-Shanker, Proceedings of the 31st International Conference on Software Engineering. the 31st International Conference on Software EngineeringIEEE Computer SocietyE. Hill, L. Pollock, and K. Vijay-Shanker, \"Automatically capturing source code context of nl-queries for software maintenance and reuse,\" in Proceedings of the 31st International Conference on Software Engi- neering. IEEE Computer Society, 2009, pp. 232-242.\n\nOn the use of automated text summarization techniques for summarizing source code. S Haiduc, J Aponte, L Moreno, A Marcus, Reverse Engineering (WCRE), 2010 17th Working Conference on. IEEES. Haiduc, J. Aponte, L. Moreno, and A. Marcus, \"On the use of automated text summarization techniques for summarizing source code,\" in Reverse Engineering (WCRE), 2010 17th Working Conference on. IEEE, 2010, pp. 35-44.\n\nTowards automatically generating summary comments for java methods. G Sridhara, E Hill, D Muppaneni, L Pollock, K Vijay-Shanker, Proceedings of the IEEE/ACM international conference on Automated software engineering. the IEEE/ACM international conference on Automated software engineeringACMG. Sridhara, E. Hill, D. Muppaneni, L. Pollock, and K. Vijay-Shanker, \"Towards automatically generating summary comments for java meth- ods,\" in Proceedings of the IEEE/ACM international conference on Automated software engineering. ACM, 2010, pp. 43-52.\n\nGenerating natural language summaries for crosscutting source code concerns. S Rastkar, G C Murphy, A W Bradley, 27th IEEE International Conference on. IEEESoftware Maintenance (ICSM)S. Rastkar, G. C. Murphy, and A. W. Bradley, \"Generating natural language summaries for crosscutting source code concerns,\" in Software Maintenance (ICSM), 2011 27th IEEE International Conference on. IEEE, 2011, pp. 103-112.\n\nAutomatic generation of natural language summaries for java classes. L Moreno, J Aponte, G Sridhara, A Marcus, L Pollock, K Vijay-Shanker, IEEE 21st International Conference on. IEEEProgram Comprehension (ICPC)L. Moreno, J. Aponte, G. Sridhara, A. Marcus, L. Pollock, and K. Vijay- Shanker, \"Automatic generation of natural language summaries for java classes,\" in Program Comprehension (ICPC), 2013 IEEE 21st International Conference on. IEEE, 2013, pp. 23-32.\n\nAn eyetracking study of java programmers and application to source code summarization. P Rodeghero, C Liu, P W Mcburney, C Mcmillan, IEEE Transactions on Software Engineering. 4111P. Rodeghero, C. Liu, P. W. McBurney, and C. McMillan, \"An eye- tracking study of java programmers and application to source code summarization,\" IEEE Transactions on Software Engineering, vol. 41, no. 11, pp. 1038-1054, 2015.\n\nA survey of machine learning for big code and naturalness. M Allamanis, E T Barr, P Devanbu, C Sutton, arXiv:1709.06182arXiv preprintM. Allamanis, E. T. Barr, P. Devanbu, and C. Sutton, \"A survey of machine learning for big code and naturalness,\" arXiv preprint arXiv:1709.06182, 2017.\n\nLearning to generate pseudo-code from source code using statistical machine translation (t). Y Oda, H Fudaba, G Neubig, H Hata, S Sakti, T Toda, S Nakamura, 30th IEEE/ACM International Conference on. IEEEAutomated Software Engineering (ASE)Y. Oda, H. Fudaba, G. Neubig, H. Hata, S. Sakti, T. Toda, and S. Nakamura, \"Learning to generate pseudo-code from source code using statistical machine translation (t),\" in Automated Software Engineering (ASE), 2015 30th IEEE/ACM International Conference on. IEEE, 2015, pp. 574-584.\n\nA convolutional attention network for extreme summarization of source code. M Allamanis, H Peng, C Sutton, International Conference on Machine Learning. M. Allamanis, H. Peng, and C. Sutton, \"A convolutional attention network for extreme summarization of source code,\" in International Conference on Machine Learning, 2016, pp. 2091-2100.\n\nSummarizing source code using a neural attention model. S Iyer, I Konstas, A Cheung, L Zettlemoyer, Proceedings of the 54th Annual Meeting of the Association for Computational Linguistics. the 54th Annual Meeting of the Association for Computational Linguistics1Long Papers)S. Iyer, I. Konstas, A. Cheung, and L. Zettlemoyer, \"Summarizing source code using a neural attention model,\" in Proceedings of the 54th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), vol. 1, 2016, pp. 2073-2083.\n\nAutomatically generating commit messages from diffs using neural machine translation. S Jiang, A Armaly, C Mcmillan, Proceedings of the 32nd IEEE/ACM International Conference on Automated Software Engineering. the 32nd IEEE/ACM International Conference on Automated Software EngineeringIEEE PressS. Jiang, A. Armaly, and C. McMillan, \"Automatically generating commit messages from diffs using neural machine translation,\" in Pro- ceedings of the 32nd IEEE/ACM International Conference on Automated Software Engineering. IEEE Press, 2017, pp. 135-146.\n\nLearning to mine aligned code and natural language pairs from stack overflow. P Yin, B Deng, E Chen, B Vasilescu, G Neubig, International Conference on Mining Software Repositories, ser. MSR. ACMP. Yin, B. Deng, E. Chen, B. Vasilescu, and G. Neubig, \"Learning to mine aligned code and natural language pairs from stack overflow,\" in International Conference on Mining Software Repositories, ser. MSR. ACM, 2018, pp. 476-486.\n\nDeep code comment generation. X Hu, G Li, X Xia, D Lo, Z Jin, Proceedings of the 26th Conference on Program Comprehension. the 26th Conference on Program ComprehensionACMX. Hu, G. Li, X. Xia, D. Lo, and Z. Jin, \"Deep code comment generation,\" in Proceedings of the 26th Conference on Program Com- prehension. ACM, 2018, pp. 200-210.\n\nAre deep neural networks the best choice for modeling source code. V J Hellendoorn, P Devanbu, Proceedings of the 2017 11th Joint Meeting on Foundations of Software Engineering. the 2017 11th Joint Meeting on Foundations of Software EngineeringACMV. J. Hellendoorn and P. Devanbu, \"Are deep neural networks the best choice for modeling source code?\" in Proceedings of the 2017 11th Joint Meeting on Foundations of Software Engineering. ACM, 2017, pp. 763-773.\n\nUCI source code data sets. C Lopes, S Bajracharya, J Ossher, P Baldi, C. Lopes, S. Bajracharya, J. Ossher, and P. Baldi, \"UCI source code data sets,\" 2010. [Online]. Available: http://www.ics.uci.edu/$\\ sim$lopes/datasets/\n\nThe code2text challenge: Text generation in source code libraries. K Richardson, S Zarrie\u00df, J Kuhn, arXiv:1708.00098arXiv preprintK. Richardson, S. Zarrie\u00df, and J. Kuhn, \"The code2text challenge: Text generation in source code libraries,\" arXiv preprint arXiv:1708.00098, 2017.\n\nWorkshop on nlp for software engineering. W Cohen, P Devanbu, W. Cohen and P. Devanbu, \"Workshop on nlp for software engineering,\" 2018. [Online]. Available: https://nl4se.github.io/\n\nIntelligent software engineering: Synergy between ai and software engineering. T Xie, Proceedings of the 11th Innovations in Software Engineering Conference. the 11th Innovations in Software Engineering ConferenceACM1T. Xie, \"Intelligent software engineering: Synergy between ai and soft- ware engineering,\" in Proceedings of the 11th Innovations in Software Engineering Conference. ACM, 2018, p. 1.\n\nSummarizing source code with transferred api knowledge. X Hu, G Li, X Xia, D Lo, S Lu, Z Jin, in IJCAI. X. Hu, G. Li, X. Xia, D. Lo, S. Lu, and Z. Jin, \"Summarizing source code with transferred api knowledge.\" in IJCAI, 2018, pp. 2269-2275.\n\nA neural architecture for generating natural language descriptions from source code changes. P Loyola, E Marrese-Taylor, Y Matsuo, arXiv:1704.04856arXiv preprintP. Loyola, E. Marrese-Taylor, and Y. Matsuo, \"A neural architecture for generating natural language descriptions from source code changes,\" arXiv preprint arXiv:1704.04856, 2017.\n\nNatural language models for predicting programming comments. D Movshovitz-Attias, W W Cohen, Proceedings of the 51st Annual Meeting of the Association for Computational Linguistics. the 51st Annual Meeting of the Association for Computational Linguistics2Short Papers)D. Movshovitz-Attias and W. W. Cohen, \"Natural language models for predicting programming comments,\" in Proceedings of the 51st Annual Meeting of the Association for Computational Linguistics (Volume 2: Short Papers), vol. 2, 2013, pp. 35-40.\n\nBimodal modelling of source code and natural language. M Allamanis, D Tarlow, A Gordon, Y Wei, International Conference on Machine Learning. M. Allamanis, D. Tarlow, A. Gordon, and Y. Wei, \"Bimodal modelling of source code and natural language,\" in International Conference on Machine Learning, 2015, pp. 2123-2132.\n\nA parallel corpus of python functions and documentation strings for automated code documentation and code generation. A V M Barone, R Sennrich, arXiv:1707.02275arXiv preprintA. V. M. Barone and R. Sennrich, \"A parallel corpus of python functions and documentation strings for automated code documentation and code generation,\" arXiv preprint arXiv:1707.02275, 2017.\n\nDeep code search. X Gu, H Zhang, S Kim, Proceedings of the 40th International Conference on Software Engineering. the 40th International Conference on Software EngineeringACMX. Gu, H. Zhang, and S. Kim, \"Deep code search,\" in Proceedings of the 40th International Conference on Software Engineering. ACM, 2018, pp. 933-944.\n\nStaqc: A systematically mined question-code dataset from stack overflow. Z Yao, D S Weld, W.-P Chen, H Sun, arXiv:1803.09371arXiv preprintZ. Yao, D. S. Weld, W.-P. Chen, and H. Sun, \"Staqc: A systemati- cally mined question-code dataset from stack overflow,\" arXiv preprint arXiv:1803.09371, 2018.\n\nNeural machine translation by jointly learning to align and translate. D Bahdanau, K Cho, Y Bengio, arXiv:1409.0473arXiv preprintD. Bahdanau, K. Cho, and Y. Bengio, \"Neural machine translation by jointly learning to align and translate,\" arXiv preprint arXiv:1409.0473, 2014.\n\nSupporting program comprehension with source code summarization. S Haiduc, J Aponte, A Marcus, Proceedings of the 32Nd. the 32NdS. Haiduc, J. Aponte, and A. Marcus, \"Supporting program compre- hension with source code summarization,\" in Proceedings of the 32Nd\n\nACM/IEEE International Conference on Software Engineering. ACM2ACM/IEEE International Conference on Software Engineering-Volume 2. ACM, 2010, pp. 223-226.\n\nAutomatically detecting and describing high level actions within methods. G Sridhara, L Pollock, K Vijay-Shanker, Proceedings of the 33rd International Conference on Software Engineering. the 33rd International Conference on Software EngineeringACMG. Sridhara, L. Pollock, and K. Vijay-Shanker, \"Automatically detecting and describing high level actions within methods,\" in Proceedings of the 33rd International Conference on Software Engineering. ACM, 2011, pp. 101-110.\n\nGenerating text with recurrent neural networks. I Sutskever, J Martens, G E Hinton, Proceedings of the 28th International Conference on Machine Learning (ICML-11). the 28th International Conference on Machine Learning (ICML-11)I. Sutskever, J. Martens, and G. E. Hinton, \"Generating text with recurrent neural networks,\" in Proceedings of the 28th International Conference on Machine Learning (ICML-11), 2011, pp. 1017-1024.\n\nSummarizing software artifacts: A literature review. N Nazar, Y Hu, H Jiang, Journal of Computer Science and Technology. 315N. Nazar, Y. Hu, and H. Jiang, \"Summarizing software artifacts: A literature review,\" Journal of Computer Science and Technology, vol. 31, no. 5, pp. 883-909, 2016.\n\nEffective approaches to attention-based neural machine translation. M.-T Luong, H Pham, C D Manning, arXiv:1508.04025arXiv preprintM.-T. Luong, H. Pham, and C. D. Manning, \"Effective ap- proaches to attention-based neural machine translation,\" arXiv preprint arXiv:1508.04025, 2015.\n\nSequence to sequence learning with neural networks. I Sutskever, O Vinyals, Q V Le, Advances in neural information processing systems. I. Sutskever, O. Vinyals, and Q. V. Le, \"Sequence to sequence learning with neural networks,\" in Advances in neural information processing systems, 2014, pp. 3104-3112.\n\nDeep learning. Y Lecun, Y Bengio, G Hinton, nature. 5217553436Y. LeCun, Y. Bengio, and G. Hinton, \"Deep learning,\" nature, vol. 521, no. 7553, p. 436, 2015.\n\nI Goodfellow, Y Bengio, A Courville, Y Bengio, Deep learning. MIT press Cambridge1I. Goodfellow, Y. Bengio, A. Courville, and Y. Bengio, Deep learning. MIT press Cambridge, 2016, vol. 1.\n\nAttention is all you need. A Vaswani, N Shazeer, N Parmar, J Uszkoreit, L Jones, A N Gomez, \u0141 Kaiser, I Polosukhin, Advances in Neural Information Processing Systems. A. Vaswani, N. Shazeer, N. Parmar, J. Uszkoreit, L. Jones, A. N. Gomez, \u0141. Kaiser, and I. Polosukhin, \"Attention is all you need,\" in Advances in Neural Information Processing Systems, 2017, pp. 5998-6008.\n\nGoogle's multilingual neural machine translation system: Enabling zero-shot translation. M Johnson, M Schuster, Q V Le, M Krikun, Y Wu, Z Chen, N Thorat, F Vi\u00e9gas, M Wattenberg, G Corrado, Transactions of the Association of Computational Linguistics. 51M. Johnson, M. Schuster, Q. V. Le, M. Krikun, Y. Wu, Z. Chen, N. Tho- rat, F. Vi\u00e9gas, M. Wattenberg, G. Corrado et al., \"Google's multilin- gual neural machine translation system: Enabling zero-shot translation,\" Transactions of the Association of Computational Linguistics, vol. 5, no. 1, pp. 339-351, 2017.\n\nAbccnn: An attention based convolutional neural network for visual question answering. K Chen, J Wang, L.-C Chen, H Gao, W Xu, R Nevatia, arXiv:1511.05960arXiv preprintK. Chen, J. Wang, L.-C. Chen, H. Gao, W. Xu, and R. Nevatia, \"Abc- cnn: An attention based convolutional neural network for visual question answering,\" arXiv preprint arXiv:1511.05960, 2015.\n\nStacked attention networks for image question answering. Z Yang, X He, J Gao, L Deng, A Smola, Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. the IEEE Conference on Computer Vision and Pattern RecognitionZ. Yang, X. He, J. Gao, L. Deng, and A. Smola, \"Stacked attention networks for image question answering,\" in Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, 2016, pp. 21- 29.\n\nDensecap: Fully convolutional localization networks for dense captioning. J Johnson, A Karpathy, L Fei-Fei, Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. the IEEE Conference on Computer Vision and Pattern RecognitionJ. Johnson, A. Karpathy, and L. Fei-Fei, \"Densecap: Fully convolutional localization networks for dense captioning,\" in Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, 2016, pp. 4565-4574.\n\nJ Mao, W Xu, Y Yang, J Wang, Z Huang, A Yuille, arXiv:1412.6632Deep captioning with multimodal recurrent neural networks (m-rnn). arXiv preprintJ. Mao, W. Xu, Y. Yang, J. Wang, Z. Huang, and A. Yuille, \"Deep captioning with multimodal recurrent neural networks (m-rnn),\" arXiv preprint arXiv:1412.6632, 2014.\n\nRecovering documentation-to-source-code traceability links using latent semantic indexing. A Marcus, J I Maletic, Proceedings of the 25th international conference on software engineering. the 25th international conference on software engineeringIEEE Computer SocietyA. Marcus and J. I. Maletic, \"Recovering documentation-to-source-code traceability links using latent semantic indexing,\" in Proceedings of the 25th international conference on software engineering. IEEE Computer Society, 2003, pp. 125-135.\n\nPortfolio: finding relevant functions and their usage. C Mcmillan, M Grechanik, D Poshyvanyk, Q Xie, C Fu, Proceedings of the 33rd International Conference on Software Engineering. the 33rd International Conference on Software EngineeringACMC. McMillan, M. Grechanik, D. Poshyvanyk, Q. Xie, and C. Fu, \"Portfolio: finding relevant functions and their usage,\" in Proceedings of the 33rd International Conference on Software Engineering. ACM, 2011, pp. 111-120.\n\nIdentifying autogenerated code by using machine learning techniques. K Shimonaka, S Sumi, Y Higo, S Kusumoto, Empirical Software Engineering in Practice (IWESEP). K. Shimonaka, S. Sumi, Y. Higo, and S. Kusumoto, \"Identifying auto- generated code by using machine learning techniques,\" in Empirical Software Engineering in Practice (IWESEP), 2016 7th International Workshop on. IEEE, 2016, pp. 18-23.\n\nLightweight transformation and fact extraction with the srcml toolkit. M L Collard, M J Decker, J I Maletic, 11th IEEE International Working Conference on. IEEESource Code Analysis and Manipulation (SCAM)M. L. Collard, M. J. Decker, and J. I. Maletic, \"Lightweight trans- formation and fact extraction with the srcml toolkit,\" in Source Code Analysis and Manipulation (SCAM), 2011 11th IEEE International Working Conference on. IEEE, 2011, pp. 173-184.\n\n@tcomment: Testing javadoc comments to detect comment-code inconsistencies. S H Tan, D Marinov, L Tan, G T Leavens, 2012 IEEE Fifth International Conference on Software Testing, Verification and Validation. S. H. Tan, D. Marinov, L. Tan, and G. T. Leavens, \"@tcomment: Testing javadoc comments to detect comment-code inconsistencies,\" in 2012 IEEE Fifth International Conference on Software Testing, Verification and Validation, April 2012, pp. 260-269.\n\nDeep learning to detect redundant method comments. A Louis, S K Dash, E T Barr, C A Sutton, abs/1806.04616CoRR. A. Louis, S. K. Dash, E. T. Barr, and C. A. Sutton, \"Deep learning to detect redundant method comments,\" CoRR, vol. abs/1806.04616, 2018.\n\nBleu: a method for automatic evaluation of machine translation. K Papineni, S Roukos, T Ward, W.-J Zhu, Proceedings of the 40th annual meeting on association for computational linguistics. the 40th annual meeting on association for computational linguisticsAssociation for Computational LinguisticsK. Papineni, S. Roukos, T. Ward, and W.-J. Zhu, \"Bleu: a method for automatic evaluation of machine translation,\" in Proceedings of the 40th annual meeting on association for computational linguistics. Association for Computational Linguistics, 2002, pp. 311-318.\n\nNltk translate bleu score calculator v3.3. R H C T L Chin Yee Lee, Hengfeng Li. R. H. C. T. L. Chin Yee Lee, Hengfeng Li. (2018) Nltk translate bleu score calculator v3.3. [Online]. Available: https: //www.nltk.org/modules/nltk/translate/bleuscore.html\n\nShow and tell: A neural image caption generator. O Vinyals, A Toshev, S Bengio, D Erhan, Proceedings of the IEEE conference on computer vision and pattern recognition. the IEEE conference on computer vision and pattern recognitionO. Vinyals, A. Toshev, S. Bengio, and D. Erhan, \"Show and tell: A neural image caption generator,\" in Proceedings of the IEEE conference on computer vision and pattern recognition, 2015, pp. 3156-3164.\n\nOpennmt ensemble decoding. S.-A Grnroos, S.-A. Grnroos. (2018) Opennmt ensemble decoding. [Online]. Available: https://github.com/OpenNMT/OpenNMT-py/pull/732\n\nEnsemble learning for multi-source neural machine translation. E Garmash, C Monz, Proceedings of COLING 2016, the 26th International Conference on Computational Linguistics: Technical Papers. COLING 2016, the 26th International Conference on Computational Linguistics: Technical PapersE. Garmash and C. Monz, \"Ensemble learning for multi-source neural machine translation,\" in Proceedings of COLING 2016, the 26th Inter- national Conference on Computational Linguistics: Technical Papers, 2016, pp. 1409-1418.\n", "annotations": {"author": "[{\"end\":117,\"start\":83},{\"end\":220,\"start\":118},{\"end\":237,\"start\":221},{\"end\":323,\"start\":238}]", "publisher": null, "author_last_name": "[{\"end\":100,\"start\":93},{\"end\":130,\"start\":125},{\"end\":236,\"start\":228}]", "author_first_name": "[{\"end\":92,\"start\":83},{\"end\":124,\"start\":118},{\"end\":227,\"start\":221}]", "author_affiliation": "[{\"end\":219,\"start\":150},{\"end\":322,\"start\":239}]", "title": "[{\"end\":80,\"start\":1},{\"end\":403,\"start\":324}]", "venue": null, "abstract": "[{\"end\":1683,\"start\":499}]", "bib_ref": "[{\"attributes\":{\"ref_id\":\"b0\"},\"end\":3099,\"start\":3096},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":3313,\"start\":3310},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":3604,\"start\":3601},{\"attributes\":{\"ref_id\":\"b5\"},\"end\":3609,\"start\":3606},{\"attributes\":{\"ref_id\":\"b6\"},\"end\":4056,\"start\":4053},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":4210,\"start\":4207},{\"attributes\":{\"ref_id\":\"b7\"},\"end\":4226,\"start\":4223},{\"attributes\":{\"ref_id\":\"b8\"},\"end\":4503,\"start\":4500},{\"attributes\":{\"ref_id\":\"b0\"},\"end\":4682,\"start\":4679},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":4688,\"start\":4684},{\"attributes\":{\"ref_id\":\"b13\"},\"end\":4694,\"start\":4690},{\"attributes\":{\"ref_id\":\"b14\"},\"end\":4778,\"start\":4774},{\"attributes\":{\"ref_id\":\"b15\"},\"end\":4876,\"start\":4872},{\"attributes\":{\"ref_id\":\"b16\"},\"end\":5766,\"start\":5762},{\"attributes\":{\"ref_id\":\"b21\"},\"end\":5772,\"start\":5768},{\"attributes\":{\"ref_id\":\"b22\"},\"end\":6629,\"start\":6625},{\"attributes\":{\"ref_id\":\"b21\"},\"end\":7128,\"start\":7124},{\"attributes\":{\"ref_id\":\"b21\"},\"end\":7720,\"start\":7716},{\"attributes\":{\"ref_id\":\"b23\"},\"end\":8273,\"start\":8269},{\"attributes\":{\"ref_id\":\"b0\"},\"end\":10631,\"start\":10628},{\"attributes\":{\"ref_id\":\"b11\"},\"end\":10637,\"start\":10633},{\"attributes\":{\"ref_id\":\"b12\"},\"end\":10643,\"start\":10639},{\"attributes\":{\"ref_id\":\"b21\"},\"end\":10649,\"start\":10645},{\"attributes\":{\"ref_id\":\"b24\"},\"end\":10655,\"start\":10651},{\"attributes\":{\"ref_id\":\"b22\"},\"end\":11516,\"start\":11512},{\"attributes\":{\"ref_id\":\"b25\"},\"end\":11631,\"start\":11627},{\"attributes\":{\"ref_id\":\"b26\"},\"end\":11722,\"start\":11718},{\"attributes\":{\"ref_id\":\"b21\"},\"end\":12950,\"start\":12946},{\"attributes\":{\"ref_id\":\"b21\"},\"end\":14103,\"start\":14099},{\"attributes\":{\"ref_id\":\"b21\"},\"end\":14286,\"start\":14282},{\"attributes\":{\"ref_id\":\"b27\"},\"end\":14859,\"start\":14855},{\"attributes\":{\"ref_id\":\"b18\"},\"end\":14954,\"start\":14950},{\"attributes\":{\"ref_id\":\"b21\"},\"end\":14977,\"start\":14973},{\"attributes\":{\"ref_id\":\"b19\"},\"end\":15166,\"start\":15162},{\"attributes\":{\"ref_id\":\"b28\"},\"end\":15189,\"start\":15185},{\"attributes\":{\"ref_id\":\"b17\"},\"end\":15273,\"start\":15269},{\"attributes\":{\"ref_id\":\"b16\"},\"end\":15352,\"start\":15348},{\"attributes\":{\"ref_id\":\"b20\"},\"end\":15448,\"start\":15444},{\"attributes\":{\"ref_id\":\"b29\"},\"end\":15472,\"start\":15468},{\"attributes\":{\"ref_id\":\"b30\"},\"end\":15499,\"start\":15495},{\"attributes\":{\"ref_id\":\"b31\"},\"end\":15585,\"start\":15581},{\"attributes\":{\"ref_id\":\"b32\"},\"end\":15601,\"start\":15597},{\"attributes\":{\"ref_id\":\"b33\"},\"end\":15739,\"start\":15735},{\"attributes\":{\"ref_id\":\"b34\"},\"end\":15847,\"start\":15843},{\"attributes\":{\"ref_id\":\"b10\"},\"end\":16021,\"start\":16017},{\"attributes\":{\"ref_id\":\"b35\"},\"end\":16027,\"start\":16023},{\"attributes\":{\"ref_id\":\"b11\"},\"end\":16335,\"start\":16331},{\"attributes\":{\"ref_id\":\"b37\"},\"end\":16341,\"start\":16337},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":16359,\"start\":16355},{\"attributes\":{\"ref_id\":\"b0\"},\"end\":16538,\"start\":16535},{\"attributes\":{\"ref_id\":\"b14\"},\"end\":16712,\"start\":16708},{\"attributes\":{\"ref_id\":\"b38\"},\"end\":16954,\"start\":16950},{\"attributes\":{\"ref_id\":\"b39\"},\"end\":17183,\"start\":17179},{\"attributes\":{\"ref_id\":\"b40\"},\"end\":17333,\"start\":17329},{\"attributes\":{\"ref_id\":\"b34\"},\"end\":17395,\"start\":17391},{\"attributes\":{\"ref_id\":\"b41\"},\"end\":17478,\"start\":17474},{\"attributes\":{\"ref_id\":\"b45\"},\"end\":17484,\"start\":17480},{\"attributes\":{\"ref_id\":\"b34\"},\"end\":19119,\"start\":19115},{\"attributes\":{\"ref_id\":\"b46\"},\"end\":20409,\"start\":20405},{\"attributes\":{\"ref_id\":\"b49\"},\"end\":20415,\"start\":20411},{\"attributes\":{\"ref_id\":\"b50\"},\"end\":20889,\"start\":20885},{\"attributes\":{\"ref_id\":\"b40\"},\"end\":24960,\"start\":24956},{\"end\":25096,\"start\":25075},{\"attributes\":{\"ref_id\":\"b23\"},\"end\":29543,\"start\":29539},{\"attributes\":{\"ref_id\":\"b51\"},\"end\":30465,\"start\":30461},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":30784,\"start\":30781},{\"attributes\":{\"ref_id\":\"b52\"},\"end\":31653,\"start\":31649},{\"attributes\":{\"ref_id\":\"b53\"},\"end\":33421,\"start\":33417},{\"attributes\":{\"ref_id\":\"b21\"},\"end\":33625,\"start\":33621},{\"attributes\":{\"ref_id\":\"b54\"},\"end\":35865,\"start\":35861},{\"attributes\":{\"ref_id\":\"b55\"},\"end\":35887,\"start\":35883},{\"attributes\":{\"ref_id\":\"b21\"},\"end\":38054,\"start\":38050},{\"attributes\":{\"ref_id\":\"b18\"},\"end\":38778,\"start\":38774},{\"attributes\":{\"ref_id\":\"b56\"},\"end\":40185,\"start\":40181},{\"attributes\":{\"ref_id\":\"b57\"},\"end\":40557,\"start\":40553},{\"attributes\":{\"ref_id\":\"b21\"},\"end\":42149,\"start\":42145},{\"attributes\":{\"ref_id\":\"b21\"},\"end\":42413,\"start\":42409},{\"attributes\":{\"ref_id\":\"b21\"},\"end\":42843,\"start\":42839},{\"attributes\":{\"ref_id\":\"b13\"},\"end\":48047,\"start\":48043},{\"attributes\":{\"ref_id\":\"b0\"},\"end\":48049,\"start\":48047},{\"attributes\":{\"ref_id\":\"b58\"},\"end\":50689,\"start\":50685},{\"attributes\":{\"ref_id\":\"b59\"},\"end\":53706,\"start\":53702},{\"attributes\":{\"ref_id\":\"b60\"},\"end\":53805,\"start\":53801},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":56072,\"start\":56069},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":56074,\"start\":56072}]", "figure": "[{\"attributes\":{\"id\":\"fig_0\"},\"end\":56028,\"start\":55869},{\"attributes\":{\"id\":\"fig_1\"},\"end\":56118,\"start\":56029},{\"attributes\":{\"id\":\"fig_2\"},\"end\":56382,\"start\":56119},{\"attributes\":{\"id\":\"tab_0\",\"type\":\"table\"},\"end\":56428,\"start\":56383},{\"attributes\":{\"id\":\"tab_3\",\"type\":\"table\"},\"end\":56478,\"start\":56429},{\"attributes\":{\"id\":\"tab_5\",\"type\":\"table\"},\"end\":56785,\"start\":56479}]", "paragraph": "[{\"end\":2878,\"start\":1685},{\"end\":2978,\"start\":2880},{\"end\":3768,\"start\":2998},{\"end\":4380,\"start\":3770},{\"end\":4948,\"start\":4382},{\"end\":5773,\"start\":4950},{\"end\":6674,\"start\":5775},{\"end\":7484,\"start\":6676},{\"end\":8156,\"start\":7486},{\"end\":8631,\"start\":8158},{\"end\":9291,\"start\":8633},{\"end\":9922,\"start\":9293},{\"end\":10656,\"start\":9951},{\"end\":11290,\"start\":10658},{\"end\":12053,\"start\":11292},{\"end\":12571,\"start\":12055},{\"end\":12718,\"start\":12573},{\"end\":12873,\"start\":12751},{\"end\":13478,\"start\":12875},{\"end\":14751,\"start\":13631},{\"end\":15078,\"start\":14753},{\"end\":15972,\"start\":15080},{\"end\":17184,\"start\":15974},{\"end\":17583,\"start\":17218},{\"end\":18071,\"start\":17585},{\"end\":18771,\"start\":18073},{\"end\":19734,\"start\":18775},{\"end\":19952,\"start\":19761},{\"end\":20320,\"start\":19974},{\"end\":20890,\"start\":20322},{\"end\":21868,\"start\":20911},{\"end\":22531,\"start\":21870},{\"end\":23131,\"start\":22533},{\"end\":23803,\"start\":23133},{\"end\":24506,\"start\":23805},{\"end\":25134,\"start\":24674},{\"end\":25483,\"start\":25136},{\"end\":26035,\"start\":25485},{\"end\":26962,\"start\":26037},{\"end\":28208,\"start\":26964},{\"end\":28673,\"start\":28210},{\"end\":28967,\"start\":28675},{\"end\":29169,\"start\":29037},{\"end\":29415,\"start\":29193},{\"end\":30081,\"start\":29441},{\"end\":31018,\"start\":30083},{\"end\":32244,\"start\":31020},{\"end\":32477,\"start\":32246},{\"end\":33375,\"start\":32479},{\"end\":33956,\"start\":33377},{\"end\":34015,\"start\":33958},{\"end\":34220,\"start\":34017},{\"end\":34365,\"start\":34222},{\"end\":34765,\"start\":34367},{\"end\":34897,\"start\":34784},{\"end\":35974,\"start\":34923},{\"end\":36746,\"start\":35976},{\"end\":37987,\"start\":36763},{\"end\":38719,\"start\":37989},{\"end\":39121,\"start\":38721},{\"end\":39341,\"start\":39123},{\"end\":40141,\"start\":39360},{\"end\":40580,\"start\":40143},{\"end\":41205,\"start\":40607},{\"end\":41514,\"start\":41233},{\"end\":41773,\"start\":41548},{\"end\":43046,\"start\":41775},{\"end\":43439,\"start\":43048},{\"end\":44133,\"start\":43441},{\"end\":44704,\"start\":44135},{\"end\":45312,\"start\":44739},{\"end\":45881,\"start\":45343},{\"end\":46317,\"start\":45883},{\"end\":47491,\"start\":46319},{\"end\":48294,\"start\":47493},{\"end\":48928,\"start\":48296},{\"end\":50227,\"start\":48930},{\"end\":52405,\"start\":50229},{\"end\":53125,\"start\":52407},{\"end\":53806,\"start\":53127},{\"end\":54365,\"start\":53808},{\"end\":54873,\"start\":54367},{\"end\":55765,\"start\":54892},{\"end\":55868,\"start\":55788}]", "formula": "[{\"attributes\":{\"id\":\"formula_0\"},\"end\":13630,\"start\":13479},{\"attributes\":{\"id\":\"formula_1\"},\"end\":18773,\"start\":18772},{\"attributes\":{\"id\":\"formula_2\"},\"end\":18774,\"start\":18773},{\"attributes\":{\"id\":\"formula_3\"},\"end\":24673,\"start\":24507},{\"attributes\":{\"id\":\"formula_4\"},\"end\":29036,\"start\":28968}]", "table_ref": null, "section_header": "[{\"end\":2996,\"start\":2981},{\"end\":9949,\"start\":9925},{\"end\":12749,\"start\":12721},{\"end\":17216,\"start\":17187},{\"end\":19759,\"start\":19737},{\"end\":19972,\"start\":19955},{\"end\":20909,\"start\":20893},{\"end\":29191,\"start\":29172},{\"end\":29439,\"start\":29418},{\"end\":34782,\"start\":34768},{\"end\":34921,\"start\":34900},{\"end\":36761,\"start\":36749},{\"end\":39358,\"start\":39344},{\"end\":40605,\"start\":40583},{\"end\":41231,\"start\":41208},{\"end\":41546,\"start\":41517},{\"end\":44737,\"start\":44707},{\"end\":45341,\"start\":45315},{\"end\":54890,\"start\":54876},{\"end\":55786,\"start\":55768},{\"end\":56128,\"start\":56120}]", "table": "[{\"end\":56785,\"start\":56578}]", "figure_caption": "[{\"end\":56028,\"start\":55871},{\"end\":56118,\"start\":56031},{\"end\":56382,\"start\":56130},{\"end\":56428,\"start\":56385},{\"end\":56478,\"start\":56431},{\"end\":56578,\"start\":56481}]", "figure_ref": "[{\"end\":41954,\"start\":41946},{\"end\":47234,\"start\":47228},{\"end\":47975,\"start\":47967},{\"end\":49102,\"start\":49094},{\"attributes\":{\"ref_id\":\"fig_2\"},\"end\":49243,\"start\":49235}]", "bib_author_first_name": "[{\"end\":57085,\"start\":57084},{\"end\":57087,\"start\":57086},{\"end\":57099,\"start\":57098},{\"end\":57407,\"start\":57406},{\"end\":57828,\"start\":57827},{\"end\":57834,\"start\":57831},{\"end\":57848,\"start\":57847},{\"end\":57850,\"start\":57849},{\"end\":58051,\"start\":58050},{\"end\":58298,\"start\":58297},{\"end\":58313,\"start\":58312},{\"end\":58324,\"start\":58323},{\"end\":58339,\"start\":58338},{\"end\":58349,\"start\":58348},{\"end\":58705,\"start\":58704},{\"end\":58707,\"start\":58706},{\"end\":58718,\"start\":58717},{\"end\":59182,\"start\":59181},{\"end\":59193,\"start\":59192},{\"end\":59195,\"start\":59194},{\"end\":59539,\"start\":59538},{\"end\":59714,\"start\":59713},{\"end\":59716,\"start\":59715},{\"end\":59724,\"start\":59723},{\"end\":59726,\"start\":59725},{\"end\":59738,\"start\":59737},{\"end\":59740,\"start\":59739},{\"end\":59749,\"start\":59748},{\"end\":59751,\"start\":59750},{\"end\":60164,\"start\":60163},{\"end\":60172,\"start\":60171},{\"end\":60183,\"start\":60182},{\"end\":60696,\"start\":60695},{\"end\":60706,\"start\":60705},{\"end\":60716,\"start\":60715},{\"end\":60726,\"start\":60725},{\"end\":61090,\"start\":61089},{\"end\":61102,\"start\":61101},{\"end\":61110,\"start\":61109},{\"end\":61123,\"start\":61122},{\"end\":61134,\"start\":61133},{\"end\":61646,\"start\":61645},{\"end\":61657,\"start\":61656},{\"end\":61659,\"start\":61658},{\"end\":61669,\"start\":61668},{\"end\":61671,\"start\":61670},{\"end\":62047,\"start\":62046},{\"end\":62057,\"start\":62056},{\"end\":62067,\"start\":62066},{\"end\":62079,\"start\":62078},{\"end\":62089,\"start\":62088},{\"end\":62100,\"start\":62099},{\"end\":62528,\"start\":62527},{\"end\":62541,\"start\":62540},{\"end\":62548,\"start\":62547},{\"end\":62550,\"start\":62549},{\"end\":62562,\"start\":62561},{\"end\":62908,\"start\":62907},{\"end\":62921,\"start\":62920},{\"end\":62923,\"start\":62922},{\"end\":62931,\"start\":62930},{\"end\":62942,\"start\":62941},{\"end\":63229,\"start\":63228},{\"end\":63236,\"start\":63235},{\"end\":63246,\"start\":63245},{\"end\":63256,\"start\":63255},{\"end\":63264,\"start\":63263},{\"end\":63273,\"start\":63272},{\"end\":63281,\"start\":63280},{\"end\":63737,\"start\":63736},{\"end\":63750,\"start\":63749},{\"end\":63758,\"start\":63757},{\"end\":64057,\"start\":64056},{\"end\":64065,\"start\":64064},{\"end\":64076,\"start\":64075},{\"end\":64086,\"start\":64085},{\"end\":64617,\"start\":64616},{\"end\":64626,\"start\":64625},{\"end\":64636,\"start\":64635},{\"end\":65161,\"start\":65160},{\"end\":65168,\"start\":65167},{\"end\":65176,\"start\":65175},{\"end\":65184,\"start\":65183},{\"end\":65197,\"start\":65196},{\"end\":65539,\"start\":65538},{\"end\":65545,\"start\":65544},{\"end\":65551,\"start\":65550},{\"end\":65558,\"start\":65557},{\"end\":65564,\"start\":65563},{\"end\":65910,\"start\":65909},{\"end\":65912,\"start\":65911},{\"end\":65927,\"start\":65926},{\"end\":66331,\"start\":66330},{\"end\":66340,\"start\":66339},{\"end\":66355,\"start\":66354},{\"end\":66365,\"start\":66364},{\"end\":66595,\"start\":66594},{\"end\":66609,\"start\":66608},{\"end\":66620,\"start\":66619},{\"end\":66849,\"start\":66848},{\"end\":66858,\"start\":66857},{\"end\":67070,\"start\":67069},{\"end\":67448,\"start\":67447},{\"end\":67454,\"start\":67453},{\"end\":67460,\"start\":67459},{\"end\":67467,\"start\":67466},{\"end\":67473,\"start\":67472},{\"end\":67479,\"start\":67478},{\"end\":67727,\"start\":67726},{\"end\":67737,\"start\":67736},{\"end\":67755,\"start\":67754},{\"end\":68036,\"start\":68035},{\"end\":68057,\"start\":68056},{\"end\":68059,\"start\":68058},{\"end\":68542,\"start\":68541},{\"end\":68555,\"start\":68554},{\"end\":68565,\"start\":68564},{\"end\":68575,\"start\":68574},{\"end\":68922,\"start\":68921},{\"end\":68926,\"start\":68923},{\"end\":68936,\"start\":68935},{\"end\":69189,\"start\":69188},{\"end\":69195,\"start\":69194},{\"end\":69204,\"start\":69203},{\"end\":69569,\"start\":69568},{\"end\":69576,\"start\":69575},{\"end\":69578,\"start\":69577},{\"end\":69589,\"start\":69585},{\"end\":69597,\"start\":69596},{\"end\":69866,\"start\":69865},{\"end\":69878,\"start\":69877},{\"end\":69885,\"start\":69884},{\"end\":70137,\"start\":70136},{\"end\":70147,\"start\":70146},{\"end\":70157,\"start\":70156},{\"end\":70564,\"start\":70563},{\"end\":70576,\"start\":70575},{\"end\":70587,\"start\":70586},{\"end\":71011,\"start\":71010},{\"end\":71024,\"start\":71023},{\"end\":71035,\"start\":71034},{\"end\":71037,\"start\":71036},{\"end\":71442,\"start\":71441},{\"end\":71451,\"start\":71450},{\"end\":71457,\"start\":71456},{\"end\":71750,\"start\":71746},{\"end\":71759,\"start\":71758},{\"end\":71767,\"start\":71766},{\"end\":71769,\"start\":71768},{\"end\":72015,\"start\":72014},{\"end\":72028,\"start\":72027},{\"end\":72039,\"start\":72038},{\"end\":72041,\"start\":72040},{\"end\":72283,\"start\":72282},{\"end\":72292,\"start\":72291},{\"end\":72302,\"start\":72301},{\"end\":72426,\"start\":72425},{\"end\":72440,\"start\":72439},{\"end\":72450,\"start\":72449},{\"end\":72463,\"start\":72462},{\"end\":72641,\"start\":72640},{\"end\":72652,\"start\":72651},{\"end\":72663,\"start\":72662},{\"end\":72673,\"start\":72672},{\"end\":72686,\"start\":72685},{\"end\":72695,\"start\":72694},{\"end\":72697,\"start\":72696},{\"end\":72706,\"start\":72705},{\"end\":72716,\"start\":72715},{\"end\":73077,\"start\":73076},{\"end\":73088,\"start\":73087},{\"end\":73100,\"start\":73099},{\"end\":73102,\"start\":73101},{\"end\":73108,\"start\":73107},{\"end\":73118,\"start\":73117},{\"end\":73124,\"start\":73123},{\"end\":73132,\"start\":73131},{\"end\":73142,\"start\":73141},{\"end\":73152,\"start\":73151},{\"end\":73166,\"start\":73165},{\"end\":73638,\"start\":73637},{\"end\":73646,\"start\":73645},{\"end\":73657,\"start\":73653},{\"end\":73665,\"start\":73664},{\"end\":73672,\"start\":73671},{\"end\":73678,\"start\":73677},{\"end\":73968,\"start\":73967},{\"end\":73976,\"start\":73975},{\"end\":73982,\"start\":73981},{\"end\":73989,\"start\":73988},{\"end\":73997,\"start\":73996},{\"end\":74428,\"start\":74427},{\"end\":74439,\"start\":74438},{\"end\":74451,\"start\":74450},{\"end\":74824,\"start\":74823},{\"end\":74831,\"start\":74830},{\"end\":74837,\"start\":74836},{\"end\":74845,\"start\":74844},{\"end\":74853,\"start\":74852},{\"end\":74862,\"start\":74861},{\"end\":75225,\"start\":75224},{\"end\":75235,\"start\":75234},{\"end\":75237,\"start\":75236},{\"end\":75697,\"start\":75696},{\"end\":75709,\"start\":75708},{\"end\":75722,\"start\":75721},{\"end\":75736,\"start\":75735},{\"end\":75743,\"start\":75742},{\"end\":76172,\"start\":76171},{\"end\":76185,\"start\":76184},{\"end\":76193,\"start\":76192},{\"end\":76201,\"start\":76200},{\"end\":76575,\"start\":76574},{\"end\":76577,\"start\":76576},{\"end\":76588,\"start\":76587},{\"end\":76590,\"start\":76589},{\"end\":76600,\"start\":76599},{\"end\":76602,\"start\":76601},{\"end\":77034,\"start\":77033},{\"end\":77036,\"start\":77035},{\"end\":77043,\"start\":77042},{\"end\":77054,\"start\":77053},{\"end\":77061,\"start\":77060},{\"end\":77063,\"start\":77062},{\"end\":77464,\"start\":77463},{\"end\":77473,\"start\":77472},{\"end\":77475,\"start\":77474},{\"end\":77483,\"start\":77482},{\"end\":77485,\"start\":77484},{\"end\":77493,\"start\":77492},{\"end\":77495,\"start\":77494},{\"end\":77728,\"start\":77727},{\"end\":77740,\"start\":77739},{\"end\":77750,\"start\":77749},{\"end\":77761,\"start\":77757},{\"end\":78270,\"start\":78269},{\"end\":78278,\"start\":78271},{\"end\":78530,\"start\":78529},{\"end\":78541,\"start\":78540},{\"end\":78551,\"start\":78550},{\"end\":78561,\"start\":78560},{\"end\":78944,\"start\":78940},{\"end\":79136,\"start\":79135},{\"end\":79147,\"start\":79146}]", "bib_author_last_name": "[{\"end\":57096,\"start\":57088},{\"end\":57108,\"start\":57100},{\"end\":57414,\"start\":57408},{\"end\":57845,\"start\":57835},{\"end\":57855,\"start\":57851},{\"end\":58060,\"start\":58052},{\"end\":58310,\"start\":58299},{\"end\":58321,\"start\":58314},{\"end\":58336,\"start\":58325},{\"end\":58346,\"start\":58340},{\"end\":58357,\"start\":58350},{\"end\":58715,\"start\":58708},{\"end\":58725,\"start\":58719},{\"end\":59190,\"start\":59183},{\"end\":59206,\"start\":59196},{\"end\":59550,\"start\":59540},{\"end\":59721,\"start\":59717},{\"end\":59735,\"start\":59727},{\"end\":59746,\"start\":59741},{\"end\":59758,\"start\":59752},{\"end\":60169,\"start\":60165},{\"end\":60180,\"start\":60173},{\"end\":60197,\"start\":60184},{\"end\":60703,\"start\":60697},{\"end\":60713,\"start\":60707},{\"end\":60723,\"start\":60717},{\"end\":60733,\"start\":60727},{\"end\":61099,\"start\":61091},{\"end\":61107,\"start\":61103},{\"end\":61120,\"start\":61111},{\"end\":61131,\"start\":61124},{\"end\":61148,\"start\":61135},{\"end\":61654,\"start\":61647},{\"end\":61666,\"start\":61660},{\"end\":61679,\"start\":61672},{\"end\":62054,\"start\":62048},{\"end\":62064,\"start\":62058},{\"end\":62076,\"start\":62068},{\"end\":62086,\"start\":62080},{\"end\":62097,\"start\":62090},{\"end\":62114,\"start\":62101},{\"end\":62538,\"start\":62529},{\"end\":62545,\"start\":62542},{\"end\":62559,\"start\":62551},{\"end\":62571,\"start\":62563},{\"end\":62918,\"start\":62909},{\"end\":62928,\"start\":62924},{\"end\":62939,\"start\":62932},{\"end\":62949,\"start\":62943},{\"end\":63233,\"start\":63230},{\"end\":63243,\"start\":63237},{\"end\":63253,\"start\":63247},{\"end\":63261,\"start\":63257},{\"end\":63270,\"start\":63265},{\"end\":63278,\"start\":63274},{\"end\":63290,\"start\":63282},{\"end\":63747,\"start\":63738},{\"end\":63755,\"start\":63751},{\"end\":63765,\"start\":63759},{\"end\":64062,\"start\":64058},{\"end\":64073,\"start\":64066},{\"end\":64083,\"start\":64077},{\"end\":64098,\"start\":64087},{\"end\":64623,\"start\":64618},{\"end\":64633,\"start\":64627},{\"end\":64645,\"start\":64637},{\"end\":65165,\"start\":65162},{\"end\":65173,\"start\":65169},{\"end\":65181,\"start\":65177},{\"end\":65194,\"start\":65185},{\"end\":65204,\"start\":65198},{\"end\":65542,\"start\":65540},{\"end\":65548,\"start\":65546},{\"end\":65555,\"start\":65552},{\"end\":65561,\"start\":65559},{\"end\":65568,\"start\":65565},{\"end\":65924,\"start\":65913},{\"end\":65935,\"start\":65928},{\"end\":66337,\"start\":66332},{\"end\":66352,\"start\":66341},{\"end\":66362,\"start\":66356},{\"end\":66371,\"start\":66366},{\"end\":66606,\"start\":66596},{\"end\":66617,\"start\":66610},{\"end\":66625,\"start\":66621},{\"end\":66855,\"start\":66850},{\"end\":66866,\"start\":66859},{\"end\":67074,\"start\":67071},{\"end\":67451,\"start\":67449},{\"end\":67457,\"start\":67455},{\"end\":67464,\"start\":67461},{\"end\":67470,\"start\":67468},{\"end\":67476,\"start\":67474},{\"end\":67483,\"start\":67480},{\"end\":67734,\"start\":67728},{\"end\":67752,\"start\":67738},{\"end\":67762,\"start\":67756},{\"end\":68054,\"start\":68037},{\"end\":68065,\"start\":68060},{\"end\":68552,\"start\":68543},{\"end\":68562,\"start\":68556},{\"end\":68572,\"start\":68566},{\"end\":68579,\"start\":68576},{\"end\":68933,\"start\":68927},{\"end\":68945,\"start\":68937},{\"end\":69192,\"start\":69190},{\"end\":69201,\"start\":69196},{\"end\":69208,\"start\":69205},{\"end\":69573,\"start\":69570},{\"end\":69583,\"start\":69579},{\"end\":69594,\"start\":69590},{\"end\":69601,\"start\":69598},{\"end\":69875,\"start\":69867},{\"end\":69882,\"start\":69879},{\"end\":69892,\"start\":69886},{\"end\":70144,\"start\":70138},{\"end\":70154,\"start\":70148},{\"end\":70164,\"start\":70158},{\"end\":70573,\"start\":70565},{\"end\":70584,\"start\":70577},{\"end\":70601,\"start\":70588},{\"end\":71021,\"start\":71012},{\"end\":71032,\"start\":71025},{\"end\":71044,\"start\":71038},{\"end\":71448,\"start\":71443},{\"end\":71454,\"start\":71452},{\"end\":71463,\"start\":71458},{\"end\":71756,\"start\":71751},{\"end\":71764,\"start\":71760},{\"end\":71777,\"start\":71770},{\"end\":72025,\"start\":72016},{\"end\":72036,\"start\":72029},{\"end\":72044,\"start\":72042},{\"end\":72289,\"start\":72284},{\"end\":72299,\"start\":72293},{\"end\":72309,\"start\":72303},{\"end\":72437,\"start\":72427},{\"end\":72447,\"start\":72441},{\"end\":72460,\"start\":72451},{\"end\":72470,\"start\":72464},{\"end\":72649,\"start\":72642},{\"end\":72660,\"start\":72653},{\"end\":72670,\"start\":72664},{\"end\":72683,\"start\":72674},{\"end\":72692,\"start\":72687},{\"end\":72703,\"start\":72698},{\"end\":72713,\"start\":72707},{\"end\":72727,\"start\":72717},{\"end\":73085,\"start\":73078},{\"end\":73097,\"start\":73089},{\"end\":73105,\"start\":73103},{\"end\":73115,\"start\":73109},{\"end\":73121,\"start\":73119},{\"end\":73129,\"start\":73125},{\"end\":73139,\"start\":73133},{\"end\":73149,\"start\":73143},{\"end\":73163,\"start\":73153},{\"end\":73174,\"start\":73167},{\"end\":73643,\"start\":73639},{\"end\":73651,\"start\":73647},{\"end\":73662,\"start\":73658},{\"end\":73669,\"start\":73666},{\"end\":73675,\"start\":73673},{\"end\":73686,\"start\":73679},{\"end\":73973,\"start\":73969},{\"end\":73979,\"start\":73977},{\"end\":73986,\"start\":73983},{\"end\":73994,\"start\":73990},{\"end\":74003,\"start\":73998},{\"end\":74436,\"start\":74429},{\"end\":74448,\"start\":74440},{\"end\":74459,\"start\":74452},{\"end\":74828,\"start\":74825},{\"end\":74834,\"start\":74832},{\"end\":74842,\"start\":74838},{\"end\":74850,\"start\":74846},{\"end\":74859,\"start\":74854},{\"end\":74869,\"start\":74863},{\"end\":75232,\"start\":75226},{\"end\":75245,\"start\":75238},{\"end\":75706,\"start\":75698},{\"end\":75719,\"start\":75710},{\"end\":75733,\"start\":75723},{\"end\":75740,\"start\":75737},{\"end\":75746,\"start\":75744},{\"end\":76182,\"start\":76173},{\"end\":76190,\"start\":76186},{\"end\":76198,\"start\":76194},{\"end\":76210,\"start\":76202},{\"end\":76585,\"start\":76578},{\"end\":76597,\"start\":76591},{\"end\":76610,\"start\":76603},{\"end\":77040,\"start\":77037},{\"end\":77051,\"start\":77044},{\"end\":77058,\"start\":77055},{\"end\":77071,\"start\":77064},{\"end\":77470,\"start\":77465},{\"end\":77480,\"start\":77476},{\"end\":77490,\"start\":77486},{\"end\":77502,\"start\":77496},{\"end\":77737,\"start\":77729},{\"end\":77747,\"start\":77741},{\"end\":77755,\"start\":77751},{\"end\":77765,\"start\":77762},{\"end\":78291,\"start\":78279},{\"end\":78538,\"start\":78531},{\"end\":78548,\"start\":78542},{\"end\":78558,\"start\":78552},{\"end\":78567,\"start\":78562},{\"end\":78952,\"start\":78945},{\"end\":79144,\"start\":79137},{\"end\":79152,\"start\":79148}]", "bib_entry": "[{\"attributes\":{\"id\":\"b0\",\"matched_paper_id\":17406565},\"end\":57334,\"start\":57019},{\"attributes\":{\"id\":\"b1\",\"matched_paper_id\":30353027},\"end\":57760,\"start\":57336},{\"attributes\":{\"id\":\"b2\",\"matched_paper_id\":1682648},\"end\":58002,\"start\":57762},{\"attributes\":{\"id\":\"b3\",\"matched_paper_id\":40027275},\"end\":58224,\"start\":58004},{\"attributes\":{\"id\":\"b4\",\"matched_paper_id\":16125167},\"end\":58626,\"start\":58226},{\"attributes\":{\"id\":\"b5\",\"matched_paper_id\":5860900},\"end\":59104,\"start\":58628},{\"attributes\":{\"id\":\"b6\",\"matched_paper_id\":8033761},\"end\":59519,\"start\":59106},{\"attributes\":{\"id\":\"b7\"},\"end\":59635,\"start\":59521},{\"attributes\":{\"id\":\"b8\",\"matched_paper_id\":12442030},\"end\":60067,\"start\":59637},{\"attributes\":{\"id\":\"b9\",\"matched_paper_id\":14387543},\"end\":60610,\"start\":60069},{\"attributes\":{\"id\":\"b10\",\"matched_paper_id\":7843537},\"end\":61019,\"start\":60612},{\"attributes\":{\"id\":\"b11\",\"matched_paper_id\":9790585},\"end\":61566,\"start\":61021},{\"attributes\":{\"id\":\"b12\",\"matched_paper_id\":11834307},\"end\":61975,\"start\":61568},{\"attributes\":{\"id\":\"b13\",\"matched_paper_id\":1129667},\"end\":62438,\"start\":61977},{\"attributes\":{\"id\":\"b14\",\"matched_paper_id\":13109013},\"end\":62846,\"start\":62440},{\"attributes\":{\"doi\":\"arXiv:1709.06182\",\"id\":\"b15\"},\"end\":63133,\"start\":62848},{\"attributes\":{\"id\":\"b16\",\"matched_paper_id\":15979705},\"end\":63658,\"start\":63135},{\"attributes\":{\"id\":\"b17\",\"matched_paper_id\":2723946},\"end\":63998,\"start\":63660},{\"attributes\":{\"id\":\"b18\",\"matched_paper_id\":8820379},\"end\":64528,\"start\":64000},{\"attributes\":{\"id\":\"b19\",\"matched_paper_id\":9237290},\"end\":65080,\"start\":64530},{\"attributes\":{\"id\":\"b20\",\"matched_paper_id\":43922261},\"end\":65506,\"start\":65082},{\"attributes\":{\"id\":\"b21\",\"matched_paper_id\":49584534},\"end\":65840,\"start\":65508},{\"attributes\":{\"id\":\"b22\",\"matched_paper_id\":21164835},\"end\":66301,\"start\":65842},{\"attributes\":{\"id\":\"b23\"},\"end\":66525,\"start\":66303},{\"attributes\":{\"doi\":\"arXiv:1708.00098\",\"id\":\"b24\"},\"end\":66804,\"start\":66527},{\"attributes\":{\"id\":\"b25\"},\"end\":66988,\"start\":66806},{\"attributes\":{\"id\":\"b26\",\"matched_paper_id\":3398323},\"end\":67389,\"start\":66990},{\"attributes\":{\"id\":\"b27\",\"matched_paper_id\":49584957},\"end\":67631,\"start\":67391},{\"attributes\":{\"doi\":\"arXiv:1704.04856\",\"id\":\"b28\"},\"end\":67972,\"start\":67633},{\"attributes\":{\"id\":\"b29\",\"matched_paper_id\":6706547},\"end\":68484,\"start\":67974},{\"attributes\":{\"id\":\"b30\",\"matched_paper_id\":2706277},\"end\":68801,\"start\":68486},{\"attributes\":{\"doi\":\"arXiv:1707.02275\",\"id\":\"b31\"},\"end\":69168,\"start\":68803},{\"attributes\":{\"id\":\"b32\",\"matched_paper_id\":47021242},\"end\":69493,\"start\":69170},{\"attributes\":{\"doi\":\"arXiv:1803.09371\",\"id\":\"b33\"},\"end\":69792,\"start\":69495},{\"attributes\":{\"doi\":\"arXiv:1409.0473\",\"id\":\"b34\"},\"end\":70069,\"start\":69794},{\"attributes\":{\"id\":\"b35\",\"matched_paper_id\":10747140},\"end\":70331,\"start\":70071},{\"attributes\":{\"id\":\"b36\"},\"end\":70487,\"start\":70333},{\"attributes\":{\"id\":\"b37\",\"matched_paper_id\":11106352},\"end\":70960,\"start\":70489},{\"attributes\":{\"id\":\"b38\",\"matched_paper_id\":8843166},\"end\":71386,\"start\":70962},{\"attributes\":{\"id\":\"b39\",\"matched_paper_id\":7418692},\"end\":71676,\"start\":71388},{\"attributes\":{\"doi\":\"arXiv:1508.04025\",\"id\":\"b40\"},\"end\":71960,\"start\":71678},{\"attributes\":{\"id\":\"b41\",\"matched_paper_id\":7961699},\"end\":72265,\"start\":71962},{\"attributes\":{\"id\":\"b42\",\"matched_paper_id\":1779661},\"end\":72423,\"start\":72267},{\"attributes\":{\"id\":\"b43\"},\"end\":72611,\"start\":72425},{\"attributes\":{\"id\":\"b44\",\"matched_paper_id\":13756489},\"end\":72985,\"start\":72613},{\"attributes\":{\"id\":\"b45\",\"matched_paper_id\":6053988},\"end\":73548,\"start\":72987},{\"attributes\":{\"doi\":\"arXiv:1511.05960\",\"id\":\"b46\"},\"end\":73908,\"start\":73550},{\"attributes\":{\"id\":\"b47\",\"matched_paper_id\":8849206},\"end\":74351,\"start\":73910},{\"attributes\":{\"id\":\"b48\",\"matched_paper_id\":14521054},\"end\":74821,\"start\":74353},{\"attributes\":{\"doi\":\"arXiv:1412.6632\",\"id\":\"b49\"},\"end\":75131,\"start\":74823},{\"attributes\":{\"id\":\"b50\",\"matched_paper_id\":7730498},\"end\":75639,\"start\":75133},{\"attributes\":{\"id\":\"b51\",\"matched_paper_id\":11339499},\"end\":76100,\"start\":75641},{\"attributes\":{\"id\":\"b52\"},\"end\":76501,\"start\":76102},{\"attributes\":{\"id\":\"b53\",\"matched_paper_id\":9459633},\"end\":76955,\"start\":76503},{\"attributes\":{\"id\":\"b54\",\"matched_paper_id\":11189276},\"end\":77410,\"start\":76957},{\"attributes\":{\"doi\":\"abs/1806.04616\",\"id\":\"b55\",\"matched_paper_id\":48362414},\"end\":77661,\"start\":77412},{\"attributes\":{\"id\":\"b56\",\"matched_paper_id\":11080756},\"end\":78224,\"start\":77663},{\"attributes\":{\"id\":\"b57\"},\"end\":78478,\"start\":78226},{\"attributes\":{\"id\":\"b58\",\"matched_paper_id\":1169492},\"end\":78911,\"start\":78480},{\"attributes\":{\"id\":\"b59\"},\"end\":79070,\"start\":78913},{\"attributes\":{\"id\":\"b60\",\"matched_paper_id\":165188},\"end\":79581,\"start\":79072}]", "bib_title": "[{\"end\":57082,\"start\":57019},{\"end\":57404,\"start\":57336},{\"end\":57825,\"start\":57762},{\"end\":58048,\"start\":58004},{\"end\":58295,\"start\":58226},{\"end\":58702,\"start\":58628},{\"end\":59179,\"start\":59106},{\"end\":59711,\"start\":59637},{\"end\":60161,\"start\":60069},{\"end\":60693,\"start\":60612},{\"end\":61087,\"start\":61021},{\"end\":61643,\"start\":61568},{\"end\":62044,\"start\":61977},{\"end\":62525,\"start\":62440},{\"end\":63226,\"start\":63135},{\"end\":63734,\"start\":63660},{\"end\":64054,\"start\":64000},{\"end\":64614,\"start\":64530},{\"end\":65158,\"start\":65082},{\"end\":65536,\"start\":65508},{\"end\":65907,\"start\":65842},{\"end\":67067,\"start\":66990},{\"end\":67445,\"start\":67391},{\"end\":68033,\"start\":67974},{\"end\":68539,\"start\":68486},{\"end\":69186,\"start\":69170},{\"end\":70134,\"start\":70071},{\"end\":70561,\"start\":70489},{\"end\":71008,\"start\":70962},{\"end\":71439,\"start\":71388},{\"end\":72012,\"start\":71962},{\"end\":72280,\"start\":72267},{\"end\":72638,\"start\":72613},{\"end\":73074,\"start\":72987},{\"end\":73965,\"start\":73910},{\"end\":74425,\"start\":74353},{\"end\":75222,\"start\":75133},{\"end\":75694,\"start\":75641},{\"end\":76169,\"start\":76102},{\"end\":76572,\"start\":76503},{\"end\":77031,\"start\":76957},{\"end\":77461,\"start\":77412},{\"end\":77725,\"start\":77663},{\"end\":78267,\"start\":78226},{\"end\":78527,\"start\":78480},{\"end\":79133,\"start\":79072}]", "bib_author": "[{\"end\":57098,\"start\":57084},{\"end\":57110,\"start\":57098},{\"end\":57416,\"start\":57406},{\"end\":57831,\"start\":57827},{\"end\":57847,\"start\":57831},{\"end\":57857,\"start\":57847},{\"end\":58062,\"start\":58050},{\"end\":58312,\"start\":58297},{\"end\":58323,\"start\":58312},{\"end\":58338,\"start\":58323},{\"end\":58348,\"start\":58338},{\"end\":58359,\"start\":58348},{\"end\":58717,\"start\":58704},{\"end\":58727,\"start\":58717},{\"end\":59192,\"start\":59181},{\"end\":59208,\"start\":59192},{\"end\":59552,\"start\":59538},{\"end\":59723,\"start\":59713},{\"end\":59737,\"start\":59723},{\"end\":59748,\"start\":59737},{\"end\":59760,\"start\":59748},{\"end\":60171,\"start\":60163},{\"end\":60182,\"start\":60171},{\"end\":60199,\"start\":60182},{\"end\":60705,\"start\":60695},{\"end\":60715,\"start\":60705},{\"end\":60725,\"start\":60715},{\"end\":60735,\"start\":60725},{\"end\":61101,\"start\":61089},{\"end\":61109,\"start\":61101},{\"end\":61122,\"start\":61109},{\"end\":61133,\"start\":61122},{\"end\":61150,\"start\":61133},{\"end\":61656,\"start\":61645},{\"end\":61668,\"start\":61656},{\"end\":61681,\"start\":61668},{\"end\":62056,\"start\":62046},{\"end\":62066,\"start\":62056},{\"end\":62078,\"start\":62066},{\"end\":62088,\"start\":62078},{\"end\":62099,\"start\":62088},{\"end\":62116,\"start\":62099},{\"end\":62540,\"start\":62527},{\"end\":62547,\"start\":62540},{\"end\":62561,\"start\":62547},{\"end\":62573,\"start\":62561},{\"end\":62920,\"start\":62907},{\"end\":62930,\"start\":62920},{\"end\":62941,\"start\":62930},{\"end\":62951,\"start\":62941},{\"end\":63235,\"start\":63228},{\"end\":63245,\"start\":63235},{\"end\":63255,\"start\":63245},{\"end\":63263,\"start\":63255},{\"end\":63272,\"start\":63263},{\"end\":63280,\"start\":63272},{\"end\":63292,\"start\":63280},{\"end\":63749,\"start\":63736},{\"end\":63757,\"start\":63749},{\"end\":63767,\"start\":63757},{\"end\":64064,\"start\":64056},{\"end\":64075,\"start\":64064},{\"end\":64085,\"start\":64075},{\"end\":64100,\"start\":64085},{\"end\":64625,\"start\":64616},{\"end\":64635,\"start\":64625},{\"end\":64647,\"start\":64635},{\"end\":65167,\"start\":65160},{\"end\":65175,\"start\":65167},{\"end\":65183,\"start\":65175},{\"end\":65196,\"start\":65183},{\"end\":65206,\"start\":65196},{\"end\":65544,\"start\":65538},{\"end\":65550,\"start\":65544},{\"end\":65557,\"start\":65550},{\"end\":65563,\"start\":65557},{\"end\":65570,\"start\":65563},{\"end\":65926,\"start\":65909},{\"end\":65937,\"start\":65926},{\"end\":66339,\"start\":66330},{\"end\":66354,\"start\":66339},{\"end\":66364,\"start\":66354},{\"end\":66373,\"start\":66364},{\"end\":66608,\"start\":66594},{\"end\":66619,\"start\":66608},{\"end\":66627,\"start\":66619},{\"end\":66857,\"start\":66848},{\"end\":66868,\"start\":66857},{\"end\":67076,\"start\":67069},{\"end\":67453,\"start\":67447},{\"end\":67459,\"start\":67453},{\"end\":67466,\"start\":67459},{\"end\":67472,\"start\":67466},{\"end\":67478,\"start\":67472},{\"end\":67485,\"start\":67478},{\"end\":67736,\"start\":67726},{\"end\":67754,\"start\":67736},{\"end\":67764,\"start\":67754},{\"end\":68056,\"start\":68035},{\"end\":68067,\"start\":68056},{\"end\":68554,\"start\":68541},{\"end\":68564,\"start\":68554},{\"end\":68574,\"start\":68564},{\"end\":68581,\"start\":68574},{\"end\":68935,\"start\":68921},{\"end\":68947,\"start\":68935},{\"end\":69194,\"start\":69188},{\"end\":69203,\"start\":69194},{\"end\":69210,\"start\":69203},{\"end\":69575,\"start\":69568},{\"end\":69585,\"start\":69575},{\"end\":69596,\"start\":69585},{\"end\":69603,\"start\":69596},{\"end\":69877,\"start\":69865},{\"end\":69884,\"start\":69877},{\"end\":69894,\"start\":69884},{\"end\":70146,\"start\":70136},{\"end\":70156,\"start\":70146},{\"end\":70166,\"start\":70156},{\"end\":70575,\"start\":70563},{\"end\":70586,\"start\":70575},{\"end\":70603,\"start\":70586},{\"end\":71023,\"start\":71010},{\"end\":71034,\"start\":71023},{\"end\":71046,\"start\":71034},{\"end\":71450,\"start\":71441},{\"end\":71456,\"start\":71450},{\"end\":71465,\"start\":71456},{\"end\":71758,\"start\":71746},{\"end\":71766,\"start\":71758},{\"end\":71779,\"start\":71766},{\"end\":72027,\"start\":72014},{\"end\":72038,\"start\":72027},{\"end\":72046,\"start\":72038},{\"end\":72291,\"start\":72282},{\"end\":72301,\"start\":72291},{\"end\":72311,\"start\":72301},{\"end\":72439,\"start\":72425},{\"end\":72449,\"start\":72439},{\"end\":72462,\"start\":72449},{\"end\":72472,\"start\":72462},{\"end\":72651,\"start\":72640},{\"end\":72662,\"start\":72651},{\"end\":72672,\"start\":72662},{\"end\":72685,\"start\":72672},{\"end\":72694,\"start\":72685},{\"end\":72705,\"start\":72694},{\"end\":72715,\"start\":72705},{\"end\":72729,\"start\":72715},{\"end\":73087,\"start\":73076},{\"end\":73099,\"start\":73087},{\"end\":73107,\"start\":73099},{\"end\":73117,\"start\":73107},{\"end\":73123,\"start\":73117},{\"end\":73131,\"start\":73123},{\"end\":73141,\"start\":73131},{\"end\":73151,\"start\":73141},{\"end\":73165,\"start\":73151},{\"end\":73176,\"start\":73165},{\"end\":73645,\"start\":73637},{\"end\":73653,\"start\":73645},{\"end\":73664,\"start\":73653},{\"end\":73671,\"start\":73664},{\"end\":73677,\"start\":73671},{\"end\":73688,\"start\":73677},{\"end\":73975,\"start\":73967},{\"end\":73981,\"start\":73975},{\"end\":73988,\"start\":73981},{\"end\":73996,\"start\":73988},{\"end\":74005,\"start\":73996},{\"end\":74438,\"start\":74427},{\"end\":74450,\"start\":74438},{\"end\":74461,\"start\":74450},{\"end\":74830,\"start\":74823},{\"end\":74836,\"start\":74830},{\"end\":74844,\"start\":74836},{\"end\":74852,\"start\":74844},{\"end\":74861,\"start\":74852},{\"end\":74871,\"start\":74861},{\"end\":75234,\"start\":75224},{\"end\":75247,\"start\":75234},{\"end\":75708,\"start\":75696},{\"end\":75721,\"start\":75708},{\"end\":75735,\"start\":75721},{\"end\":75742,\"start\":75735},{\"end\":75748,\"start\":75742},{\"end\":76184,\"start\":76171},{\"end\":76192,\"start\":76184},{\"end\":76200,\"start\":76192},{\"end\":76212,\"start\":76200},{\"end\":76587,\"start\":76574},{\"end\":76599,\"start\":76587},{\"end\":76612,\"start\":76599},{\"end\":77042,\"start\":77033},{\"end\":77053,\"start\":77042},{\"end\":77060,\"start\":77053},{\"end\":77073,\"start\":77060},{\"end\":77472,\"start\":77463},{\"end\":77482,\"start\":77472},{\"end\":77492,\"start\":77482},{\"end\":77504,\"start\":77492},{\"end\":77739,\"start\":77727},{\"end\":77749,\"start\":77739},{\"end\":77757,\"start\":77749},{\"end\":77767,\"start\":77757},{\"end\":78293,\"start\":78269},{\"end\":78540,\"start\":78529},{\"end\":78550,\"start\":78540},{\"end\":78560,\"start\":78550},{\"end\":78569,\"start\":78560},{\"end\":78954,\"start\":78940},{\"end\":79146,\"start\":79135},{\"end\":79154,\"start\":79146}]", "bib_venue": "[{\"end\":57151,\"start\":57110},{\"end\":57497,\"start\":57416},{\"end\":57865,\"start\":57857},{\"end\":58093,\"start\":58062},{\"end\":58400,\"start\":58359},{\"end\":58799,\"start\":58727},{\"end\":59269,\"start\":59208},{\"end\":59536,\"start\":59521},{\"end\":59797,\"start\":59760},{\"end\":60271,\"start\":60199},{\"end\":60794,\"start\":60735},{\"end\":61236,\"start\":61150},{\"end\":61718,\"start\":61681},{\"end\":62153,\"start\":62116},{\"end\":62614,\"start\":62573},{\"end\":62905,\"start\":62848},{\"end\":63333,\"start\":63292},{\"end\":63811,\"start\":63767},{\"end\":64187,\"start\":64100},{\"end\":64738,\"start\":64647},{\"end\":65272,\"start\":65206},{\"end\":65629,\"start\":65570},{\"end\":66018,\"start\":65937},{\"end\":66328,\"start\":66303},{\"end\":66592,\"start\":66527},{\"end\":66846,\"start\":66806},{\"end\":67146,\"start\":67076},{\"end\":67493,\"start\":67485},{\"end\":67724,\"start\":67633},{\"end\":68154,\"start\":68067},{\"end\":68625,\"start\":68581},{\"end\":68919,\"start\":68803},{\"end\":69282,\"start\":69210},{\"end\":69566,\"start\":69495},{\"end\":69863,\"start\":69794},{\"end\":70189,\"start\":70166},{\"end\":70390,\"start\":70333},{\"end\":70675,\"start\":70603},{\"end\":71124,\"start\":71046},{\"end\":71507,\"start\":71465},{\"end\":71744,\"start\":71678},{\"end\":72095,\"start\":72046},{\"end\":72317,\"start\":72311},{\"end\":72485,\"start\":72472},{\"end\":72778,\"start\":72729},{\"end\":73236,\"start\":73176},{\"end\":73635,\"start\":73550},{\"end\":74082,\"start\":74005},{\"end\":74538,\"start\":74461},{\"end\":74951,\"start\":74886},{\"end\":75319,\"start\":75247},{\"end\":75820,\"start\":75748},{\"end\":76263,\"start\":76212},{\"end\":76657,\"start\":76612},{\"end\":77162,\"start\":77073},{\"end\":77522,\"start\":77518},{\"end\":77850,\"start\":77767},{\"end\":78304,\"start\":78293},{\"end\":78646,\"start\":78569},{\"end\":78938,\"start\":78913},{\"end\":79262,\"start\":79154},{\"end\":57565,\"start\":57499},{\"end\":58858,\"start\":58801},{\"end\":59317,\"start\":59271},{\"end\":60330,\"start\":60273},{\"end\":61309,\"start\":61238},{\"end\":64261,\"start\":64189},{\"end\":64816,\"start\":64740},{\"end\":65675,\"start\":65631},{\"end\":66086,\"start\":66020},{\"end\":67203,\"start\":67148},{\"end\":68228,\"start\":68156},{\"end\":69341,\"start\":69284},{\"end\":70199,\"start\":70191},{\"end\":70734,\"start\":70677},{\"end\":71189,\"start\":71126},{\"end\":74146,\"start\":74084},{\"end\":74602,\"start\":74540},{\"end\":75378,\"start\":75321},{\"end\":75879,\"start\":75822},{\"end\":77920,\"start\":77852},{\"end\":78710,\"start\":78648},{\"end\":79357,\"start\":79264}]"}}}, "year": 2023, "month": 12, "day": 17}