{"id": 209376771, "updated": "2023-09-27 22:03:04.603", "metadata": {"title": "Dota 2 with Large Scale Deep Reinforcement Learning", "authors": "[{\"first\":\"Christopher\",\"last\":\"Berner\",\"middle\":[]},{\"first\":\"Greg\",\"last\":\"Brockman\",\"middle\":[]},{\"first\":\"Brooke\",\"last\":\"Chan\",\"middle\":[]},{\"first\":\"Vicki\",\"last\":\"Cheung\",\"middle\":[]},{\"first\":\"Przemyslaw\",\"last\":\"Dkebiak\",\"middle\":[]},{\"first\":\"Christy\",\"last\":\"Dennison\",\"middle\":[]},{\"first\":\"David\",\"last\":\"Farhi\",\"middle\":[]},{\"first\":\"Quirin\",\"last\":\"Fischer\",\"middle\":[]},{\"first\":\"Shariq\",\"last\":\"Hashme\",\"middle\":[]},{\"first\":\"Chris\",\"last\":\"Hesse\",\"middle\":[]},{\"first\":\"Rafal\",\"last\":\"J'ozefowicz\",\"middle\":[]},{\"first\":\"Scott\",\"last\":\"Gray\",\"middle\":[]},{\"first\":\"Catherine\",\"last\":\"Olsson\",\"middle\":[]},{\"first\":\"Jakub\",\"last\":\"Pachocki\",\"middle\":[]},{\"first\":\"Michael\",\"last\":\"Petrov\",\"middle\":[]},{\"first\":\"Henrique\",\"last\":\"Pinto\",\"middle\":[\"Pond'e\",\"de\",\"Oliveira\"]},{\"first\":\"Jonathan\",\"last\":\"Raiman\",\"middle\":[]},{\"first\":\"Tim\",\"last\":\"Salimans\",\"middle\":[]},{\"first\":\"Jeremy\",\"last\":\"Schlatter\",\"middle\":[]},{\"first\":\"Jonas\",\"last\":\"Schneider\",\"middle\":[]},{\"first\":\"Szymon\",\"last\":\"Sidor\",\"middle\":[]},{\"first\":\"Ilya\",\"last\":\"Sutskever\",\"middle\":[]},{\"first\":\"Jie\",\"last\":\"Tang\",\"middle\":[]},{\"first\":\"Filip\",\"last\":\"Wolski\",\"middle\":[]},{\"first\":\"Susan\",\"last\":\"Zhang\",\"middle\":[]}]", "venue": null, "journal": "arXiv: Learning", "publication_date": {"year": 2019, "month": null, "day": null}, "abstract": "On April 13th, 2019, OpenAI Five became the first AI system to defeat the world champions at an esports game. The game of Dota 2 presents novel challenges for AI systems such as long time horizons, imperfect information, and complex, continuous state-action spaces, all challenges which will become increasingly central to more capable AI systems. OpenAI Five leveraged existing reinforcement learning techniques, scaled to learn from batches of approximately 2 million frames every 2 seconds. We developed a distributed training system and tools for continual training which allowed us to train OpenAI Five for 10 months. By defeating the Dota 2 world champion (Team OG), OpenAI Five demonstrates that self-play reinforcement learning can achieve superhuman performance on a difficult task.", "fields_of_study": "[\"Computer Science\",\"Mathematics\"]", "external_ids": {"arxiv": "1912.06680", "mag": "2996037775", "acl": null, "pubmed": null, "pubmedcentral": null, "dblp": "journals/corr/abs-1912-06680", "doi": null}}, "content": {"source": {"pdf_hash": "d55db7853c9eb051890e931560c211f388c4ea23", "pdf_src": "Arxiv", "pdf_uri": "[\"https://arxiv.org/pdf/1912.06680v1.pdf\"]", "oa_url_match": false, "oa_info": null}, "grobid": {"id": "5d8083ee727d955880e4aa353f75a523f4a03174", "type": "plain-text", "url": "s3://ai2-s2-pdf-extraction-prod/parse-results/s2orc_worker/d55db7853c9eb051890e931560c211f388c4ea23.txt", "contents": "\nDota 2 with Large Scale Deep Reinforcement Learning\nDecember 17, 2019\n\nOpenai \nChristopher Berner \nGreg Brockman \nBrooke Chan \nPrzemys\u0142awVicki Cheung \n&quot; Psyho \n&quot; D\u0119biak \nChristy Dennison \nDavid Farhi \nQuirin Fischer \nShariq Hashme \nChris Hesse \nRafal J\u00f3zefowicz \nScott Gray \nCatherine Olsson \nJakub Pachocki \nMichael Petrov \nHenrique Pond\u00e9 \nOliveira Pinto \nJonathan Raiman \nTim Salimans \nJeremy Schlatter \nJonas Schneider \nSzymon Sidor \nIlya Sutskever \nJie Tang \nFilip Wolski \nSusan Zhang \nDota 2 with Large Scale Deep Reinforcement Learning\nDecember 17, 2019\nOn April 13th, 2019, OpenAI Five became the first AI system to defeat the world champions at an esports game. The game of Dota 2 presents novel challenges for AI systems such as long time horizons, imperfect information, and complex, continuous state-action spaces, all challenges which will become increasingly central to more capable AI systems. OpenAI Five leveraged existing reinforcement learning techniques, scaled to learn from batches of approximately 2 million frames every 2 seconds. We developed a distributed training system and tools for continual training which allowed us to train OpenAI Five for 10 months. By defeating the Dota 2 world champion (Team OG), OpenAI Five demonstrates that self-play reinforcement learning can achieve superhuman performance on a difficult task. * Authors listed alphabetically. Please cite as OpenAI et al., and use the following bibtex for citation:\n\nIntroduction\n\nThe long-term goal of artificial intelligence is to solve advanced real-world challenges. Games have served as stepping stones along this path for decades, from Backgammon (1992) to Chess (1997) to Atari (2013) [1][2][3]. In 2016, AlphaGo defeated the world champion at Go using deep reinforcement learning and Monte Carlo tree search [4]. In recent years, reinforcement learning (RL) models have tackled tasks as varied as robotic manipulation [5], text summarization [6], and video games such as Starcraft [7] and Minecraft [8].\n\nRelative to previous AI milestones like Chess or Go, complex video games start to capture the complexity and continuous nature of the real world. Dota 2 is a multiplayer real-time strategy game produced by Valve Corporation in 2013, which averaged between 500,000 and 1,000,000 concurrent players between 2013 and 2019. The game is actively played by full time professionals; the prize pool for the 2019 international championship exceeded $35 million (the largest of any esports game in the world) [9,10]. The game presents challenges for reinforcement learning due to long time horizons, partial observability, and high dimensionality of observation and action spaces. Dota 2's rules are also complex -the game has been actively developed for over a decade, with game logic implemented in hundreds of thousands of lines of code.\n\nThe key ingredient in solving this complex environment was to scale existing reinforcement learning systems to unprecedented levels, utilizing thousands of GPUs over multiple months. We built a distributed training system to do this which we used to train a Dota 2-playing agent called OpenAI Five. In April 2019, OpenAI Five defeated the Dota 2 world champions (Team OG 1 ), the first time an AI system has beaten an esport world champion 2 . We also opened OpenAI Five to the Dota 2 community for competitive play; OpenAI Five won 99.4% of over 7000 games.\n\nOne challenge we faced in training was that the environment and code continually changed as our project progressed. In order to train without restarting from the beginning after each change, we developed a collection of tools to resume training with minimal loss in performance which we call surgery. Over the 10-month training process, we performed approximately one surgery per two weeks. These tools allowed us to make frequent improvements to our strongest agent within a shorter time than the typical practice of training from scratch would allow. As AI systems tackle larger and harder problems, further investigation of settings with ever-changing environments and iterative development will be critical.\n\nIn section 2, we describe Dota 2 in more detail along with the challenges it presents. In section 3 we discuss the technical components of the training system, leaving most of the details to appendices cited therein. In section 4, we summarize our long-running experiment and the path that lead to defeating the world champions. We also describe lessons we've learned about reinforcement learning which may generalize to other complex tasks.\n\n\nDota 2\n\nDota 2 is played on a square map with two teams defending bases in opposite corners. Each team's base contains a structure called an ancient; the game ends when one of these ancients is destroyed by the opposing team. Teams have five players, each controlling a hero unit with unique abilities. During the game, both teams have a constant stream of small \"creep\" units, uncontrolled by the players, which walk towards the enemy base attacking any opponent units or buildings. Players gather resources such as gold from creeps, which they use to increase their hero's power by purchasing items and improving abilities. 3 To play Dota 2, an AI system must address various challenges:\n\n\u2022 Long time horizons. Dota 2 games run at 30 frames per second for approximately 45 minutes. OpenAI Five selects an action every fourth frame, yielding approximately 20,000 steps per episode. By comparison, chess usually lasts 80 moves, Go 150 moves [11].\n\n\u2022 Partially-observed state. Each team in the game can only see the portion of the game state near their units and buildings; the rest of the map is hidden. Strong play requires making inferences based on incomplete data, and modeling the opponent's behavior.\n\n1 https://www.facebook.com/OGDota2/ 2 Full game replays and other supplemental can be downloaded from: https://openai.com/blog/ how-to-train-your-openai-five/ 3 Further information the rules and gameplay of Dota 2 is readily accessible online; a good introductory resource is https://purgegamers.true.io/g/dota-2-guide/ \u2022 High-dimensional action and observation spaces. Dota 2 is played on a large map containing ten heroes, dozens of buildings, dozens of non-player units, and a long tail of game features such as runes, trees, and wards. OpenAI Five observes \u223c 16, 000 total values (mostly floats and categorical values with hundreds of possibilities) each time step. We discretize the action space; on an average timestep our model chooses among 8,000 to 80,000 actions (depending on hero). For comparison Chess requires around one thousand values per observation (mostly 6-possibility categorical values) and Go around six thousand values (all binary) [12]. Chess has a branching factor of around 35 valid actions, and Go around 250 [11].\n\nOur system played Dota 2 with two limitations from the regular game:\n\n\u2022 Subset of 17 heroes -in the normal game players select before the game one from a pool of 117 heroes to play; we support 17 of them. 4\n\n\u2022 No support for items which allow a player to temporarily control multiple units at the same time (Illusion Rune, Helm of the Dominator, Manta Style, and Necronomicon). We removed these to avoid the added technical complexity of enabling the agent to control multiple units.\n\n\nTraining System\n\n\nPlaying Dota using AI\n\nHumans interact with the Dota 2 game using a keyboard, mouse, and computer monitor. They make decisions in real time, reason about long-term consequences of their actions, and more. We adopt the following framework to translate the vague problem of \"play this complex game at a superhuman level\" into a detailed objective suitable for optimization. Although the Dota 2 engine runs at 30 frames per second, OpenAI Five only acts on every 4th frame which we call a timestep. Each timestep, OpenAI Five receives an observation from the game engine encoding all the information a human player would see such as units' health, position, etc (see Appendix E for an in-depth discussion of the observation). OpenAI Five then returns a discrete action to the game engine, encoding a desired movement, attack, etc.\n\nCertain game mechanics were controlled by hand-scripted logic rather than the policy: the order in which heroes purchase items and abilities, control of the unique courier unit, and which items heroes keep in reserve. While we believe the agent could ultimately perform better if these actions were not scripted, we achieved superhuman performance before doing so. Full details of our action space and scripted actions are described in Appendix F. Some properties of the environment were randomized during training, including the heroes in the game and which items the heroes purchased. Sufficiently diverse training games are necessary to ensure robustness to the wide variety of strategies and situations that arise in games against human opponents. See subsection O.2 for details of the domain randomizations.\n\nWe define a policy (\u03c0) as a function from the history of observations to a probability distribution over actions, which we parameterize as a recurrent neural network with approximately 159 million parameters (\u03b8). The neural network consists primarily of a single-layer 4096-unit LSTM [13] (see Figure 1). Given a policy, we play games by repeatedly passing the current observation as input and sampling an action from the output distribution at each timestep. The complex multi-array observation space is processed into a single vector, which is then passed through a 4096-unit LSTM. The LSTM state is projected to obtain the policy outputs (actions and value function). Each of the five heroes on the team is controlled by a replica of this network with nearly identical inputs, each with its own hidden state. The networks take different actions due to a part of the observation processing's output indicating which of the five heroes is being controlled. The LSTM composes 84% of the model's total parameter count. See Figure 17 and Figure 18 in Appendix H for a detailed breakdown of our model architecture.\n\nSeparate replicas of the same policy function (with identical parameters \u03b8) are used to control each of the five heroes on the team. Because visible information and fog of war (area that is visible to players due to proximity of friendly units) are shared across a team in Dota 2, the observations are nearly 5 identical for each hero.\n\nInstead of using the pixels on the screen, we approximate the information available to a human player in a set of data arrays (see Appendix E for full details of the observations space). This approximation is imperfect; there are small pieces of information which humans can gain access to which we have not encoded in the observations. On the flip side, while we were careful to ensure that all the information available to the model is also available to a human, the model does get to see all the information available simultaneously every time step, whereas a human needs to actively click to see various parts of the map and status modifiers. OpenAI Five uses this semantic observation space for two reasons: First, because our goal is to study strategic planning and high-level decisionmaking rather than focus on visual processing. Second, it is infeasible for us to render each frame to pixels in all training games; this would multiply the computation resources required for the project many-fold. Although these discrepancies exist, we do not believe they introduce significant bias when benchmarking against human players. To allow the five networks to choose different actions, the LSTM receives an extra input from the observation processing, indicating which of the five heroes is being controlled, detailed in Figure 17.\n\nBecause of the expansive nature of the problem and the size and expense of each experiment, it was not practical to investigate all the details of the policy and training system. Many details, even some large ones, were set for historical reasons or on the basis of preliminary investigations without full ablations.\n\n\nOptimizing the Policy\n\nOur goal is to find a policy which maximizes the probability of winning the game against professional human experts. In practice, we maximize a reward function which includes additional signals such as characters dying, collecting resources, etc. We also apply several techniques to exploit the zerosum multiplayer structure of the problem when computing the reward function -for example, we symmetrize rewards by subtracting the reward earned by the opposing team. We discuss the details of the reward function in Appendix G. We constructed the reward function once at the start of the project based on team members' familiarity with the game. Although we made minor tweaks when game versions changed, we found that our initial choice of what to reward worked fairly well. The presence of these additional signals was important for successful training (as discussed in Appendix G).\n\nThe policy is trained using Proximal Policy Optimization (PPO) [14], a variant of advantage actor critic [15,16]. 6 The optimization algorithm uses Generalized Advantage Estimation [17] (GAE), a standard advantage-based variance reduction technique [15] to stabilize and accelerate training. We train a network with a central, shared LSTM block, that feeds into separate fully connected layers producing policy and value function outputs.\n\nThe training system is represented in Figure 2. We train our policy using collected self-play experience from playing Dota 2, similar to [18]. A central pool of optimizer GPUs receives game data and stores it asynchronously in local buffers called experience buffers. Each optimizer GPU computes gradients using minibatches sampled randomly from its experience buffer. Gradients are averaged across the pool using NCCL2 [19] allreduce before being synchronously applied to the parameters. In this way the effective batch size is the batch size on each GPU (120 samples, each with 16 timesteps) multiplied by the number of GPUs (up to 1536 at the peak), for a total batch size of 2,949,120 time steps (each with five hero policy replicas).\n\nWe apply the Adam optimizer [20] using truncated backpropagation through time[21] over samples of 16 timesteps. Gradients are additionally clipped per parameter to be within between \u00b15 \u221a v where v is the running estimate of the second moment of the (unclipped) gradient. Every 32 gradient steps, the optimizers publish a new version of the parameters to a central Redis 7 storage called the controller. The controller also stores all metadata about the state of the system, for stopping and restarting training runs.\n\n\"Rollout\" worker machines run self-play games. They run these games at approximately 1/2 real time, because we found that we could run slightly more than twice as many games in parallel at this speed, increasing total throughput. We describe our integration with the Dota 2 engine in Appendix K. They play the latest policy against itself for 80% of games, and play against older policies for 20% of games (for details of opponent sampling, see Appendix N). The rollout machines run the game engine but not the policy; they communicate with a separate pool of GPU machines which run forward passes in larger batches of approximately 60. These machines frequently poll the controller to gather the newest parameters. Figure 2: System Overview: Our training system consists of 4 primary types of machines. Rollouts run the Dota 2 game on CPUs. They communicate in a tight loop with Forward Pass GPUs, which sample actions from the policy given the current observation. Rollouts send their data to Optimizer GPUs, which perform gradient updates. The Optimizers publish the parameter versions to storage in the Controller, and the Forward Pass GPUs occasionally pull the latest parameter version. Machine numbers are for the Rerun experiment described in subsection 4.2; OpenAI Five's numbers fluctuated between this scale and approximately 3x larger.\n\nRollout machines send data asynchronously from games that are in progress, instead of waiting for an entire game to finish before publishing data for optimization 8 ; see Figure 8 in Appendix C for more discussion of how rollout data is aggregated. See Figure 5b for the benefits of keeping the rollout-optimization loop tight. Because we use GAE with \u03bb = 0.95, the GAE rewards need to be smoothed over a number of timesteps 1/\u03bb = 20; using 256 timesteps causes relatively little loss. The entire system runs on our custom distributed training platform called Rapid [5], running on Google Cloud Platform. We use ops from the blocksparse library for fast GPU training [22]. For a full list of the hyperparameters used in training, see Appendix C.\n\n\nContinual Transfer via Surgery\n\nAs the project progressed, our code and environment gradually changed for three different reasons:\n\n1. As we experimented and learned, we implemented changes to the training process (reward structure, observations, etc) or even to the architecture of the policy neural network.\n\n2. Over time we expanded the set of game mechanics supported by the agent's action and observation spaces. These were not introduced gradually in an effort to build a perfect curriculum.\n\nRather they were added incrementally as a consequence of following the standard engineering practice of building a system by starting simple and adding complexity piece by piece over time.\n\n3. From time to time, Valve publishes a new Dota 2 version including changes to the core game mechanics and the properties of heroes, items, maps, etc; to compare to human players our agent must play on the latest game version.\n\nThese changes can modify the shapes and sizes of the model's layers, the semantic meaning of categorical observation values, etc. When these changes occur, most aspects of the old model are likely relevant in the new environment. But cherry-picking parts of the parameter vector to carry over is challenging and limits reproducibility. For these reasons training from scratch is the safe and common response to such changes.\n\nHowever, training OpenAI Five was a multi-month process with high capital expenditure, motivating the need for methods that can persist models across domain and feature changes. It would have been prohibitive (in time and money) to train a fresh model to a high level of skill after each such change (approximately every two weeks). For example, we changed to Dota 2 version 7.21d, eight days before our match against the world champions (OG); this would not have been possible if we had not continued from the previous agent.\n\nOur approach, which we term \"surgery\", can be viewed as a collection of tools to perform offline operations to the old model \u03c0 \u03b8 to obtain a new model\u03c0\u03b8 compatible with the new environment, which performs at the same level of skill even if the parameter vectors\u03b8 and \u03b8 have different sizes and semantics. We then begin training in the new environment using\u03c0\u03b8. In the simplest case where the environment, observation, and action spaces did not change, our standard reduces to insisting that the new policy implements the same function from observed states to action probabilities as the old:\n\u2200o\u03c0\u03b8(o) = \u03c0 \u03b8 (o)(1)\nThis case is a special case of Net2Net-style function preserving transformations [23]. We have developed tools to implement Equation 1 exactly when possible (adding observations, expanding layers, and other situations), and approximately when the type of modification to the environment, observation space, or action space precludes satisfying it exactly. See Appendix B for further discussion of surgery.\n\nIn the end, we performed over twenty surgeries (along with many unsuccessful surgery attempts) over the ten-month lifetime of OpenAI Five (see Table 1 in Appendix B for a full list). Surgery enabled continuous training without loss in performance (see Figure 4). In subsection 4.2 we discuss our experimental verification of this method.\n\n\nExperiments and Evaluation\n\nOpenAI Five is a single training run that ran from June 30th, 2018 to April 22nd, 2019. After ten months of training using 770\u00b150 PFlops/s\u00b7days of compute, it defeated the Dota 2 world champions in a best-of-three match and 99.4% of human players during a multi-day online showcase.\n\nIn order to utilize this level of compute effectively we had to scale up along three axes. First, we used batch sizes of 1 to 3 million timesteps (grouped in unrolled LSTM windows of length 16). Second, we used a model with over 150 million parameters. Finally, OpenAI Five trained for 180 days (spread over 10 months of real time due to restarts and reverts). Compared AlphaGo [4], we use 50 to 150 times larger batch size, 20 times larger model, and 25 times longer training time. Simultaneous works in recent months [7,24] have matched or slightly exceeded our scale.\n\n\nHuman Evaluation\n\nOver the course of training, OpenAI Five played games against numerous amateur players, professional players, and professional teams in order to gauge progress. For a complete list of the professional teams OpenAI Five played against over time, see Appendix I.\n\nOn April 13th, OpenAI Five played a high-profile game against OG, the reigning Dota 2 world champions, winning a best-of-three (2-0) and demonstrating that our system can learn to play at the highest levels of skill. For detailed analysis of our agent's performance during this game and its overall understanding of the environment, see Appendix D.\n\nMachine Learning systems often behave poorly when confronted with unexpected situations[25]. While winning a single high-stakes showmatch against the world champion indicates a very high level of skill, it does not prove a broad understanding of the variety of challenges the human community can present. To explore whether OpenAI Five could be consistently exploited by creative or outof-distribution play, we ran OpenAI Five Arena, in which we opened OpenAI Five to the public for competitive online games from April 18-21, 2019. In total, Five played 3,193   To provide informal context for how TrueSkill corresponds to human skill, we mark the level at which OpenAI Five begins to defeat various opponents, from random to world champions. Note that this is biased against earlier models; this TrueSkill evaluation is performed using the final policy and environment (Dota 2 version 7.21d, all non-illusion items, etc), even though earlier models were trained in the earlier environment. We believe this contributes to the inflection point around 600 PFLOPs/s-days -around that point we gave the policy control of a new action (buyback) and performed a major Dota 2 version upgrade (7.20). We speculate that the rapid increase to TrueSkill 200 early in training is due to the exponential nature of the scale -a constant TrueSkill difference of approximately 8.3 corresponds to an 80% winrate, and it is easier to learn how to consistently defeat bad agents.\n\n\nlost.\n\nIn Dota 2, the key measure of human dexterity is reaction time 10 . OpenAI Five can react to a game event in 217ms on average. This quantity does not vary depending on game state. It is difficult to find reliable data on Dota 2 professionals' reaction times, but typical human visual reaction time is approximately 250ms [26]. See Appendix L for more details.\n\nWhile human evaluation is the ultimate goal, we also need to evaluate our agents continually during training in an automated way. We achieve this by comparing them to a pool of fixed reference agents with known skill using the TrueSkill rating system [27]. In our TrueSkill environment, a rating of 0 corresponds to a random agent, and a difference of approximately 8.3 TrueSkill between two agents roughly corresponds to an 80% winrate of one versus the other (see Appendix J for details of our TrueSkill setup). OpenAI Five's TrueSkill rating over time can be seen in Figure 3.\n\nOpenAI Five's \"playstyle\" is difficult to analyze rigorously (and is likely influenced by our shaped reward function) but we can discuss in broad terms the flavor of comments human players made to describe how our agent approached the game. Over the course of training, OpenAI Five developed a distinct style of play with noticeable similarities and differences to human playstyles. Early in training, OpenAI Five prioritized large group fights in the game as opposed to accumulating resources for later, which led to games where they were significantly behind if the enemy team avoided fights early. This playstyle was risky and would result in quick wins in under 20 minutes if OpenAI Five got an early advantage, but had no way to recover from falling behind, leading to long and drawn out losses often over 45 minutes.\n\nAs the agents improved, the playstyle evolved to align closer with human play while still maintaining many of the characteristics learned early on. OpenAI Five began to concentrate resources in the hands of its strongest heroes, which is common in human play. Five relied heavily on large group battles, effectively applying pressure when holding a significant advantage, but also avoided fights and focused on gathering resources if behind.\n\nThe final agent played similar to humans in many broad areas, but had a few interesting differences. Human players tend to assign heroes to different areas of the map and only reassign occasionally, but OpenAI Five moved heroes back and forth across the map much more frequently. Human players are often cautious when their hero has low health; OpenAI Five seemed to have a very finely-tuned understanding of when an aggressive attack with a low-health hero was worth a risk. Finally OpenAI Five tended to more readily consume resources, as well as abilities with long cooldowns (time it takes to reload), while humans tend to hold on to those in case a better opportunity arises later.\n\n\nValidating Surgery with Rerun\n\nIn order to validate the time and resources saved by our surgery method (see subsection 3.3), we trained a second agent between May 18, 2019 and June 12, 2019, using only the final environment, model architecture, etc. This training run, called \"Rerun\", did not go through a tortuous route of changing game rules, modifications to the neural network parameters, online experiments with hyperparameters, etc.\n\nRerun took 2 months and 150 \u00b1 5 PFlops/s\u00b7days of compute (see Figure 4). This timeframe is significantly longer than the frequency of our surgery changes (which happened every 1-2 weeks). As a naive comparison, if we had trained from scratch after each of our twenty major surgeries, the project would have taken 40 months instead of 10 (in practice we likely would have made fewer changes). Another benefit of surgery was that we had a very high-skill agent available for evaluation at all times, significantly tightening the iteration loop for experimental changes. In OpenAI Five's regime -exploring a novel task and building a novel environment -perpetual training is a significant benefit.\n\nOf course, in situations where the environment is pre-built and well-understood from the start, we see little need for surgery. Rerun took approximately 20% of the resources of OpenAI Five; if we had access to the final training environment ahead of time there would be no reason to start training e.g. on a different version of the game.\n\nRerun continued to improve beyond OpenAI Five's skill, and reached over 98% winrate against the final version of OpenAI Five. We wanted to validate that our final code and hyperparameters would reproduce OpenAI Five performance, so we ceased training at that point. We believe Rerun would have continued improving, both because of its upward trend and because we had yet to fully anneal hyperparameters like learning rate and horizon to their final OpenAI Five settings.\n\nThis process of surgery successfully allowed us to change the environment every week. However, the model ultimately plateaued at a weaker skill level than the from-scratch model was able to  In the top panel we see the full history of our project -we used surgery methods to continue training OpenAI Five at each environment or policy change without loss in performance; then we restarted once at the end to run Rerun. On the bottom we see the hypothetical alternative, if we had restarted after each change and waited for the model to reach the same level of skill (assuming pessimistically that the curve would be identical to OpenAI Five). The ideal option would be to run Rerun-like training from the very start, but this is impossible -the OpenAI Five curve represents lessons learned that led to the final codebase, environment, etc., without which it would not be possible to train Rerun.\n\nachieve. Learning how to continue long-running training without affecting final performance is a promising area for future work.\n\nUltimately, while surgery as currently conceived is far from perfect, with proper tooling it becomes a useful method for incorporating certain changes into long-running experiments without paying the cost of a restart for each.\n\n\nBatch Size\n\nIn this section, we evaluate the benefits of increasing the batch size using small scale experiments. Increasing the batch size in our case means two things: first, using twice as many optimizer GPUs to optimize over the larger batch, and second, using twice as many rollout machines and forward pass GPUs to produce twice as many samples to feed the increased optimizer pool.\n\nOne compelling benchmark to compare against when increasing the batch size is linear speedup: using 2x as much compute gets to the same skill level in 1/2 the time. If this scaling property holds, it is possible to use the same total amount of GPU-days (and thus dollars) to reach a given result [28]. In practice we see less than this ideal speedup, but the speedup from increasing batch size is still noticeable and allows us to reach the result in less wall time.\n\nTo understand how batch size affects training speed, we calculate the \"speedup\" of an experiment to reach various TrueSkill thresholds, defined as:\nspeedup(T ) =\nVersions for baseline to first reach TrueSkill T Versions for experiment to first reach TrueSkill T\n\nThe results of varying batch size in the early part of training can be seen in Figure 5. Full details of the experimental setup can be found in Appendix M. We find that increasing the batch size speeds up training through the regime we tested, up to batches of millions of observations.\n\nUsing the scale of Rerun, we were able to reach superhuman performance in two months. In Figure 5a, we see that Rerun's batch size (983k time steps) had a speedup factor of around 2.5x over the baseline batch size (123k). If we had instead used the smaller batch size, then, we might expect to wait 5 months for the same result. We speculate that it would likely be longer, as the speedup factor of 2.5 applies at TrueSkill 175 early in training, but it appears to increase with higher TrueSkill.\n\nPer results in [28], we hoped to find (in the early part of training) linear speedup from increasing batch size; i.e. that it would be 2x faster to train an agent to certain thresholds if we use 2x the compute and data. Our results suggest that speedup is less than linear. However, we speculate that this may change later in training when the problem becomes more difficult. Also, given the relevant compute costs, in this ablation study we did not tune hyperparameters such as learning rate separately for each batch size.\n\n\nData Quality\n\nOne unusual feature of our task is the length of the games; each rollout can take up to two hours to complete. For this reason it is infeasible for us to optimize entirely on fully on-policy trajectories; if we waited to apply gradient updates for an entire rollout game to be played using the latest parameters, we could make only one update every two hours. Instead, our rollout workers and optimizers operate asynchronously: rollout workers download the latest parameters, play a small    Higher speedup means that training was faster and more efficient. These four thresholds are chosen arbitrarily; a few are omitted when the uncertainties are too large (for example in Figure 5c fewer than half the experiments reach 175, so that speedup curve would not be informative).\n\nportion of the game, and upload data to the experience buffer, while optimizers continually sample from whatever data is present in the experience buffer to optimize ( Figure 2). Early on in the project, we had rollout workers collect full episodes before sending it to the optimizers and downloading new parameters. This means that once the data finally enters the optimizers, it can be several hours old, corresponding to thousands of gradient steps. Gradients computed from these old parameters were often useless or destructive. In the final system rollout workers send data to optimizers after only 256 timesteps, but even so this can be a problem.\n\nWe found it useful to define a metric for this called staleness. If a sample was generated by parameter version N and we are now optimizing version M , then we define the staleness of that data to be M \u2212 N . In Figure 5b, we see that increasing staleness by \u223c 8 versions causes significant slowdowns. Note that this level of staleness corresponds to a few minutes in a multimonth experiment. Our final system design targeted a staleness between 0 and 1 by sending game data every 30 seconds of gameplay and updating to fresh parameters approximately once a minute, making the loop faster than the time it takes the optimizers to process a single batch (32 PPO gradient steps). Because of the high impact of staleness, in future work it may be worth investigating whether optimization methods more robust to off-policy data could provide significant improvement in our asynchronous data collection regime.\n\nBecause optimizers sample from an experience buffer, the same piece of data can be re-used many times. If data is reused too often, it can lead to overfitting on the reused data [18]. To diagnose this, we defined a metric called the sample reuse of the experiment as the instantaneous ratio between the rate of optimizers consuming data and rollouts producing data. If optimizers are consuming samples twice as fast as rollouts are producing them, then on average each sample is being used twice and we say that the sample reuse is 2. In Figure 5c, we see that reusing the same data even 2-3 times can cause a factor of two slowdown, and reusing it 8 times may prevent the learning of a competent policy altogether. Our final system targets sample reuse \u223c 1 in all our experiments.\n\nThese experiments on the early part of training indicate that high quality data matters even more than compute consumed; small degradations in data quality have severe effects on learning. Full details of the experiment setup can be found in Appendix M.\n\n\nLong term credit assignment\n\nDota 2 has extremely long time dependencies. Where many reinforcement learning environment episodes last hundreds of steps ([4, 29-31]), games of Dota 2 can last for tens of thousands of time steps. Agents must execute plans that play out over many minutes, corresponding to thousands of timesteps. This makes our experiment a unique platform to test the ability of these algorithms to understand long-term credit assignment.\n\nIn Figure 6, we study the time horizon over which our agent discounts rewards, defined as\nH = T 1 \u2212 \u03b3(3)\nHere \u03b3 is the discount factor [17] and T is the real game time corresponding to each step (0.133 seconds). This measures the game time over which future rewards are integrated, and we use it as a proxy for the long-term credit assignment which the agent can perform. In Figure 6, we see that resuming training a skilled agent using a longer horizon makes it perform better, up to the longest horizons we explored (6-12 minutes). This implies that our optimization was capable of accurately assigning credit over long time scales, and capable of learning policies and Win rate 45s 90s 180s 360s 720s Figure 6: Effect of horizon on agent performance. We resume training from a trained agent using different horizons (we expect long-horizon planning to be present in highly-skilled agents, but not from-scratch agents). The base agent was trained with a horizon of 180 seconds (\u03b3 = 0.9993), and we include as a baseline continued training at horizon 180s. Increasing horizon increases win rate over the trained agent at the point training was resumed, with diminishing returns at high horizons.\n\nactions which maximize rewards 6-12 minutes into the future. As the environments we attempt to solve grow in complexity, long-term planning and thinking will become more and more important for intelligent behavior.\n\n\nRelated Work\n\nThe OpenAI Five system builds upon several bodies of work combining deep reinforcement learning, large-scale optimization of deep learning models, and using self-play to explore environments and strategies.\n\nCompetitive games have long served as a testbed for learning. Early systems mastered Backgammon [1], Checkers [32], and Chess [2]. Self-play was shown to be a powerful algorithm for learning skills within high-dimensional continuous environments [33] and a method for automatically generating curricula [34]. Our use of self-play is similar in spirit to fictitious play [35], which has been successfully applied to poker [36] -in this work we learn a distribution over opponents and use the latest policy rather than an average policy.\n\nUsing a combination of imitation learning human games and self-play, Silver et al. demonstrated a master-level Go player [4]. Building upon this work, AlphaGoZero, AlphaZero, and ExIt discard imitation learning in favor of using Monte-Carlo Tree Search during training to obtain higher quality trajectories [12,37,38] and apply this to Go, Chess, Shogi, and Hex. Most recently, human-level play has been demonstrated in 3D first-person multi-player environments [30], professional-level play in the real-time strategy game StarCraft 2 using AlphaStar [7], and superhuman performance in Poker [39].\n\nAlphaStar is particularly relevant to this paper. In that effort, which ran concurrently to our own, researchers trained agents to play Starcraft 2, another complex game with real-time performance requirements, imperfect information, and long time horizons. The model for AlphaStar used a similar hand-designed architecture to embed observations and an autoregressive action decoder, with an LSTM core to handle partial observability. Both systems used actor critic reinforcement learning methods as part of the overall objective. OpenAI Five has certain sub-systems hard-coded (such as item buying), whereas AlphaStar handled similar decisions (e.g. building order) by conditioning (during training) on statistics derived from human replays. OpenAI Five trained using self play, while AlphaStar used a league consisting of multiple agents, where agents were trained to beat certain subsets of other agents. Finally, AlphaStar's value network observed full information about the game state (including observations hidden from the policy); this method improved their training and exploring its application to Dota 2 is a promising direction for future work.\n\nDeep reinforcement learning has been successfully applied to learning control policies from high dimensional input. In 2013, Mnih et al. [3] show that it is possible to combine a deep convolutional neural network with a Q-learning algorithm[40] and a novel experience replay approach to learn policies that can reach superhuman performance on the Atari ALE games. Following this work, a variety of efforts have pushed performance on the remaining Atari games [16], reduced the sample complexity, and introduced new challenges by focusing on intrinsic rewards [41-43].\n\nAs more computational resources have become available, a body of work has developed addressing the use of distributed systems in training. Larger batch sizes were found to accelerate training of image models [44][45][46]. Proximal Policy Optimization [14] and A3C [47] improve the ability to asynchronously collect rollout data. Recent work has demonstrated the benefit of distributed learning on a wide array of problems including single-player video games[48] and robotics [5].\n\nThe motivation for our surgery method is similar to prior work on Net2Net style function preserving transformations [23] which attempt to add model capacity without compromising performance, whereas our surgery technique was used in cases where the inputs, outputs, and recurrent layer size changed. \n\n\nConclusion\n\nWhen successfully scaled up, modern reinforcement learning techniques can achieve superhuman performance in competitive esports games. The key ingredients are to expand the scale of compute used, by increasing the batch size and total training time. In order to extend the training time of a single run to ten months, we developed surgery techniques for continuing training across changes to the model and environment. While we focused on Dota 2, we hypothesize these results will apply more generally and these methods can solve any zero-sum two-team continuous environment which can be simulated in parallel across hundreds of thousands of instances. In the future, environments and tasks will continue to grow in complexity. Scaling will become even more important (for current methods) as the tasks become more challenging.\n\n\nAcknowledgements\n\nMyriad individuals contributed to this work from within OpenAI, within the Dota 2 community, and elsewhere. We extend our utmost gratitude to everyone who helped us along the way! We would like to especially recognize the following contributions: \u2022 Dota 2 Support from Valve (special thanks to Chris Carollo)\n\u2022\n\u2022 Dota 2 guides and builds from Tortedelini (Michael Cohen) and buyback saving strategy from Adam Michalik \n\n\nAuthor Contributions\n\nThis manuscript is the result of the work of the entire OpenAI Dota team. For each major area, we list the primary contributors in alphabetical order.\n\n\u2022 Greg Brockman, Brooke Chan, Przemys\u0142aw \"Psyho\" D\u0119biak, Christy Dennison, David Farhi, Scott Gray, Jakub Pachocki, Michael Petrov, Henrique Pond\u00e9 de Oliveira Pinto, Jonathan Raiman, Szymon Sidor, Jie Tang, Filip Wolski, and Susan Zhang developed and trained OpenAI Five, including developing surgery, expanding tools for large-scale distributed RL, expanding the capabilities to the 5v5 game, and running benchmarks against humans including the OG match and OpenAI Arena.\n\n\u2022 Christopher Berner, Greg Brockman, Vicki Cheung, Przemys\u0142aw \"Psyho\" D\u0119biak, Quirin Fischer, Shariq Hashme, Chris Hesse, Rafal J\u00f3zefowicz, Catherine Olsson, Jakub Pachocki, Tim Salimans, Jeremy Schlatter, Jonas Schneider, Szymon Sidor, Ilya Sutskever, and Jie Tang developed the 1v1 training system, including the Dota 2 gym interface, building the first Dota agent, and initial exploration of batch size scaling.\n\n\u2022 Brooke Chan, David Farhi, Michael Petrov, Henrique Pond\u00e9 de Oliveira Pinto, Jonathan Raiman, Jie Tang, and Filip Wolski wrote this manuscript, including running Rerun and all of the ablation studies.\n\n\u2022 Jakub Pachocki and Szymon Sidor set research direction throughout the project, including developing the first version of Rapid to demonstrate initial benefits of large scale computing in RL.\n\n\u2022 Greg Brockman and Rafal J\u00f3zefowicz kickstarted the team.   \n\n\nA Compute Usage\n\nWe estimate the optimization compute usage as follows: We break the experiment in segments between each major surgery or batch size change. For each of those, we calculate the number of gradient descent steps taken (number of iterations \u00d7 32). We estimate the compute per step per GPU using TensorFlow's tf.profiler.total_float_ops, then multiply together:\ntotal compute = segment 32 \u00d7 (iteration end \u2212 iteration start )\u00d7(4)\n(# gpus) \u00d7 (compute per step per gpu)\n\nOur uncertainty on this estimate comes primarily from ambiguities about what computation \"counts.\" For example the tensorflow metrics include all ops in the graph including metric logging, nan-checking, etc. It also includes the prediction of auxiliary heads such as win probability, which are not necessary for gameplay or training. It does not count non-GPU compute on the optimizer machines such as exporting parameter versions to the rollouts. We estimate these and other ambiguities to be around 5%. In addition, for OpenAI Five (although not for Rerun) we use a simplified history of the experiment, rather than keeping track of every change and every time something crashed and needed to be restarted; we estimate this does not add more than 5% error. We combine these rough error estimates into a (very crude) net ambiguity estimate of 5-10%.\n\nThis computation concludes that OpenAI Five used 770\u00b150 PFlops/s\u00b7days of total optimization compute on GPUs at the time of playing the world champions (April 13, 2019), and 820\u00b150 total optimization compute when it was finally turned off on April 22nd, 2019. Rerun, on the other hand, used 150 \u00b1 5 PFlops/s\u00b7days between May 18th and July 12th, 2019.\n\nWe adopted the methodology from [57] to facilitate comparisons. This has several important caveats. First, the above computation only considers compute used for optimization. In fact this is a relatively small portion of the total compute budget for the training run. In addition to the GPU machines doing optimization (roughly 30% of the cost by dollars spent) there are approximately the same number of GPUs running forward passes for the rollout workers (30%), as well as the actual rollouts CPUs running the selfplay games (30%) and the overhead of controllers, TrueSkill evaluators, CPUs on the GPU machines, etc (10%).\n\nSecond, with any research project one needs to run many small studies, ablations, false starts, etc. One also inevitably wastes some computing resources due to imperfect utilization. Traditionally the AI community has not counted these towards the compute used by the project, as it is much easier to count only the resources used by the final training run. However, with our advent of surgery, the line becomes much fuzzier. After 5 months of training on an older environment, we could have chosen to start from scratch in the new environment, or performed surgery to keep the old model. Either way, the same total amount of compute gets used; but the above calculation ignores all the compute used up until the last time we chose to restart. For these reasons the compute number for OpenAI Five should be taken with a large grain of salt, but this caveat does not apply to Rerun, which was trained without surgery.\n\n\nB Surgery\n\nAs discussed in 3.3, we designed \"surgery\" tools for continuing to train a single set of paramters across changes to the environment, model architecture, observation space, and action space.  changes (such as improvements to partial reward weights or scripted logic). \"Obs\" indicates than a new observation was added as an input to the model or an existing one was changed. \"Action\" indicates that a new game action was made available, along with appropriate observations about the state of that action. \"Item\" indicates that a new item was introduced, including observation of the item and the action to use the item. The Dota 2 version updates (7.19, 7.20 and 7.21) include many new items, actions, and observations. goal in each case is to resume training after the change without the agent losing any skill from the change. Table 1 lists the major surgeries we performed in the lifetime of the OpenAI Five experiment.\n\nFor changes which add parameters, one of the key questions to ask is how to initialize the new parameters. If we initialize the parameters randomly and continue optimization, then noise will flow into other parts of the model, causing the model to play badly and causing large gradients which destroy the learned behaviors.\n\nIn the rest of this appendix we provide details of the tools we used to continue training across each type of change. In general we had a high-skill model \u03c0 \u03b8 trained to act in one environment, and due to a change to the problem design we need to begin training a newly-shaped model\u03c0\u03b8 in a new environment. Ultimately the goal is for the TrueSkill of agent\u03c0\u03b8 to match that of \u03c0 \u03b8 .\n\nChanging the architecture In the most straightforward situation, the observation space, action space, and environment do not change. In this case, per Equation 1, we can insist that the new policy\u03c0\u03b8 implement exactly the same mathematical function from observations to actions as the old policy.\n\nA simple example here would be adding more units to an internal fully-connected layer of the model. Suppose that before the change, some part of the interior of the model contained an input vector x (dimension d x ), which is transformed to an activation vector y = W 1 x + B 1 (dimension d y ), which is then consumed by another fully-connected layer z = W 2 y + B 2 (dimension d z ). We desire to increase the dimension of of y from d y tod y . This causes the shapes of three parameter arrays to change:\nW 1 (from [d x , d y ] to [d x ,d y ]), B 1 (from [d y ] to [d y ]), and W 2 (from [d y , d z ] to [d y , d z ]).\nIn this case we initialize the new variables in the first layer as:\nW 1 = W 1 R() B 1 = B 1 R() \u0174 2 = W 2 0(6)\nWhere R() indicates a random initialization. The initializations of\u0174 1 andB 1 ensure that the first d y dimensions of activations\u0177 will be the same data as the old activations y, and the remained will be randomized. The randomization ensures that symmetry is broken among the new dimensions. The initialization of\u0174 2 , on the other hand, ensures that the next layer will ignore the new random activations, and the next layer's activations will be the same as in the old model; z = z. The weights which are initialized to zero will move away from zero due to the gradients, if the corresponding new dimensions in y are useful to the downstream function.\n\nInitializing neural network weights to zero is a dangerous business, because it can introduce undesired symmetries between the indices of the output vector. However we found that in most cases of interest, this was easy to avoid by only zero-ing the minimal set of weights. In the example above, the symmetry is broken by the randomization of\u0174 1 andB 1 .\n\nA more advanced version of this surgery was required when we wanted to increase the model capacity dramatically, by increasing the hidden dimension of our LSTM from 2048 units to 4096 units. Because the LSTM state is recurrent, there was no way to achieve the separation present in Equation 6; if we randomize the new weights they will impact performance, but if we set them to zero then the new hidden dimensions will be symmetric and gradient updates will never differentiate them. In practice we set the new weights to random small values -rather than randomize new weight values on the same order of magnitude as the existing weights, we randomized new weights significantly smaller. The scale of randomization was set empirically by choosing the highest scale which did not noticeably decrease the agent's TrueSkill.\n\nChanging the Observation Space Most of our surgeries caused the observation space changes, for example when we added 3 new float observations encoding the time until neutral creeps, bounties, and runes would spawn. In these cases it is impossible to insist that the new policy implement the same function from observation space to action space, as the input domain has changed. However, in some sense the input domain has not changed; the game state is still the same. In reality our system is not only a function \u03c0 : o \u2192 a; before the policy sees the observation arrays, an \"encoder\" function E has turned a game state s into an input array o:\n(Game State Protobuf s) E \u2212 \u2192 (Observation Arrays o) \u03c0 \u2212 \u2192 (Action a)(7)\nBy adding new observations we are enhancing the encoder function E, making it take the same game state and simply output richer arrays for the model to consume. Thus in this case while we cannot ensure that\u03c0\u03b8 = \u03c0 \u03b8 , we can ensure the functions are identical if we go one step back:\n\u2200s\u03c0\u03b8(\u00ca(s)) = \u03c0 \u03b8 (E(s))(8)\nWhen the change is simply additive, this can then be enforced as in the previous section. Suppose the new observations extend a vector x from dimension d x to dimensiond x , and the input vector x is consumed by a weight matrix W via y = W x (and y is then processed by the rest of the model downstream). Then we initialize the new weights\u0174 as:\nW = W 0(9)\nAs before, this ensures that the rest of the model is unchanged, as the output is unchanged (\u0177 = y). The weights which are initialized to zero will move away from zero due to the gradients, if the corresponding observations are found to be useful.\n\nChanging the Environment or Action Space The second broad class of changes are those which change the environment itself, either by making new actions available to the policy (e.g. when we replaced scripted logic for the Buyback action with model-controlled logic) or by simply changing the Dota 2 rules (for example when we moved to Dota 2 version 7.21, or when we added new items). For some of these changes, such as upgrading Dota 2 version, we found simply making the change on the rollout workers to be relatively stable; the old policy played well enough in the new environment that it was able to smoothly adapt.\n\nEven so, whenever possible, we attempted to \"anneal\" in these new features, starting with 0% of rollout games played with the new environment or actions, and slowly ramping up to 100%. This prevents a common problem where a change in one part of the agent's behavior could force unnecessary relearning large portions of the strategy. For example, when we attempted to give the model control of the Buyback action without annealing, the model-based control of the action was (at first) worse than the scripted version had been, causing the agent to adapt its overall strategies to games where allies and enemies alike often misuse this action. This would cause the agent to significantly drop in overall skill; while it would likely eventually recover, it may require \"repeating\" the investment of a large amount of compute. By annealing the new action in gradually, we ensure that the model never loses overall skill due to a sudden change of one part of the environment;\n\nwhen we observe the model losing TrueSkill during the annealing process, we revert and attempt the anneal at a slower rate. This annealing process makes sense even if the environment is becoming fundamentally \"harder\" because our agent's skill is measured through winrates against other models; the opponent also has to play in the new environment.\n\nRemoving Model Parts Requiring exact policy equivalence after the surgery outlaws many types of surgery. For example, most surgeries which remove parameters are not possible in this framework. For this reason our model continued to observe some \"deprecated\" observations, which were simply always set to constants. Further work such as [24] has already begun to explore alternate methods of surgery which avoid this constraint.\n\nSmooth Training Restart The gradient moments stored by the Adam optimizer present a nuisance when restarting training with new parameter shape. To ensure that the moments have enough time to properly adjust, we use a learning rate of 0 for the first several hours of training after surgery. This also ensures that the distribution of rollout games has entered steady state by the time we begin training in earnest.\n\nOne additional nuisance when changing the shape of the model is the entire history of parameters which are stored (in the past opponent manager, see Appendix N), and used as opponents in rollouts. Because the rollout GPUs will be running the newest code, all of these past versions must be updated in the same way as the current version to ensure compatibility. If the surgery operation fails to exactly preserve the policy function, these frozen past agents will forever play worse, reducing the quality of the opponent pool. Therefore it is crucial to ensure agent behavior is unchanged after surgery.\n\nBenefits of Surgery These surgeries primarily permitted us to have a tighter iteration loop for these features. When we added a new game feature which we expect to only matter at high skill, it would simply be impossible to test and iterate on it by training from scratch. Using surgery from the current OpenAI Five, we could have a more feasible process, which allowed us to safely include many minor features and improvements that otherwise would have been impossible to verify, such as adding long-tail items (Bottle, Rapier), minor improvements to the observation space (stock counts, modifiers on nonheroes), and others.\n\n\nC Hyperparameters\n\nThe optimization algorithm has several important hyperparameters that have different settings throughout the training process. Over the course of training of OpenAI Five, these hyperparameters were modified by looking for improvement plateaus. Because of compute limitations which prevented us from testing hyperparameter changes in separate experiments, OpenAI Five's longrunning training process included numerous experimental hyperparameter changes. Some of these worked well and were kept, others were reverted as our understanding developed over the course of the 10-month period. As it is impossible for us to scan over any of these hyperparameters when our experiment is so large, we make no claim that the hyperparams used are optimal.\n\nWhen we ran Rerun we simplified the hyperparameter schedule based on the lessons we had learned. In the end we made changes to only four key hyperparameters: \u2022 Learning Rate\n\n\u2022 Entropy penalty coefficient (see Appendix O)\n\n\u2022 Team Spirit (see Appendix G)\n\n\n\u2022 GAE time horizon (see Equation 3)\n\nThis schedule is far from optimized as it was used in only our second iteration of this large experiment. In future work it could likely be significantly improved.\n\nThere are many other hyperparams that were not changed during the final Rerun experiment. Their values are listed in Table 2. Some of these were changed in the original OpenAI Five out of necessity (e.g. batch size changed many times as more or less compute resources became available, or SampleReuse changed as the relative speeds of different machine pools fluctuated), and others were changed experimentally in the original OpenAI Five run but were ultimately not important as evidenced by Rerun working without those changes (e.g. increasing the time horizon from 360 seconds to 840 seconds).\n\n\nD Evaluating agents' understanding\n\nIt is often difficult to infer the intentions of an RL agent. Some actions are obviously usefulhitting an enemy that is low on health, or freezing them as they're trying to escape -but many other decisions can be less obvious. This is tightly coupled with questions on intentionality: does our agent plan on attacking the tower, or doe it opportunistically deal the most damage possible in next few seconds?\n\nTo assess this, we attempt to predict future state of various features of the game from agent's LSTM state:\n\n\u2022 Win probability: Binary label of either 0 or 1 at the end of the game. b Fraction of games played against past opponents (as opposed to self-play). c We normalize rewards using a running estimate of the standard deviation, and the value loss weight is applied post-normalization. d See Appendix N. e See Figure 8 for definitions of the various timescale subdivisions of a rollout episode. For those which were modified during training, x \u2192 y indicates a smooth monotonic transition (usually a linear change over one to three days), and x \u2194 y indicates a less controlled variation due to either ongoing experimentation or distributed systems fluctuations. The \"Baseline\" indicates the default values for all the experiments in Appendix M (each individual experiment used these hyperparameters other than any it explicitly studied, for example in subsection M.1 the batch size was changed from the baseline in each training run, but all the other hyperparameters were from this table). \u2022 Net worth rank: Which rank among the team (1)(2)(3)(4)(5) in terms of total resources collected will this hero be at the end of the game? This prediction is used by scripted item-buying logic to decide which agents buy items shared by the team such as wards. In human play (which the scripted logic is based on) this task is traditionally performed by heroes who will have the lowest net worth at the end of the game.\n\n\u2022 Team objectives / enemy buildings: whether this hero will help the team destroy a given enemy building in the near future.\n\nWe added small networks of fully-connected layers that transform LSTM output into predictions of these values. For historical reasons, win probability passes gradients to the main LSTM and rest of the agent with a very small weight; the other auxiliary predictions use Tensorflow's stop_gradient method to train on their own.\n\nOne difficulty in training these predictors is that we train our agent on 30-second segments of the game (see Figure 8), and any given 30-second snippet may not contain the ground truth (e.g. for win probability and networth position, we only have ground truth on the very last segment of the game). We address this by training these heads in a similar fashion to how we train value functions. If a segment contains the ground truth label, we use the ground truth label for all time steps in that segment; if not, we use the model's prediction at the end of the segment as the label. For win probability, for example, more precisely the label y for a segment from time t 1 to t 2 is given by:\ny = \uf8f1 \uf8f2 \uf8f3 1\nlast segment of the game, we win 0 last segment of the game, we los\u00ea y(t 2 ) else (10) Where\u0177(t 2 ) is the model's predicted win probability at the end of the segment. Although this requires information to travel backward through the game, we find it trains these heads to a degree of calibration and accuracy.\n\nFor the team objectives, we are additionally interested in whether the event will happen soon. For these we apply an additional discount factor with horizon of 2 minutes. This means that the enemy building predictions are not calibrated probabilities, but rather probabilities discounted by the expected time to the event.\n\n\nD.1 Understanding OpenAI Five Finals\n\nWe used these supervised predictions to look closer at the game 1 from OpenAI Five Finals.\n\nIn Figure 9 we explore the progression of win probability predictions over the course of training Rerun, illustrating the evolution of understanding. Version 5,000 of the agent (early in the training process and low performance) already has a sense of what situations in the game may lead to eventual win. The prediction continues to get better and better as training proceeds. This matches human performance at this task, where even spectators with relatively little gameplay experience can estimate who is ahead based on simple heuristics, but with more gameplay practice human experts can estimate the winner more and more accurately.\n\nOn the winrate graph two dramatic game events are marked, at roughly the 5 and 18 minute point. One of them illustrates OpenAI Five's win probability drop, due to an unexpected loss of 3 heroes in close succession. The other shows how the game turns from good to great as a key enemy hero is killed.  Predictions by different heroes differ as they specifically predict whether they will participate in bringing given building down. Predictions should not be read as calibrated probabilities, because they are trained with a discount factor. See Figure 11a and Figure 11b for descriptions of the events corresponding to two of these buildings.\n\nWe also looked at heroes participation in destroying objectives. In Figure 10 we can see different heroes' predictions for each of the objectives in game 1 of OpenAI Five Finals. In several cases all heroes predict they will participate in the attack (and they do). In few cases one or two heroes are left out, and indeed by watching the game replay we see that those heroes are busy in the different part of the map during that time. In Figure 11 we illustrate these predictions with more details for two of the events.\n\n\nD.2 Hero selection\n\nIn the normal game of Dota 2, two teams at the beginning of the game go through the process of selecting heroes. This is a very important step for future strategy, as heroes have different skill sets and special abilities. OpenAI Five, however, is trained purely on learning to play the best game of Dota 2 possible given randomly selected heroes.\n\nAlthough we could likely train a separate drafting agent to play the draft phase, we do not need to; instead we can use the win probability predictor. Because the main varying observation that agents see at the start of the game is which heroes are on each team, the win probability at the start of the game estimates the strength of a given matchup. Because there are only 4,900,896 combinations of two 5-hero teams from the pool of 17 heroes, we can precompute agent's predicted  Figure 10) and plan perhaps to kill it (their predictions go up). But they are chased away by the incoming dire (human) heroes, and their plan changes (the prediction that they will participate in the tower kill falls back to zero). Radiant creeps kill the tower half a minute later. In 11b, all radiant heroes attack mid tower 2 (center in Figure 10). However just before it falls, few dire heroes show up trying to save it, and most radiant heroes end up chasing them a fair distance away from the building. The prediction for those heroes to participate in the tower kill drops accordingly. Figure 12: When drafting heroes, our drafting program would pick the one that maximizes worstcase scenario of opponent hero selection (minimax algorithm). In this example (from OpenAI Finals game 1), OpenAI Five deems the humans' first pick suboptimal, immediately updating its expected win probability of 52.8% to 65.1%. The drafter then makes two choices (which it believes to be optimal of course). The humans' second and third choices further decreases their chances of victory (according to the agent), indicated by the green win probability. However, for the human team's last two choices, OpenAI Five agrees they were optimal, as can be seen by the win probability remaining constant (even though choice 4, Riki, is a character very differently played by humans and by OpenAI Five).\n\nwin probability from the first few frames of every lineup. Given these precomputed win probabilities, we apply a dynamic programming algorithm to draft the best hero available on each turn. Results of this approach in a web-based drafting program that we have built can be seen on Figure 12.\n\nIn addition to building a hero selection tool, we also learned about our agent's preferences from this exercise. In many ways OpenAI Five's preferences match human player's preferences such as placing a high value (within this pool) on the hero Sniper. In other ways it does not agree with typical human knowledge, for example it places low value on Earthshaker. Our agent had trouble dealing with geometry of this hero's \"Fissure\" skill, making this hero worse than others in training rollouts.\n\nAnother interesting tidbit is that at the very start of the draft, before any heroes are picked, OpenAI Five believes that the Radiant team has a 54% win chance (if picking first in the draft) or 53% (if picking second). Our agent's higher estimate for the Radiant side over the Dire agrees with conventional wisdom within the Dota 2 community. Of course, this likely depends on the set of heroes available.\n\n\nE Observation Space\n\nAt each time step one of our heroes observes \u223c 16, 000 inputs about the game state (mostly real numbers with some integer categorical data as well). See Figure 14 for a schematic outline of our observation space and Table 4 for a full listing of the observations.\n\nInstead of using the pixels on the screen, we approximate the information available to a human player in a set of data arrays. This approximation is imperfect; there are small pieces of information which humans can gain access to which we have not encoded in the observations. On the flip side, f This observation appears twice, and serves as an example of the difficulties of surgery. Although this is a categorical input, we began by treating it as a float input to save on engineering work (this observation is unlikely to be very important). Later the time came to upgrade it to a properly embedded categorical input, but our surgery tools do not support removing existing observations. Hence we added the new observation, but were forced to leave the deprecated observation as well.  Figure 13: Dota 2's human \"Observation Space\"\n\nwhile we were careful to ensure that all the information available to the model is also available to a human, the model does get to see all the information available simultaneously every time step, whereas a human needs to click into various menus and options to get that data. Although these discrepancies are a limitation, we do not believe they meaningfully detract from our ability to benchmark against human players. Humans observe the game via a rendered screen, depicted in Figure 13. OpenAI Five uses a more semantic observation space than this for two reasons: First, because our goal is to study strategic planning and gameplay rather than focus on visual processing. Second, it is infeasible for us to render each frame to pixels in all training games; this would multiply the computation resources required for the project manyfold.\n\nAll float observations (including booleans which are treated as floats that happen to take values 0 or 1) are normalized before feeding into the neural network. For each observation, we keep a running mean and standard deviation of all data ever observed; at each timestep we subtract the mean and divide by the st dev, clipping the final result to be within (-5, 5).\n\n\nF Action Space\n\nDota 2 is usually controlled using a mouse and keyboard. The majority of the actions involve a high-level command (attack, use a certain spell, or activate a certain item), along with a target (which might be an enemy unit for an attack, or a spot on the map for a movement). For that reason we represent the action our agent can choose at each timestep as a single primary action (a) Delay: An integer from 0 to 3 indicating which frame during the next frameskip to take the action on (see Appendix L). If 0, the action will be taken immediately when the game engine processes this time step; if 3, the action will be taken on the last game frame before the next policy observation. This parameter is never ignored. (c) Offset: A 2D (X, Y ) coordinate indicating a spatial offset, used for abilities which target a location on the map. The offset is interpreted relative to the caster or the unit selected by the Unit Selection parameter, depending on the ability. Both X and Y are discrete integer outputs ranging from -4 to +4 inclusive, producing a grid of 81 possible coordinate pairs. The number of primary actions available varies from time step to time step, averaging 8.1 in the games against OG. The primary actions available at a given time include universal actions like noop, move, attack, and others; use or activate one of the hero's spells; use or activate one of the hero's items; situational actions such as Buyback (if dead), Shrine (if near a shrine), or Purchase (if near a shop); and more. For many of the actions we wrote simple action filters, which determine whether the action is available; these check if there is a valid target nearby, if the ability/item is on cooldown, etc. At each timestep we restrict the set of available actions using these filters and present the final choices to the model.\n\nIn addition to a primary action, the model chooses action parameters. At each timestep the model outputs a value for each of them; depending on the primary action, some of them are read and others ignored (when optimizing, we mask out the ignored ones since their gradients would be pure noise). There are 3 parameter outputs, Delay (4 dim), unit selection (189 dim), and offset (81 dim), described in Figure 15.\n\nAll together this produces a combined factorized action space size of up to 30 \u00d7 4 \u00d7 189 \u00d7 81 = 1, 837, 080 dimensions (30 being the maximum number of primary actions we support). This number ignores the fact that the number of primary actions is usually much lower; some parameters are masked depending on the primary action; and some parameter combinations are invalid and those actions are treated as no-ops.\n\nTo get a better picture, we looked at actual data from the two games played against Team OG, and simply counted number of available actions at each step. The average number of available  Unit Selection and Offset are actually implemented within the model as several different, mutually exclusive parameters depending on the primary action. For Unit Selection, we found that using a single output head caused that head to learn very well to target tactical spells and abilities. One ability called \"teleport,\" however, is significantly different from all the others -rather than being used in a tactical fight, it is used to strategically reposition units across the map. Because the action is much more rare, the learning signal for targeting this ability would be drowned out if we used a single model output head for both. For this reason the model outputs a normal Unit Selection parameter and a separate Teleport Selection parameter, and one or the other is used depending on the primary action. Similarly, the Offset parameter is split into \"Regular Offset,\" \"Caster Offset\" (for actions which only make sense offset from the caster), and \"Ward Placement Offset\" (for the rare action of placing observer wards).\n\nWe categorize all primary actions into 6 \"Action target types\" which determines which parameters the action uses, listed in Table 5.\n\n\nF.1 Scripted Actions\n\nNot all actions that a human takes in a game of Dota 2 are controlled by our RL agent. Some of the actions are scripted, meaning that we have written a rudimentary rules-based system to handle these decisions. Most of these are for historical reasons -at the start of the project we gave the model control over a small set of the actions, and we gradually expanded it over time. Each additional action that we remove from the scripted logic and hand to the model's control gives the RL system a higher potential skill cap, but comes with an cost measured in engineering effort to set it up and risks associated with learning and exploration. Indeed even when adding these new actions gradually and systematically, we occasionally encountered instabilities; for example the agent might quickly learn never to take a new action (and thus fail to explore the small fraction of circumstances where that action helps), and thus moreover fail to learn (or unlearn) the dependent parts of the gameplay which require competent use of the new action.\n\nIn the end there were still several systems that we had not yet removed from the scripted logic by the time the agent reached superhuman performance. While we believe the agent could ultimately perform better if these actions were not scripted, we saw no reason to do remove the scripting because superhuman performance had already been achieved. The full set of remaining scripted actions is:\n\n1. Ability Builds: Each hero has four spell abilities. Over the course of the game, a player can choose which of these to \"level up,\" making that particular skill more powerful. For these, in evaluation games we follow a fixed schedule (improve ability X at level 1, then Y at level 2, then Z at level 3, etc). In training, we randomize around this fixed script somewhat to ensure the model is robust to the opponent choosing a different schedule.\n\n2. Item Purchasing: As a hero gains gold, they can purchase items. We divide items into consumables -items which are consumed for a one-time benefit such as healing -and everything else. For consumables, we use a simple logic which ensures that the agent always has a certain set of consumables; when the agent uses one up, we then purchase a new one. After a certain time in the game, we stop purchasing consumables. For the non-consumables we use a system similar to the ability builds -we follow a fixed schedule (first build X, then Y, then Z, etc). Again at training time we randomly perturb these builds to ensure robustness to opponents using different items. 11 3. Item Swap: Each player can choose 6 of the items they hold to keep in their \"inventory\" where they are actively usable, leaving up to 3 inactive items in their \"backpack.\" Instead of letting the model control this, we use a heuristic which approximately keeps the most valuable items in the inventory.\n\n4. Courier Control: Each side has a single \"Courier\" unit which cannot fight but can carry items from the shop to the player which purchased them. We use a state-machine based logic to control this character.\n\n\nG Reward Weights\n\nOur agent's ultimate goal is to win the game. In order to simplify the credit assignment problem (the task of figuring out which of the many actions the agent took during the game led to the final positive or negative reward), we use a more detailed reward function. Our shaped reward is modeled loosely after potential-based shaping functions [58], though the guarantees therein do not apply here. We give the agent reward (or penalty) for a set of actions which humans playing the game generally agree to be good (gaining resources, killing enemies, etc). All the results that we reward can be found in Table 6, with the amount of the reward. Some are given to every hero on the team (\"Team\") and some just to the hero who took the action \"Solo.\" Note that this means that when team spirit is 1.0, the total amount of reward is five times higher for \"Team\" rewards than \"Solo\" rewards.\n\nIn addition to the set of actions rewarded and their weights, our reward function contains 3 other pieces: Per second in wrong lane. * For buildings, two-thirds of the reward is earned linearly as the building loses health, and one-third is earned as a lump sum when it dies. \u2020 See item O.2. \u2021 Hero's health is quartically interpolated between 0 (dead) and 1 (full health); health at fraction x of full health is worth x + 1 \u2212 (1 \u2212 x) 4 /2. This function was not tuned; it was set once and then untouched for the duration of the project. \u2022 Game time weighting: Each player's \"power\" increases dramatically over the course of a game of Dota 2. A character who struggled to kill a single weak creep early in the game can often kill many at once with a single stroke by the end of the game. This means that the end of the game simply produces more rewards in total (positive or negative). If we do not account for this, the learning procedure focuses entirely on the later stages of the game and ignores the earlier stages because they have less total reward magnitude. We use a simple renormalization to deal with this, multiplying all rewards other than the win/loss reward by a factor which decays exponentially over the course of the game. Each reward \u03c1 i earned a time T since the game began is scaled:\n\u03c1 i \u2190 \u03c1 i \u00d7 0.6 (T /10 mins)(11)\n\u2022 Team Spirit: Because we have multiple agents on one team, we have an additional dimension to the credit assignment problem, where the agents need learn which of the five agent's behavior cause some positive outcome. The partial rewards defined in Table 6 are an attempt to make the credit assignment easier, but they may backfire and in fact add more variance if an agent receives reward when a different agent takes a good action. To attempt dealing with this, we have introduced team spirit. It measures how much agents on the team share in the spoils of their teammates. If each hero earns raw individual reward \u03c1 i , then we compute the hero's final reward r i as follows:\nr i = (1 \u2212 \u03c4 )\u03c1 i + \u03c4 \u03c1(12)\nwith scalar \u03c1 being equal to mean of \u03c1. If team spirit is 0, then it's every hero for themselves; each hero only receives reward for their own actions r i = \u03c1 i . If team spirit is 1, then every reward is split equally among all five heroes; r i = \u03c1. For a team spirit \u03c4 in between, team spirit-adjusted rewards are linearly interpolated between the two.\n\nUltimately we care about optimizing for team spirit \u03c4 = 1; we want the actions to be chosen to optimize the success of the entire team. However we find that lower team spirit reduces gradient variance in early training, ensuring that agents receive clearer reward for advancing their mechanical and tactical ability to participate in fights individually. See Appendix O for an ablation of this method.\n\nWe ran a small-scale ablation with partial reward weights disabled (see Figure 16). Surprisingly, the model learned to play well enough to beat a hand-coded scripted agent consistently, though with a large penalty to sample efficiency relative to the shaped reward baseline. From watching these games, it appears that this policy does not play as effectively at the beginning of the game, but has learned to coordinate fights nearer to the end of the game. Investigating the tradeoffs and benefits of sparse rewards is an interesting direction for future work.\n\n\nH Neural Network Architecture\n\nA simplified diagram of the joint policy and value network is shown in the main text in Figure 1. The combined policy + value network uses 158,502,815 parameters (in the final version).\n\nThe policy network is designed to receive observations from our bot-API observation space, and interact with the game using a rich factorized action space. These structured observation and action spaces heavily inform the neural network architecture used. We use five replica neural networks, (a) Flattening the observation space: First we process the complicated observation space into a single vector. The observation space has a tree structure; the full game state has various attributes such as global continuous data and a set of allied heroes. Each allied hero in turn has a set of abilities, a set of modifiers, etc. We process each node in the tree according to its data type. For example for spatial data, we concatenate the data within each cell and then apply a 2 layer conv net. For unordered sets, a common feature of our observations, we use a \"Process Set\" module. Weights in the Process Set module for processing abilities/items/modifiers are shared across allied and enemy heroes; weights for processing modifiers are shared across allied/enemy/neutral nonheroes. In addition to the main Game State observation, we extract the the Unit Embeddings from the \"embedding output\" of the units' process sets, for use in the output (see Figure 18).\n\n(b) Preparing for LSTM: In order to tell each LSTM which of the team's heroes it controls, we append the controlled hero's Unit Embedding from the Unit Embeddings output of Figure 17a to the Game State vector. Almost all of the inputs are the same for each of the five replica LSTMs (the only differences are the nearby map, previous action, and a very small fraction of the observations for each unit). In order to allow each replica to respond to the non-identical inputs of other replicas if needed, we add a \"cross-hero pool\" operation, in which we maxpool the first 25% of the vector across the five replica networks. each responsible for the observations and actions of one of the heroes in the team. At a high level, this network consists of three parts: first the observations are processed and pooled into a single vector summarizing the state (see Figure 17), then that is processed by a single-layer large LSTM, then the outputs of that LSTM are projected to produce outputs using linear projections (see Figure 18). To provide the full details, we should clarify that Figure 1 is a slight over-simplification in three ways:\n\n1. In practice the Observation Processing portion of the model is also cloned 5 times for the five different heroes. The weights are identical and the observations are nearly identical -but there are a handful of derived features which are different for each replica (such as \"distance to me\" for each unit; see Table 4 for the list of observations that vary). Thus the five replicas produce nearly identical, but perhaps not entirely identical, LSTM inputs. These non-identical features form a small portion of the observation space, and were not ablated; it is possible that they are not needed at all.\n\n2. The \"Flattened Observation\" and \"Hero Embedding\" are processed before being sent into the LSTM (see Figure 17b) by a fully-connected layer and a \"cross-hero pool\" operation, to ensure that the non-identical observations can be used by other members of the team if needed.\n\n3. The \"Unit Embeddings\" from the observation processing are carried along beside the LSTM, and used by the action heads to choose a unit to target (see Figure 18).\n\nIn addition to the action logits, the value function is computed as another linear projection of the LSTM state. Thus our value function and action policy share a network and share gradients.\n\n\nI Human Games\n\nSee Table 7 for a listing of the games OpenAI Five played against high-profile teams.\n\n\nJ TrueSkill: Evaluating a Dota 2 Agent Automatically\n\nWe use the TrueSkill [27] rating system to evaluate our agents.\n\nWe first establish a pool of many reference agents of known skill. We evaluate the reference agents' TrueSkill by playing many games between the the various reference agents, and using the outcome of the games to compute a TrueSkill for each agent. Our TrueSkill environment use the parameters \u03c3 = 25/3, \u03b2 = \u03c3/2, \u03c4 = 0.0, draw_probability=0.02. Reference agents' \u00b5 are aligned so that an agent playing randomly has \u00b5 = 0. A hand-crafted scripted agent which we wrote, which can defeat beginners but not amateur players, has TrueSkill around 105.\n\nDuring our experiments we continually added new reference agents as our agent \"outgrew\" the existing ones. For all results in this work, however, use a single reference agent pool containing mostly agents from OpenAI Five's training history along with some other smaller experiments at the lower end. The 83 reference agents range in TrueSkill from 0 (random play) to 254 (the version that beat the world champions).\n\nTo evaluate a training run during training, a dedicated set of computers continually download the latest agent parameters and plays games between the latest trained agent and the reference agents. We attempt to only play games against reference agents that are nearby in skill in order to gain maximally useful information; we avoid playing agents more than 10 TrueSkill points away (corresponding to a winrate less than 15% or more than 85%). When a game finishes, we use the TrueSkill algorithm to update the test agent's TrueSkill, but treat the reference agent's TrueSkill as a constant. After 750 games have been reported, we log that version's TrueSkill and move on to the new current version. New agents are initialized with \u00b5 equal to the final \u00b5 of the previous agent. This system gives us updates approximately once every two hours during running experiments.\n\nOne difficulty in using TrueSkill across a long training experiment was maintaining consistent metrics with a changing environment. Two agents that were trained on different game versions must ultimately play on a single version of the game, which will result in an inherent advantage for the agent that trained on it. Older agents had their code upgraded in order to always be compatible with the newest version, but this still leads to metric inflation for newer agents who got to train on the same code they are evaluated on. This included any updates to the hero pool (adding new heroes that old agents didn't train with), game client updates or balancing changes, and adding any new actions (using a particular consumable or item differently).\n\n\nK Dota 2 Gym Environment\n\nK.1 Data flow between the training environment and Dota 2 Dota 2 includes a scripting API designed for building bots. The provided API is exposed through Lua and has methods for querying the visible state of the game as well as submitting actions for bots to take. Parts of the map that are out of sight are considered to be in the fog of war and cannot be queried through the scripting API, which prevents us from accidentally \"cheating\" by observing anything a human player would not be able to see (although see Appendix Q).   Figure 19: Reaction Time: OpenAI Five observes four frames bundled together, so any surprising new information will become available at a random frame in the red region. The model then processes the observation in parallel while the game engine runs forward four more frames. The soonest it can submit an action based on the red observations is marked in yellow. This is between 5 and 8 frames (167-267ms) after the surprising event.\n\nWe designed our Dota 2 environment to behave like a standard OpenAI Gym environment[59]. This standard respects an API contract where a step method takes action parameters and returns an observation from the next state of the environment. To send actions to Dota 2, we implemented a helper process in Go that we load into Dota 2 through an attached debugger that exposes a gRPC server. This gRPC server implements methods to configure a game and perform an environment step. By running the game with an embedded server, we are able to communicate with it over the network from any remote process.\n\nWhen the step method is called in the gRPC server, it gets dispatched to the Lua code and then the method blocks until an observation arrives back from Lua to be returned to the caller. In parallel, the Dota 2 engine runs our Lua code on every step, sending the current game state observation 12 to the gRPC server and waiting for it to return the current action. The game blocks until an action is available. These two parallel processes end up meeting in the middle, exchanging actions from gRPC in return for observations from Lua. Go was chosen to make this architecture easy to implement through its channels feature.\n\nPutting the game environment behind a gRPC server allowed us to package the game into a Docker image and easily run many isolated game instances per machine. It also allowed us to easily setup, reset, and use the environment from anywhere where Docker is running. This design choice significantly improved researcher productivity when iterating on and debugging this system.\n\n\nL Reaction time\n\nThe Dota 2 game engine runs at 30 steps per second so in theory a bot could submit an action every 33ms. Both to speed up our game execution and in order to bring reactions of our model closer to the human scale we downsample to every 4th frame, which we call frameskip. This yields an effective observation and action rate of 7.5 frames per second. To allow the model to take precisely timed actions, the action space includes a \"delay\" which indicates which frame during the frameskip the model wants this action to evaluate on. Thus the model can still take actions at a particular frame if so desired, although in practice we found that the model did not learn to do this and simply taking the action at the start of the frameskip was better.\n\nMoreover, we reduce our computational requirements by allowing the game and the machine learning model to run concurrently by asynchronously issuing actions with an action offset. When the model receives an observation at time T , rather than making the game engine wait for the model to produce an action at time T , we let the game engine carry on running until it produces an observation at time T + 1. The game engine then sends the observation at time T + 1 to the model, and by this time the model has produced its action choice based on the observation at time T . In this way the action which the model takes at time T + 1 is based upon the observation at time T . In exchange for this penalty in available \"reaction time,\" we are able to utilize our compute resources much more efficiently by preventing the two major computations from blocking one another (see Figure 19).\n\nTaken together, these effects mean that the agent can react to new information with a reaction time randomly distributed between 5 and 8 frames (167ms to 267ms), depending on when during the frameskip the new information happens to occur. For comparison, human reaction time has been measured at 250ms in controlled experimental settings [26]. This is likely an underestimate of reaction time during a Dota game.\n\n\nM Scale and Data Quality Ablation Details\n\nAs shown in Figure 5 of the main text, we studied several key ingredients of RL at this scale, and learned important lessons which we conjecture should generalize beyond this environment. In this section we explain the details of these experiments.\n\nTraining runs the size of OpenAI Five are expensive; running a scan of 4 different variants would be prohibitively expensive. For this reason we use the normal Dota 2 environment, simply using a batch size 8x smaller than Rerun (which itself was 2-3 times smaller than OpenAI Five). See Figure 20 for an estimate of the variation in these training runs.\n\nThroughout the following sections we scan over various parameters of the experimental setup and monitor the results in terms of TrueSkill (see Appendix J) and speedup (see Equation 2).\n\nOur the uncertainty on speedup comes from uncertainty in both the numerator and the denominator. Although we have some understanding in the variance in the number of iterations for a baseline to reach each TrueSkill (see Figure 20), we do not have the luxury of multiple runs of every experiment. Instead, we use as proxy for the uncertainty on the number of iterations to reach TrueSkill T , the number of iterations to reach to reach T \u00b1\u2206T where \u2206T is the variance in TrueSkill across the variations in Figure 20, approximately 2 TrueSkill points. We combine the numerator and denominator uncertainty in quadrature to attain an overall uncertainty for the speedup.\n\nIn each experiment the baseline uses hyperparameters given in Appendix C, except as noted. \n\n\nM.1 Batch Size\n\nTraining using small mini-batches is a generally accepted trade-off between convergence time and number of optimization steps. However, recent literature on large-scale supervised learning of image classifiers [44-46] explored much larger batch sizes and showed that strong scaling was possible by carefully tuning learning rate and initialization of the neural network. This renewed interest in reducing convergence-time and treating batch-size as a key design parameter also motivated the work of [28], where an analytical tool is derived to estimate a training-time optimal batch size on per task basis by studying the \"noise scale\" of the gradients. While existing literature on large-scale training of neural networks had focused on supervised learning, as far as we know using large batch sizes for reinforcement learning was novel when we began the Dota 2 project. These observations were later shown to be consistent with the analytical tools derived in [28]. In this section we demonstrate how large batch-sizes affect optimization time.\n\nBecause we average gradients across the pool of optimizer machines, the effective total batch size is given by the product of the number of GPU optimizers with the batch size on each optimizer. We always use the maximum batch size on each optimizer which will fit within the GPU's memory constraints (120 for our setup). Thus in order to change the overall batch size we increase the number of optimizer GPUs. We increase the size of the other machine pools in the experiment (rollout CPU workers, forward pass GPUs, etc), such that the larger batch size experiment is truly optimizing over more data, not simply reusing the same data more. This means that doubling the batch size causes the experiment to use twice as much computing power in almost all respects. Because we do not have the resources to separately optimize these hyperparameters at each individual batch size, we keep all other hyperparameters fixed to those listed under \"baseline\" in Table 2.\n\nResults can be seen in Figure 5a, with discussion in the main text.\n\n\nM.2 Sample Quality -Staleness\n\nIn an ideal world, each piece of data in the optimizer would be perfectly on-policy (to obtain unbiased gradients), would be used exactly once and then thrown out (to avoid overfitting), would be from a completely different episode than every other piece of data (to eliminate correlations), and more. Because of our enormous batch size and small learning rate, we hypothesized that loosening the above constraints would not be a large price to pay in exchange for the benefits of asynchronous processing. However, we actually learned that issues like this surrounding data quality can be quite significant. In this and next section we will focus on two of these issues, which we call staleness and sample reuse. Early on in the development of our agent we would play the whole game of Dota 2 using single set of parameters, then send this huge package of sample data to optimizers for training. One of the negative effects of this approach was that this would render data stale; the policy parameters which played the start of the game would be an hour old or more, making the gradients estimated from them incorrect. Therefore we have switched to accumulating small amount of training data; sending it over to optimizers and updating agent parameters; then continuing with the same game. In order to generate rollouts with a certain version of the parameters, a long round-trip has to happen (see Figure 2). This new set of parameters is published to the controller, then independently pulled by forward pass machines, which only then will start using this version of parameters to perform forward-passes of our agent. Then some amount of gameplay must be rolled forward and after that the data is finally sent to the optimizers. In the meanwhile, the optimizers have been running on previously-collected data and advanced by some number of new gradient descent steps. In our setup where rollouts send about 30 seconds of gameplay in each chunk, this loop takes 1-2 minutes. Because our learning rate is small, and this is only a few minutes on the scale of a multiweek learning endeavor, one might expect this to be a minor concern -but to the contrary, we observe that this it can be a crucial detail.\n\nIn this study we artificially introducing additional delay to see the effect. This is implemented on the rollout workers; instead of sending their data immediately back to the optimizers, they now put it in a queue, and pop data off the end of it to send to the optimizers. Thus the length of the queue determines the amount of artificial staleness introduced. See Figure 23; we observe the desired increase in measured staleness with the length of the queue.\n\nThe results can be found in the main text in Figure 5b, and are reproduced in Figure 22. Staleness negatively affects speed of training, and the drop can be quite severe when the staleness is larger than a few versions. For this reason we attempt to keep staleness as low as possible in our experiments.  Figure 23: Adding a queue that buffers rollout data on the way to optimizers increases measured staleness in a predictable manner. Error bars indicate the standard deviation of measured staleness as it varied over the course of training due to distributed systems fluctuations.\n\n\nM.3 Sample Quality -Sampling and Sample Reuse\n\nOur asynchronous training system reuses samples in multiple optimization steps. Each optimizer's experience buffer is constantly asynchronously collecting data from rollout machines. At each optimization step, a batch of data is sampled from this buffer. The buffer is configured to hold 4096 samples. Our optimizers compute the average sample reuse as the ratio between data arrival and consumption rates:\n\nSample Reuse \u2261 (samples per batch) \u00d7 (batches per second) (experience buffer intake samples per second) (13) Sample reuse is a function of the round trip time between rollout machines and optimizers, the ratio of rollout machines to optimizers, and other factors, and thus we only approximately hit target values but do not set them exactly. We measure the effect of sample reuse by varying the rate of incoming samples to the optimizers. In practice, the rate of data production from each rollout worker stays relatively stable, so we vary this rate by changing the number of rollout CPU workers and forward pass GPUs while keeping the number of optimizers and everything else fixed.\n\nOur baseline experiment is tuned to have a sample reuse of approximately 1. To measure the effect of sample reuse we reduced the number of rollouts by 2, 4, and 8x to induce higher sample reuse. Additionally we also doubled the number of rollouts for one experiment to investigate the regime where sample reuse is lower than 1. These adjustments yielded sample reuse measurements between 0.57 and 6.3 (see Figure 25). It is important to highlight that adjusting the number of rollouts directly affects the number of simultaneous games being played, which affects the diversity of games that are used for training.\n\nThe results can be found in the main text in Figure 5c, and are reproduced in Figure 24. We found that increasing sample reuse causes a significant decrease in performance. As long as the optimizers are reusing data, adding additional rollout workers appears to be a relatively cheap way to accelerate training. CPUs are often easier and cheaper to scale up than GPUs and this can be a significant performance boost in some setups. Increasing sample reuse causes significant slowdowns. In fact, the run with 1/8th as many rollout workers (sample reuse around 6.3), seems to have converged to less than 75 TrueSkill.  Plots of TrueSkill over the course of training for a \"baseline\" experiment together with a \"synchronous\" run using only on-policy data (staleness = 0) and restricting each sample to be used at most once (max sample reuse = 1). On the left, the x-axis is wall time. On the right, the x-axis is iterations. Asynchronous training is nearly 3x faster at achieving TrueSkill 150 when measuring by wall time, even though the two runs perform similarly as a function of the number of iterations.\n\nThe fact that our algorithms benefit from extremely low sample reuse underlines how sample inefficient they are. Ideally, our training methods could take a small amount of experience and use that to learn a great deal, but currently we cannot even usefully optimize over that experience for more than a couple of gradient steps. Learning to use rollout data more efficiently is one of the major areas for future work in RL research.\n\nThis investigation suggests that sample reuse below one can be beneficial. This experiment out performed all others after around iteration 5,000, including the experiment with sample reuse 1. The improvement over sample reuse 1 is minor compared to the gaps between more severe sample reuses, but it is significant. Intuitively one might expect that using each sample exactly once would be the most optimal, as no data would get wasted and no data would get used twice; collecting more data and then not optimizing over it would not help.\n\nHowever, the sample reuse is measured as an average rate of data production to consumption (Equation 13). Because the optimizers sample each batch randomly from the buffer, sample reuse 1 just means that on average each sample is used once, but in fact many samples are used twice, and some not used at all. For this reason producing twice as much data as we can consume still reduces the number of samples which get selected multiple times. Of course the magnitude of improvement is relatively small and the cost (doubling the number of rollout workers and forward pass GPUs) is significant. Doubling the number of rollout workers may also decrease correlation across samples; using two adjacent samples from the same game (when very little has changed between them) may have similar drawbacks to using the same sample twice.\n\n\nN Self-play\n\nOpenAI Five is trained without any human gameplay data through a self-improvement process named self-play. This technique was successfully used in prior work to obtain super human performance in a variety of multiplayer games including Backgammon, Go, Chess, Hex, StarCraft 2, Poker [1,4,7,[37][38][39]. In self-play training, we continually pit the current best version of an agent against itself or older versions, and optimize for new strategies that can defeat these past and present opponents.\n\nIn training OpenAI Five 80% of the games are played against the latest set of parameters, and 20% play against past versions. We play occasionally against past parameter versions in order to obtain more robust strategies and avoid strategy collapse in which the agent forgets how to play against a wide variety of opponents because it only requires a narrow set of strategies to defeat its immediate past version (see Balduzzi et al.\n\n[60] for a discussion of cyclic strategies in games with simultaneous-turns and/or imperfect information).\n\nOpenAI Five uses a dynamic sampling system in which each past opponent i = 1..N is given a quality score q i . Opponent agents are sampled according to a softmax distribution; agent i is chosen with probability p i proportional to e q i . Every 10 iterations we add the current agent to past opponent pool and initialize its quality score to the maximum of the existing qualities. After each rollout game is completed, if the past opponent defeats the current agent, no update is applied. If the current agent defeats a past opponent, an update is applied proportional to a learning rate constant \u03b7 (which we fix at 0.01):\nq i \u2190 q i \u2212 \u03b7 N p i(14)\nIn Figure 27 we see the opponent distribution at several points in early training. The spread of the distribution gives a good picture of how quickly the agent is improving: when the agent is improving rapidly, then older opponents are worthless to play against and have very low scores; when progress is slower the agent plays against a wide variety of past opponents.\n\n\nO Exploration\n\nExploration is a well-known and well-researched problem in the context of reinforcement learning. We encourage exploration in two different ways: by shaping the loss (entropy and team spirit) and by randomizing the training environment.\n\n\nO.1 Loss function\n\nPer [14], we use entropy bonus to encourage exploration. This bonus is added to the PPO loss function in the form of cS[\u03c0 \u03b8 ](s t ), where c is a hyperparameter referred to as entropy coefficient. In initial stages of training a long-running experiment like OpenAI Five or Rerun we set it to an initial value and lower it during training. Similarly to [14], [16], or [61], we find that using entropy bonus prevents premature convergence to suboptimal policy. In Figure 28, we see that entropy bonus of 0.01 (our default) performs best. We also find that setting it to 0 in early training, while not optimal, does not completely prevent learning.\n\nAs discussed in Appendix G, we introduced a hyperparameter team spirit to control whether agents optimize for their individual reward or the shared reward of the team. Early training and speedup curves for team spirit can be seen in Figure 29. We see evidence that early in training, As the performance of the agent improves, the distribution over past versions changes to find stronger contenders. The slope in the distribution reflects how fast the current agent is outpacing previous versions: a slow falloff indicates that the agent is still challenged by far older versions, while a steep falloff is evidence that counter-strategies have been found that eliminate past agents. In later versions the opponent distribution includes many more past versions, suggesting that after a warmup period, skill progression slows.  lower team spirits do better. At the very start team spirit 0 is the best, quickly ovdertaken by team spirit 0.3 and 0.5. We hypothesize that later in training team spirit 1.0 will be best, as it is optimizing the actual reward signal of interest.\n\n\nO.2 Environment Randomization\n\nWe further encouraged exploration through randomization of the environment, with three simultaneous goals:\n\n1. If a long and very specific series of actions is necessary to be taken by the agent in order to randomly stumble on a reward, and any deviation from that sequence will result in negative advantage, then the longer this series, the less likely is agent to explore this skill thoroughly and learn to use it when necessary.\n\n2. If an environment is highly repetitive, then the agent is more likely to find and stay in a local minimum.\n\n3. In order to be robust to various strategies humans employ, our agents must have encountered a wide variety of situations in training. This parallels the success of domain randomization in transferring policies from simulation to real-world robotics [5].\n\nWe randomize many parts of the environment:\n\n\u2022 Initial State: In our rollout games, heroes start with random perturbations around the default starting level, experience, and gold, armor, movement speed, health regeneration, mana regeneration, magic resistance, strength, intellect, and agility.\n\n\u2022 Lane Assignments: From a strategic perspective it makes sense for heroes to act in certain area of the map more than the others. Most inter-team skirmishes happen on lanes (3 distinct paths that connect opposing bases). At a certain stage of our work, we noticed that our agents developed a preference to stick together as a group of 5 on a single lane, and fighting any opponent coming their way. This represents a large local minimum, with higher shortterm reward but lower long-term one as the resources from the other lanes are lost. After that we introduced lane assignments, which randomly assigned each hero to a subset of lanes, and penalized them with negative reward for leaving those lanes. However, the ablation study in Figure 30 indicates that this may not have been necessary in the end.\n\n\u2022 Roshan Health: Roshan is a powerful neutral creature, that sits in a specific location on the map and awaits challengers. Early in training our agents were no match for it; later on, they would already have internalized the lesson never to approach this creature. In order to make this task easier to learn, we randomize Roshan's health between zero and the full value, making it easier (sometimes much easier) to kill.\n\n\u2022 Hero Lineup:\n\nIn each training game, we randomly sample teams from the hero pool. While the hero randomization is necessary for robustness in evaluations against human players (which may use any hero teams), we hypothesize that it may serve as additional exploration encouragement, varying the game and preventing premature convergence. In Appendix P, we see that training with additional heroes causes only a modest slowdown to training despite the extra heroes having new abilities and strategies which interact in complex ways.\n\n\u2022 Item Selection: Our item selection is scripted: in an evaluation game, our agents always buy the same set of items for each specific hero. In training we randomize around that, swapping, adding, or removing some items from the build. This way we expose our agents to enemies playing with and using those alternative items, which makes our agents more robust to games against human players. There are shortcomings to this method, e.g. a team with randomly picked items is likely to perform worse, as our standard build is carefully crafted. In the end our agent was able to perform well against humans who choose a wide variety of items.\n\n\nP Hero Pool Size\n\nOne of the primary limitations of our agent is its inability to play all the heroes in the game. We compared the progress in early training from training with various numbers of heroes. In all cases, each training game is played using an independent random sampling of five heroes from the pool for each team. To ensure a fair comparison across the runs, evaluation games are played using only the smallest set of heroes. Because the test environment uses only five heroes, the runs which train with fewer heroes are training closer to the test distribution, and thus can be expected to perform better; the question is how much better? In Figure 31, we see that training with more heroes causes only a modest slowdown. Training with 80 heroes has a speedup factor of approximately 0.8, meaning early training runs 20% slower than with the base 17 heroes. From this we hypothesize that an agent trained on the larger set of heroes using the full resources of compute of Rerun would attain a similar high level of skill with approximately 20% more training time. Of course this experiment only compares the very early stages of training; it could be that the speedup factor becomes worse later in training. ) granted by varying the size of the hero pool. Additional heroes slows down early training only slightly. The severe underperformance of the 5-hero run for the first 4k versions was not investigated in detail. It is likely not due to the hero count but rather some instability in that particular training run. Figure 32: Learning Rate during The International: This is what happens when humans under time pressure choose hyperparameters. We believe that in the future automated systems should optimize these hyperparameters instead. After this event, our team began to internally refer to the act of frantically searching over hyperparameters as \"designing skyscrapers.\"\n\n\nQ Bloopers\n\n\nQ.1 Manually Tuned Hyperparameters\n\nLeading into The International competition in August 2018, we already a very good agent, but we felt it was likely not yet as good as the very best humans (as indeed turned out to be the case; we lost both games at that event). In the final few days before the games, we sought to explore high-variance options which had a chance of offering a surprising improvement. In the end, however, we ultimately believe that human intuition, especially under time pressure, is not the best way to set hyperparameters. See Figure 32 for the history of our learning rate parameter during those few days.\n\n\nQ.2 Zero Team Spirit Embedding\n\nOne of our team members stumbled upon a very strange phenomenon while debugging a failed surgery. It turned out that replacing a certain set of 128 learned parameters in the model with zero increased the model's performance significantly (about 55% winrate after versus before). We believe that the optimizers were unable to find this direction for improvement because although the win rate was higher, the shaped reward (see Table 6) was approximately the same. A random perturbation to the parameters should have overwhelming probability of making things worse rather than better. We do not know why zero would be a special value for these parameters. These parameters were certainly an unusual piece of the model. In the early stages of applying team spirit (see Appendix G), we attempted to randomize the team spirit parameter in each game. We had a fixed list of four possible team spirit values; each rollout game one was chosen at random. The agent was allowed to observe the current team spirit, via an embedding table with four entries. We hoped this might encourage exploring games of different styles, some very selfless games and some very selfish games.\n\nAfter training in this way for only a short period, we decided this randomization was not helping, and turned it off. Because our surgery methods do not allow for removing parameters easily, we simply set the team spirit observation to always use a fixed entry in the embedding table. In this way we arrived at a situation where the vector of \"global\" observations g consisted of the real observations g r , concatenated with 128 dimensions from this fixed embedding E; these extra dimensions were learned parameters which did not depend on the observations state:\ng = [g r , E](15)\nBecause this vector is consumed by a fully connected layer W g + B, these extra parameters do not affect the space of functions representable by the neural network. They are exactly equivalent to not including E in the global observations and instead using a modified bias vector:\nB = W [0, E] + B(16)\nFor this reason we were comfortable leaving this vestigial part of the network in place.\n\nBecause it was an embedding, there should be nothing special about 0 in the 128-dimensional space of possible values of E. However we see clear evidence that zero is special, because a generic perturbation to the parameters should have a negative effect. Indeed, we tried this explicitlyperturbing these parameters in other random directions -and the effect was always negative except for the particular direction of moving towards zero.\n\n\nQ.3 Learning path dependency\n\nThe initial training of OpenAI Five was done as a single consecutive experiment over multiple months. During that time new items, observations, heroes, and neural network components were added. The order of introduction of these changes was a priori not critical to learning, however when reproducing this result in Rerun with all the final observations, heroes, and items included, we found that one item -Divine Rapier -could cause the agents to enter a negative feedback loop that reduced their skill versus reference opponents. As Rapier began to be used, we noted a decrease in episodic reward and TrueSkill. When repeating this experiment with Rapiers banned from the items available for purchase, TrueSkill continues to improve.\n\nWe hypothesize that this effect was not observed during our initial long-lasting training because Rapier was only added after the team spirit hyperparamater was raised to 1 (see Appendix G). Rapier is a unique item which does not stay in your inventory when you die, but instead falls to the ground and can be picked up by enemies or allies. Because of this ability to transfer a high-value item, it is possible that the reward collected in a game increases in variance, thereby preventing OpenAI Five from learning a reliable value function.\n\nFigure 1 :\n1Simplified OpenAI Five Model Architecture:\n\nFigure 3 :\n3TrueSkill over the course of training for OpenAI Five.\n\nFigure 4 :\n4Training in an environment under development:\n\n\nBatch size: Larger batch size speeds up training. In the early part of training studied here, the speedup is sublinear in the computation and samples required. See subsection M.1 for experiment details.\n\n\nData Staleness: Training on stale rollout data causes significant losses in training speed. Queue length estimates the amount of artificial staleness introduced; see subsection M.2 for experiment details.\n\n\nSample Reuse: Reusing each sample of training data causes significant slowdowns. See subsection M.3 for experiment details.\n\nFigure 5 :\n5Batch Size and data quality in early training: For each parameter, we ran multiple training runs varying only that parameter. These runs cover early training (approximately one week) at small scale (8x smaller than Rerun). On the left we plot TrueSkill over time for each run. On the right, we plot the \"speedup\" to reach fixed TrueSkill thresholds of 100, 125, 150, and 175 as a function of the parameter under study compared to the baseline (marked with 'b'); seeEquation 2.\n\n\u2022\nDota 2 expertise and community advice from Blitz (William Lee) \u2022 Dota 2 Casters: Blitz (William Lee), Capitalist (Austin Walsh), Purge (Kevin Godec), ODPixel (Owen Davies), Sheever (Jorien van der Heijden), Kyle Freedman \u2022 Dota 2 World Champions (OG): ana (Anathan Pham), Topson (Topias Taavitsainen), Ceb (S\u00e9bastien Debs), JerAx (Jesse Vainikka), N0tail (Johan Sundstein) \u2022 Dota 2 Professional Teams: Team Secret, Team Lithium, Alliance, SG E-sports \u2022 Benchmark Players: Moonmeander (David Tan), Merlini (Ben Wu), Capitalist (Austin Walsh), Fogged (Ioannis Loucas), Blitz (William Lee) \u2022 Playtesting: Alec Radford, Bowen Baker, Alex Botev, Pedja Marinkovic, Devin McGarry, Ryan Perron, Garrett Fisher, Jordan Beeli, Aaron Wasnich, David Park, Connor Mason, James Timothy Herron, Austin Hamilton, Kieran Wasylyshyn, Jakob Roedel, William Rice, Joel Olazagasti, Samuel Anderson \u2022 We thank the entire Dota 2 community for their support and enthusiasm. We especially profusely thank all 39,356 Dota 2 players from 225 countries who participated in OpenAI Five Arena and all the players who played against the 1v1 agent during the LAN event at The International 2017!\n\n24 .\n24OpenAI, Akkaya, I., Andrychowicz, M., Chociej, M., Litwin, M., McGrew, B., Petron, A., Paino, A., Plappert, M., Powell, G., Ribas, R., Schneider, J., Tezak, N., Tworek, J., Welinder, P., Weng, L., Yuan, Q., Zaremba, W. & Zhang, L. Solving Rubik's Cube with a Robot Hand 2019. arXiv: 1910.07113 [cs.LG]. 25. Dalvi, N., Domingos, P., Mausam, Sanghai, S. & Verma, D. Adversarial Classification in Proceedings of the Tenth ACM SIGKDD International Conference on Knowledge Discovery and Data Mining (ACM, Seattle, WA, USA, 2004), 99-108. isbn: 1-58113-888-1. doi:10.1145/ 1014052.1014066. <http://doi.acm.org/10.1145/1014052.1014066>. 26. Jain, A., Bansal, R., Kumar, A. & Singh, K. A comparative study of visual and auditory reaction times on the basis of gender and physical activity levels of medical first year students. International journal of applied and basic medical research 5, 125-127 (2015). 27. Herbrich, R., Minka, T. & Graepel, T. TrueSkill: a Bayesian skill rating system in Advances in neural information processing systems (2007), 569-576. 28. McCandlish, S., Kaplan, J., Amodei, D. & Team, O. D. An empirical model of large-batch training. arXiv preprint arXiv:1812.06162 (2018). 29. Cobbe, K., Klimov, O., Hesse, C., Kim, T. & Schulman, J. Quantifying Generalization in Reinforcement Learning. CoRR abs/1812.02341. arXiv: 1812.02341. <http://arxiv. org/abs/1812.02341> (2018). 30. Jaderberg, M., Czarnecki, W. M., Dunning, I., Marris, L., Lever, G., Castaneda, A. G., Beattie, C., Rabinowitz, N. C., Morcos, A. S., Ruderman, A., et al. Human-level performance in firstperson multiplayer games with population-based deep reinforcement learning. arXiv preprint arXiv:1807.01281 (2018). 31. Morav\u010d\u00edk, M., Schmid, M., Burch, N., Lis\u00fd, V., Morrill, D., Bard, N., Davis, T., Waugh, K., Johanson, M. & Bowling, M. Deepstack: Expert-level artificial intelligence in heads-up no-limit poker. Science 356, 508-513 (2017). 32. Schaeffer, J., Culberson, J., Treloar, N., Knight, B., Lu, P. & Szafron, D. A world championship caliber checkers program. Artificial Intelligence 53, 273-289. issn: 0004-3702 (1992). 33. Bansal, T., Pachocki, J., Sidor, S., Sutskever, I. & Mordatch, I. Emergent complexity via multi-agent competition. arXiv preprint arXiv:1710.03748 (2017). 34. Sukhbaatar, S., Lin, Z., Kostrikov, I., Synnaeve, G., Szlam, A. & Fergus, R. Intrinsic motivation and automatic curricula via asymmetric self-play. arXiv preprint arXiv:1703.05407 (2017). 35. Brown, G. W. in Activity Analysis of Production and Allocation (ed Koopmans, T. C.) (Wiley, New York, 1951). 36. Heinrich, J. & Silver, D. Deep Reinforcement Learning from Self-Play in Imperfect-Information Games. CoRR abs/1603.01121. arXiv: 1603.01121 (2016). 37. Silver, D., Schrittwieser, J., Simonyan, K., Antonoglou, I., Huang, A., Guez, A., Hubert, T., Baker, L., Lai, M., Bolton, A., et al. Mastering the game of go without human knowledge. Nature 550, 354 (2017). 38. Anthony, T., Tian, Z. & Barber, D. Thinking fast and slow with deep learning and tree search in Advances in Neural Information Processing Systems (2017), 5360-5370. 39. Brown, N. & Sandholm, T. Superhuman AI for multiplayer poker. Science, eaay2400 (2019). 40. Watkins, C. J. & Dayan, P. Q-learning. Machine learning 8, 279-292 (1992). 41. Kulkarni, T. D., Narasimhan, K., Saeedi, A. & Tenenbaum, J. Hierarchical deep reinforcement learning: Integrating temporal abstraction and intrinsic motivation in Advances in neural information processing systems (2016), 3675-3683. 42. Burda, Y., Edwards, H., Storkey, A. & Klimov, O. Exploration by random network distillation. arXiv preprint arXiv:1810.12894 (2018). 43. Ecoffet, A., Huizinga, J., Lehman, J., Stanley, K. O. & Clune, J. Montezuma's revenge solved by go-explore, a new algorithm for hard-exploration problems (sets records on pitfall too). Uber Engineering Blog, Nov (2018). 44. Goyal, P., Doll\u00e1r, P., Girshick, R., Noordhuis, P., Wesolowski, L., Kyrola, A., Tulloch, A., Jia, Y. & He, K. Accurate, Large Minibatch SGD: Training ImageNet in 1 Hour (June 2017).\n\nFigure 7 :\n7Hyperparameter changes during Rerun. Changes are displayed in table-form on the left, and called out in the trueskill vs iterations graph of the training run on the right. Each hyperparameter change was applied gradually over the course of 1-2 days, corresponding to several thousand iterations (the reported time in the table is the start of the change). Our pre-planned schedule included further changes to bring the experiment into line with OpenAI Five's final hyperparameters (Horizon to 840 sec, team spirit to 1.0, and learning rate to 1e-6), but Rerun reached OpenAI Five's skill level before we reached those hyperparameters.\n\nFigure 8 :\n8Timescales and Staleness: The breakdown of a rollout game. Rather than collect an entire game before sending it to the optimizers, rollout machines send data in shorter segments. The segment is further subdivided into samples of 16 policy actions which are optimized together using truncated BPTT. Each policy action bundles together four game engine frames.\n\nFigure 9 :\n9Win Probability prediction of game 1 of OpenAI Five Finals In red we show the (OpenAI Five) agent's win probability prediction over the course of the game (which can be viewed by downloading the replay from https://openai.com/blog/ how-to-train-your-openai-five/). Marked are two significant events that significantly affected win probability prediction. At roughly 5 minutes in the human team killed several of Ope-nAI Five's heroes, making it doubt its lead. At roughly 18 minutes in, OpenAI Five team killed three human heroes in a row, regrouped all their heroes at the mid lane, and marched on declaring 95% probability of victory. Versions 0-56k are progressive versions of Rerun agent predicting win probabilities by replaying the same game; as we can see, prediction converges to that of the bot that actually played the game (original OpenAI Five), despite training over self-play games from separate training runs.\n\nFigure 10 :\n10Continuous prediction of destroying enemy buildings by OpenAI Five in Finals game 1.\n\nFigure 11 :\n11Screenshots right before two of the dire tower falls in the OpenAI Five Finals game 1. In 11a, Gyrocopter and Crystal Maiden attack the bottom tower 1 (upper left in\n\nFigure 14 :\n14Observation Space Overview: The arrays that OpenAI Five observes at each timestep. Most of OpenAI Five's observations are unit-centered; for 189 different units on the map, we observe a set of basic properties. These units are grouped along the top of the figure. We observe some data about all units, some extra data about the primary units (the heroes), and even more data about the heroes on our team. A few observations are not tied to any unit. Finally, two observations having to do with hero control (terrain near me, and my previous action) are only observed about the individual hero that this LSTM replica operates. In this diagram blue bands represent categorical data and yellow bands represent continuous or boolean data; most entities (units, modifiers, abilities, items, and pickups), have some of each. Each piece of the figure summarizes the total dimensionality of that portion of the input. All together, an OpenAI Five hero observes 1,200 categorical values and 14,534 continuous/boolean values.\n\n( b )\nbUnit Selection: One of the 189 visible units in the observation. For actions and abilities which target units, either enemy units or friendly units. For many actions, some of the possible unit targets will be invalid; attempting an action with an invalid target results in a noop.\n\nFigure 15 :\n15Action Parameters along with a number of parameter actions.\n\nFigure 16 :\n16Sparse rewards in Dota 2: TrueSkill over the course of training for experiments run with 0-1 loss only. For the sparse reward run horizon was set to 1 hour (\u03b3 = 0.99996) (versus 180 seconds for the baseline run). The baseline otherwise uses identical settings and hyperparameters including our shaped reward. The sparse reward succeeds at reaching TrueSkill 155; for reference, a hand-coded scripted agent reaches TrueSkill 100.\n\nFigure 17 :FCFCFigure 18 :\n1718Observation The target unit is chosen via an attention mechanism over the available units. The unit keys are masked by a learned per-action mask based on the sampled action. The hidden state of the LSTM and unit embeddings are used to parameterize the actions.\n\nFigure 20 :\n20Variation in 5v5 baseline training: On the left, the TrueSkill over the course of training for different \"baseline\" experiments, using identical settings and hyperparameters. On the right, the standard deviation in TrueSkill across four runs. See Appendix C for the hyperparameters used. Although we only have 4 runs, we can estimate that different runs tend to vary by about 2 TrueSkill.\n\nFigure 21 :\n21Effect of batch size on training speed: (Replicated from main textFigure 5a) TrueSkill over the course of training (see Appendix J) and speedup measured by the rate to attain different TrueSkill thresholds (computed using Equation 2) granted by increasing the batch size. The dotted line indicates perfect linear scaling (using 2x more data gives 2x speedup). Larger batch size significantly speeds up training, but the speedup is sublinear in the resources consumed. Later training (TrueSkill 175) benefits more from increased scale than earlier training (TrueSkill 100). Note that TrueSkill 175 is still quite early in the overall training of OpenAI Five which ultimately reaches above 250 (seeFigure 3), so these results are inconclusive about whether large batch size causes linear speedup for the bulk of the training time.\n\nFigure 22 :\n22Effect of Staleness on training speed. (Replicated from main text Figure 5b) TrueSkill over the course of training (see Appendix J) and speedup measured by the rate to attain different TrueSkill thresholds (computed using Equation 2) granted by increasing Staleness. Increasing staleness of data causes significant losses in training speed.\n\nFigure 24 :\n24Effect of Sample Reuse on training speed. (Replicated from main text Figure 5c) TrueSkill over the course of training (see Appendix J) and speedup measured by the rate to attain different TrueSkill thresholds (computed using Equation 2) granted by increasing Sample Reuse.\n\nFigure 25 :\n25As our target sample reuse increases measured sample reuse increases predictably. Error bars indicate the standard deviation of measured sample reuse as it varied over the course of training.\n\nFigure 26 :\n26Asynchronous training:\n\nFigure 27 :\n27Opponent Manager Distribution over past versions.\n\nFigure 28 :Figure 29 :\n2829Entropy in early training: TrueSkill and speedup with varied entropy coefficients. Lower entropy performs worse because the model has a harder time exploring; higher entropy performs much worse because the actions are too random. Team Spirit in early training: Very early in training (TrueSkill <125) the run with team spirit 0 does best; this can be seen by the speedup for lower TrueSkill being highest at team spirit 0. The maximum speedup quickly moves to 0.5 in the medium TrueSkill regime (150 and 175).\n\nFigure 30 :\n30Lane Assignments: \"Lane assignments\" randomization on vs. off. In this ablation we see that this randomization actually provided little benefit.\n\nFigure 31 :\n31Effect of hero pool size on training speed: TrueSkill over the course of training (see Appendix J) and speedup measured by the rate to attain different TrueSkill thresholds (computed using Equation 2\n\n\nteams in 7,257 total games, winning 99.4% 9 . Twenty-nine teams managed to defeat OpenAI Five for a total of 42 gamesOG (world champions) \n\n0 \n100 \n200 \n300 \n400 \n500 \n600 \n700 \n800 \n\nCompute (PFLOPs/s-days) \n\n0 \n\n50 \n\n100 \n\n150 \n\n200 \n\n250 \n\nTrueSkill \n\nBenchmark (casters) \nTest team A (semi-pro) \nTest team B (amateur) \n\nHand-scripted \n\nRandom \n\nOpenAI Five \nPro matches won \nCalibration matches \n\n\n\n\nPast methods have grown neural networks by incrementally training and freezing parts of the network [49], [50], [51]. Li & Hoiem [52] and Rusu et al. [53] use similar methods to use a trained model to quickly learn novel tasks. Distillation [54] and imitation learning [55, 56] offer an alternate approach to surgery for making model changes in response to a shifting environment. In concurrent work, OpenAI et al. [24] has reported success using behavioral cloning for similar purposes.\n\n\nTechnical discussions with numerous people within OpenAI including Bowen Baker, Paul Christiano, Danny Hernandez, Sam McCandlish, Alec Radford\u2022 Review of early drafts by Bowen Baker, Danny Hernandez, Jacob Hilton, Quoc Le, Luke Metz, \nMatthias Plappert, Alec Radford, Oriol Vinyals \n\n\u2022 Event Support from Larissa Schiavo, Diane Yoon, Loren Kwan \n\n\u2022 Communication, writing, and outreach support from Ben Barry, Justin Wang, Shan Carter, \nAshley Pilipiszyn, Jack Clark \n\n\u2022 OpenAI infrastructure support from Eric Sigler \n\n\u2022 Google Cloud Support (Solomon Boulos, JS Riehl, Florent de Goriainoff, Somnath Roy, Win-\nston Lee, Andrew Sallaway, Danny Hammo, Jignesh Naik) \n\n\u2022 Microsoft Azure Support (Jack Kabat, Jason Vallery, Niel Mackenzie, David Kalmin, Dina \nFrandsen) \n\n\n\n45 .\n45You, Y., Gitman, I. & Ginsburg, B. Scaling SGD Batch Size to 32K for ImageNet Training (Aug. 2017). 46. You, Y., Zhang, Z., Hsieh, C.-J., Demmel, J. & Keutzer, K. ImageNet Training in Minutes in Proceedings of the 47th International Conference on Parallel Processing (ACM, Eugene, OR, USA, 2018), 1:1-1:10. isbn: 978-1-4503-6510-9. doi:10.1145/3225058.3225069. <http: //doi.acm.org/10.1145/3225058.3225069>. 47. Mnih, V., Badia, A. P., Mirza, M., Graves, A., Lillicrap, T., Harley, T., Silver, D. & Kavukcuoglu, K. Asynchronous Methods for Deep Reinforcement Learning in Proceedings of The 33rd International Conference on Machine Learning (eds Balcan, M. F. & Weinberger, K. Q.) 48 (PMLR, New York, New York, USA, June 2016), 1928-1937. <http://proceedings.mlr.press/ v48/mniha16.html>. 48. Espeholt, L., Soyer, H., Munos, R., Simonyan, K., Mnih, V., Ward, T., Doron, Y., Firoiu, V., Harley, T., Dunning, I., et al. Impala: Scalable distributed deep-rl with importance weighted actor-learner architectures. arXiv preprint arXiv:1802.01561 (2018). 49. Fahlman, S. E. & Lebiere, C. in (ed Touretzky, D. S.) 524-532 (Morgan Kaufmann Publishers Inc., San Francisco, CA, USA, 1990). isbn: 1-55860-100-7. <http : / / dl . acm . org / citation.cfm?id=109230.107380>. 50. Wang, Y., Ramanan, D. & Hebert, M. Growing a Brain: Fine-Tuning by Increasing Model Capacity in 2017 IEEE Conference on Computer Vision and Pattern Recognition, CVPR 2017, Honolulu, HI, USA, July 21-26, 2017 (2017), 3029-3038. doi:10.1109/CVPR.2017.323. <https://doi.org/10.1109/CVPR.2017.323>. 51. Czarnecki, W. M., Jayakumar, S. M., Jaderberg, M., Hasenclever, L., Teh, Y. W., Osindero, S., Heess, N. & Pascanu, R. Mix&Match -Agent Curricula for Reinforcement Learning. CoRR abs/1806.01780. arXiv: 1806 . 01780. <http : / / arxiv . org / abs / 1806 . 01780> (2018). 52. Li, Z. & Hoiem, D. Learning without Forgetting. IEEE Transactions on Pattern Analysis and Machine Intelligence 40, 2935-2947. issn: 0162-8828 (Dec. 2018). 53. Rusu, A. A., Rabinowitz, N. C., Desjardins, G., Soyer, H., Kirkpatrick, J., Kavukcuoglu, K., Pascanu, R. & Hadsell, R. Progressive Neural Networks. arXiv preprint arXiv:1606.04671 (2016). 54. Hinton, G., Vinyals, O. & Dean, J. Distilling the Knowledge in a Neural Network in NIPS Deep Learning and Representation Learning Workshop (2015). <http://arxiv.org/abs/ 1503.02531>.55. Ross, S., Gordon, G. & Bagnell, D. A Reduction of Imitation Learning and Structured Prediction to No-Regret Online Learning in Proceedings of the Fourteenth International Conference on Artificial Intelligence and Statistics (eds Gordon, G., Dunson, D. & Dud\u00edk, M.) 15 (PMLR, Fort Lauderdale, FL, USA, Apr. 2011), 627-635. <http://proceedings.mlr.press/ v15/ross11a.html>. 56. Levine, S. & Koltun, V. Guided Policy Search in Proceedings of the 30th International Conference on International Conference on Machine Learning -Volume 28 (JMLR.org, Atlanta, GA, USA, 2013), III-1-III-9. <http://dl.acm.org/citation.cfm?id=3042817. 3042937>. 57. OpenAI. AI and Compute https://openai.com/blog/ai-and-compute/. [Online; accessed 9-Sept-2019]. 2018. 58. Ng, A. Y., Harada, D. & Russell, S. Policy invariance under reward transformations: Theory and application to reward shaping in In Proceedings of the Sixteenth International Conference on Machine Learning (Morgan Kaufmann, 1999), 278-287. 59. Brockman, G., Cheung, V., Pettersson, L., Schneider, J., Schulman, J., Tang, J. & Zaremba, W. OpenAI Gym. CoRR abs/1606.01540. arXiv: 1606.01540. <http://arxiv.org/ abs/1606.01540> (2016). 60. Balduzzi, D., Garnelo, M., Bachrach, Y., Czarnecki, W. M., P\u00e9rolat, J., Jaderberg, M. & Graepel, T. Open-ended Learning in Symmetric Zero-sum Games. CoRR abs/1901.08106. arXiv: 1901.08106. <http://arxiv.org/abs/1901.08106> (2019). 61. Williams, R. J. & Peng, J. Function optimization using connectionist reinforcement learning algorithms. Connection Science 3, 241-268 (1991).D.1 Understanding OpenAI Five Finals . . . . . . . . . . . . . . . . . . . . . . . . . . . 33 D.2 Hero selection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35 F.1 Scripted Actions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42 K.1 Data flow between the training environment and Dota 2 . . . . . . . . . . . . . . . 49 M.1 Batch Size . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53 M.2 Sample Quality -Staleness . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54 M.3 Sample Quality -Sampling and Sample Reuse . . . . . . . . . . . . . . . . . . . . 56 O.1 Loss function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59 O.2 Environment Randomization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62 Q.1 Manually Tuned Hyperparameters . . . . . . . . . . . . . . . . . . . . . . . . . . . 65 Q.2 Zero Team Spirit Embedding . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65 Q.3 Learning path dependency . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66Appendix \n\nTable of Contents \n\nA Compute Usage \n25 \n\nB Surgery \n25 \n\nC Hyperparameters \n29 \n\nD Evaluating agents' understanding \n30 \n\nE Observation Space \n37 \n\nF Action Space \n39 \n\nG Reward Weights \n43 \n\nH Neural Network Architecture \n45 \n\nI Human Games \n49 \n\nJ TrueSkill: Evaluating a Dota 2 Agent Automatically \n49 \n\nK Dota 2 Gym Environment \n49 \n\nL Reaction time \n51 \n\nM Scale and Data Quality Ablation Details \n52 \n\nN Self-play \n59 \n\nO Exploration \n59 \n\nP Hero Pool Size \n63 \n\nQ Bloopers \n65 \n\n\n\n\nThe Obs: Roshan spawn timing 10/12/2018 140,402 156,811,805 Item: Bottle 10/19/2018 144,121 156,286,925 Obs: Stock counts; Obs: Remove some obsolete obs 10/24/2018 150,111 156,286,867 Obs: Neutral creep & rune spawn timers 11/7/2018 161,482 156,221,309 Obs: Item swap cooldown; Obs: Remove some obsolete obs 11/28/2018 185,749 156,221,669 Item: Divine rapier; Obs: Improve observation of stale enemy heroes 12/10/2018 193,701 157,378,165 Obs: Modifiers on nonhero units. 12/14/2018 196,800 157,650,795 Action: Consumables on allies; Obs: Line of sight information; Obs: next item this hero will purchase; Action: buyback 12/20/2018 203,241 157,679,655 Dota 2 version 7.20 adds new items, new item slot, changes map, etc; Obs: number of empty inventory slots 1/23/2019 211,191 158,495,991 Obs: Improve observations of area of effects; Obs: improve observation of modifiers' duration; Obs: Improve observations about item Power Treads. 4/5/2019 220,076 158,502,815 Dota 2 version 7.21 adds new items, abilities, etc.Date \n\nIteration # params Change \n6/30/2018 \n1 \n43,436,520 Experiment started \n8/17/2018 \n81,821 \n43,559,322 Dota 2 version 7.19 adds new items, abilities, etc. \n8/18/2018 \n84,432 \n43,805,274 Change environment to single courier; \nremove \"cheating\" observations \n8/26/2018 \n91,471 \n156,737,674 Double LSTM size \n9/27/2018 \n123,821 156,809,485 Support for more heroes \n10/3/2018 \n130,921 156,809,501 \n\nTable 1 :\n1All successful surgeries and major environment changes performed during the training of OpenAI Five. This table does not include surgeries which were ultimately reverted due to training failures, nor minor environment\n\n\nBatch size can be measured in samples (each an unrolled LSTM of 16 frames) or in individual timesteps.Param \n\nRerun \nOpenAI Five \nBaseline \nFrameskip e \n4 \n4 \n4 \nLSTM Unroll length e \n16 \n16 \n16 \nSamples Per Segment e \n16 \n16 \n16 \nNumber of optimizer GPUs \n512 \n480\u21941,536 \n64 \nBatch Size/optimizer GPU (samples) \n120 \n120\u2194128 \n120 \nTotal Batch Size (samples) a \n61,440 \n61,440\u2194196,608 \n7,680 \nTotal Batch Size (timesteps) a \n983,040 \n983,040\u21943,145,728 122,880 \nNumber of rollout GPUs \n512 \n500\u21941,440 \n64 \nNumber of rollout CPUs \n51,200 \n80,000\u2194172,800 \n6,400 \nSteps per Iteration \n32 \n32 \n32 \nLSTM Size \n4096 \n2048 \u2192 4096 \n4096 \nSample Reuse \n1.0 \u2194 1.1 \n0.8\u21942.7 \n1.0\u21941.1 \nTeam Spirit \n0.3 \u2192 0.8 \n0.3 \u2192 1.0 \n0.3 \nGAE Horizon \n180 secs \u2192 360 secs 60 secs \u2192 840 secs 180 secs \nGAE \u03bb \n0.95 \n0.95 \n0.95 \nPPO clipping \n0.2 \n0.2 \n0.2 \nValue loss weight c \n1.0 \n0.25 \u2194 1.0 \n1.0 \nEntropy coefficient \n0.01 \u2192 0.001 \n0.01 \u2192 0.001 \n0.01 \nLearning rate \n5e-5 \u2192 5e-6 \n5e-5 \u2194 1e-6 \n5e-5 \nAdam \u03b2 1 \n0.9 \n0.9 \n0.9 \nAdam \u03b2 2 \n0.999 \n0.999 \n0.999 \nPast opponents b \n20% \n20% \n20% \nPast Opponents Learning Rate d \n0.01 \n0.01 \n0.01 \na \n\nTable 2 :\n2Hyperparameters: The OpenAI Five and Rerun columns indicate what was done for those individual experiments.\n\n\na These observations are leftover from an early version of Five which played a restricted 1v1 version of the game. They are likely obsolete and not needed, but this was not tested. b These observations are about our per-game randomizations. See Appendix O. c For items: gem, smoke of deciept, observer ward, infused raindrop. d Observations are not visible per-se, but can be estimated. We use scripted logic to estimate them from visible observations. e These observations (only) are different for the five different heroes on the team.Global data \n\n22 \ntime since game started \n1 \nis it day or night? \ntime to next day/night change \n2 \ntime to next spawn: creep, \nneutral, bounty, runes \n\n4 \n\ntime since seen enemy courier \nis that > 40 seconds? a \n2 \nmin&max time to Rosh spawn \n2 \nRoshan's current max hp \n1 \nis Roshan definitely alive? \n1 \nis Roshan definitely dead? \n1 \nNext Roshan drops cheese? \n1 \nNext Roshan drops refresher? \n1 \nRoshan health randomization b \n1 \nGlyph cooldown (both teams) \n2 \nStock counts c \n4 \nPer-unit (189 units) \n43 \nposition (x, y, z) \n3 \nfacing angle (cos, sin) \n2 \ncurrently attacking? e \ntime since last attack d \n2 \nmax health \nlast 16 timesteps' hit points \n17 \nattack damage, attack speed \n2 \nphysical resistance \n1 \ninvulnerable due to glyph? \nglyph timer \n2 \nmovement speed \n1 \non my team? neutral? \n2 \nanimation cycle time \n1 \neta of incoming ranged & tower \ncreep projectile (if any) \n# melee creeps atking this unit d 3 \n[Shrine only] shrine cooldown \n1 \nvector to me (dx, dy, length) e \n3 \nam I attacking this unit? e \nis this unit attacking me? d,e \neta projectile from unit to me e \n3 \nunit type \n1 \ncurrent animation \n1 \n\nPer-hero add'l (10 heroes) \n25 \nis currently alive? \n1 \nnumber of deaths \n1 \nhero currently in sight? \ntime since this hero last seen \n2 \nhero currently teleporting? \nif so, target coordinates (x, y) \ntime they've been channeling \n4 \nrespawn time \n1 \ncurrent gold (allies only) \n1 \nlevel \n1 \nmana: max, current, & regen \n3 \nhealth regen rate \n1 \nmagic resistance \n1 \nstrength, agility, intelligence \n3 \ncurrently invisible? \n1 \nis using ability? \n1 \n# allied/enemy creeps/heroes \nin line btwn me and this hero e \n\n4 \n\nPer-allied-hero additional \n(5 allied heroes) \n\n211 \n\nScripted purchasing settings b \n7 \nBuyback: has?, cost, cooldown \n3 \nEmpty inventory & backpack \nslots \n\n2 \n\nLane Assignments b \n3 \nFlattened \nnearby \nter-\nrain: \n14x14 grid of pass-\nable/impassable? \n\n196 \n\nscripted build id \nnext item to purchase b \n2 \n\nNearby map (8x8) e \n6 \nterrain: elevation, passable? \n2 \nallied & enemy creep density \n2 \narea of effect spells in effect. f \n2 \narea of effect spells in effect. f \n2 \n\nPrevious Sampled Action e \n310 \nOffset? \n(Regular, Caster, \nWard) \n\n3x2x9 \n\nUnit Target's Embedding \n128 \nPrimary Action's Embedding \n128 \n\nPer-modifier (10 heroes x \n10 modifiers & 179 non-\nheroes x 2 modifiers) \n\n2 \n\nremaining duration \n1 \nstack count \n1 \nmodifier name \n1 \n\nPer-item (10 heroes x 16 \nitems) \n\n13 \n\nlocation \none-hot \n(inven-\ntory/backpack/stash) \n\n3 \n\ncharges \n1 \nis on cooldown? \ncooldown time \n2 \nis disabled by recent swap? \nitem swap cooldown \n2 \ntoggled state \n1 \nspecial Power Treads one-hot \n(str/agi/int/none) \n4 \nitem name \n1 \n\nPer-ability (10 heroes x 6 \nabilities) \n\n7 \n\ncooldown time \n1 \nin use? \n1 \ncastable \n1 \nLevel 1/2/3/4 unlocked? d \n4 \nability name \n1 \n\nPer-pickup (6 pickups) \n15 \nstatus one-hot (present/not \npresent/unknown) \n\n3 \n\nlocation (x, y) \n2 \ndistance from all 10 heroes \n10 \npickup name \n1 \n\nMinimap (10 tiles x 10 \ntiles) \n\n9 \n\nfraction of tile visible \n1 \n# allied & enemy creeps \n2 \n# allied & enemy wards \n2 \n# enemy heroes \n1 \ncell (x, y, id) \n3 \n\n\n\nTable 4 :\n4Full Observation Space: All observations OpenAI Five receives at each time step. If the number of visible units in a category is less than the allotted number, the rest are padded with zeroes. If more, we observe only the units closest to allied heroes. Units in fog of war are not observed. When enemy heroes are in fog of war, we reuse the observation from the last time step when the unit was visible.Blue rows are categorical data. Entries with a question mark are boolean observations (only take \nvalues 0 or 1 but treated as floats otherwise). The bulk of the observations are per-unit observations, \nobserved for each of 189 units: heroes (5), creeps (30), buildings (21), wards (30), and courier (1) \nfor each team, plus 15 neutrals. \n\n\nAction Target Type ExampleParameters \nNo Target \nPower Treads \nDelay \nPoint Target \nMove \nDelay, Offset (Caster) \nUnit Target \nAttack \nDelay, Unit Selection (Regular) \nUnit Offset Target \nSniper's Shrapnel \nDelay, Unit Selection (Regular), Offset (Regular) \nTeleport Target \nTown Portal Scroll \nDelay, Unit Selection (Teleport), Offset (Regular) \nWard Target \nPlace Observer Ward Delay, Offset (Ward) \n\n\n\nTable 5 :\n5Action Target Typesactions varies significantly across heroes, as different heroes have different numbers spells and items \nwith larger parameter counts. Across the two games the average number of actions for a hero varied \nfrom 8,000 to 80,000. \n\n\nTable 6 :\n6Shaped Reward Weights\n\nTable 7 :\n7Major matches of OpenAI Five against high-skill human players.4 frames to decide \non an action \n\n4 game frames combined \ninto an observation \nSubmit Action \n\nSoonest possible \naction frame \n\n\nSee Appendix P for experiments characterizing the effect of hero pool size.\nWe do include a very small number of derived features which depend on the hero being controlled, for example the \"distance to me\" feature of each unit in the game.\nEarly on in the project, we considered other algorithms including other policy gradient methods, q-learning, and evolutionary strategies. PPO was the first to show initial learning progress. 7 http://redis.io\nRollout machines produce 7.5 steps per second; they send data every 256 steps, or 34 seconds of game play. Because our rollout games run at approximately half-speed, this means they push data approximately once per minute.\nHuman players often abandoned losing games rather than playing them to the end, even abandoning games right after an unfavorable hero selection draft before the main game begins. OpenAI Five does not abandon games, so we count abandoned games as wins for OpenAI Five. These abandoned games (3140 of the 7215 wins) likely includes a small number of games that were abandoned for technical or personal reasons.\nContrast with RTS games like Starcraft, where the key measure is actions per minute due to the large number of units that need to be supplied with actions.\n\u2022 Zero sum: The game is zero sum (only one team can win), everything that benefits one team necessarily hurts the other team. We ensure that all our rewards are zero-sum, by subtracting from each hero's reward the average of the enemies' rewards.11 This randomization is done randomly deleting items from the build order and randomly inserting new items sampled from the distribution of which items that hero usually buys in human games. This is the only place in our system which relies on data from human games.\nOriginally the Lua scripting API was used to iterate and gather the visible game state, however this was somewhat slow and our final system used an all-in-one game state collection method that was added through cooperation with Valve\n\nTD-Gammon, a self-teaching backgammon program, achieves master-level play. G Tesauro, Neural computation. 6Tesauro, G. TD-Gammon, a self-teaching backgammon program, achieves master-level play. Neural computation 6, 215-219 (1994).\n\n. M Campbell, A J HoaneJr, F.-H. Deep Hsu, Blue, Artif. Intell. 134Campbell, M., Hoane Jr., A. J. & Hsu, F.-h. Deep Blue. Artif. Intell. 134, 57-83. issn: 0004- 3702 (Jan. 2002).\n\nPlaying atari with deep reinforcement learning. V Mnih, K Kavukcuoglu, D Silver, A Graves, I Antonoglou, D Wierstra, M Riedmiller, arXiv:1312.5602arXiv preprintMnih, V., Kavukcuoglu, K., Silver, D., Graves, A., Antonoglou, I., Wierstra, D. & Riedmiller, M. Playing atari with deep reinforcement learning. arXiv preprint arXiv:1312.5602 (2013).\n\nMastering the game of Go with deep neural networks and tree search. D Silver, A Huang, C J Maddison, A Guez, L Sifre, G Van Den Driessche, J Schrittwieser, I Antonoglou, V Panneershelvam, M Lanctot, nature. 529484Silver, D., Huang, A., Maddison, C. J., Guez, A., Sifre, L., Van Den Driessche, G., Schrittwieser, J., Antonoglou, I., Panneershelvam, V., Lanctot, M., et al. Mastering the game of Go with deep neural networks and tree search. nature 529, 484 (2016).\n\nLearning Dexterity https : / / openai . com / blog / learning -dexterity. Openai, 28OpenAI. Learning Dexterity https : / / openai . com / blog / learning -dexterity/. [Online; accessed 28-May-2019]. 2018.\n\nR Paulus, C Xiong, R Socher, Deep, arXiv:1705.04304Reinforced Model for Abstractive Summarization. cs.CLPaulus, R., Xiong, C. & Socher, R. A Deep Reinforced Model for Abstractive Summarization 2017. arXiv: 1705.04304 [cs.CL].\n\nGrandmaster level in StarCraft II using multi-agent reinforcement learning. O Vinyals, I Babuschkin, W M Czarnecki, M Mathieu, A Dudzik, J Chung, D H Choi, R Powell, T Ewalds, P Georgiev, Nature. Vinyals, O., Babuschkin, I., Czarnecki, W. M., Mathieu, M., Dudzik, A., Chung, J., Choi, D. H., Powell, R., Ewalds, T., Georgiev, P., et al. Grandmaster level in StarCraft II using multi-agent reinforcement learning. Nature, 1-5 (2019).\n\nThe MineRL Competition on Sample Efficient Reinforcement Learning using Human Priors. W H Guss, C Codel, K Hofmann, B Houghton, N Kuno, S Milani, S P Mohanty, D P Liebana, R Salakhutdinov, N Topin, M Veloso, P Wang, arXiv:1904.10079Guss, W. H., Codel, C., Hofmann, K., Houghton, B., Kuno, N., Milani, S., Mohanty, S. P., Liebana, D. P., Salakhutdinov, R., Topin, N., Veloso, M. & Wang, P. The MineRL Competition on Sample Efficient Reinforcement Learning using Human Priors. CoRR abs/1904.10079. arXiv: 1904.10079. <http://arxiv.org/abs/1904.10079> (2019).\n\nWikipedia contributors. Dota 2 -Wikipedia, The Free Encyclopedia. Wikipedia contributors. Dota 2 -Wikipedia, The Free Encyclopedia https://en.wikipedia. org/w/index.php?title=Dota_2&oldid=913733447. [Online; accessed 9-September- 2019]. 2019.\n\nThe Free Encyclopedia https: //en.wikipedia.org/w/index.php?title=The_International_2018&oldid= 912865272. Wikipedia contributors. The International 2018 -Wikipedia. Wikipedia contributors. The International 2018 -Wikipedia, The Free Encyclopedia https: //en.wikipedia.org/w/index.php?title=The_International_2018&oldid= 912865272. [Online; accessed 9-September-2019]. 2019.\n\nSearching for solutions in games and artificial intelligence in. L V Allis, Allis, L. V. Searching for solutions in games and artificial intelligence in (1994).\n\nA general reinforcement learning algorithm that masters chess, shogi, and Go through self-play. D Silver, T Hubert, J Schrittwieser, I Antonoglou, M Lai, A Guez, M Lanctot, L Sifre, D Kumaran, T Graepel, Science. 362Silver, D., Hubert, T., Schrittwieser, J., Antonoglou, I., Lai, M., Guez, A., Lanctot, M., Sifre, L., Kumaran, D., Graepel, T., et al. A general reinforcement learning algorithm that masters chess, shogi, and Go through self-play. Science 362, 1140-1144 (2018).\n\nLearning to forget: Continual prediction with LSTM. F A Gers, J Schmidhuber, F Cummins, Gers, F. A., Schmidhuber, J. & Cummins, F. Learning to forget: Continual prediction with LSTM (1999).\n\nJ Schulman, F Wolski, P Dhariwal, A Radford, O Klimov, arXiv:1707.06347Proximal policy optimization algorithms. arXiv preprintSchulman, J., Wolski, F., Dhariwal, P., Radford, A. & Klimov, O. Proximal policy optimization algorithms. arXiv preprint arXiv:1707.06347 (2017).\n\nActor-critic algorithms in. V R Konda, J N Tsitsiklis, Advances in neural information processing systems. Konda, V. R. & Tsitsiklis, J. N. Actor-critic algorithms in Advances in neural information processing systems (2000), 1008-1014.\n\nV Mnih, A P Badia, M Mirza, A Graves, T Lillicrap, T Harley, D Silver, K Kavukcuoglu, Asynchronous methods for deep reinforcement learning in International conference on machine learning. Mnih, V., Badia, A. P., Mirza, M., Graves, A., Lillicrap, T., Harley, T., Silver, D. & Kavukcuoglu, K. Asynchronous methods for deep reinforcement learning in International conference on ma- chine learning (2016), 1928-1937.\n", "annotations": {"author": "[{\"end\":79,\"start\":72},{\"end\":99,\"start\":80},{\"end\":114,\"start\":100},{\"end\":127,\"start\":115},{\"end\":151,\"start\":128},{\"end\":165,\"start\":152},{\"end\":180,\"start\":166},{\"end\":198,\"start\":181},{\"end\":211,\"start\":199},{\"end\":227,\"start\":212},{\"end\":242,\"start\":228},{\"end\":255,\"start\":243},{\"end\":273,\"start\":256},{\"end\":285,\"start\":274},{\"end\":303,\"start\":286},{\"end\":319,\"start\":304},{\"end\":335,\"start\":320},{\"end\":351,\"start\":336},{\"end\":367,\"start\":352},{\"end\":384,\"start\":368},{\"end\":398,\"start\":385},{\"end\":416,\"start\":399},{\"end\":433,\"start\":417},{\"end\":447,\"start\":434},{\"end\":463,\"start\":448},{\"end\":473,\"start\":464},{\"end\":487,\"start\":474},{\"end\":500,\"start\":488}]", "publisher": null, "author_last_name": "[{\"end\":78,\"start\":72},{\"end\":98,\"start\":92},{\"end\":113,\"start\":105},{\"end\":126,\"start\":122},{\"end\":150,\"start\":144},{\"end\":164,\"start\":159},{\"end\":179,\"start\":173},{\"end\":197,\"start\":189},{\"end\":210,\"start\":205},{\"end\":226,\"start\":219},{\"end\":241,\"start\":235},{\"end\":254,\"start\":249},{\"end\":272,\"start\":262},{\"end\":284,\"start\":280},{\"end\":302,\"start\":296},{\"end\":318,\"start\":310},{\"end\":334,\"start\":328},{\"end\":350,\"start\":345},{\"end\":366,\"start\":361},{\"end\":383,\"start\":377},{\"end\":397,\"start\":389},{\"end\":415,\"start\":406},{\"end\":432,\"start\":423},{\"end\":446,\"start\":441},{\"end\":462,\"start\":453},{\"end\":472,\"start\":468},{\"end\":486,\"start\":480},{\"end\":499,\"start\":494}]", "author_first_name": "[{\"end\":91,\"start\":80},{\"end\":104,\"start\":100},{\"end\":121,\"start\":115},{\"end\":143,\"start\":138},{\"end\":158,\"start\":152},{\"end\":172,\"start\":166},{\"end\":188,\"start\":181},{\"end\":204,\"start\":199},{\"end\":218,\"start\":212},{\"end\":234,\"start\":228},{\"end\":248,\"start\":243},{\"end\":261,\"start\":256},{\"end\":279,\"start\":274},{\"end\":295,\"start\":286},{\"end\":309,\"start\":304},{\"end\":327,\"start\":320},{\"end\":344,\"start\":336},{\"end\":360,\"start\":352},{\"end\":376,\"start\":368},{\"end\":388,\"start\":385},{\"end\":405,\"start\":399},{\"end\":422,\"start\":417},{\"end\":440,\"start\":434},{\"end\":452,\"start\":448},{\"end\":467,\"start\":464},{\"end\":479,\"start\":474},{\"end\":493,\"start\":488}]", "author_affiliation": null, "title": "[{\"end\":52,\"start\":1},{\"end\":552,\"start\":501}]", "venue": null, "abstract": "[{\"end\":1468,\"start\":571}]", "bib_ref": "[{\"end\":1662,\"start\":1645},{\"end\":1678,\"start\":1666},{\"attributes\":{\"ref_id\":\"b0\"},\"end\":1698,\"start\":1695},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":1701,\"start\":1698},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":1704,\"start\":1701},{\"attributes\":{\"ref_id\":\"b3\"},\"end\":1822,\"start\":1819},{\"attributes\":{\"ref_id\":\"b4\"},\"end\":1932,\"start\":1929},{\"attributes\":{\"ref_id\":\"b5\"},\"end\":1956,\"start\":1953},{\"attributes\":{\"ref_id\":\"b6\"},\"end\":1995,\"start\":1992},{\"attributes\":{\"ref_id\":\"b7\"},\"end\":2013,\"start\":2010},{\"attributes\":{\"ref_id\":\"b8\"},\"end\":2518,\"start\":2515},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":2521,\"start\":2518},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":5192,\"start\":5191},{\"attributes\":{\"ref_id\":\"b10\"},\"end\":5510,\"start\":5506},{\"attributes\":{\"ref_id\":\"b11\"},\"end\":6733,\"start\":6729},{\"attributes\":{\"ref_id\":\"b10\"},\"end\":6814,\"start\":6810},{\"attributes\":{\"ref_id\":\"b12\"},\"end\":9252,\"start\":9248},{\"attributes\":{\"ref_id\":\"b13\"},\"end\":13043,\"start\":13039},{\"attributes\":{\"ref_id\":\"b14\"},\"end\":13085,\"start\":13081},{\"attributes\":{\"ref_id\":\"b15\"},\"end\":13088,\"start\":13085},{\"attributes\":{\"ref_id\":\"b5\"},\"end\":13091,\"start\":13090},{\"attributes\":{\"ref_id\":\"b14\"},\"end\":13229,\"start\":13225},{\"end\":13557,\"start\":13553},{\"end\":13840,\"start\":13836},{\"attributes\":{\"ref_id\":\"b4\"},\"end\":16592,\"start\":16589},{\"end\":16694,\"start\":16690},{\"end\":19340,\"start\":19336},{\"attributes\":{\"ref_id\":\"b3\"},\"end\":20695,\"start\":20692},{\"attributes\":{\"ref_id\":\"b6\"},\"end\":20836,\"start\":20833},{\"end\":20839,\"start\":20836},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":22073,\"start\":22071},{\"end\":22076,\"start\":22073},{\"end\":22708,\"start\":22702},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":23052,\"start\":23050},{\"end\":23312,\"start\":23308},{\"end\":23603,\"start\":23599},{\"end\":29780,\"start\":29776},{\"end\":34059,\"start\":34055},{\"end\":35904,\"start\":35890},{\"attributes\":{\"ref_id\":\"b0\"},\"end\":37108,\"start\":37105},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":37138,\"start\":37135},{\"end\":37316,\"start\":37312},{\"end\":37383,\"start\":37379},{\"attributes\":{\"ref_id\":\"b3\"},\"end\":37670,\"start\":37667},{\"attributes\":{\"ref_id\":\"b11\"},\"end\":37857,\"start\":37853},{\"end\":37860,\"start\":37857},{\"end\":37863,\"start\":37860},{\"attributes\":{\"ref_id\":\"b6\"},\"end\":38100,\"start\":38097},{\"end\":38142,\"start\":38138},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":39443,\"start\":39440},{\"attributes\":{\"ref_id\":\"b15\"},\"end\":39766,\"start\":39762},{\"end\":40084,\"start\":40080},{\"end\":40088,\"start\":40084},{\"end\":40092,\"start\":40088},{\"attributes\":{\"ref_id\":\"b13\"},\"end\":40127,\"start\":40123},{\"attributes\":{\"ref_id\":\"b4\"},\"end\":40350,\"start\":40347},{\"end\":55112,\"start\":55108},{\"attributes\":{\"ref_id\":\"b0\"},\"end\":60258,\"start\":60255},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":60261,\"start\":60258},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":60264,\"start\":60261},{\"attributes\":{\"ref_id\":\"b3\"},\"end\":60267,\"start\":60264},{\"attributes\":{\"ref_id\":\"b4\"},\"end\":60270,\"start\":60267},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":61876,\"start\":61872},{\"attributes\":{\"ref_id\":\"b10\"},\"end\":76739,\"start\":76737},{\"end\":92778,\"start\":92774},{\"end\":93681,\"start\":93671},{\"end\":94966,\"start\":94962},{\"end\":95429,\"start\":95425},{\"attributes\":{\"ref_id\":\"b12\"},\"end\":100391,\"start\":100387},{\"attributes\":{\"ref_id\":\"b12\"},\"end\":103768,\"start\":103766},{\"attributes\":{\"ref_id\":\"b0\"},\"end\":104793,\"start\":104790},{\"attributes\":{\"ref_id\":\"b3\"},\"end\":104795,\"start\":104793},{\"attributes\":{\"ref_id\":\"b6\"},\"end\":104797,\"start\":104795},{\"end\":104801,\"start\":104797},{\"end\":104805,\"start\":104801},{\"end\":104809,\"start\":104805},{\"attributes\":{\"ref_id\":\"b13\"},\"end\":106850,\"start\":106846},{\"attributes\":{\"ref_id\":\"b13\"},\"end\":107198,\"start\":107194},{\"attributes\":{\"ref_id\":\"b15\"},\"end\":107204,\"start\":107200},{\"attributes\":{\"ref_id\":\"b4\"},\"end\":109394,\"start\":109391},{\"attributes\":{\"ref_id\":\"b10\"},\"end\":149445,\"start\":149443}]", "figure": "[{\"attributes\":{\"id\":\"fig_0\"},\"end\":118618,\"start\":118563},{\"attributes\":{\"id\":\"fig_1\"},\"end\":118686,\"start\":118619},{\"attributes\":{\"id\":\"fig_3\"},\"end\":118745,\"start\":118687},{\"attributes\":{\"id\":\"fig_4\"},\"end\":118950,\"start\":118746},{\"attributes\":{\"id\":\"fig_5\"},\"end\":119157,\"start\":118951},{\"attributes\":{\"id\":\"fig_6\"},\"end\":119283,\"start\":119158},{\"attributes\":{\"id\":\"fig_7\"},\"end\":119773,\"start\":119284},{\"attributes\":{\"id\":\"fig_9\"},\"end\":120940,\"start\":119774},{\"attributes\":{\"id\":\"fig_10\"},\"end\":125013,\"start\":120941},{\"attributes\":{\"id\":\"fig_11\"},\"end\":125661,\"start\":125014},{\"attributes\":{\"id\":\"fig_12\"},\"end\":126033,\"start\":125662},{\"attributes\":{\"id\":\"fig_13\"},\"end\":126971,\"start\":126034},{\"attributes\":{\"id\":\"fig_14\"},\"end\":127071,\"start\":126972},{\"attributes\":{\"id\":\"fig_15\"},\"end\":127252,\"start\":127072},{\"attributes\":{\"id\":\"fig_16\"},\"end\":128283,\"start\":127253},{\"attributes\":{\"id\":\"fig_17\"},\"end\":128572,\"start\":128284},{\"attributes\":{\"id\":\"fig_18\"},\"end\":128647,\"start\":128573},{\"attributes\":{\"id\":\"fig_19\"},\"end\":129091,\"start\":128648},{\"attributes\":{\"id\":\"fig_20\"},\"end\":129384,\"start\":129092},{\"attributes\":{\"id\":\"fig_21\"},\"end\":129788,\"start\":129385},{\"attributes\":{\"id\":\"fig_22\"},\"end\":130632,\"start\":129789},{\"attributes\":{\"id\":\"fig_23\"},\"end\":130988,\"start\":130633},{\"attributes\":{\"id\":\"fig_25\"},\"end\":131276,\"start\":130989},{\"attributes\":{\"id\":\"fig_26\"},\"end\":131483,\"start\":131277},{\"attributes\":{\"id\":\"fig_27\"},\"end\":131521,\"start\":131484},{\"attributes\":{\"id\":\"fig_28\"},\"end\":131586,\"start\":131522},{\"attributes\":{\"id\":\"fig_29\"},\"end\":132124,\"start\":131587},{\"attributes\":{\"id\":\"fig_30\"},\"end\":132284,\"start\":132125},{\"attributes\":{\"id\":\"fig_31\"},\"end\":132499,\"start\":132285},{\"attributes\":{\"id\":\"tab_0\",\"type\":\"table\"},\"end\":132903,\"start\":132500},{\"attributes\":{\"id\":\"tab_1\",\"type\":\"table\"},\"end\":133393,\"start\":132904},{\"attributes\":{\"id\":\"tab_2\",\"type\":\"table\"},\"end\":134165,\"start\":133394},{\"attributes\":{\"id\":\"tab_4\",\"type\":\"table\"},\"end\":139743,\"start\":134166},{\"attributes\":{\"id\":\"tab_5\",\"type\":\"table\"},\"end\":141159,\"start\":139744},{\"attributes\":{\"id\":\"tab_6\",\"type\":\"table\"},\"end\":141389,\"start\":141160},{\"attributes\":{\"id\":\"tab_7\",\"type\":\"table\"},\"end\":142506,\"start\":141390},{\"attributes\":{\"id\":\"tab_8\",\"type\":\"table\"},\"end\":142626,\"start\":142507},{\"attributes\":{\"id\":\"tab_9\",\"type\":\"table\"},\"end\":146300,\"start\":142627},{\"attributes\":{\"id\":\"tab_10\",\"type\":\"table\"},\"end\":147055,\"start\":146301},{\"attributes\":{\"id\":\"tab_11\",\"type\":\"table\"},\"end\":147461,\"start\":147056},{\"attributes\":{\"id\":\"tab_12\",\"type\":\"table\"},\"end\":147721,\"start\":147462},{\"attributes\":{\"id\":\"tab_14\",\"type\":\"table\"},\"end\":147755,\"start\":147722},{\"attributes\":{\"id\":\"tab_16\",\"type\":\"table\"},\"end\":147959,\"start\":147756}]", "paragraph": "[{\"end\":2014,\"start\":1484},{\"end\":2846,\"start\":2016},{\"end\":3406,\"start\":2848},{\"end\":4119,\"start\":3408},{\"end\":4562,\"start\":4121},{\"end\":5254,\"start\":4573},{\"end\":5511,\"start\":5256},{\"end\":5771,\"start\":5513},{\"end\":6815,\"start\":5773},{\"end\":6885,\"start\":6817},{\"end\":7023,\"start\":6887},{\"end\":7300,\"start\":7025},{\"end\":8148,\"start\":7344},{\"end\":8962,\"start\":8150},{\"end\":10075,\"start\":8964},{\"end\":10412,\"start\":10077},{\"end\":11748,\"start\":10414},{\"end\":12066,\"start\":11750},{\"end\":12974,\"start\":12092},{\"end\":13414,\"start\":12976},{\"end\":14154,\"start\":13416},{\"end\":14672,\"start\":14156},{\"end\":16021,\"start\":14674},{\"end\":16768,\"start\":16023},{\"end\":16901,\"start\":16803},{\"end\":17080,\"start\":16903},{\"end\":17268,\"start\":17082},{\"end\":17458,\"start\":17270},{\"end\":17687,\"start\":17460},{\"end\":18113,\"start\":17689},{\"end\":18641,\"start\":18115},{\"end\":19233,\"start\":18643},{\"end\":19660,\"start\":19255},{\"end\":19999,\"start\":19662},{\"end\":20312,\"start\":20030},{\"end\":20884,\"start\":20314},{\"end\":21165,\"start\":20905},{\"end\":21515,\"start\":21167},{\"end\":22977,\"start\":21517},{\"end\":23346,\"start\":22987},{\"end\":23927,\"start\":23348},{\"end\":24751,\"start\":23929},{\"end\":25194,\"start\":24753},{\"end\":25882,\"start\":25196},{\"end\":26323,\"start\":25916},{\"end\":27019,\"start\":26325},{\"end\":27359,\"start\":27021},{\"end\":27831,\"start\":27361},{\"end\":28728,\"start\":27833},{\"end\":28858,\"start\":28730},{\"end\":29087,\"start\":28860},{\"end\":29478,\"start\":29102},{\"end\":29946,\"start\":29480},{\"end\":30095,\"start\":29948},{\"end\":30209,\"start\":30110},{\"end\":30497,\"start\":30211},{\"end\":30995,\"start\":30499},{\"end\":31521,\"start\":30997},{\"end\":32314,\"start\":31538},{\"end\":32969,\"start\":32316},{\"end\":33875,\"start\":32971},{\"end\":34658,\"start\":33877},{\"end\":34913,\"start\":34660},{\"end\":35370,\"start\":34945},{\"end\":35461,\"start\":35372},{\"end\":36568,\"start\":35477},{\"end\":36784,\"start\":36570},{\"end\":37007,\"start\":36801},{\"end\":37544,\"start\":37009},{\"end\":38143,\"start\":37546},{\"end\":39301,\"start\":38145},{\"end\":39870,\"start\":39303},{\"end\":40351,\"start\":39872},{\"end\":40653,\"start\":40353},{\"end\":41495,\"start\":40668},{\"end\":41824,\"start\":41516},{\"end\":41934,\"start\":41827},{\"end\":42109,\"start\":41959},{\"end\":42583,\"start\":42111},{\"end\":42999,\"start\":42585},{\"end\":43202,\"start\":43001},{\"end\":43396,\"start\":43204},{\"end\":43459,\"start\":43398},{\"end\":43835,\"start\":43479},{\"end\":43941,\"start\":43904},{\"end\":44793,\"start\":43943},{\"end\":45144,\"start\":44795},{\"end\":45770,\"start\":45146},{\"end\":46688,\"start\":45772},{\"end\":47623,\"start\":46702},{\"end\":47948,\"start\":47625},{\"end\":48331,\"start\":47950},{\"end\":48628,\"start\":48333},{\"end\":49136,\"start\":48630},{\"end\":49318,\"start\":49251},{\"end\":50014,\"start\":49362},{\"end\":50370,\"start\":50016},{\"end\":51193,\"start\":50372},{\"end\":51839,\"start\":51195},{\"end\":52195,\"start\":51913},{\"end\":52567,\"start\":52223},{\"end\":52826,\"start\":52579},{\"end\":53447,\"start\":52828},{\"end\":54420,\"start\":53449},{\"end\":54770,\"start\":54422},{\"end\":55199,\"start\":54772},{\"end\":55615,\"start\":55201},{\"end\":56220,\"start\":55617},{\"end\":56847,\"start\":56222},{\"end\":57612,\"start\":56869},{\"end\":57787,\"start\":57614},{\"end\":57835,\"start\":57789},{\"end\":57867,\"start\":57837},{\"end\":58070,\"start\":57907},{\"end\":58668,\"start\":58072},{\"end\":59114,\"start\":58707},{\"end\":59223,\"start\":59116},{\"end\":60630,\"start\":59225},{\"end\":60756,\"start\":60632},{\"end\":61083,\"start\":60758},{\"end\":61777,\"start\":61085},{\"end\":62100,\"start\":61790},{\"end\":62424,\"start\":62102},{\"end\":62555,\"start\":62465},{\"end\":63194,\"start\":62557},{\"end\":63838,\"start\":63196},{\"end\":64360,\"start\":63840},{\"end\":64730,\"start\":64383},{\"end\":66597,\"start\":64732},{\"end\":66890,\"start\":66599},{\"end\":67387,\"start\":66892},{\"end\":67796,\"start\":67389},{\"end\":68083,\"start\":67820},{\"end\":68919,\"start\":68085},{\"end\":69765,\"start\":68921},{\"end\":70134,\"start\":69767},{\"end\":71979,\"start\":70153},{\"end\":72393,\"start\":71981},{\"end\":72806,\"start\":72395},{\"end\":74024,\"start\":72808},{\"end\":74158,\"start\":74026},{\"end\":75224,\"start\":74183},{\"end\":75619,\"start\":75226},{\"end\":76068,\"start\":75621},{\"end\":77044,\"start\":76070},{\"end\":77254,\"start\":77046},{\"end\":78162,\"start\":77275},{\"end\":79468,\"start\":78164},{\"end\":80180,\"start\":79502},{\"end\":80563,\"start\":80209},{\"end\":80966,\"start\":80565},{\"end\":81528,\"start\":80968},{\"end\":81747,\"start\":81562},{\"end\":83007,\"start\":81749},{\"end\":84144,\"start\":83009},{\"end\":84750,\"start\":84146},{\"end\":85026,\"start\":84752},{\"end\":85192,\"start\":85028},{\"end\":85385,\"start\":85194},{\"end\":85488,\"start\":85403},{\"end\":85608,\"start\":85545},{\"end\":86155,\"start\":85610},{\"end\":86573,\"start\":86157},{\"end\":87444,\"start\":86575},{\"end\":88194,\"start\":87446},{\"end\":89186,\"start\":88223},{\"end\":89784,\"start\":89188},{\"end\":90408,\"start\":89786},{\"end\":90784,\"start\":90410},{\"end\":91550,\"start\":90804},{\"end\":92434,\"start\":91552},{\"end\":92848,\"start\":92436},{\"end\":93142,\"start\":92894},{\"end\":93497,\"start\":93144},{\"end\":93683,\"start\":93499},{\"end\":94351,\"start\":93685},{\"end\":94444,\"start\":94353},{\"end\":95509,\"start\":94463},{\"end\":96472,\"start\":95511},{\"end\":96541,\"start\":96474},{\"end\":98780,\"start\":96575},{\"end\":99241,\"start\":98782},{\"end\":99825,\"start\":99243},{\"end\":100281,\"start\":99875},{\"end\":100967,\"start\":100283},{\"end\":101582,\"start\":100969},{\"end\":102689,\"start\":101584},{\"end\":103123,\"start\":102691},{\"end\":103663,\"start\":103125},{\"end\":104491,\"start\":103665},{\"end\":105005,\"start\":104507},{\"end\":105440,\"start\":105007},{\"end\":105548,\"start\":105442},{\"end\":106172,\"start\":105550},{\"end\":106566,\"start\":106197},{\"end\":106820,\"start\":106584},{\"end\":107487,\"start\":106842},{\"end\":108561,\"start\":107489},{\"end\":108701,\"start\":108595},{\"end\":109026,\"start\":108703},{\"end\":109137,\"start\":109028},{\"end\":109395,\"start\":109139},{\"end\":109440,\"start\":109397},{\"end\":109691,\"start\":109442},{\"end\":110497,\"start\":109693},{\"end\":110920,\"start\":110499},{\"end\":110936,\"start\":110922},{\"end\":111454,\"start\":110938},{\"end\":112094,\"start\":111456},{\"end\":113991,\"start\":112115},{\"end\":114635,\"start\":114043},{\"end\":115836,\"start\":114670},{\"end\":116402,\"start\":115838},{\"end\":116701,\"start\":116421},{\"end\":116811,\"start\":116723},{\"end\":117250,\"start\":116813},{\"end\":118018,\"start\":117283},{\"end\":118562,\"start\":118020}]", "formula": "[{\"attributes\":{\"id\":\"formula_0\"},\"end\":19254,\"start\":19234},{\"attributes\":{\"id\":\"formula_1\"},\"end\":30109,\"start\":30096},{\"attributes\":{\"id\":\"formula_3\"},\"end\":35476,\"start\":35462},{\"attributes\":{\"id\":\"formula_4\"},\"end\":41826,\"start\":41825},{\"attributes\":{\"id\":\"formula_5\"},\"end\":43903,\"start\":43836},{\"attributes\":{\"id\":\"formula_7\"},\"end\":49250,\"start\":49137},{\"attributes\":{\"id\":\"formula_8\"},\"end\":49361,\"start\":49319},{\"attributes\":{\"id\":\"formula_9\"},\"end\":51912,\"start\":51840},{\"attributes\":{\"id\":\"formula_10\"},\"end\":52222,\"start\":52196},{\"attributes\":{\"id\":\"formula_11\"},\"end\":52578,\"start\":52568},{\"attributes\":{\"id\":\"formula_12\"},\"end\":61789,\"start\":61778},{\"attributes\":{\"id\":\"formula_13\"},\"end\":79501,\"start\":79469},{\"attributes\":{\"id\":\"formula_14\"},\"end\":80208,\"start\":80181},{\"attributes\":{\"id\":\"formula_15\"},\"end\":106196,\"start\":106173},{\"attributes\":{\"id\":\"formula_16\"},\"end\":116420,\"start\":116403},{\"attributes\":{\"id\":\"formula_17\"},\"end\":116722,\"start\":116702}]", "table_ref": "[{\"attributes\":{\"ref_id\":\"tab_6\"},\"end\":19812,\"start\":19805},{\"attributes\":{\"ref_id\":\"tab_6\"},\"end\":47537,\"start\":47530},{\"attributes\":{\"ref_id\":\"tab_8\"},\"end\":58196,\"start\":58189},{\"attributes\":{\"ref_id\":\"tab_10\"},\"end\":68043,\"start\":68036},{\"attributes\":{\"ref_id\":\"tab_12\"},\"end\":74157,\"start\":74150},{\"attributes\":{\"ref_id\":\"tab_14\"},\"end\":77887,\"start\":77880},{\"attributes\":{\"ref_id\":\"tab_14\"},\"end\":79758,\"start\":79751},{\"attributes\":{\"ref_id\":\"tab_10\"},\"end\":84465,\"start\":84458},{\"attributes\":{\"ref_id\":\"tab_16\"},\"end\":85414,\"start\":85407},{\"attributes\":{\"ref_id\":\"tab_8\"},\"end\":96471,\"start\":96464},{\"attributes\":{\"ref_id\":\"tab_14\"},\"end\":115103,\"start\":115096}]", "section_header": "[{\"attributes\":{\"n\":\"1\"},\"end\":1482,\"start\":1470},{\"attributes\":{\"n\":\"2\"},\"end\":4571,\"start\":4565},{\"attributes\":{\"n\":\"3\"},\"end\":7318,\"start\":7303},{\"attributes\":{\"n\":\"3.1\"},\"end\":7342,\"start\":7321},{\"attributes\":{\"n\":\"3.2\"},\"end\":12090,\"start\":12069},{\"attributes\":{\"n\":\"3.3\"},\"end\":16801,\"start\":16771},{\"attributes\":{\"n\":\"4\"},\"end\":20028,\"start\":20002},{\"attributes\":{\"n\":\"4.1\"},\"end\":20903,\"start\":20887},{\"end\":22985,\"start\":22980},{\"attributes\":{\"n\":\"4.2\"},\"end\":25914,\"start\":25885},{\"attributes\":{\"n\":\"4.3\"},\"end\":29100,\"start\":29090},{\"attributes\":{\"n\":\"4.4\"},\"end\":31536,\"start\":31524},{\"attributes\":{\"n\":\"4.5\"},\"end\":34943,\"start\":34916},{\"attributes\":{\"n\":\"5\"},\"end\":36799,\"start\":36787},{\"attributes\":{\"n\":\"6\"},\"end\":40666,\"start\":40656},{\"end\":41514,\"start\":41498},{\"end\":41957,\"start\":41937},{\"end\":43477,\"start\":43462},{\"end\":46700,\"start\":46691},{\"end\":56867,\"start\":56850},{\"end\":57905,\"start\":57870},{\"end\":58705,\"start\":58671},{\"end\":62463,\"start\":62427},{\"end\":64381,\"start\":64363},{\"end\":67818,\"start\":67799},{\"end\":70151,\"start\":70137},{\"end\":74181,\"start\":74161},{\"end\":77273,\"start\":77257},{\"end\":81560,\"start\":81531},{\"end\":85401,\"start\":85388},{\"end\":85543,\"start\":85491},{\"end\":88221,\"start\":88197},{\"end\":90802,\"start\":90787},{\"end\":92892,\"start\":92851},{\"end\":94461,\"start\":94447},{\"end\":96573,\"start\":96544},{\"end\":99873,\"start\":99828},{\"end\":104505,\"start\":104494},{\"end\":106582,\"start\":106569},{\"end\":106840,\"start\":106823},{\"end\":108593,\"start\":108564},{\"end\":112113,\"start\":112097},{\"end\":114004,\"start\":113994},{\"end\":114041,\"start\":114007},{\"end\":114668,\"start\":114638},{\"end\":117281,\"start\":117253},{\"end\":118574,\"start\":118564},{\"end\":118630,\"start\":118620},{\"end\":118698,\"start\":118688},{\"end\":119295,\"start\":119285},{\"end\":119776,\"start\":119775},{\"end\":120946,\"start\":120942},{\"end\":125025,\"start\":125015},{\"end\":125673,\"start\":125663},{\"end\":126045,\"start\":126035},{\"end\":126984,\"start\":126973},{\"end\":127084,\"start\":127073},{\"end\":127265,\"start\":127254},{\"end\":128290,\"start\":128285},{\"end\":128585,\"start\":128574},{\"end\":128660,\"start\":128649},{\"end\":129119,\"start\":129093},{\"end\":129397,\"start\":129386},{\"end\":129801,\"start\":129790},{\"end\":130645,\"start\":130634},{\"end\":131001,\"start\":130990},{\"end\":131289,\"start\":131278},{\"end\":131496,\"start\":131485},{\"end\":131534,\"start\":131523},{\"end\":131610,\"start\":131588},{\"end\":132137,\"start\":132126},{\"end\":132297,\"start\":132286},{\"end\":134171,\"start\":134167},{\"end\":141170,\"start\":141161},{\"end\":142517,\"start\":142508},{\"end\":146311,\"start\":146302},{\"end\":147472,\"start\":147463},{\"end\":147732,\"start\":147723},{\"end\":147766,\"start\":147757}]", "table": "[{\"end\":132903,\"start\":132619},{\"end\":134165,\"start\":133538},{\"end\":139743,\"start\":139245},{\"end\":141159,\"start\":140760},{\"end\":142506,\"start\":141494},{\"end\":146300,\"start\":143166},{\"end\":147055,\"start\":146717},{\"end\":147461,\"start\":147084},{\"end\":147721,\"start\":147493},{\"end\":147959,\"start\":147830}]", "figure_caption": "[{\"end\":118618,\"start\":118576},{\"end\":118686,\"start\":118632},{\"end\":118745,\"start\":118700},{\"end\":118950,\"start\":118748},{\"end\":119157,\"start\":118953},{\"end\":119283,\"start\":119160},{\"end\":119773,\"start\":119297},{\"end\":120940,\"start\":119777},{\"end\":125013,\"start\":120949},{\"end\":125661,\"start\":125027},{\"end\":126033,\"start\":125675},{\"end\":126971,\"start\":126047},{\"end\":127071,\"start\":126987},{\"end\":127252,\"start\":127087},{\"end\":128283,\"start\":127268},{\"end\":128572,\"start\":128292},{\"end\":128647,\"start\":128588},{\"end\":129091,\"start\":128663},{\"end\":129384,\"start\":129124},{\"end\":129788,\"start\":129400},{\"end\":130632,\"start\":129804},{\"end\":130988,\"start\":130648},{\"end\":131276,\"start\":131004},{\"end\":131483,\"start\":131292},{\"end\":131521,\"start\":131499},{\"end\":131586,\"start\":131537},{\"end\":132124,\"start\":131615},{\"end\":132284,\"start\":132140},{\"end\":132499,\"start\":132300},{\"end\":132619,\"start\":132502},{\"end\":133393,\"start\":132906},{\"end\":133538,\"start\":133396},{\"end\":139245,\"start\":134174},{\"end\":140760,\"start\":139746},{\"end\":141389,\"start\":141172},{\"end\":141494,\"start\":141392},{\"end\":142626,\"start\":142519},{\"end\":143166,\"start\":142629},{\"end\":146717,\"start\":146313},{\"end\":147084,\"start\":147058},{\"end\":147493,\"start\":147474},{\"end\":147755,\"start\":147734},{\"end\":147830,\"start\":147768}]", "figure_ref": "[{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":9266,\"start\":9258},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":9995,\"start\":9986},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":10009,\"start\":10000},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":11747,\"start\":11738},{\"end\":13462,\"start\":13454},{\"end\":15398,\"start\":15390},{\"attributes\":{\"ref_id\":\"fig_12\"},\"end\":16202,\"start\":16194},{\"attributes\":{\"ref_id\":\"fig_7\"},\"end\":16285,\"start\":16276},{\"attributes\":{\"ref_id\":\"fig_3\"},\"end\":19922,\"start\":19914},{\"attributes\":{\"ref_id\":\"fig_1\"},\"end\":23926,\"start\":23918},{\"attributes\":{\"ref_id\":\"fig_3\"},\"end\":26395,\"start\":26387},{\"attributes\":{\"ref_id\":\"fig_7\"},\"end\":30298,\"start\":30290},{\"attributes\":{\"ref_id\":\"fig_7\"},\"end\":30597,\"start\":30588},{\"attributes\":{\"ref_id\":\"fig_7\"},\"end\":32222,\"start\":32213},{\"end\":32492,\"start\":32484},{\"attributes\":{\"ref_id\":\"fig_7\"},\"end\":33191,\"start\":33182},{\"attributes\":{\"ref_id\":\"fig_7\"},\"end\":34424,\"start\":34415},{\"end\":35383,\"start\":35375},{\"end\":35755,\"start\":35747},{\"end\":36084,\"start\":36076},{\"end\":50664,\"start\":50654},{\"attributes\":{\"ref_id\":\"fig_12\"},\"end\":59539,\"start\":59531},{\"attributes\":{\"ref_id\":\"fig_12\"},\"end\":61204,\"start\":61195},{\"attributes\":{\"ref_id\":\"fig_13\"},\"end\":62568,\"start\":62560},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":63751,\"start\":63741},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":63766,\"start\":63756},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":63917,\"start\":63908},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":64287,\"start\":64278},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":65223,\"start\":65214},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":65564,\"start\":65555},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":65817,\"start\":65808},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":66889,\"start\":66880},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":67982,\"start\":67973},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":68883,\"start\":68874},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":69411,\"start\":69402},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":72392,\"start\":72383},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":81050,\"start\":81040},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":81658,\"start\":81650},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":83005,\"start\":82996},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":83192,\"start\":83182},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":83876,\"start\":83867},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":84034,\"start\":84025},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":84097,\"start\":84089},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":84865,\"start\":84855},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":85190,\"start\":85181},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":88762,\"start\":88753},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":92432,\"start\":92423},{\"attributes\":{\"ref_id\":\"fig_7\"},\"end\":92914,\"start\":92906},{\"attributes\":{\"ref_id\":\"fig_21\"},\"end\":93440,\"start\":93431},{\"attributes\":{\"ref_id\":\"fig_21\"},\"end\":93916,\"start\":93906},{\"attributes\":{\"ref_id\":\"fig_21\"},\"end\":94199,\"start\":94190},{\"attributes\":{\"ref_id\":\"fig_7\"},\"end\":96506,\"start\":96497},{\"end\":97982,\"start\":97974},{\"attributes\":{\"ref_id\":\"fig_1\"},\"end\":99156,\"start\":99147},{\"attributes\":{\"ref_id\":\"fig_7\"},\"end\":99297,\"start\":99288},{\"attributes\":{\"ref_id\":\"fig_23\"},\"end\":99330,\"start\":99321},{\"attributes\":{\"ref_id\":\"fig_1\"},\"end\":99557,\"start\":99548},{\"attributes\":{\"ref_id\":\"fig_7\"},\"end\":101384,\"start\":101375},{\"attributes\":{\"ref_id\":\"fig_7\"},\"end\":101638,\"start\":101629},{\"attributes\":{\"ref_id\":\"fig_3\"},\"end\":101671,\"start\":101662},{\"attributes\":{\"ref_id\":\"fig_11\"},\"end\":106209,\"start\":106200},{\"attributes\":{\"ref_id\":\"fig_12\"},\"end\":107313,\"start\":107304},{\"attributes\":{\"ref_id\":\"fig_13\"},\"end\":107731,\"start\":107722},{\"attributes\":{\"ref_id\":\"fig_1\"},\"end\":110437,\"start\":110428},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":112763,\"start\":112754},{\"attributes\":{\"ref_id\":\"fig_1\"},\"end\":113640,\"start\":113631},{\"attributes\":{\"ref_id\":\"fig_1\"},\"end\":114565,\"start\":114556}]", "bib_author_first_name": "[{\"end\":150022,\"start\":150021},{\"end\":150182,\"start\":150181},{\"end\":150194,\"start\":150193},{\"end\":150196,\"start\":150195},{\"end\":150216,\"start\":150206},{\"end\":150408,\"start\":150407},{\"end\":150416,\"start\":150415},{\"end\":150431,\"start\":150430},{\"end\":150441,\"start\":150440},{\"end\":150451,\"start\":150450},{\"end\":150465,\"start\":150464},{\"end\":150477,\"start\":150476},{\"end\":150773,\"start\":150772},{\"end\":150783,\"start\":150782},{\"end\":150792,\"start\":150791},{\"end\":150794,\"start\":150793},{\"end\":150806,\"start\":150805},{\"end\":150814,\"start\":150813},{\"end\":150823,\"start\":150822},{\"end\":150844,\"start\":150843},{\"end\":150861,\"start\":150860},{\"end\":150875,\"start\":150874},{\"end\":150893,\"start\":150892},{\"end\":151376,\"start\":151375},{\"end\":151386,\"start\":151385},{\"end\":151395,\"start\":151394},{\"end\":151679,\"start\":151678},{\"end\":151690,\"start\":151689},{\"end\":151704,\"start\":151703},{\"end\":151706,\"start\":151705},{\"end\":151719,\"start\":151718},{\"end\":151730,\"start\":151729},{\"end\":151740,\"start\":151739},{\"end\":151749,\"start\":151748},{\"end\":151751,\"start\":151750},{\"end\":151759,\"start\":151758},{\"end\":151769,\"start\":151768},{\"end\":151779,\"start\":151778},{\"end\":152123,\"start\":152122},{\"end\":152125,\"start\":152124},{\"end\":152133,\"start\":152132},{\"end\":152142,\"start\":152141},{\"end\":152153,\"start\":152152},{\"end\":152165,\"start\":152164},{\"end\":152173,\"start\":152172},{\"end\":152183,\"start\":152182},{\"end\":152185,\"start\":152184},{\"end\":152196,\"start\":152195},{\"end\":152198,\"start\":152197},{\"end\":152209,\"start\":152208},{\"end\":152226,\"start\":152225},{\"end\":152235,\"start\":152234},{\"end\":152245,\"start\":152244},{\"end\":153280,\"start\":153279},{\"end\":153282,\"start\":153281},{\"end\":153473,\"start\":153472},{\"end\":153483,\"start\":153482},{\"end\":153493,\"start\":153492},{\"end\":153510,\"start\":153509},{\"end\":153524,\"start\":153523},{\"end\":153531,\"start\":153530},{\"end\":153539,\"start\":153538},{\"end\":153550,\"start\":153549},{\"end\":153559,\"start\":153558},{\"end\":153570,\"start\":153569},{\"end\":153908,\"start\":153907},{\"end\":153910,\"start\":153909},{\"end\":153918,\"start\":153917},{\"end\":153933,\"start\":153932},{\"end\":154047,\"start\":154046},{\"end\":154059,\"start\":154058},{\"end\":154069,\"start\":154068},{\"end\":154081,\"start\":154080},{\"end\":154092,\"start\":154091},{\"end\":154348,\"start\":154347},{\"end\":154350,\"start\":154349},{\"end\":154359,\"start\":154358},{\"end\":154361,\"start\":154360},{\"end\":154556,\"start\":154555},{\"end\":154564,\"start\":154563},{\"end\":154566,\"start\":154565},{\"end\":154575,\"start\":154574},{\"end\":154584,\"start\":154583},{\"end\":154594,\"start\":154593},{\"end\":154607,\"start\":154606},{\"end\":154617,\"start\":154616},{\"end\":154627,\"start\":154626}]", "bib_author_last_name": "[{\"end\":150030,\"start\":150023},{\"end\":150191,\"start\":150183},{\"end\":150202,\"start\":150197},{\"end\":150220,\"start\":150217},{\"end\":150226,\"start\":150222},{\"end\":150413,\"start\":150409},{\"end\":150428,\"start\":150417},{\"end\":150438,\"start\":150432},{\"end\":150448,\"start\":150442},{\"end\":150462,\"start\":150452},{\"end\":150474,\"start\":150466},{\"end\":150488,\"start\":150478},{\"end\":150780,\"start\":150774},{\"end\":150789,\"start\":150784},{\"end\":150803,\"start\":150795},{\"end\":150811,\"start\":150807},{\"end\":150820,\"start\":150815},{\"end\":150841,\"start\":150824},{\"end\":150858,\"start\":150845},{\"end\":150872,\"start\":150862},{\"end\":150890,\"start\":150876},{\"end\":150901,\"start\":150894},{\"end\":151249,\"start\":151243},{\"end\":151383,\"start\":151377},{\"end\":151392,\"start\":151387},{\"end\":151402,\"start\":151396},{\"end\":151408,\"start\":151404},{\"end\":151687,\"start\":151680},{\"end\":151701,\"start\":151691},{\"end\":151716,\"start\":151707},{\"end\":151727,\"start\":151720},{\"end\":151737,\"start\":151731},{\"end\":151746,\"start\":151741},{\"end\":151756,\"start\":151752},{\"end\":151766,\"start\":151760},{\"end\":151776,\"start\":151770},{\"end\":151788,\"start\":151780},{\"end\":152130,\"start\":152126},{\"end\":152139,\"start\":152134},{\"end\":152150,\"start\":152143},{\"end\":152162,\"start\":152154},{\"end\":152170,\"start\":152166},{\"end\":152180,\"start\":152174},{\"end\":152193,\"start\":152186},{\"end\":152206,\"start\":152199},{\"end\":152223,\"start\":152210},{\"end\":152232,\"start\":152227},{\"end\":152242,\"start\":152236},{\"end\":152250,\"start\":152246},{\"end\":153288,\"start\":153283},{\"end\":153480,\"start\":153474},{\"end\":153490,\"start\":153484},{\"end\":153507,\"start\":153494},{\"end\":153521,\"start\":153511},{\"end\":153528,\"start\":153525},{\"end\":153536,\"start\":153532},{\"end\":153547,\"start\":153540},{\"end\":153556,\"start\":153551},{\"end\":153567,\"start\":153560},{\"end\":153578,\"start\":153571},{\"end\":153915,\"start\":153911},{\"end\":153930,\"start\":153919},{\"end\":153941,\"start\":153934},{\"end\":154056,\"start\":154048},{\"end\":154066,\"start\":154060},{\"end\":154078,\"start\":154070},{\"end\":154089,\"start\":154082},{\"end\":154099,\"start\":154093},{\"end\":154356,\"start\":154351},{\"end\":154372,\"start\":154362},{\"end\":154561,\"start\":154557},{\"end\":154572,\"start\":154567},{\"end\":154581,\"start\":154576},{\"end\":154591,\"start\":154585},{\"end\":154604,\"start\":154595},{\"end\":154614,\"start\":154608},{\"end\":154624,\"start\":154618},{\"end\":154639,\"start\":154628}]", "bib_entry": "[{\"attributes\":{\"id\":\"b0\",\"matched_paper_id\":14742574},\"end\":150177,\"start\":149946},{\"attributes\":{\"id\":\"b1\"},\"end\":150357,\"start\":150179},{\"attributes\":{\"doi\":\"arXiv:1312.5602\",\"id\":\"b2\"},\"end\":150702,\"start\":150359},{\"attributes\":{\"id\":\"b3\",\"matched_paper_id\":515925},\"end\":151167,\"start\":150704},{\"attributes\":{\"id\":\"b4\"},\"end\":151373,\"start\":151169},{\"attributes\":{\"doi\":\"arXiv:1705.04304\",\"id\":\"b5\"},\"end\":151600,\"start\":151375},{\"attributes\":{\"id\":\"b6\",\"matched_paper_id\":204972004},\"end\":152034,\"start\":151602},{\"attributes\":{\"doi\":\"arXiv:1904.10079\",\"id\":\"b7\"},\"end\":152592,\"start\":152036},{\"attributes\":{\"id\":\"b8\"},\"end\":152836,\"start\":152594},{\"attributes\":{\"id\":\"b9\"},\"end\":153212,\"start\":152838},{\"attributes\":{\"id\":\"b10\"},\"end\":153374,\"start\":153214},{\"attributes\":{\"id\":\"b11\",\"matched_paper_id\":54457125},\"end\":153853,\"start\":153376},{\"attributes\":{\"id\":\"b12\"},\"end\":154044,\"start\":153855},{\"attributes\":{\"doi\":\"arXiv:1707.06347\",\"id\":\"b13\"},\"end\":154317,\"start\":154046},{\"attributes\":{\"id\":\"b14\",\"matched_paper_id\":207779694},\"end\":154553,\"start\":154319},{\"attributes\":{\"id\":\"b15\"},\"end\":154967,\"start\":154555}]", "bib_title": "[{\"end\":150019,\"start\":149946},{\"end\":150770,\"start\":150704},{\"end\":151676,\"start\":151602},{\"end\":152943,\"start\":152838},{\"end\":153470,\"start\":153376},{\"end\":154345,\"start\":154319}]", "bib_author": "[{\"end\":150032,\"start\":150021},{\"end\":150193,\"start\":150181},{\"end\":150206,\"start\":150193},{\"end\":150222,\"start\":150206},{\"end\":150228,\"start\":150222},{\"end\":150415,\"start\":150407},{\"end\":150430,\"start\":150415},{\"end\":150440,\"start\":150430},{\"end\":150450,\"start\":150440},{\"end\":150464,\"start\":150450},{\"end\":150476,\"start\":150464},{\"end\":150490,\"start\":150476},{\"end\":150782,\"start\":150772},{\"end\":150791,\"start\":150782},{\"end\":150805,\"start\":150791},{\"end\":150813,\"start\":150805},{\"end\":150822,\"start\":150813},{\"end\":150843,\"start\":150822},{\"end\":150860,\"start\":150843},{\"end\":150874,\"start\":150860},{\"end\":150892,\"start\":150874},{\"end\":150903,\"start\":150892},{\"end\":151251,\"start\":151243},{\"end\":151385,\"start\":151375},{\"end\":151394,\"start\":151385},{\"end\":151404,\"start\":151394},{\"end\":151410,\"start\":151404},{\"end\":151689,\"start\":151678},{\"end\":151703,\"start\":151689},{\"end\":151718,\"start\":151703},{\"end\":151729,\"start\":151718},{\"end\":151739,\"start\":151729},{\"end\":151748,\"start\":151739},{\"end\":151758,\"start\":151748},{\"end\":151768,\"start\":151758},{\"end\":151778,\"start\":151768},{\"end\":151790,\"start\":151778},{\"end\":152132,\"start\":152122},{\"end\":152141,\"start\":152132},{\"end\":152152,\"start\":152141},{\"end\":152164,\"start\":152152},{\"end\":152172,\"start\":152164},{\"end\":152182,\"start\":152172},{\"end\":152195,\"start\":152182},{\"end\":152208,\"start\":152195},{\"end\":152225,\"start\":152208},{\"end\":152234,\"start\":152225},{\"end\":152244,\"start\":152234},{\"end\":152252,\"start\":152244},{\"end\":153290,\"start\":153279},{\"end\":153482,\"start\":153472},{\"end\":153492,\"start\":153482},{\"end\":153509,\"start\":153492},{\"end\":153523,\"start\":153509},{\"end\":153530,\"start\":153523},{\"end\":153538,\"start\":153530},{\"end\":153549,\"start\":153538},{\"end\":153558,\"start\":153549},{\"end\":153569,\"start\":153558},{\"end\":153580,\"start\":153569},{\"end\":153917,\"start\":153907},{\"end\":153932,\"start\":153917},{\"end\":153943,\"start\":153932},{\"end\":154058,\"start\":154046},{\"end\":154068,\"start\":154058},{\"end\":154080,\"start\":154068},{\"end\":154091,\"start\":154080},{\"end\":154101,\"start\":154091},{\"end\":154358,\"start\":154347},{\"end\":154374,\"start\":154358},{\"end\":154563,\"start\":154555},{\"end\":154574,\"start\":154563},{\"end\":154583,\"start\":154574},{\"end\":154593,\"start\":154583},{\"end\":154606,\"start\":154593},{\"end\":154616,\"start\":154606},{\"end\":154626,\"start\":154616},{\"end\":154641,\"start\":154626}]", "bib_venue": "[{\"end\":150050,\"start\":150032},{\"end\":150241,\"start\":150228},{\"end\":150405,\"start\":150359},{\"end\":150909,\"start\":150903},{\"end\":151241,\"start\":151169},{\"end\":151472,\"start\":151426},{\"end\":151796,\"start\":151790},{\"end\":152120,\"start\":152036},{\"end\":152658,\"start\":152594},{\"end\":153002,\"start\":152945},{\"end\":153277,\"start\":153214},{\"end\":153587,\"start\":153580},{\"end\":153905,\"start\":153855},{\"end\":154156,\"start\":154117},{\"end\":154423,\"start\":154374},{\"end\":154741,\"start\":154641}]"}}}, "year": 2023, "month": 12, "day": 17}