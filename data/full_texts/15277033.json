{"id": 15277033, "updated": "2023-11-12 17:58:39.693", "metadata": {"title": "Fixed-Rate Compressed Floating-Point Arrays", "authors": "[{\"first\":\"Peter\",\"last\":\"Lindstrom\",\"middle\":[]}]", "venue": "IEEE Transactions on Visualization and Computer Graphics", "journal": "IEEE Transactions on Visualization and Computer Graphics", "publication_date": {"year": 2014, "month": null, "day": null}, "abstract": "Current compression schemes for floating-point data commonly take fixed-precision values and compress them to a variable-length bit stream, complicating memory management and random access. We present a fixed-rate, near-lossless compression scheme that maps small blocks of 4d values in d dimensions to a fixed, user-specified number of bits per block, thereby allowing read and write random access to compressed floating-point data at block granularity. Our approach is inspired by fixed-rate texture compression methods widely adopted in graphics hardware, but has been tailored to the high dynamic range and precision demands of scientific applications. Our compressor is based on a new, lifted, orthogonal block transform and embedded coding, allowing each per-block bit stream to be truncated at any point if desired, thus facilitating bit rate selection using a single compression scheme. To avoid compression or decompression upon every data access, we employ a software write-back cache of uncompressed blocks. Our compressor has been designed with computational simplicity and speed in mind to allow for the possibility of a hardware implementation, and uses only a small number of fixed-point arithmetic operations per compressed value. We demonstrate the viability and benefits of lossy compression in several applications, including visualization, quantitative data analysis, and numerical simulation.", "fields_of_study": "[\"Medicine\"]", "external_ids": {"arxiv": null, "mag": "2052440657", "acl": null, "pubmed": "26356981", "pubmedcentral": null, "dblp": "journals/tvcg/Lindstrom14", "doi": "10.1109/tvcg.2014.2346458"}}, "content": {"source": {"pdf_hash": "5164163dfe32185fead63649d28ff6ea62f23565", "pdf_src": "ScienceParsePlus", "pdf_uri": null, "oa_url_match": false, "oa_info": {"license": null, "open_access_url": "https://www.osti.gov/biblio/1228014", "status": "GREEN"}}, "grobid": {"id": "9e912ec45c152ac44f534665796b9f9034ff19d4", "type": "plain-text", "url": "s3://ai2-s2-science-parse-plus-prod/parse-results/s2orc_worker/5164163dfe32185fead63649d28ff6ea62f23565.txt", "contents": "\n\n\n\nPeter Lindstrom pl@llnl.gov. \nCenter for Applied Scientific Computing\nLawrence Livermore National Laboratory\n\n862903A795649D5A4F331E9C62EA6B2Creceived 31 Mar. 2014; accepted 1 Aug. 2014; date of publication xx xxx 2014; date of current version xx xxx 2014.Data compressionfloating-point arraysorthogonal block transformembedded coding\nCurrent compression schemes for floating-point data commonly take fixed-precision values and compress them to a variable-length bit stream, complicating memory management and random access.We present a fixed-rate, near-lossless compression scheme that maps small blocks of 4 d values in d dimensions to a fixed, user-specified number of bits per block, thereby allowing read and write random access to compressed floating-point data at block granularity.Our approach is inspired by fixed-rate texture compression methods widely adopted in graphics hardware, but has been tailored to the high dynamic range and precision demands of scientific applications.Our compressor is based on a new, lifted, orthogonal block transform and embedded coding, allowing each per-block bit stream to be truncated at any point if desired, thus facilitating bit rate selection using a single compression scheme.To avoid compression or decompression upon every data access, we employ a software write-back cache of uncompressed blocks.Our compressor has been designed with computational simplicity and speed in mind to allow for the possibility of a hardware implementation, and uses only a small number of fixed-point arithmetic operations per compressed value.We demonstrate the viability and benefits of lossy compression in several applications, including visualization, quantitative data analysis, and numerical simulation.\n\nINTRODUCTION\n\nCurrent trends in high-performance computing point to an exponential increase in core count and commensurate decrease in memory bandwidth per core.Similar bandwidth shortages are already observed for I/O, inter-node communication, and between CPU and GPU memory.This trend suggests that the performance of future computations will be dictated in large part by the amount of data movement.Moreover, with large data sets often being generated remotely, e.g. on shared compute clusters or in the cloud, the cost of transferring the results of the computation for visual exploration, quantitative analysis, and archival storage can be substantial.This increase in compute power has also led to a new challenge in visualization: with insufficient I/O bandwidth to store the simulation results at high enough temporal or spatial fidelity for off-line analysis, in situ visualization is needed that runs in tandem with the simulation.\n\nHere the visualization has to compete with the simulation for the same memory and bandwidth resources, putting further strain on the system.\n\nOne approach to alleviating this data movement bottleneck is to remove any redundancy in the data, e.g. using data compression.With abundant compute power at our disposal, using otherwise wasted compute cycles to compress the data makes sense if it can be done quickly enough to feed the compute-starved cores.However, for scientific applications that predominantly work with large arrays of floating-point numbers, lossless compression affords only modest data reductions.\n\nLossy compression has long been accepted in computer graphics, for instance for reduced storage of textures, and dedicated hardware for texture de-compression is now common in GPUs and mobile devices [1].Such compressed formats and related efforts in visualization on rendering from compressed storage [12,15,41] have primarily been motivated from the standpoint of preserving visual fidelity, whereas quantitative analysis and numerical simulation place stricter requirements on tolerable errors.Moreover, these techniques tend to be highly asymmetric, with compression speed sacrificed in favor of as-fast-as-possible decompression.However, many tasks in visualization require online computation of derived fields, while simulation evolves fields over time.Both are uses cases where compressed reads cannot happen without prior compressed writes.\n\nThe goal of this work is to develop a compressed floating-point array primitive, analogous to compressed textures, that supports fast compression and decompression, but tailored to the high-precision, numerical data common in science and engineering applications.To be effective, we require lossy compression.We note that while this may seem a controversial proposition, there is nothing \"magic\" about the 64-bit precision currently used.As we will show, many visualization and simulation tasks can cope with far less precision-and even fewer bits per value, by using compression.\n\nA major obstacle to be cleared first is the support for random access.Current lossy compression methods have primarily been designed to produce the shortest bit stream possible using variable-length coding, and as a result do not easily handle random access, especially when the compressed stream has to be updated whenever the data is modified.Even methods like Samplify's APAX compressor [48] that have some support for fixed rate achieve this only via a feedback loop that periodically adapts the level of compression, and likewise don't support random access.\n\nTo respond to these needs, we present a fixed-rate compression scheme that supports random read and write access to d-dimensional floating-point arrays at the granularity of small blocks of 4 d values (e.g. 4 \u00d7 4 \u00d7 4 values in 3D).Our compressed array primitive is wrapped by a C++ interface that to the user appears like a regular linear or multidimensional array, and which uses a software cache, whose size can be specified by the user, under the hood to limit the frequency of compression and decompression.The resulting C++ class can be substituted into applications very easily with minimal code changes, thus reducing the memory footprint and bandwidth consumption, or increasing the size of arrays that can fit in memory.We show that while currently executed in software, our compressed array incurs only a minor performance penalty in visualization applications.\n\nAlthough the main ingredients of our compressor-orthogonal block transform and embedded coding-are not new ideas, each stage of the compressor has been carefully designed to achive high speed, implementation simplicity, symmetric performance, SNR scalability, fine bit rate granularity, and the level of quality demanded by applications that process single-or double-precision data, such as quantitative data analysis, visualization, and numerical simulation.Moreover, our design is simple in order to accommodate a hardware implementation.At up to 400 MB/s throughput, our software codec is an order of magnitude slower than per-core memory bandwidth, but virtually instant in relation to current I/O rates.Part of its speed is due to a new, simplified block transform that has an elegant lifted implementation, and which we believe will have applications beyond floating-point compression.\n\nTo our knowledge, this is the first solution that serves as a generalpurpose compressed representation of floating-point arrays, that supports both efficient, fine-grained read and write access enabled by fixed-rate compression, and that allows the user to specify the exact number of bits to allocate to each array.\n\n\nPREVIOUS WORK\n\nWe here review current state of the art in compression of floating-point data, as well as related work on fixed-rate compression of images.\n\n\nLossless floating-point compression\n\nThe majority of work on compression of double-precision data has focused on lossless compression, justifiably so as such precision is most often used in situations that demand accuracy.With few exceptions, these methods use linear prediction and encode the smaller residuals using some variant of non-statistical [5,9,39] or statistical [14,21,30] variable-length codes (e.g.entropy codes).The methods by Burtscher and co-workers [5,39] are notable in that they rely on hash functions to extract non-linear relationships.The issue of what makes a good predictor has been further explored by Fout and Ma [13].Although important in many applications, lossless methods rarely achieve more than 1.5x compression on double-precision data, and therefore have only limited impact on bandwidth reduction.\n\n\nLossy floating-point compression\n\nThe idea of using compression to effectively increase bandwidth [49] and the amount of data that can be stored in memory for visualization is at least two decades old [14,35,45].Like the pioneering work of Ning and Hesselink [35], Schneider and Westermann [41] proposed a lossy compression method based on vector quantization (VQ) to render volume data directly from compressed storage.While supporting random access reads, generating good VQ codebooks on the fly can be expensive, and VQ is not easily amenable to rate control.Several related efforts have focused on volume rendering from compressed storage [11,15,31], primarily with the goal of minimizing the perceptual error in rendered images, and with the assumption of compress-once, read-only access.These approaches are predominantly asymmetric, with fast decompression but slow compression [12].Our scheme bears some resemblance to the DCT-based coders of Yeo and Liu [50] and Laurance and Monro [28], but uses smaller blocks for more fine-grained access and a more efficient transform and coding scheme, while also supporting fixed-rate coding to enable random-access writes.\n\nThe majority of these prior methods have proven effective in volume rendering applications by exploiting the data access pattern (e.g. as slices), limited data precision (e.g. 8 bits), an anticipated transfer function, or the need for perceptually but not necessarily numerically accurate results [8].It is, however, unknown how these methods would fare on nonvisual, quantitative tasks other than volume rendering.Indeed, one contribution of our paper is such an evaluation of lossy compression on analysis and simulation tasks.\n\nCompression has also been recognized within the high-performance computing community as a potential way of reducing data movement, e.g. for accelerating I/O and communication, but even for reducing memory bus traffic within simulations [2,3,19,22,25,27].This trend is notable, as computational scientists are warming up to the prospect of using lossy compression, not only for visualization and data analysis, but also on the simulation state itself.\n\nIn the recent study by Laney et al. [27], the simulation state is stored compressed and is then decompressed in its entirety at the beginning of each time step to simulate the effects of inline compression.Such an approach does not reduce memory bandwidth, however, unless the entire uncompressed state fits in cache.In this paper we consider a tighter integration of compression, where the state is decompressed piecemeal on demand to a small cache, and is possibly written back to persistent compressed storage once or multiple times per time step.\n\n\nImage, Texture, and Buffer Compression\n\nA substantial body of work exists on compression of images, textures, and GPU buffers.Many of today's image formats represent a spectrum of compression techniques that we could draw upon for encoding 2D and 3D arrays.For instance, the GIF format uses vector quantization on RGB color vectors; PNG and JPEG-LS use linear prediction; JPEG, like our solution, uses block transform coding; JPEG XR relies on lapped transforms; while JPEG2000 uses higher-order wavelets.These formats also represent a progression of increasing complexity and quality.We find lapped transforms [32], in which the basis functions extend across block boundaries, unsuitable since they preclude blocks from being compressed and decompressed independently.For the same reasons, wavelets other than the Haar basis have wide stencils and cascading data dependencies at coarser resolution that span block boundaries.\n\nIn part to address these issues, many texture compression formats have been proposed [10,20,36,43].Like our representation, these partition the texture up into small blocks and allocate a fixed number of bits of compressed storage per block.Unfortunately, these formats are unsuitable for our purposes, as they exploit the low dynamic range and precision (typically 8-bit) of natural images and the limitations of human vision in order to preserve visual similarity.Moreover, few of them support bit rate selection beyond one or two fixed settings.\n\nToday's GPUs store data other than textures, such as depth and color buffers.These buffers, with few exceptions [38], demand lossless persistent storage [1,37,44], but it is often feasible to read from them using a lossy transmission mode or to benefit from lossless transmission of portions that compress well.The goal in buffer compression is to reduce bandwidth rather than storage.In this paper we achieve both via lossy compression.\n\n\nCOMPRESSION SCHEME\n\nOur compression scheme for 3D double-precision data is inspired by ideas developed for texture compression of 2D image data.As in most texture compression formats, we divide the 3D array into small, fixedsize blocks of dimensions 4 \u00d7 4 \u00d7 4 that are each stored using the same, user-specified number of bits, and which can be accessed entirely independently.At a high level, our method compresses a block by performing the following sequence of steps: (1) align the values in a block to a common exponent; (2) convert the floating-point values to a fixed-point representation; (3) apply an orthogonal block transform to decorrelate the values; (4) order the transform coefficients by expected magnitude; and (5) encode the resulting coefficients one \"bit plane\" at a time.We will detail each of these steps below.\n\n\nConversion to Fixed-Point\n\nWith a hardware implementation in mind, we begin by converting the double-precision values in a 4 \u00d7 4 \u00d7 4 block to a common fixedpoint format, as in [46,48].This alignment of values, aka.blockfloating-point storage, is done by expressing each value with respect to the largest floating-point exponent in a block, which is stored uncompressed at the head of the block, resulting in normalized values in the range (\u22121, +1).We use a Q3.60 fixed-point two's complement format that allows numbers in the range [\u22128, +8) to be represented, i.e. a 64-bit signed integer i represents the value 2 \u221260 i.Although the floating-point values after exponent normalization lie in a smaller range (\u22121, +1), the subsequent block transform stage requires additional precision to represent intermediate values and final transform coefficients.Note that the implicit leading one bit of non-zero floatingpoint numbers is represented explicitly in this fixed-point format.\n\n\nBlock Transform\n\nWe transform the fixed-point values to a basis that allows the spatially correlated values to be mostly decorrelated, as this results in many near-zero coefficients that can be compressed efficiently.As is common for regularly gridded data, we employ a separable transform in d dimensions that can be expressed as d 1D transforms along each dimension, resulting in a basis that is the tensor product of 1D basis functions.Our goal is thus to find a suitable 1D basis.\n\nMany discrete orthogonal block transforms have been proposed, each with their pros and cons.Examples include the discrete Haar wavelet transform (HWT), the slant transform (ST), the family of discrete cosine transforms (DCT), among which DCT-II from JPEG is the most common, the high-correlation transform (HCT) used in H.264, the Walsh-Hadamard transform (WHT), and the discrete Hartley transform (DHT); see, e.g., [47].Another orthogonal basis is the Gram polynomial (aka.discrete Chebyshev polynomial) basis (GP).\n\nWe make the observation that in the case of transformations of 4vectors, all of the above transforms can be expressed as orthogonal matrices of the form\nA = 1 2 H f d 1 1 1 1 c s \u2212s \u2212c 1 \u22121 \u22121 1 s \u2212c c \u2212s I g e(1)s = \u221a 2 sin \u03c0 2 t c = \u221a 2 cos \u03c0 2 t(2)\nwhere t \u2208 [0, 1] is a parameter.Based on these definitions, t = {0, 2 \u03c0 tan \u22121 1 3 , 1 4 , 2 \u03c0 tan \u22121 1 2 , 1 2 } corresponds to HWT (90 degrees phase shifted), ST, DCT-II, HCT, and WHT, respectively, with DHT coinciding with WHT and GP with ST (modulo sign differences and/or permutation of the basis vectors).To our knowledge, this is the first such parametric description that unifies several well-known orthogonal transforms.\n\nWe now form a separable basis for 3D blocks by taking tensor products of the basis vectors (rows) of A:\nB ijk (x, y, z) = bi(x) \u2297 bj(y) \u2297 b k (z)(3)\nwith 0 \u2264 i, j, k \u2264 3, ||B|| = 1, and where bi is the i th basis vector of A (and similarly for bj and b k ).Transforming a block to this basis is equivalent to performing a sequence of independent 1D transforms along x, y, and z.We will later order the basis functions by sequency [47], i.e. by i + j + k, which can be thought of as a generalization of the zigzag ordering used in JPEG to 3D arrays.We may think of the indices i, j, k as encoding the polynomial degree of the corresponding 1D basis functions (this is certainly true for the Gram basis), with 0 \u2264 i + j + k \u2264 9 representing the total degree.This divides the basis functions into ten equivalence classes.for general values of s and c.In our transform s = 1 2 , and therefore y * = s and w /= s are replaced with y /= 2 and w * = 2.\n\n\nLifted Implementation\n\nA na\u00efve implementation of the transform would either unfold the block into a 64-vector and apply multiplication by the 64 \u00d7 64 basis matrix, or perform a sequence of forty-eight 4 \u00d7 4 matrix multiplications by taking advantage of separability.Fortunately any orthogonal matrix can be decomposed into a sequence of plane rotations, each of which can be expressed efficiently using the lifting scheme [7] via in-place additions, subtractions, and multiplications.The unique structure of our basis A leads to a very efficient lifted implementation.\n\nIn order to eliminate unnecessary sign changes, we slightly rewrite the basis by negating the last two rows of A and let A denote this modified basis.This change affects only the signs of the transform coefficients and has no impact on orthogonality or error.The resulting forward transform A can then be implemented as shown in Listing 1.The inverse transform simply reverses the sequence of steps, with addition and multiplication interchanged with subtraction and division.\n\nAlthough the polyphase decomposition of the transform is not unique [7], we have chosen this particular sequence of lifting steps in order to minimize range expansion of the intermediate quantities.This is an important consideration since the transform is implemented in fixed point and could otherwise overflow.For inputs in (\u22121, +1), each output (and intermediate) quantity lies in (\u22122, +2), and after three separable passes in (\u22128, +8).The tradeoff is some slight loss in precision due to the irreversible divisions by two.Note that multiplications and divisions by two can be implemented as bit shifts and, while not exploited here, the sixteen 4-vectors can be transformed in parallel, with the independent lifting steps enabling additional concurrency.\n\n\nA New, Computationally Efficient Transform\n\nThe above lifted transform, while efficient, requires both multiplication and division by s.Although the division can be implemented as a multiplication by the reciprocal of the constant s, these integer multiplications are nevertheless the most expensive operations involved in the transform.Using the judicious choice s = 1 2 , we turn these multiplications into bit shifts.Remarkably, this choice is not only attractive from a performance standpoint, but is also near optimal in terms of decorrelation efficiency and coding gain, two measures that are commonly used to assess the effectiveness of orthogonal transforms [6].The decorrelation efficiency \u03b7 and coding gain \u03b3 are both computed from the 64 \u00d7 64 covariance matrix \u03a3 = [\u03c3 2 ij ] of the transformed signal, where each of the 64 entries in a block is considered to be a random variable that we seek to decorrelate to improve compression.These quantities are given by\n\u03b7 = i \u03c3 2 ii i j |\u03c3 2 ij | \u03b3 = i \u03c3 2 ii 64 i \u03c3 2 ii \u00a1 1/64(4)\nUsing 21 scalar fields from different simulations, comprising nearly 0.8 billion floating-point values in total, we computed \u03b7(t) and \u03b3(t) as functions of the transform parameter t (cf.Eq. ( 2)).To obtain comparable units for the different quantities represented by the fields, we first normalized the variance of each field to unity and then computed the aggregate covariance matrix across all fields, from which \u03b7 and \u03b3 were obtained.For ease of interpretation, we normalized \u03b3 by the maximum coding gain possible, as given by the (data-dependent) Karhunen-Lo\u00e8ve Transform (KLT), which produces a diagonal covariance matrix.As Fig. 2 shows, our choice t = 2 \u03c0 cot \u22121 \u221a 7 \u2248 0.230 is close to optimal, both with respect to \u03b7 and \u03b3, for these fields.Furthermore, this choice allows us to replace generic multiplications and divisions with bit shifts (Listing 1).\n\nThe resulting transform involves 8 additions, 6 bit shifts (by one), and 2 integer multiplications per transformed 4-vector.Amortized over each numerical value, the complete 3D transform uses 6 additions, 4.5 shifts, and 1.5 multiplications per compressed scalar.This compares quite favorably with the 64 multiplications and 63 additions per scalar required by a na\u00efve matrix-vector product implementation of the transform.It is also reasonably competitive with the Lorenzo predictor employed in FPZIP [30], which requires 7 floating-point additions per compressed value.\n\nThe 64-bit fixed-point multiplications could be implemented as four 32-bit multiplications (with 64-bit products) and some bit shifting.We note that in our transform, c =\n\u221a 7 2 \u2248 1.323 \u2248 10837 2 13\n. This rational approximation is accurate to 7 digits and results in the bottom 32 bits of c being zero, allowing the fixed-point multiplication to be executed as only two instead of four 32-bit integer multiplications.We use this value of c for our results.\n\nA hardware implementation might prefer an even simpler approximation c \u2248 5  4 .Multiplication by this constant can be efficiently performed using one addition and a shift by two, allowing the entire transform to be implemented using only integer addition and bit shifting.Note that the orthogonality of the basis and invertibility of the transform are independent of the choice of c, and as long as c \u2264 further range expansion occurs.c does, however, affect the norm of the basis vectors and thus the relative magnitudes of the transform coefficients.We also observed that this crude approximation of c tends to result in some degradation in quality.\n\n\nEmbedded Coding\n\nGiven a collection of transform coefficients, most of which are expected to be small in magnitude, how should they be encoded to yield the best quality for a given bit budget?Ideally, the codec should allow for many different bit rates (as prescribed by the user).Toward this end, we turn to embedded encoding, which produces a stream of bits that are ordered roughly by their impact on error.We note that due to the orthogonality of our transform, the root mean square (RMS) error in the signal domain equals the RMS error in the transform domain, and in this sense all coefficients are equally important.More precisely, all coefficient bits within the same \"bit plane\" have the same impact on error, and hence our strategy is to encode one bit plane at a time.\n\nIn embedded coding, each bit encodes some partial information about the signal, and any prefix of this stream can be decoded independently to yield a valid solution (with any unencoded bit set to zero by the decoder).In this manner, we may use a single codec to produce a full (near) lossless encoding of each block, and this stream can then be truncated to satisfy the user-specified bit rate.Moreover, any already compressed block can be degraded in fidelity by simply further truncating the bit stream, i.e. with no need for recompression.\n\nSeveral embedded coding strategies exist, among which embedded zerotrees [42] and set partitioning [40] are among the better known, both having been designed for coding wavelet coefficients.Hong and Ladner [17] showed that both of these schemes can be thought of as variants of group testing-a procedure originally invented to test consolidated blood samples for infectious disease among larger populations.We employ a custom group testing procedure to encode our transform coefficients.\n\nThe main idea is to perform a set of significance tests, with each test returning which (signed) coefficients are larger in magnitude than a given threshold.Using progressively smaller thresholds that are powers of two, this amounts to determining which coefficients have a one bit in the current bit plane, not counting those coefficients that were found to be significant in a previous pass.The idea behind group testing is to test not individual coefficients but groups of them as a whole, with the assumption that most of them are insignificant.Thus, a single bit can be used to encode that a whole collection of coefficients are insignificant with respect to the current threshold.\n\nIf at least one coefficient in a group is significant, the group is refined by splitting it into two smaller groups, and the procedure is applied recursively until each significant group consists of a single coefficient.For each such significant coefficient, we first encode its sign and then place it onto the list of significant coefficients, whose remaining, less significant bits will be encoded verbatim for subsequent bit planes.The remaining, insignificant groups are then further refined in subsequent passes, until each coefficient is significant or zero, or until we have exhausted the bit budget.\n\nHow should we group coefficients for group testing?Unlike in [18], we cannot group corresponding coefficients across blocks, since we must allow each block to be decompressed independently.Instead, we make the observation that the signal energy tends to decrease with frequency, and consequently we expect the magnitudes of coefficients to be ordered by sequency.This is indeed the case, as evidenced by the box plot shown in Fig. 3. Thus, placing the coefficients in sequency order results in a nearly sorted list.For any significant group, we expect the significant coefficients to come from the lower-sequency half, and that in each refined group the coefficients will have roughly the same magnitude.Once a group is found to be significant, we next test the subgroup expected to be insignificant, since when this is the case we may infer that the other subgroup must be significant, eliminating the need to test that group and encode the redundant result.\n\nAssuming groups are always split in equal halves, this recursive structure gives rise to a complete binary tree, where each internal node corresponds to a group of leaves (its descendants).The partitioning into groups corresponds to a cut through this tree, and each group test amounts to encoding, using one bit, a node on the cut.If the bit is zero (insignificant), the node is left on the cut until the next bit plane is coded.Otherwise, it is refined by replacing it with its children.Thus, for each bit plane we make a breadth-first traversal of the tree and refine the cut as needed.Once a leaf node is found to be significant, we mark it as such and remove it from the cut.Each bit plane pass then sends one value bit for each significant node followed by group test bits that refine the cut.\n\nWe note that a balanced tree structure is not necessarily optimal.For instance, as seen in Fig. 3, the DC component (far left in the plot) usually has a greater magnitude than the other coefficients.In a balanced tree, the group refinement that first exposes the DC component as the only significant coefficient splits the coefficients into log 2 N +1 progressively smaller groups, (where N = 64 is the block size), and each of the log 2 N = 6 insignificant groups are then tested in subsequent passes, even though they are often all insignificant (see Fig. 4).\n\nTo address this issue, we use an unbalanced tree that locates the low-sequency components near the root, and where groups of highersequency coefficients are stored progressively deeper in the tree.This results in fewer groups initially, allowing more value bits to be coded (Fig. 4, bottom).We found that this unbalancing of the tree gave a 2-6 dB increase in PSNR at low bit rates.For efficiency, we represent the cut in the tree as a single 127-bit mask, the set of significant coefficients as a 64-bit mask, and the (fixed) tree structure as an array of per-node \"pointers\" to the left child (siblings have consecutive coefficient indices).\n\n\nCACHING\n\nAs presented, the proposed scheme would for each floating-point value accessed require decompressing its corresponding block and then compressing and storing the block upon each write (or update) access.This would be prohibitively expensive if implemented in software, but also if compression were done in hardware.Not only would this approach incur frequent computation associated with (de)compression, but precious memory bandwidth would also be spent on transferring compressed data over the memory bus.\n\nTo alleviate this bandwidth pressure, we use a small, direct-mapped software cache of decompressed blocks.We use a write-back policy with a \"dirty bit\" stored with each cached block, such that compression is only invoked for blocks evicted from the cache that have been modified.That is, for tasks that do not modify the floating-point array (e.g.many analysis tasks), only decompression is needed, ensuring that the fidelity of the data is not impacted after the initial one-time compression stage.This user-configurable cache represents the only memory overhead in our scheme beyond the compressed blocks.\n\nMany analysis tasks and simulation kernels \"stream through\" the 3D array sequentially in an outer loop and access only immediate neighbors in an inner loop.A similar access pattern is used when gathering or scattering values between data with different centerings, such as between nodes (vertices) and cells (elements).To best support such access patterns, our default cache size accommodates two layers of blocks.Assuming no cache conflicts, this ensures that only compulsory cache misses are incurred when making a sequential pass over the array elements and accessing only immediate neighbors.\n\n\nRESULTS\n\nWe evaluated the quality and speed of our compressor, code named ZFP, on various double-precision fields obtained from four physics simulations: Miranda (an LLNL hydrodynamics code), S3D (a Sandia combustion code), pF3D (an LLNL laser-plasma interaction code), and LULESH (an LLNL shock hydrodynamics proxy application).We ran our experiments on a single core of an iMac with 3.4 GHz Intel Core i7 processors and 32 GB of 1600 MHz DDR3 RAM.We use bpd (bits per double) to refer to the amortized storage cost of each value.\n\n\nQuality\n\nIn order to assess the quality provided by our lossy compression scheme, we report on two quality measures: the peak signal to noise ratio (PSNR) and accuracy.We define PSNR Q for a discrete signal x of length N and approximate signal x as\nQ(x, x) = 10 log 10 \u00a2 1 2 (maxi xi \u2212 mini xi) \u00a3 2 1 N i (xi \u2212 xi) 2(5)\nNote that Q accounts for the absolute error.For applications that are more concerned with element-wise relative error, we measure the accuracy as the number of bits of agreement between two floating-point numbers.Because this measure is not straightforward to define when one number is zero, when the two numbers are of opposite sign, or when they narrowly straddle a power of two, we adopt the following definition.Let I(x) denote the binary integer representation of x obtained by converting the sign-magnitude floating-point representation to a two's complement integer, such that I(x) < I(y) \u21d0\u21d2 x < y.The accuracy \u03b1 of x with respect to x is then given by\n\u03b1(x, x) = 64 \u2212 log 2 (|I(x) \u2212 I(x)| + 1)(6)\nwhere |I(x) \u2212 I(x)| measures the number of floating-point values between x and x. \u03b1 does indeed relate to the number of bits of agreement when the signs and exponents of x and x agree, but also handles numbers with different exponents or signs in an intuitive manner.Rather than reporting the accuracy directly, which tends to vary linearly with the rate, we plot its difference with the rate, which we call the accuracy gain.This gain is the additional number of bits inferred, e.g.via prediction or orthogonal transform, and in a sense is the amount of redundant information exposed and discarded by the compressor.Note that it is possible for the accuracy gain to be negative.\n\nWe compare ZFP with several alternatives.One straightforward way to reduce precision is to store values in single (float) precision.This is common in visualization and analysis, which usually demand less float  precision.Such conversion usually results in a positive accuracy gain of four bits; three of these are due to the difference in number of exponent bits between single and double precision, and the fourth results from rounding rather than truncating the mantissa when converting to float.Two other common approaches are to truncate the mantissa (and even exponent) by discarding (zeroing) least significant bits (with bounded relative error), and to uniformly quantize numbers between the extremal values (with bounded absolute error).\ntruncate quantize ISABELA FPZIP FPZIP 4X4X4 ZFP\nWe also compare with two other lossy floating-point compressors: FPZIP [29,30] and ISABELA [24,25] (using B-splines with W0 = 1024, C = 30, and varying error tolerance ), as well as with lossless compressors GZIP and FPC [4,5] (with a 16 MB hash).FPZIP is primarily a lossless predictive coder, but supports a lossy mode by losslessly compressing truncated mantissas.Hence FPZIP bounds the relative error, as does ISABELA via a tolerance parameter.We found FPZIP to always outperform ISABELA, and we will focus our comparison primarily on FPZIP.Because FPZIP is a streaming variable-rate coder, it does not support localized random access.We attempted a more apples-to-apples comparison by applying FPZIP to the same 4 3sized blocks used by ZFP (while excluding header information).We will refer to this method as FPZIP 4 \u00d7 4 \u00d7 4.\n\nTable 1 lists compression ratios (uncompressed size divided by compressed size), PSNR, and median accuracy for several fields for ZFP and the other compressors.This table also lists for each field its average local dynamic range represented as the median of values log 2 (max |xi|/ min |xi|), where the local extrema are computed over 4 \u00d7 4 \u00d7 4 blocks.In \"lossless\" mode we encoded 58 bit planes for ZFP, which always provided a median accuracy of 64 bits and PSNR of at least 313 dB (i.e.better than floating-point epsilon), and we relaxed the fixed-rate requirement.Even though ZFP was not designed for lossless compression, it performed slightly better than FPZIP and significantly better than FPC in aggregate (harmonic mean compression ratio).We then ran FPZIP in 16-and 32-bit precision mode (truncating mantissas), and assigned a fixed rate to ZFP so that it compressed to the same size as FPZIP.In 32-bit mode, we found FPZIP to give higher PSNR on the easier to compress fields (as hinted by the lossless compression ratios and low dynamic range), while ZFP did better on less compressible data.In virtually all cases, ZFP gave a higher accuracy, however.At higher compression ratios, ZFP also gave significantly higher PSNR.The one anomaly is the single-exponent N2 field, for which ZFP was only allowed 7 bits per block in addition to the common exponent.\n\nFig. 5 plots the PSNR and median accuracy gain for three of these scalar fields: the S3D temperature and oxygen mass fraction fields, and the Miranda viscocity field.These three data sets represent different exponent distributions in the double-precision numbers, from the very low entropy temperature field (only three exponents), to a data set with hundreds of exponents (for predominantly positive numbers), to one with a roughly equal number of negative and positive values.Although the mass fractions should all be non-negative, numerical error caused some of them to be slightly negative.This figure shows that PSNR increases linearly with rate (as expected) for most methods, until reaching infinity when there is no loss.We observe a plateau in PSNR for ZFP reached around 56 bpd.This occurs because the uncompressed data has only 52 bits of mantissa, while we reserve four non-mantissa bits in our fixed-point representation for the sign and extra precision needed by the block transform.Using more than 56 bpd is beneficial only for blocks with non-uniform exponents, where the mantissa is shifted into the least 8 significant bits.For values closer to zero, exponent differences within a block may exceed eight, in which case ZFP loses some low-order mantissa bits, preventing fully lossless compression.However, such low-order bits would also be lost in arithmetic operations like addition whenever the exponents of two operands differ; a loss that is generally accepted.\n\nWe note that other than for the easily compressible temperature field, ZFP outperforms FPZIP by 30-50 dB (i.e.1.5-2.5 decimal digits), and the blocked version of FPZIP and ISABELA by even more-in spite of ZFP being a fixed-rate compressor.ZFP is disadvantaged by easy-to-compress data, in that blocks that compress very well must still be padded to the fixed bit budget.We notice that the PSNR for ZFP exhibits a surprising consistency (e.g.Q \u2248 240 dB at 32 bpd) across the data sets, and is largely unaffected by the compressibility of the data.In contrast, PSNR for FPZIP varies by as much as 80 dB across these three data sets for a fixed bit rate.We see this predictable behavior as a strength of ZFP that is likely to facilitate rate selection.\n\nBecause FPZIP bounds the relative error, it is perhaps not surprising that it does not always perform well in terms of absolute error.The middle row of Fig. 5, which plots the relative error in terms of accuracy gain, reveals a surprise, however.Here FPZIP is again outperformed by ZFP.Moreover, we see that ZFP excels at very low bit rates.This ability to keep both absolute and relative errors low is another strength of ZFP.Because the accuracy gain plus the bit rate equal the accuracy \u03b1 \u2264 64, the plot is bounded by the diagonal line y = 64 \u2212 x, which explains the convergence of the curves to this line.\n\nThe bottom row of Fig. 5 shows at 32 bpd the cumulative distribution of absolute errors normalized by field range (CDF values are shown on the right vertical axis).We see that the maximum error (the rightmost point on each curve) correlates quite well with PSNR.Evidently ZFP achieves low maximum errors even for difficult-tocompress blocks, in spite of the fixed-rate constraint.\n\nWe also evaluated our efficient transform with respect to the discrete cosine transform within the framework of our compressor.On average, we found our transform to give a 1.5-4.0dB improvement in PSNR at low to mid bit rates, and even more in the near-lossless regime.\n\n\nSpeed and Cache Utilization\n\nWe here evaluate the raw speed of our compressor when applied to the 384 \u00d7 384 \u00d7 256 Miranda pressure field (other fields gave similar  results) while performing strided data accesses to the uncompressed array.Fig. 6 shows the throughput in number of uncompressed bytes input from or output to main memory per second, which at 1 bpd tops out around 400 MB/s for our decompressor and 280 MB/s for the compressor.This is roughly comparable to the speed of FPZIP.As the rate increases, progressively more bit planes are processed and output, resulting in a gradual reduction in throughput.\n\nWe also evaluated the speed of ZFP array accesses using the wellknown STREAM benchmark [33] on arrays initialized with the pressure field to avoid trivial compression of constant values.The overhead of translating linear array indices and caching data reduces throughput by a nearly constant 1.7x over raw (de)compression.\n\nTo test the effectiveness of caching decompressed blocks, we used our compressed array in a ray tracer.We measured both cache misses and total rendering time vs. cache size (Fig. 7) while rendering the data set in Fig. 1(b).Other than good correlation between cache misses and rendering time, this figure shows three distinct plateaus.For small caches, many misses occur during initialization when the array is traversed in raster order to precompute which cells intersect the interval volume, as determined by 8 adjacent cell corner values.When smaller than the 96-block wide domain, the cache must be reloaded each time the innermost loop restarts.A similar issue occurs when a whole slice does not fit in cache.We find that in spite of 18 million rays cast, more than half of the cache misses occur during initialization, as consecutive primary rays tend to traverse similar regions of the domain.Once the third, lowest plateau is reached, very few cache misses occur.Using a cache of 16 K blocks and 4 bpd compression, the rendering time of 33 seconds is only slightly longer than the 28 seconds taken without compression, though using 11 times less memory: 18 MB of compressed data and 8 MB of cache, vs. 288 MB uncompressed.Remarkably only 24 MB of compressed data had to be decompressed to satisfy the 3.6 GB worth of floating-point read accesses made.\n\n\nAPPLICATIONS\n\nWe now evaluate our compressor in a number of applications.We note that the total programming effort to modify all of these applications to use our compressor was less than 90 minutes.\n\n\nQuantitative and Visual Analysis\n\nWe begin by assessing the viability of lossy compression for quantitative analysis, which normally is done at reduced (single) precision, and hence we expect some loss in precision to be acceptable.We first consider computing the Fourier spectrum of the density field at the mid plane of a Rayleigh-Taylor instability simulation [26].This is a common analysis method used in hydrodynamics for detecting turbulence, which should manifest itself as an exponentially decaying spectrum with a slope of \u22125/3 at middle frequencies.Fig. 8 shows the spectrum for a late time step in the simulation, where turbulence has set in, and confirms the expected power law.We applied our lossy compressor to this 512 3 double-precision field and reran the spectral analysis The figure shows that low-frequency modes are well represented, but the loss in precision and blocking introduce high-frequency noise, where the spectra disagree.At 4 bpd (16x compression), however, the spectrum is well represented at all but the very highest frequencies, and at 8 bpd the difference is virtually undetectable.Using 4-bit uniform quantization, we obtained comparable results to using 1 bpd compression.We note that the sharp drop in power at the highest frequencies is common in simulation codes, as numerical accuracy demands that the field is well resolved and varies reasonably smoothly at the finest grid scale.\n\nA common objection to block transform coding is the potential for artifacts, which usually manifest themselves as visible discontinuities between blocks (cf.JPEG artifacts).Such discontinuities are also quite evident in the 1 bpd field shown in Fig. 1(a), though perhaps not surprisingly so given the high compression rate.\n\nWe note that even minor discontinuities in a scalar field are usually exposed when computing its derivatives.To test the presence for such artifacts, we computed unstable manifolds of scalar fields using a variation of the technique presented in [16].Each such manifold consists of the set of points in the domain whose downward gradient integral lines converge on the same minimum, and collectively these manifolds segment the domain into spatially coherent pieces.Fig. 10 shows these unstable manifolds for the 2D mid plane of the vertical velocity field (w) from the Miranda run.Similar segmentations were done by Laney et al. [26] to extract \"bubble and spike\" features that characterize the turbulent behavior of the Rayleigh-Taylor instability.Each segment corresponds to a region of downward motion due to gravity associated with a spike during fluid mixing.We notice the spurious extrema and segments in Fig. 10(a), where 64x compression was used.These could possibly be removed using persistencebased simplification.(Differences in segment color are primarily due to minor shifts in the locations of minima.)Nevertheless, most segments are still recognizable, whereas results based on 1-bit truncation or quantization would clearly be nonsensical.At 4 bpd, the segmentation is essentially indistinguishable from ground truth.Fig. 10(d) quantifies the error in segmentation using an information theoretic measure.Here the error is the normalized variation of information 0 \u2264 V (X,Y )\n\nH(X,Y ) \u2264 1, where V (X, Y ) = H(X, Y ) \u2212 I(X; Y ) is the variation of information [34] (a metric) between segmentations X and Y , H(X, Y ) is the joint entropy of corresponding segmentation labels, and I(X; Y ) is their mutual information.This error converges quickly to zero as the bit rate is increased.We conclude that our block transform does not appear to introduce any discontinuities in the field or its first derivatives at 4 bpd and above.\n\n\nVisualization\n\nWe take the discrete approximation to gradients performed above for Morse segmentations one step further and compute streamlines in bilinearly interpolated vector fields using 4 th order Runge-Kutta integration.Any errors in the vector field should be exposed by diverging streamlines with respect to the uncompressed field, as small errors have the potential to grow over the course of integration.Fig. 9 shows streamlines for the uncompressed field in black, overlaid by green streamlines computed for the compressed vector fields.Again we use the mid plane of the RTI simulation, where the vector field is given by the horizontal velocity (u, v), although we extracted this 2D field from the compressed 3D field.At half a bit per double, many per-streamline errors are evident, yet the field is qualitatively a fair approximation of the full 64-bit field.Very few errors (black lines) are evident in the 4 bpd vector field plot.Again, block artifacts do not seem to be significant enough to cause concern.\n\nAs discussed above, we also integrated our compressor with a volumetric ray tracer, which computes interval volumes (the region between two isosurfaces) and spawns secondary rays for shadow casting and ambient occlusion to simulate global illumination (see Fig. 1, for instance).Although the artifacts in Fig. 1(a) are readily visible, the 4 bpd rendering, which also uses gradients for lighting, is virtually indistinguishable from the 64 bpd uncompressed field.\n\n\nBlast Wave Simulation\n\nWe conclude with a more challenging problem that involves both frequent reads from and writes to the compressed array-a fluid dynamics simulation.We used LULESH [23], a shock hydrodynamics code that simulates a point explosion known as a Sedov blast.LULESH is a Lagrangian (moving mesh) C++ code that uses a logically regular 3D grid.The initial point explosion generates a shock wave that propagates radially and distorts the mesh as it travels through the domain.\n\nThe Sedov problem can be solved in closed form, giving r(t) \u221d t 2/5 , where r is the radial position of the shock wave and t is time.\n\nUsing our compressor within LULESH presents a new challengethe fields are not only read at reduced accuracy, but are also updated several times each time step.This periodic decompression and lossy compression introduces errors that may propagate and grow over time, potentially causing the simulation to diverge.Our goal was, thus, to assess whether such divergence was observed in practice, and what levels of compression (if any) were deemed acceptable.We note that this experiment is similar to the one carried out by Laney et al. [27], but differs in that in our case compression and decompression occur over the course of each time step, as dictated by our caching scheme, whereas Laney et al. applied full decompression and compression of the entire state at the beginning and end of each time step.Thus, our experiment is a more challenging stress case, as compression may occur more than once per time step.Furthermore, this example involves fields with a sharp discontinuity near the shock wave that could be difficult to preserve.One important consideration is the cache size to use.Since kernels in LULESH perform gathers and scatters between nodes and cells in raster order, we conjectured that a cache holding two layers of blocks would be sufficient.Using such a cache, LULESH required writeback (lossy compression) of each block 1.18 times per time step on average.Halving the cache size, we observed a dramatic increase in this number to 20.9.Consequently, we used two block layers in our evaluation, representing 1  8 of the 64 3 domain.We note that although per mesh element errors may be observed relative to a run with no compression, the important quantity of interest is the actual shock position r(t), which we measured as the radial position (relative to the point source) of the mesh element of maximal density.For the 1,000 time steps executed, we computed the Pearson correlation coefficient between t and r(t) 5/2 , which theory predicts to be linearly related.For a run using 16 bpd compression, we found the correlation with theory to be 99.994%, with a relative error in final shock position of 0.06% compared to the uncompressed run.Reducing the precision to 12 bpd and 8 bpd, this error increased to 0.80% and 7.38%, respectively.We conclude that in spite of over a thousand applications of lossy compression to each mesh element, the outcome of this simulation did not change appreciably at 4-5x compression.\n\n\nDISCUSSION\n\nAlthough some of the ideas proposed here partially overlap with prior work on compressed representations, we would like to discuss some of the unique aspects and strengths of our approach, potential use cases not covered already, as well as limitations.\n\n\nLimitations\n\nOur representation is inherently limited to regularly gridded data, and it is unclear how it could be adapted to unstructured grids.However, we believe that it could find utility in adaptive mesh refinement codes that use nested regular grids.For effective compression, the data should exhibit some smoothness at fine scales, which is common in simulation data, though observational data may be more noisy.The fact that we handle shocks adequately is a promising sign, however.\n\nAs designed, our scheme cannot easily bound the maximum error incurred.Our approach has been to minimize the RMS error, which we believe is a good compromise between mean and maximum error.Moreover, by relaxing the fixed-rate constraint, we can easily support a fixed-quality mode, where either an absolute or relative error tolerance is met.Doing so requires essentially no changes to the compressor.\n\n\nBenefits\n\nPerhaps one of the main strengths of our approach is its ease of integration.Our compressed array primitive supports a simple C++ interface, including (i, j, k) indexing and flat 1D array view, which allows it to be dropped into existing codes with minimal coding effort.The applications considered here collectively exceed well over 10,000 lines of code, yet our integration of compression required only just over an hour of total programming work to swap out array declarations and add controls for rate selection and cache size.\n\nWe have so far discussed using our compressor for storing static fields in visualization and analysis, and evolving fields in simulation.There is a third important use case: representing large, constant tables of numerical data, such as (multidimensional) equation of state and opacity tables queried by the simulation.These can occupy gigabytes to terabytes and require distributed storage.Using our compressed representation, memory is freed up and communication is reduced while sharing these tables across nodes.\n\nAlthough not stressed here, our compressor allows for a smooth tradeoff between quality and memory usage.Thus, for very large data sets that normally do not fit in main memory, the analysis could nearly always proceed compressed, albeit at reduced accuracy.\n\nBecause the bit stream is embedded, it can be truncated at any point (or lengthened via zero padding).Thus no decompression followed by re-compression is needed to change the precision of a coded block, which could introduce further loss.Rather, a single unified format can be used for simulation, visualization, analysis, off-line storage, etc., with each user choosing only how many bits of precision to retain.\n\nFinally, we are not aware of any other fixed-rate compression scheme for floating-point data, let alone a compressed array primitive.In addition to facilitating random access, the fixed storage size also allows the ordering of compressed blocks to be optimized to improve locality of reference, e.g. for out-of-core computations.\n\n\nCONCLUSION\n\nWe presented a compressed representation of 3D floating-point arrays that supports random-access reads and writes.To achieve high compression ratios, our scheme is lossy, but by allowing the user to specify the exact amount of compression our method can approach lossless mode.In spite of being constrained to meet a fixed rate, our method compares favorably to state-of-the-art variable-length compressorsespecially at low bit rates.Our compressor achieves high quality through a new and efficient orthogonal block transform, and can be implemented using only integer addition and shifting.It is hence very fast, and can through caching nearly entirely hide the overhead of decompression.Although we focused on compression of 3D arrays of double-precision numbers, our approach is straightforward to generalize to single-precision values and arrays of other dimensions.\n\nUsing several examples we demonstrated that 16x compression or more can often be tolerated in visualization and analysis applications, while 4x compression is possible in simulations that demand repeated state updates and, thus, frequent compression and decompression.\n\nFuture work is needed to make our approach more widely applicable, including resolving issues like thread safety, investigating more effective caching, finding good layouts of the compressed blocks, extending the compressor to time-varying data, and further tuning the method for hardware implementation.Some applications may want to adapt the rate spatially.While supported by our compressor, variablelength blocks would require more complicated memory management.We are particularly intrigued by the idea of applying our approach to texture compression, noting that further simplifications can be made to the compressor when working with two-dimensional integer arrays.\n\nFixed-Fig. 1 :\n1\nFig. 1: Interval volume renderings of compressed double-precision floating-point data on a 384 \u00d7 384 \u00d7 256 grid.At 4 bits/double (16x compression) the image is visually indistinguishable from full 64-bit precision.\n\n\nFig. 3 :\n3\nFig.3: Box plot showing the distributions of the number of significant bits for the coefficients associated with the 64 basis functions (grouped and color coded by sequency) based on data from 30 different fields.This plot confirms that the energy is concentrated in the low frequencies.\n\n\nFig. 5 :\n5\nFig.5: Peak signal to noise ratio (top) and median accuracy gain (middle) vs.rate (bpd = bits per double) and cumulative normalized-error distribution at 32 bpd (bottom) for our ZFP method, ISABELA, original FPZIP, FPZIP applied to 4 \u00d7 4 \u00d7 4 blocks, and na\u00efve approaches like mantissa truncation, uniform quantization, and conversion to single-precision floats.The CDFs have been transformed nonlinearly to emphasize the tails.\n\n\nFig. 6 :\n6\nFig.6: Raw compression and decompression throughput in number of uncompressed bytes input or output per second.Higher rates require more bit plane passes in ZFP and thus more time.\n\n\nFig. 7 :\n7\nFig.7: Cache utilization and total rendering time (dashed) as a function of cache size for 4 bpd ray tracing.The full, uncompressed scalar field is 288 MB, and took 28 seconds to render without compression.\n\n\nFig. 8 :\n8\nFig. 8: Density spectrum computed over the 2D mid plane.The spectrum follows a k \u22125/3 power law in the middle region that typifies turbulent behavior.The spectrum is well represented at 4 bpd and above.\n\n\nFig. 9 :\n9\nFig. 9: Streamlines extracted from compressed Rayleigh-Taylor velocity fields.The green lines from each compressed field overlay the black lines from the uncompressed field.\n\n\nFig. 10 :\n10\nFig. 10: (a-c) Morse segmentations of the vertical velocity field from the Rayleigh-Taylor simulation.(d) Segmentation error of unstable manifolds in terms of normalized variation of information as a function of compressed bit budget.\n\n\n\n\nFig. 2: Decorrelation efficiency (blue; note the vertical scale) and coding gain (red) for 21 scalar fields achieved by several transforms parameterized by t \u2208 [0, 1].Evidently our efficient transform is near optimal.\n100%100%99%Ours90%decorrelation efficiency92% 93% 94% 95% 96% 97% 98%SlantDCT-II HCT20% 30% 40% 50% 60% 70% 80%coding gain relative to KLT91%HaarWalsh-Hadamard10%90%0%0.000.250.500.751.00transform family parameter tw -=x;w /= 2;x +=w;y -=z;y /= 2;z +=y;z -=x;x * = 2;x +=z;y * = s;y -= c * w;w * = 2;w += c * y;w /= s;\nListing 1: C implementation of the lifted transform A x y z w \u00a1 T\n\n\nTable 1 :\n1\nCompression ratios, peak signal to noise ratio, and accurary in bits for ZFP and other compressors (the best results appear in bold).DR denotes the median base-2 dynamic range across 4 \u00d7 4 \u00d7 4 blocks.\nlosslessFPZIP 32-bit precisionFPZIP 16-bit precisionfield DRratioratio PSNR accuracy ratioPSNRaccuracyGZIP FPC FPZIP ZFPFPZIP ZFP FPZIP ZFPFPZIP ZFP FPZIP ZFP\u03c10.00 2.11 1.92 2.74 2.61 14.67 120 77 31.2 53.0 37.3 22.7 53.2 15.0 42.0p1.62 1.06 1.13 1.38 1.37 4.47 156 141 32.0 32.5 27.2 59.5 67.9 16.0 19.6u0.77 1.05 1.16 1.46 1.43 5.36 148 130 32.0 32.8 30.6 52.2 66.0 16.0 21.0v0.76 1.05 1.17 1.46 1.43 5.36 148 130 32.0 32.8 31.0 51.5 65.8 16.0 21.0w0.65 1.05 1.17 1.46 1.44 5.45 147 131 32.0 32.8 31.3 51.0 67.7 16.0 21.1\u00b5 7.30 1.04 1.05 1.11 1.21 2.52 156 205 32.0 35.26.7 60.0 110.4 16.0 19.4D 7.32 1.04 1.05 1.12 1.21 2.53 156 204 32.0 35.16.7 60.0 109.9 16.0 19.4T0.00 1.15 1.34 1.65 1.63 8.72 126 95 32.0 34.6 101.5 30.4 36.7 15.8 19.8u0.25 1.05 1.19 1.45 1.44 5.25 135 129 32.0 32.7 36.9 39.0 62.1 16.0 21.0v0.27 1.06 1.17 1.45 1.43 5.28 137 131 32.0 32.6 37.3 40.8 64.9 16.0 20.8w0.32 1.06 1.18 1.45 1.43 5.21 135 132 32.0 32.5 36.9 39.2 65.3 16.0 20.7H 2 0.18 1.12 1.27 1.59 1.58 6.84 126 111 32.0 31.7 50.8 28.0 51.1 15.5 20.8O 2 0.06 1.16 1.29 1.60 1.61 6.53 127 105 32.1 32.2 52.2 31.8 45.9 16.1 21.5O 6.08 1.03 1.07 1.25 1.31 3.27 141 174 32.0 33.0 12.0 44.7 90.5 15.9 19.2OH 6.17 1.03 1.08 1.26 1.33 3.31 141 170 32.0 32.6 11.7 44.7 89.3 16.2 19.2H 2 O 6.02 1.06 1.12 1.30 1.38 3.51 124 161 31.9 31.9 11.9 34.1 86.6 16.4 19.5H 5.89 1.03 1.08 1.24 1.31 3.28 140 171 32.0 33.1 11.7 44.1 88.8 16.1 19.4HO 2 5.59 1.03 1.08 1.24 1.31 3.25 138 151 32.0 33.3 11.7 42.1 67.5 16.1 19.5H 2 O 2 5.91 1.03 1.08 1.24 1.31 3.24 140 156 32.0 33.3 11.5 44.2 72.6 16.1 19.5N 2 0.00 1.24 1.43 1.82 1.81 10.98 113 83 32.0 34.2 226.3 16.8 -1.3 16.6 15.8aggregate 1.09 1.18 1.41 1.44 4.41 138 139 32.0 34.1 18.1 41.8 68.1 16.0 21.0\nThis document was prepared as an account of work sponsored by an agency of the United States government.Neither the United States government nor Lawrence Livermore National Security, LLC, nor any of their employees makes any warranty, expressed or implied, or assumes any legal liability or responsibility for the accuracy, completeness, or usefulness of any information, apparatus, product, or process disclosed, or represents that its use would not infringe privately owned rights.Reference herein to any specific commercial product, process, or service by trade name, trademark, manufacturer, or otherwise does not necessarily constitute or imply its endorsement, recommendation, or favoring by the United States government or Lawrence Livermore National Security, LLC.The views and opinions of authors expressed herein do not necessarily state or reflect those of the United States government or Lawrence Livermore National Security, LLC, and shall not be used for advertising or product endorsement purposes.\nGraphics processing units for handhelds. T Akenine-M\u00f6ller, J Str\u00f6m, Proceedings of the IEEE. the IEEE200896\n\nA methodology for evaluating the impact of data compression on climate simulation data. A H Baker, H Xu, J M Dennis, M N Levy, D Nychka, S A Mickelson, J Edwards, M Vertenstein, A Wegener, ACM Symposium on High-Performance Parallel and Distributed Computing. 2014\n\nIntegrating online compression to accelerate large-scale data analytics applications. T Bicer, J Yin, D Chiu, G Agrawal, K Schuchardt, IEEE International Symposium on Parallel & Distributed Processing. 2013\n\nM Burtscher, FPC version 1. 2006\n\nHigh throughput compression of double-precision floating-point data. M Burtscher, P Ratanaworabhan, Data Compression Conference. 2007\n\nTransform coding of images. R J Clarke, 1985Academic Press, Inc\n\nFactoring wavelet transforms into lifting steps. I Daubechies, W Sweldens, Journal of Fourier Analysis and Applications. 431998\n\nReal-time volume graphics. K Engel, M Hadwiger, J Kniss, A Lefohn, C Salama, D Weiskopf, ACM SIGGRAPH Course #. 282004\n\nLossless compression of highvolume numerical data from simulations. V Engelson, D Fritzson, P Fritzson, Data Compression Conference. 2000\n\nTexture compression using low-frequency signal modulation. S Fenney, Graphics Hardware. 2003\n\nHigh-quality rendering of compressed volume data formats. N Fout, H Akiba, K.-L Ma, A E Lefohn, J Kniss, Eurovis. 2005\n\nTransform coding for hardware-accelerated volume rendering. N Fout, K.-L Ma, IEEE Transactions on Visualization and Computer Graphics. 1362007\n\nAn adaptive prediction-based approach to lossless compression of floating-point volume data. N Fout, K.-L Ma, IEEE Transactions on Visualization and Computer Graphics. 18122012\n\nLossless compression of volume data. J Fowler, R Yagel, IEEE Symposium on Volume Visualization. 1994\n\nReal-time decompression and visualization of animated volume data. S Guthe, W Strasser, IEEE Visualization. 2001\n\nComputing Morse-Smale complexes with accurate geometry. A Gyulassy, P.-T Bremer, V Pascucci, IEEE Transactions on Visualization and Computer Graphics. 18122012\n\nGroup testing for image compression. E S Hong, R E Ladner, IEEE Transactions on Image Processing. 1182002\n\nGroup testing for block transform image compression. E S Hong, R E Ladner, E A Riskin, Asilomar Conference on Signals, Systems and Computers. 2001\n\nEvaluating lossy compression on climate data. N Huebbe, A Wegener, J Kunkel, Y Ling, T Ludwig, International Supercomputing Conference. 2013\n\nSystem and method for fixed-rate block-based image compression with inferred pixel values. K Iourcha, K Nayak, Z Hong, 1999\n\nLossless compression of predicted floating-point geometry. M Isenburg, P Lindstrom, J Snoeyink, Computer-Aided Design. 3782005\n\nFast and effective lossy compression algorithms for scientific datasets. J Iverson, C Kamath, G Karypis, Euro-Par Parallel Processing. 2012\n\nExploring traditional and emerging parallel programming models using a proxy application. I Karlin, A Bhatele, J Keasler, B L Chamberlain, J Cohen, Z Devito, R Haque, D Laney, E Luke, F Wang, D Richards, M Schulz, C Still, IEEE International Parallel & Distributed Processing Symposium. 2013\n\nISABELA version 0. S Lakshminarasimhan, June 20142\n\nCompressing the incompressible with IS-ABELA: In-situ reduction of spatio-temporal data. S Lakshminarasimhan, N Shah, S Ethier, S Klasky, R Latham, R Ross, N F Samatova, Euro-Par Parallel Processing. 2011\n\nUnderstanding the structure of the turbulent mixing layer in hydrodynamic instabilities. D Laney, P.-T Bremer, A Mascarenhas, P Miller, V Pascucci, IEEE Transactions on Visualization and Computer Graphics. 1252006\n\nAssessing the effects of data compression in simulations using physically motivated metrics. D Laney, S Langer, C Weber, P Lindstrom, A Wegener, ACM/IEEE International Conference on High Performance Computing, Networking, Storage and Analysis. 201376\n\nEmbedded DCT coding with significance masking. N K Laurance, D M Monro, IEEE International Conference on Acoustics, Speech, and Signal Processing. 1997\n\nFPZIP version 1.1.0. P Lindstrom, June 2014\n\nFast and efficient compression of floatingpoint data. P Lindstrom, M Isenburg, IEEE Transactions on Visualization and Computer Graphics. 1252006\n\nTexture hardware rendering of timevarying volume data. E B Lum, K.-L Ma, J Clyne, IEEE Visualization. 2001\n\nExtended lapped transforms: Properties, applications, and fast algorithms. H S Malvar, IEEE Transactions on Signal Processing. 40111992\n\nMemory bandwidth and machine balance in current high performance computers. J D Mccalpin, IEEE Computer Society Technical Committee on Computer Architecture (TCCA) Newsletter. 1995\n\nComparing clusterings by the variation of information. M Meila, Learning Theory and Kernel Machines. 2003\n\nVector quantization for volume rendering. P Ning, L Hesselink, In ACM Workshop on. Visualization1992\n\nAdaptive scalable texture compression. J Nystad, A Lassen, A Pomianowski, S Ellis, T Olson, Eurographics/ACM SIGGRAPH Symposium on High Performance Graphics. 2012\n\nLossless compression of variableprecision floating-point buffers on GPUs. J Pool, A Lastra, M Singh, ACM SIGGRAPH Symposium on Interactive 3D Graphics and Games. 2012\n\nError-bounded lossy compression of floating-point color buffers using quadtree decomposition. J Rasmusson, J Str\u00f6m, T Akenine-M\u00f6ller, The Visual Computer. 2612010\n\nFast lossless compression of scientific floating-point data. P Ratanaworabhan, J Ke, M Burtscher, Data Compression Conference. 2006\n\nA new, fast, and efficient image codec based on set partitioning in hierarchical trees. A Said, W A Pearlman, IEEE Transactions on Circuits and Systems for Video Technology. 631996\n\nCompression domain volume rendering. J Schneider, R Westermann, IEEE Visualization. 2003\n\nEmbedded image coding using zerotrees of wavelet coefficients. J M Shapiro, IEEE Transactions on Signal Processing. 41121993\n\niPACKMAN: High-quality, lowcomplexity texture compression for mobile phones. J Str\u00f6m, T Akeninie-M\u00f6ller, Graphics Hardware. 2005\n\nFloating-point buffer compression in a unified codec architecture. J Str\u00f6m, P Wennersten, J Rasmusson, J Hasselgren, J Munkberg, P Clarberg, T Akenine-M\u00f6ller, Graphics Hardware. 2008\n\nWavelets applied to lossless compression and progressive transmission of floating point data in 3-D curvilinear grids. A Trott, R Moorhead, J Mcginley, IEEE Visualization. 1996\n\nJPEG2000 extensions for bit plane coding of floating point data. B E Usevitch, Data Compression Conference. 2003451\n\nOrthogonal Transforms. R Wang, 2012Cambridge University Press\n\nBlock floating point compression of signal data. A Wegener, 2012\n\nRevisiting wavelet compression for large-scale climate data using JPEG 2000 and ensuring data precision. J Woodring, S Mniszewski, C Brislawn, D Demarle, J Ahrens, IEEE Large Data Analysis and Visualization. 2011\n\nVolume rendering of DCT-based compressed 3D scalar data. B.-L Yeo, B Liu, IEEE Transactions on Visualization and Computer Graphics. 111995\n", "annotations": {"author": "[{\"end\":114,\"start\":4}]", "publisher": null, "author_last_name": "[{\"end\":19,\"start\":10}]", "author_first_name": "[{\"end\":9,\"start\":4}]", "author_affiliation": "[{\"end\":113,\"start\":34}]", "title": null, "venue": null, "abstract": "[{\"end\":1747,\"start\":339}]", "bib_ref": "[{\"attributes\":{\"ref_id\":\"b0\"},\"end\":3512,\"start\":3509},{\"attributes\":{\"ref_id\":\"b11\"},\"end\":3615,\"start\":3611},{\"attributes\":{\"ref_id\":\"b14\"},\"end\":3618,\"start\":3615},{\"attributes\":{\"ref_id\":\"b40\"},\"end\":3621,\"start\":3618},{\"attributes\":{\"ref_id\":\"b47\"},\"end\":5135,\"start\":5131},{\"attributes\":{\"ref_id\":\"b4\"},\"end\":7901,\"start\":7898},{\"attributes\":{\"ref_id\":\"b8\"},\"end\":7903,\"start\":7901},{\"attributes\":{\"ref_id\":\"b38\"},\"end\":7906,\"start\":7903},{\"attributes\":{\"ref_id\":\"b13\"},\"end\":7926,\"start\":7922},{\"attributes\":{\"ref_id\":\"b20\"},\"end\":7929,\"start\":7926},{\"attributes\":{\"ref_id\":\"b29\"},\"end\":7932,\"start\":7929},{\"attributes\":{\"ref_id\":\"b4\"},\"end\":8018,\"start\":8015},{\"attributes\":{\"ref_id\":\"b38\"},\"end\":8021,\"start\":8018},{\"attributes\":{\"ref_id\":\"b12\"},\"end\":8192,\"start\":8188},{\"attributes\":{\"ref_id\":\"b48\"},\"end\":8486,\"start\":8482},{\"attributes\":{\"ref_id\":\"b13\"},\"end\":8589,\"start\":8585},{\"attributes\":{\"ref_id\":\"b34\"},\"end\":8592,\"start\":8589},{\"attributes\":{\"ref_id\":\"b44\"},\"end\":8595,\"start\":8592},{\"attributes\":{\"ref_id\":\"b34\"},\"end\":8647,\"start\":8643},{\"attributes\":{\"ref_id\":\"b40\"},\"end\":8678,\"start\":8674},{\"attributes\":{\"ref_id\":\"b10\"},\"end\":9031,\"start\":9027},{\"attributes\":{\"ref_id\":\"b14\"},\"end\":9034,\"start\":9031},{\"attributes\":{\"ref_id\":\"b30\"},\"end\":9037,\"start\":9034},{\"attributes\":{\"ref_id\":\"b11\"},\"end\":9273,\"start\":9269},{\"attributes\":{\"ref_id\":\"b49\"},\"end\":9351,\"start\":9347},{\"attributes\":{\"ref_id\":\"b27\"},\"end\":9379,\"start\":9375},{\"attributes\":{\"ref_id\":\"b7\"},\"end\":9857,\"start\":9854},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":10327,\"start\":10324},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":10329,\"start\":10327},{\"attributes\":{\"ref_id\":\"b18\"},\"end\":10332,\"start\":10329},{\"attributes\":{\"ref_id\":\"b21\"},\"end\":10335,\"start\":10332},{\"attributes\":{\"ref_id\":\"b24\"},\"end\":10338,\"start\":10335},{\"attributes\":{\"ref_id\":\"b26\"},\"end\":10341,\"start\":10338},{\"attributes\":{\"ref_id\":\"b26\"},\"end\":10580,\"start\":10576},{\"attributes\":{\"ref_id\":\"b31\"},\"end\":11708,\"start\":11704},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":12110,\"start\":12106},{\"attributes\":{\"ref_id\":\"b19\"},\"end\":12113,\"start\":12110},{\"attributes\":{\"ref_id\":\"b35\"},\"end\":12116,\"start\":12113},{\"attributes\":{\"ref_id\":\"b42\"},\"end\":12119,\"start\":12116},{\"attributes\":{\"ref_id\":\"b37\"},\"end\":12687,\"start\":12683},{\"attributes\":{\"ref_id\":\"b0\"},\"end\":12727,\"start\":12724},{\"attributes\":{\"ref_id\":\"b36\"},\"end\":12730,\"start\":12727},{\"attributes\":{\"ref_id\":\"b43\"},\"end\":12733,\"start\":12730},{\"attributes\":{\"ref_id\":\"b45\"},\"end\":14026,\"start\":14022},{\"attributes\":{\"ref_id\":\"b47\"},\"end\":14029,\"start\":14026},{\"attributes\":{\"ref_id\":\"b46\"},\"end\":15731,\"start\":15727},{\"attributes\":{\"ref_id\":\"b46\"},\"end\":16946,\"start\":16942},{\"attributes\":{\"ref_id\":\"b6\"},\"end\":17885,\"start\":17882},{\"attributes\":{\"ref_id\":\"b6\"},\"end\":18579,\"start\":18576},{\"attributes\":{\"ref_id\":\"b5\"},\"end\":19938,\"start\":19935},{\"attributes\":{\"ref_id\":\"b29\"},\"end\":21672,\"start\":21668},{\"attributes\":{\"ref_id\":\"b41\"},\"end\":24252,\"start\":24248},{\"attributes\":{\"ref_id\":\"b39\"},\"end\":24278,\"start\":24274},{\"attributes\":{\"ref_id\":\"b16\"},\"end\":24385,\"start\":24381},{\"attributes\":{\"ref_id\":\"b17\"},\"end\":26026,\"start\":26022},{\"attributes\":{\"ref_id\":\"b28\"},\"end\":33765,\"start\":33761},{\"attributes\":{\"ref_id\":\"b29\"},\"end\":33768,\"start\":33765},{\"attributes\":{\"ref_id\":\"b23\"},\"end\":33785,\"start\":33781},{\"attributes\":{\"ref_id\":\"b24\"},\"end\":33788,\"start\":33785},{\"attributes\":{\"ref_id\":\"b3\"},\"end\":33914,\"start\":33911},{\"attributes\":{\"ref_id\":\"b4\"},\"end\":33916,\"start\":33914},{\"attributes\":{\"ref_id\":\"b32\"},\"end\":40099,\"start\":40095},{\"attributes\":{\"ref_id\":\"b25\"},\"end\":42262,\"start\":42258},{\"attributes\":{\"ref_id\":\"b15\"},\"end\":43895,\"start\":43891},{\"attributes\":{\"ref_id\":\"b25\"},\"end\":44279,\"start\":44275},{\"attributes\":{\"ref_id\":\"b33\"},\"end\":45225,\"start\":45221},{\"attributes\":{\"ref_id\":\"b22\"},\"end\":47269,\"start\":47265},{\"attributes\":{\"ref_id\":\"b26\"},\"end\":48244,\"start\":48240}]", "figure": "[{\"attributes\":{\"id\":\"fig_0\"},\"end\":55441,\"start\":55208},{\"attributes\":{\"id\":\"fig_1\"},\"end\":55742,\"start\":55442},{\"attributes\":{\"id\":\"fig_2\"},\"end\":56183,\"start\":55743},{\"attributes\":{\"id\":\"fig_3\"},\"end\":56377,\"start\":56184},{\"attributes\":{\"id\":\"fig_4\"},\"end\":56597,\"start\":56378},{\"attributes\":{\"id\":\"fig_5\"},\"end\":56813,\"start\":56598},{\"attributes\":{\"id\":\"fig_6\"},\"end\":57000,\"start\":56814},{\"attributes\":{\"id\":\"fig_7\"},\"end\":57250,\"start\":57001},{\"attributes\":{\"id\":\"tab_0\",\"type\":\"table\"},\"end\":57857,\"start\":57251},{\"attributes\":{\"id\":\"tab_2\",\"type\":\"table\"},\"end\":59797,\"start\":57858}]", "paragraph": "[{\"end\":2690,\"start\":1763},{\"end\":2832,\"start\":2692},{\"end\":3307,\"start\":2834},{\"end\":4157,\"start\":3309},{\"end\":4739,\"start\":4159},{\"end\":5304,\"start\":4741},{\"end\":6177,\"start\":5306},{\"end\":7070,\"start\":6179},{\"end\":7388,\"start\":7072},{\"end\":7545,\"start\":7406},{\"end\":8381,\"start\":7585},{\"end\":9555,\"start\":8418},{\"end\":10086,\"start\":9557},{\"end\":10538,\"start\":10088},{\"end\":11090,\"start\":10540},{\"end\":12019,\"start\":11133},{\"end\":12569,\"start\":12021},{\"end\":13008,\"start\":12571},{\"end\":13843,\"start\":13031},{\"end\":14822,\"start\":13873},{\"end\":15309,\"start\":14842},{\"end\":15827,\"start\":15311},{\"end\":15981,\"start\":15829},{\"end\":16510,\"start\":16081},{\"end\":16615,\"start\":16512},{\"end\":17457,\"start\":16661},{\"end\":18028,\"start\":17483},{\"end\":18506,\"start\":18030},{\"end\":19266,\"start\":18508},{\"end\":20240,\"start\":19313},{\"end\":21164,\"start\":20303},{\"end\":21737,\"start\":21166},{\"end\":21909,\"start\":21739},{\"end\":22195,\"start\":21937},{\"end\":22847,\"start\":22197},{\"end\":23629,\"start\":22867},{\"end\":24173,\"start\":23631},{\"end\":24662,\"start\":24175},{\"end\":25350,\"start\":24664},{\"end\":25959,\"start\":25352},{\"end\":26920,\"start\":25961},{\"end\":27721,\"start\":26922},{\"end\":28284,\"start\":27723},{\"end\":28929,\"start\":28286},{\"end\":29447,\"start\":28941},{\"end\":30056,\"start\":29449},{\"end\":30654,\"start\":30058},{\"end\":31188,\"start\":30666},{\"end\":31439,\"start\":31200},{\"end\":32170,\"start\":31511},{\"end\":32894,\"start\":32215},{\"end\":33641,\"start\":32896},{\"end\":34520,\"start\":33690},{\"end\":35888,\"start\":34522},{\"end\":37373,\"start\":35890},{\"end\":38124,\"start\":37375},{\"end\":38735,\"start\":38126},{\"end\":39117,\"start\":38737},{\"end\":39388,\"start\":39119},{\"end\":40006,\"start\":39420},{\"end\":40330,\"start\":40008},{\"end\":41691,\"start\":40332},{\"end\":41892,\"start\":41708},{\"end\":43318,\"start\":41929},{\"end\":43643,\"start\":43320},{\"end\":45136,\"start\":43645},{\"end\":45587,\"start\":45138},{\"end\":46613,\"start\":45605},{\"end\":47078,\"start\":46615},{\"end\":47569,\"start\":47104},{\"end\":47704,\"start\":47571},{\"end\":50148,\"start\":47706},{\"end\":50416,\"start\":50163},{\"end\":50909,\"start\":50432},{\"end\":51312,\"start\":50911},{\"end\":51856,\"start\":51325},{\"end\":52374,\"start\":51858},{\"end\":52633,\"start\":52376},{\"end\":53048,\"start\":52635},{\"end\":53379,\"start\":53050},{\"end\":54264,\"start\":53394},{\"end\":54534,\"start\":54266},{\"end\":55207,\"start\":54536},{\"end\":55440,\"start\":55226},{\"end\":55741,\"start\":55454},{\"end\":56182,\"start\":55755},{\"end\":56376,\"start\":56196},{\"end\":56596,\"start\":56390},{\"end\":56812,\"start\":56610},{\"end\":56999,\"start\":56826},{\"end\":57249,\"start\":57015},{\"end\":57471,\"start\":57254},{\"end\":57856,\"start\":57791},{\"end\":58071,\"start\":57871}]", "formula": "[{\"attributes\":{\"id\":\"formula_0\"},\"end\":16042,\"start\":15982},{\"attributes\":{\"id\":\"formula_1\"},\"end\":16080,\"start\":16042},{\"attributes\":{\"id\":\"formula_2\"},\"end\":16660,\"start\":16616},{\"attributes\":{\"id\":\"formula_3\"},\"end\":20302,\"start\":20241},{\"attributes\":{\"id\":\"formula_4\"},\"end\":21936,\"start\":21910},{\"attributes\":{\"id\":\"formula_5\"},\"end\":31510,\"start\":31440},{\"attributes\":{\"id\":\"formula_6\"},\"end\":32214,\"start\":32171}]", "table_ref": "[{\"attributes\":{\"ref_id\":\"tab_2\"},\"end\":34529,\"start\":34528}]", "section_header": "[{\"attributes\":{\"n\":\"1\"},\"end\":1761,\"start\":1749},{\"attributes\":{\"n\":\"2\"},\"end\":7404,\"start\":7391},{\"attributes\":{\"n\":\"2.1\"},\"end\":7583,\"start\":7548},{\"attributes\":{\"n\":\"2.2\"},\"end\":8416,\"start\":8384},{\"attributes\":{\"n\":\"2.3\"},\"end\":11131,\"start\":11093},{\"attributes\":{\"n\":\"3\"},\"end\":13029,\"start\":13011},{\"attributes\":{\"n\":\"3.1\"},\"end\":13871,\"start\":13846},{\"attributes\":{\"n\":\"3.2\"},\"end\":14840,\"start\":14825},{\"attributes\":{\"n\":\"3.2.1\"},\"end\":17481,\"start\":17460},{\"attributes\":{\"n\":\"3.2.2\"},\"end\":19311,\"start\":19269},{\"attributes\":{\"n\":\"3.3\"},\"end\":22865,\"start\":22850},{\"attributes\":{\"n\":\"4\"},\"end\":28939,\"start\":28932},{\"attributes\":{\"n\":\"5\"},\"end\":30664,\"start\":30657},{\"attributes\":{\"n\":\"5.1\"},\"end\":31198,\"start\":31191},{\"attributes\":{\"n\":\"5.2\"},\"end\":39418,\"start\":39391},{\"attributes\":{\"n\":\"6\"},\"end\":41706,\"start\":41694},{\"attributes\":{\"n\":\"6.1\"},\"end\":41927,\"start\":41895},{\"attributes\":{\"n\":\"6.2\"},\"end\":45603,\"start\":45590},{\"attributes\":{\"n\":\"6.3\"},\"end\":47102,\"start\":47081},{\"attributes\":{\"n\":\"7\"},\"end\":50161,\"start\":50151},{\"attributes\":{\"n\":\"7.1\"},\"end\":50430,\"start\":50419},{\"attributes\":{\"n\":\"7.2\"},\"end\":51323,\"start\":51315},{\"attributes\":{\"n\":\"8\"},\"end\":53392,\"start\":53382},{\"end\":55223,\"start\":55209},{\"end\":55451,\"start\":55443},{\"end\":55752,\"start\":55744},{\"end\":56193,\"start\":56185},{\"end\":56387,\"start\":56379},{\"end\":56607,\"start\":56599},{\"end\":56823,\"start\":56815},{\"end\":57011,\"start\":57002},{\"end\":57868,\"start\":57859}]", "table": "[{\"end\":57790,\"start\":57472},{\"end\":59797,\"start\":58072}]", "figure_caption": "[{\"end\":55441,\"start\":55225},{\"end\":55742,\"start\":55453},{\"end\":56183,\"start\":55754},{\"end\":56377,\"start\":56195},{\"end\":56597,\"start\":56389},{\"end\":56813,\"start\":56609},{\"end\":57000,\"start\":56825},{\"end\":57250,\"start\":57014},{\"end\":57472,\"start\":57253},{\"end\":58072,\"start\":57870}]", "figure_ref": "[{\"end\":20938,\"start\":20937},{\"attributes\":{\"ref_id\":\"fig_1\"},\"end\":26393,\"start\":26392},{\"attributes\":{\"ref_id\":\"fig_1\"},\"end\":27820,\"start\":27819},{\"end\":28282,\"start\":28281},{\"end\":28567,\"start\":28566},{\"attributes\":{\"ref_id\":\"fig_2\"},\"end\":35896,\"start\":35895},{\"attributes\":{\"ref_id\":\"fig_2\"},\"end\":38284,\"start\":38283},{\"attributes\":{\"ref_id\":\"fig_2\"},\"end\":38761,\"start\":38760},{\"attributes\":{\"ref_id\":\"fig_3\"},\"end\":39636,\"start\":39635},{\"attributes\":{\"ref_id\":\"fig_4\"},\"end\":40512,\"start\":40511},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":40555,\"start\":40551},{\"attributes\":{\"ref_id\":\"fig_5\"},\"end\":42460,\"start\":42459},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":43571,\"start\":43570},{\"attributes\":{\"ref_id\":\"fig_7\"},\"end\":44118,\"start\":44116},{\"attributes\":{\"ref_id\":\"fig_7\"},\"end\":44567,\"start\":44562},{\"attributes\":{\"ref_id\":\"fig_7\"},\"end\":44988,\"start\":44984},{\"attributes\":{\"ref_id\":\"fig_6\"},\"end\":46010,\"start\":46009},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":46878,\"start\":46877},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":46926,\"start\":46925}]", "bib_author_first_name": "[{\"end\":60854,\"start\":60853},{\"end\":60872,\"start\":60871},{\"end\":61010,\"start\":61009},{\"end\":61012,\"start\":61011},{\"end\":61021,\"start\":61020},{\"end\":61027,\"start\":61026},{\"end\":61029,\"start\":61028},{\"end\":61039,\"start\":61038},{\"end\":61041,\"start\":61040},{\"end\":61049,\"start\":61048},{\"end\":61059,\"start\":61058},{\"end\":61061,\"start\":61060},{\"end\":61074,\"start\":61073},{\"end\":61085,\"start\":61084},{\"end\":61100,\"start\":61099},{\"end\":61273,\"start\":61272},{\"end\":61282,\"start\":61281},{\"end\":61289,\"start\":61288},{\"end\":61297,\"start\":61296},{\"end\":61308,\"start\":61307},{\"end\":61395,\"start\":61394},{\"end\":61498,\"start\":61497},{\"end\":61511,\"start\":61510},{\"end\":61592,\"start\":61591},{\"end\":61594,\"start\":61593},{\"end\":61678,\"start\":61677},{\"end\":61692,\"start\":61691},{\"end\":61785,\"start\":61784},{\"end\":61794,\"start\":61793},{\"end\":61806,\"start\":61805},{\"end\":61815,\"start\":61814},{\"end\":61825,\"start\":61824},{\"end\":61835,\"start\":61834},{\"end\":61946,\"start\":61945},{\"end\":61958,\"start\":61957},{\"end\":61970,\"start\":61969},{\"end\":62076,\"start\":62075},{\"end\":62169,\"start\":62168},{\"end\":62177,\"start\":62176},{\"end\":62189,\"start\":62185},{\"end\":62195,\"start\":62194},{\"end\":62197,\"start\":62196},{\"end\":62207,\"start\":62206},{\"end\":62291,\"start\":62290},{\"end\":62302,\"start\":62298},{\"end\":62468,\"start\":62467},{\"end\":62479,\"start\":62475},{\"end\":62590,\"start\":62589},{\"end\":62600,\"start\":62599},{\"end\":62722,\"start\":62721},{\"end\":62731,\"start\":62730},{\"end\":62825,\"start\":62824},{\"end\":62840,\"start\":62836},{\"end\":62850,\"start\":62849},{\"end\":62967,\"start\":62966},{\"end\":62969,\"start\":62968},{\"end\":62977,\"start\":62976},{\"end\":62979,\"start\":62978},{\"end\":63090,\"start\":63089},{\"end\":63092,\"start\":63091},{\"end\":63100,\"start\":63099},{\"end\":63102,\"start\":63101},{\"end\":63112,\"start\":63111},{\"end\":63114,\"start\":63113},{\"end\":63231,\"start\":63230},{\"end\":63241,\"start\":63240},{\"end\":63252,\"start\":63251},{\"end\":63262,\"start\":63261},{\"end\":63270,\"start\":63269},{\"end\":63418,\"start\":63417},{\"end\":63429,\"start\":63428},{\"end\":63438,\"start\":63437},{\"end\":63511,\"start\":63510},{\"end\":63523,\"start\":63522},{\"end\":63536,\"start\":63535},{\"end\":63653,\"start\":63652},{\"end\":63664,\"start\":63663},{\"end\":63674,\"start\":63673},{\"end\":63811,\"start\":63810},{\"end\":63821,\"start\":63820},{\"end\":63832,\"start\":63831},{\"end\":63843,\"start\":63842},{\"end\":63845,\"start\":63844},{\"end\":63860,\"start\":63859},{\"end\":63869,\"start\":63868},{\"end\":63879,\"start\":63878},{\"end\":63888,\"start\":63887},{\"end\":63897,\"start\":63896},{\"end\":63905,\"start\":63904},{\"end\":63913,\"start\":63912},{\"end\":63925,\"start\":63924},{\"end\":63935,\"start\":63934},{\"end\":64033,\"start\":64032},{\"end\":64155,\"start\":64154},{\"end\":64176,\"start\":64175},{\"end\":64184,\"start\":64183},{\"end\":64194,\"start\":64193},{\"end\":64204,\"start\":64203},{\"end\":64214,\"start\":64213},{\"end\":64222,\"start\":64221},{\"end\":64224,\"start\":64223},{\"end\":64361,\"start\":64360},{\"end\":64373,\"start\":64369},{\"end\":64383,\"start\":64382},{\"end\":64398,\"start\":64397},{\"end\":64408,\"start\":64407},{\"end\":64580,\"start\":64579},{\"end\":64589,\"start\":64588},{\"end\":64599,\"start\":64598},{\"end\":64608,\"start\":64607},{\"end\":64621,\"start\":64620},{\"end\":64786,\"start\":64785},{\"end\":64788,\"start\":64787},{\"end\":64800,\"start\":64799},{\"end\":64802,\"start\":64801},{\"end\":64913,\"start\":64912},{\"end\":64991,\"start\":64990},{\"end\":65004,\"start\":65003},{\"end\":65138,\"start\":65137},{\"end\":65140,\"start\":65139},{\"end\":65150,\"start\":65146},{\"end\":65156,\"start\":65155},{\"end\":65266,\"start\":65265},{\"end\":65268,\"start\":65267},{\"end\":65404,\"start\":65403},{\"end\":65406,\"start\":65405},{\"end\":65565,\"start\":65564},{\"end\":65659,\"start\":65658},{\"end\":65667,\"start\":65666},{\"end\":65758,\"start\":65757},{\"end\":65768,\"start\":65767},{\"end\":65778,\"start\":65777},{\"end\":65793,\"start\":65792},{\"end\":65802,\"start\":65801},{\"end\":65957,\"start\":65956},{\"end\":65965,\"start\":65964},{\"end\":65975,\"start\":65974},{\"end\":66145,\"start\":66144},{\"end\":66158,\"start\":66157},{\"end\":66167,\"start\":66166},{\"end\":66276,\"start\":66275},{\"end\":66294,\"start\":66293},{\"end\":66300,\"start\":66299},{\"end\":66436,\"start\":66435},{\"end\":66444,\"start\":66443},{\"end\":66446,\"start\":66445},{\"end\":66567,\"start\":66566},{\"end\":66580,\"start\":66579},{\"end\":66683,\"start\":66682},{\"end\":66685,\"start\":66684},{\"end\":66823,\"start\":66822},{\"end\":66832,\"start\":66831},{\"end\":66943,\"start\":66942},{\"end\":66952,\"start\":66951},{\"end\":66966,\"start\":66965},{\"end\":66979,\"start\":66978},{\"end\":66993,\"start\":66992},{\"end\":67005,\"start\":67004},{\"end\":67017,\"start\":67016},{\"end\":67179,\"start\":67178},{\"end\":67188,\"start\":67187},{\"end\":67200,\"start\":67199},{\"end\":67303,\"start\":67302},{\"end\":67305,\"start\":67304},{\"end\":67378,\"start\":67377},{\"end\":67467,\"start\":67466},{\"end\":67589,\"start\":67588},{\"end\":67601,\"start\":67600},{\"end\":67615,\"start\":67614},{\"end\":67627,\"start\":67626},{\"end\":67638,\"start\":67637},{\"end\":67758,\"start\":67754},{\"end\":67765,\"start\":67764}]", "bib_author_last_name": "[{\"end\":60869,\"start\":60855},{\"end\":60878,\"start\":60873},{\"end\":61018,\"start\":61013},{\"end\":61024,\"start\":61022},{\"end\":61036,\"start\":61030},{\"end\":61046,\"start\":61042},{\"end\":61056,\"start\":61050},{\"end\":61071,\"start\":61062},{\"end\":61082,\"start\":61075},{\"end\":61097,\"start\":61086},{\"end\":61108,\"start\":61101},{\"end\":61279,\"start\":61274},{\"end\":61286,\"start\":61283},{\"end\":61294,\"start\":61290},{\"end\":61305,\"start\":61298},{\"end\":61319,\"start\":61309},{\"end\":61405,\"start\":61396},{\"end\":61508,\"start\":61499},{\"end\":61526,\"start\":61512},{\"end\":61601,\"start\":61595},{\"end\":61689,\"start\":61679},{\"end\":61701,\"start\":61693},{\"end\":61791,\"start\":61786},{\"end\":61803,\"start\":61795},{\"end\":61812,\"start\":61807},{\"end\":61822,\"start\":61816},{\"end\":61832,\"start\":61826},{\"end\":61844,\"start\":61836},{\"end\":61955,\"start\":61947},{\"end\":61967,\"start\":61959},{\"end\":61979,\"start\":61971},{\"end\":62083,\"start\":62077},{\"end\":62174,\"start\":62170},{\"end\":62183,\"start\":62178},{\"end\":62192,\"start\":62190},{\"end\":62204,\"start\":62198},{\"end\":62213,\"start\":62208},{\"end\":62296,\"start\":62292},{\"end\":62305,\"start\":62303},{\"end\":62473,\"start\":62469},{\"end\":62482,\"start\":62480},{\"end\":62597,\"start\":62591},{\"end\":62606,\"start\":62601},{\"end\":62728,\"start\":62723},{\"end\":62740,\"start\":62732},{\"end\":62834,\"start\":62826},{\"end\":62847,\"start\":62841},{\"end\":62859,\"start\":62851},{\"end\":62974,\"start\":62970},{\"end\":62986,\"start\":62980},{\"end\":63097,\"start\":63093},{\"end\":63109,\"start\":63103},{\"end\":63121,\"start\":63115},{\"end\":63238,\"start\":63232},{\"end\":63249,\"start\":63242},{\"end\":63259,\"start\":63253},{\"end\":63267,\"start\":63263},{\"end\":63277,\"start\":63271},{\"end\":63426,\"start\":63419},{\"end\":63435,\"start\":63430},{\"end\":63443,\"start\":63439},{\"end\":63520,\"start\":63512},{\"end\":63533,\"start\":63524},{\"end\":63545,\"start\":63537},{\"end\":63661,\"start\":63654},{\"end\":63671,\"start\":63665},{\"end\":63682,\"start\":63675},{\"end\":63818,\"start\":63812},{\"end\":63829,\"start\":63822},{\"end\":63840,\"start\":63833},{\"end\":63857,\"start\":63846},{\"end\":63866,\"start\":63861},{\"end\":63876,\"start\":63870},{\"end\":63885,\"start\":63880},{\"end\":63894,\"start\":63889},{\"end\":63902,\"start\":63898},{\"end\":63910,\"start\":63906},{\"end\":63922,\"start\":63914},{\"end\":63932,\"start\":63926},{\"end\":63941,\"start\":63936},{\"end\":64051,\"start\":64034},{\"end\":64173,\"start\":64156},{\"end\":64181,\"start\":64177},{\"end\":64191,\"start\":64185},{\"end\":64201,\"start\":64195},{\"end\":64211,\"start\":64205},{\"end\":64219,\"start\":64215},{\"end\":64233,\"start\":64225},{\"end\":64367,\"start\":64362},{\"end\":64380,\"start\":64374},{\"end\":64395,\"start\":64384},{\"end\":64405,\"start\":64399},{\"end\":64417,\"start\":64409},{\"end\":64586,\"start\":64581},{\"end\":64596,\"start\":64590},{\"end\":64605,\"start\":64600},{\"end\":64618,\"start\":64609},{\"end\":64629,\"start\":64622},{\"end\":64797,\"start\":64789},{\"end\":64808,\"start\":64803},{\"end\":64923,\"start\":64914},{\"end\":65001,\"start\":64992},{\"end\":65013,\"start\":65005},{\"end\":65144,\"start\":65141},{\"end\":65153,\"start\":65151},{\"end\":65162,\"start\":65157},{\"end\":65275,\"start\":65269},{\"end\":65415,\"start\":65407},{\"end\":65571,\"start\":65566},{\"end\":65664,\"start\":65660},{\"end\":65677,\"start\":65668},{\"end\":65765,\"start\":65759},{\"end\":65775,\"start\":65769},{\"end\":65790,\"start\":65779},{\"end\":65799,\"start\":65794},{\"end\":65808,\"start\":65803},{\"end\":65962,\"start\":65958},{\"end\":65972,\"start\":65966},{\"end\":65981,\"start\":65976},{\"end\":66155,\"start\":66146},{\"end\":66164,\"start\":66159},{\"end\":66182,\"start\":66168},{\"end\":66291,\"start\":66277},{\"end\":66297,\"start\":66295},{\"end\":66310,\"start\":66301},{\"end\":66441,\"start\":66437},{\"end\":66455,\"start\":66447},{\"end\":66577,\"start\":66568},{\"end\":66591,\"start\":66581},{\"end\":66693,\"start\":66686},{\"end\":66829,\"start\":66824},{\"end\":66848,\"start\":66833},{\"end\":66949,\"start\":66944},{\"end\":66963,\"start\":66953},{\"end\":66976,\"start\":66967},{\"end\":66990,\"start\":66980},{\"end\":67002,\"start\":66994},{\"end\":67014,\"start\":67006},{\"end\":67032,\"start\":67018},{\"end\":67185,\"start\":67180},{\"end\":67197,\"start\":67189},{\"end\":67209,\"start\":67201},{\"end\":67314,\"start\":67306},{\"end\":67383,\"start\":67379},{\"end\":67475,\"start\":67468},{\"end\":67598,\"start\":67590},{\"end\":67612,\"start\":67602},{\"end\":67624,\"start\":67616},{\"end\":67635,\"start\":67628},{\"end\":67645,\"start\":67639},{\"end\":67762,\"start\":67759},{\"end\":67769,\"start\":67766}]", "bib_entry": "[{\"attributes\":{\"id\":\"b0\",\"matched_paper_id\":30645513},\"end\":60919,\"start\":60812},{\"attributes\":{\"id\":\"b1\",\"matched_paper_id\":16725293},\"end\":61184,\"start\":60921},{\"attributes\":{\"id\":\"b2\",\"matched_paper_id\":6284457},\"end\":61392,\"start\":61186},{\"attributes\":{\"id\":\"b3\"},\"end\":61426,\"start\":61394},{\"attributes\":{\"id\":\"b4\",\"matched_paper_id\":14288063},\"end\":61561,\"start\":61428},{\"attributes\":{\"id\":\"b5\"},\"end\":61626,\"start\":61563},{\"attributes\":{\"id\":\"b6\",\"matched_paper_id\":121331324},\"end\":61755,\"start\":61628},{\"attributes\":{\"id\":\"b7\",\"matched_paper_id\":9495823},\"end\":61875,\"start\":61757},{\"attributes\":{\"id\":\"b8\",\"matched_paper_id\":1052091},\"end\":62014,\"start\":61877},{\"attributes\":{\"id\":\"b9\",\"matched_paper_id\":8630946},\"end\":62108,\"start\":62016},{\"attributes\":{\"id\":\"b10\",\"matched_paper_id\":18212493},\"end\":62228,\"start\":62110},{\"attributes\":{\"id\":\"b11\",\"matched_paper_id\":7459411},\"end\":62372,\"start\":62230},{\"attributes\":{\"id\":\"b12\",\"matched_paper_id\":8433853},\"end\":62550,\"start\":62374},{\"attributes\":{\"id\":\"b13\",\"matched_paper_id\":16663927},\"end\":62652,\"start\":62552},{\"attributes\":{\"id\":\"b14\",\"matched_paper_id\":6094265},\"end\":62766,\"start\":62654},{\"attributes\":{\"id\":\"b15\",\"matched_paper_id\":2157587},\"end\":62927,\"start\":62768},{\"attributes\":{\"id\":\"b16\",\"matched_paper_id\":17782776},\"end\":63034,\"start\":62929},{\"attributes\":{\"id\":\"b17\",\"matched_paper_id\":16526438},\"end\":63182,\"start\":63036},{\"attributes\":{\"id\":\"b18\",\"matched_paper_id\":18762833},\"end\":63324,\"start\":63184},{\"attributes\":{\"id\":\"b19\"},\"end\":63449,\"start\":63326},{\"attributes\":{\"id\":\"b20\",\"matched_paper_id\":14916908},\"end\":63577,\"start\":63451},{\"attributes\":{\"id\":\"b21\",\"matched_paper_id\":263706338},\"end\":63718,\"start\":63579},{\"attributes\":{\"id\":\"b22\",\"matched_paper_id\":15374646},\"end\":64011,\"start\":63720},{\"attributes\":{\"id\":\"b23\"},\"end\":64063,\"start\":64013},{\"attributes\":{\"id\":\"b24\"},\"end\":64269,\"start\":64065},{\"attributes\":{\"id\":\"b25\",\"matched_paper_id\":16198634},\"end\":64484,\"start\":64271},{\"attributes\":{\"id\":\"b26\",\"matched_paper_id\":16869595},\"end\":64736,\"start\":64486},{\"attributes\":{\"id\":\"b27\",\"matched_paper_id\":699989},\"end\":64889,\"start\":64738},{\"attributes\":{\"id\":\"b28\"},\"end\":64934,\"start\":64891},{\"attributes\":{\"id\":\"b29\"},\"end\":65080,\"start\":64936},{\"attributes\":{\"id\":\"b30\"},\"end\":65188,\"start\":65082},{\"attributes\":{\"id\":\"b31\",\"matched_paper_id\":14124219},\"end\":65325,\"start\":65190},{\"attributes\":{\"id\":\"b32\"},\"end\":65507,\"start\":65327},{\"attributes\":{\"id\":\"b33\",\"matched_paper_id\":4341039},\"end\":65614,\"start\":65509},{\"attributes\":{\"id\":\"b34\",\"matched_paper_id\":18463411},\"end\":65716,\"start\":65616},{\"attributes\":{\"id\":\"b35\",\"matched_paper_id\":9041675},\"end\":65880,\"start\":65718},{\"attributes\":{\"id\":\"b36\",\"matched_paper_id\":12538227},\"end\":66048,\"start\":65882},{\"attributes\":{\"id\":\"b37\",\"matched_paper_id\":1276428},\"end\":66212,\"start\":66050},{\"attributes\":{\"id\":\"b38\",\"matched_paper_id\":7573897},\"end\":66345,\"start\":66214},{\"attributes\":{\"id\":\"b39\",\"matched_paper_id\":1268433},\"end\":66527,\"start\":66347},{\"attributes\":{\"id\":\"b40\",\"matched_paper_id\":18401318},\"end\":66617,\"start\":66529},{\"attributes\":{\"id\":\"b41\",\"matched_paper_id\":263752414},\"end\":66743,\"start\":66619},{\"attributes\":{\"id\":\"b42\",\"matched_paper_id\":14568927},\"end\":66873,\"start\":66745},{\"attributes\":{\"id\":\"b43\",\"matched_paper_id\":15351943},\"end\":67057,\"start\":66875},{\"attributes\":{\"id\":\"b44\",\"matched_paper_id\":10289553},\"end\":67235,\"start\":67059},{\"attributes\":{\"id\":\"b45\",\"matched_paper_id\":32576758},\"end\":67352,\"start\":67237},{\"attributes\":{\"id\":\"b46\"},\"end\":67415,\"start\":67354},{\"attributes\":{\"id\":\"b47\"},\"end\":67481,\"start\":67417},{\"attributes\":{\"id\":\"b48\",\"matched_paper_id\":18870338},\"end\":67695,\"start\":67483},{\"attributes\":{\"id\":\"b49\",\"matched_paper_id\":12756769},\"end\":67835,\"start\":67697}]", "bib_title": "[{\"end\":60851,\"start\":60812},{\"end\":61007,\"start\":60921},{\"end\":61270,\"start\":61186},{\"end\":61495,\"start\":61428},{\"end\":61675,\"start\":61628},{\"end\":61782,\"start\":61757},{\"end\":61943,\"start\":61877},{\"end\":62073,\"start\":62016},{\"end\":62166,\"start\":62110},{\"end\":62288,\"start\":62230},{\"end\":62465,\"start\":62374},{\"end\":62587,\"start\":62552},{\"end\":62719,\"start\":62654},{\"end\":62822,\"start\":62768},{\"end\":62964,\"start\":62929},{\"end\":63087,\"start\":63036},{\"end\":63228,\"start\":63184},{\"end\":63508,\"start\":63451},{\"end\":63650,\"start\":63579},{\"end\":63808,\"start\":63720},{\"end\":64152,\"start\":64065},{\"end\":64358,\"start\":64271},{\"end\":64577,\"start\":64486},{\"end\":64783,\"start\":64738},{\"end\":64988,\"start\":64936},{\"end\":65135,\"start\":65082},{\"end\":65263,\"start\":65190},{\"end\":65401,\"start\":65327},{\"end\":65562,\"start\":65509},{\"end\":65656,\"start\":65616},{\"end\":65755,\"start\":65718},{\"end\":65954,\"start\":65882},{\"end\":66142,\"start\":66050},{\"end\":66273,\"start\":66214},{\"end\":66433,\"start\":66347},{\"end\":66564,\"start\":66529},{\"end\":66680,\"start\":66619},{\"end\":66820,\"start\":66745},{\"end\":66940,\"start\":66875},{\"end\":67176,\"start\":67059},{\"end\":67300,\"start\":67237},{\"end\":67586,\"start\":67483},{\"end\":67752,\"start\":67697}]", "bib_author": "[{\"end\":60871,\"start\":60853},{\"end\":60880,\"start\":60871},{\"end\":61020,\"start\":61009},{\"end\":61026,\"start\":61020},{\"end\":61038,\"start\":61026},{\"end\":61048,\"start\":61038},{\"end\":61058,\"start\":61048},{\"end\":61073,\"start\":61058},{\"end\":61084,\"start\":61073},{\"end\":61099,\"start\":61084},{\"end\":61110,\"start\":61099},{\"end\":61281,\"start\":61272},{\"end\":61288,\"start\":61281},{\"end\":61296,\"start\":61288},{\"end\":61307,\"start\":61296},{\"end\":61321,\"start\":61307},{\"end\":61407,\"start\":61394},{\"end\":61510,\"start\":61497},{\"end\":61528,\"start\":61510},{\"end\":61603,\"start\":61591},{\"end\":61691,\"start\":61677},{\"end\":61703,\"start\":61691},{\"end\":61793,\"start\":61784},{\"end\":61805,\"start\":61793},{\"end\":61814,\"start\":61805},{\"end\":61824,\"start\":61814},{\"end\":61834,\"start\":61824},{\"end\":61846,\"start\":61834},{\"end\":61957,\"start\":61945},{\"end\":61969,\"start\":61957},{\"end\":61981,\"start\":61969},{\"end\":62085,\"start\":62075},{\"end\":62176,\"start\":62168},{\"end\":62185,\"start\":62176},{\"end\":62194,\"start\":62185},{\"end\":62206,\"start\":62194},{\"end\":62215,\"start\":62206},{\"end\":62298,\"start\":62290},{\"end\":62307,\"start\":62298},{\"end\":62475,\"start\":62467},{\"end\":62484,\"start\":62475},{\"end\":62599,\"start\":62589},{\"end\":62608,\"start\":62599},{\"end\":62730,\"start\":62721},{\"end\":62742,\"start\":62730},{\"end\":62836,\"start\":62824},{\"end\":62849,\"start\":62836},{\"end\":62861,\"start\":62849},{\"end\":62976,\"start\":62966},{\"end\":62988,\"start\":62976},{\"end\":63099,\"start\":63089},{\"end\":63111,\"start\":63099},{\"end\":63123,\"start\":63111},{\"end\":63240,\"start\":63230},{\"end\":63251,\"start\":63240},{\"end\":63261,\"start\":63251},{\"end\":63269,\"start\":63261},{\"end\":63279,\"start\":63269},{\"end\":63428,\"start\":63417},{\"end\":63437,\"start\":63428},{\"end\":63445,\"start\":63437},{\"end\":63522,\"start\":63510},{\"end\":63535,\"start\":63522},{\"end\":63547,\"start\":63535},{\"end\":63663,\"start\":63652},{\"end\":63673,\"start\":63663},{\"end\":63684,\"start\":63673},{\"end\":63820,\"start\":63810},{\"end\":63831,\"start\":63820},{\"end\":63842,\"start\":63831},{\"end\":63859,\"start\":63842},{\"end\":63868,\"start\":63859},{\"end\":63878,\"start\":63868},{\"end\":63887,\"start\":63878},{\"end\":63896,\"start\":63887},{\"end\":63904,\"start\":63896},{\"end\":63912,\"start\":63904},{\"end\":63924,\"start\":63912},{\"end\":63934,\"start\":63924},{\"end\":63943,\"start\":63934},{\"end\":64053,\"start\":64032},{\"end\":64175,\"start\":64154},{\"end\":64183,\"start\":64175},{\"end\":64193,\"start\":64183},{\"end\":64203,\"start\":64193},{\"end\":64213,\"start\":64203},{\"end\":64221,\"start\":64213},{\"end\":64235,\"start\":64221},{\"end\":64369,\"start\":64360},{\"end\":64382,\"start\":64369},{\"end\":64397,\"start\":64382},{\"end\":64407,\"start\":64397},{\"end\":64419,\"start\":64407},{\"end\":64588,\"start\":64579},{\"end\":64598,\"start\":64588},{\"end\":64607,\"start\":64598},{\"end\":64620,\"start\":64607},{\"end\":64631,\"start\":64620},{\"end\":64799,\"start\":64785},{\"end\":64810,\"start\":64799},{\"end\":64925,\"start\":64912},{\"end\":65003,\"start\":64990},{\"end\":65015,\"start\":65003},{\"end\":65146,\"start\":65137},{\"end\":65155,\"start\":65146},{\"end\":65164,\"start\":65155},{\"end\":65277,\"start\":65265},{\"end\":65417,\"start\":65403},{\"end\":65573,\"start\":65564},{\"end\":65666,\"start\":65658},{\"end\":65679,\"start\":65666},{\"end\":65767,\"start\":65757},{\"end\":65777,\"start\":65767},{\"end\":65792,\"start\":65777},{\"end\":65801,\"start\":65792},{\"end\":65810,\"start\":65801},{\"end\":65964,\"start\":65956},{\"end\":65974,\"start\":65964},{\"end\":65983,\"start\":65974},{\"end\":66157,\"start\":66144},{\"end\":66166,\"start\":66157},{\"end\":66184,\"start\":66166},{\"end\":66293,\"start\":66275},{\"end\":66299,\"start\":66293},{\"end\":66312,\"start\":66299},{\"end\":66443,\"start\":66435},{\"end\":66457,\"start\":66443},{\"end\":66579,\"start\":66566},{\"end\":66593,\"start\":66579},{\"end\":66695,\"start\":66682},{\"end\":66831,\"start\":66822},{\"end\":66850,\"start\":66831},{\"end\":66951,\"start\":66942},{\"end\":66965,\"start\":66951},{\"end\":66978,\"start\":66965},{\"end\":66992,\"start\":66978},{\"end\":67004,\"start\":66992},{\"end\":67016,\"start\":67004},{\"end\":67034,\"start\":67016},{\"end\":67187,\"start\":67178},{\"end\":67199,\"start\":67187},{\"end\":67211,\"start\":67199},{\"end\":67316,\"start\":67302},{\"end\":67385,\"start\":67377},{\"end\":67477,\"start\":67466},{\"end\":67600,\"start\":67588},{\"end\":67614,\"start\":67600},{\"end\":67626,\"start\":67614},{\"end\":67637,\"start\":67626},{\"end\":67647,\"start\":67637},{\"end\":67764,\"start\":67754},{\"end\":67771,\"start\":67764}]", "bib_venue": "[{\"end\":60903,\"start\":60880},{\"end\":61178,\"start\":61110},{\"end\":61386,\"start\":61321},{\"end\":61420,\"start\":61407},{\"end\":61555,\"start\":61528},{\"end\":61589,\"start\":61563},{\"end\":61747,\"start\":61703},{\"end\":61867,\"start\":61846},{\"end\":62008,\"start\":61981},{\"end\":62102,\"start\":62085},{\"end\":62222,\"start\":62215},{\"end\":62363,\"start\":62307},{\"end\":62540,\"start\":62484},{\"end\":62646,\"start\":62608},{\"end\":62760,\"start\":62742},{\"end\":62917,\"start\":62861},{\"end\":63025,\"start\":62988},{\"end\":63176,\"start\":63123},{\"end\":63318,\"start\":63279},{\"end\":63415,\"start\":63326},{\"end\":63568,\"start\":63547},{\"end\":63712,\"start\":63684},{\"end\":64005,\"start\":63943},{\"end\":64030,\"start\":64013},{\"end\":64263,\"start\":64235},{\"end\":64475,\"start\":64419},{\"end\":64728,\"start\":64631},{\"end\":64883,\"start\":64810},{\"end\":64910,\"start\":64891},{\"end\":65071,\"start\":65015},{\"end\":65182,\"start\":65164},{\"end\":65315,\"start\":65277},{\"end\":65501,\"start\":65417},{\"end\":65608,\"start\":65573},{\"end\":65697,\"start\":65679},{\"end\":65874,\"start\":65810},{\"end\":66042,\"start\":65983},{\"end\":66203,\"start\":66184},{\"end\":66339,\"start\":66312},{\"end\":66519,\"start\":66457},{\"end\":66611,\"start\":66593},{\"end\":66733,\"start\":66695},{\"end\":66867,\"start\":66850},{\"end\":67051,\"start\":67034},{\"end\":67229,\"start\":67211},{\"end\":67343,\"start\":67316},{\"end\":67375,\"start\":67354},{\"end\":67464,\"start\":67417},{\"end\":67689,\"start\":67647},{\"end\":67827,\"start\":67771},{\"end\":60913,\"start\":60905}]"}}}, "year": 2023, "month": 12, "day": 17}