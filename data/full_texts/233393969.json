{"id": 233393969, "updated": "2023-11-11 04:00:25.105", "metadata": {"title": "The Reachability Problem for Petri Nets is Not Primitive Recursive", "authors": "[{\"first\":\"J'erome\",\"last\":\"Leroux\",\"middle\":[]}]", "venue": "FOCS", "journal": "1241-1252", "publication_date": {"year": 2021, "month": 4, "day": 26}, "abstract": "We provide an Ackermannian complexity lower bound for the reachability problem for checking programs, a model equivalent to Petri nets. Moreover in fixed dimension $2d+4$, we show that the problem is $\\mathbb{F}_d$-hard. As a direct corollary, the reachability problem in dimension 10 is not elementary.", "fields_of_study": "[\"Computer Science\"]", "external_ids": {"arxiv": null, "mag": null, "acl": null, "pubmed": null, "pubmedcentral": null, "dblp": "conf/focs/Leroux21", "doi": "10.1109/focs52979.2021.00121"}}, "content": {"source": {"pdf_hash": "b2c7a8648197f840299eae243e1c6dbc4479c6b8", "pdf_src": "Arxiv", "pdf_uri": "[\"https://arxiv.org/pdf/2104.12695v4.pdf\"]", "oa_url_match": false, "oa_info": null}, "grobid": {"id": "af5f152cdc1eca2803e3addb7ea0fad56ad2b5c7", "type": "plain-text", "url": "s3://ai2-s2-pdf-extraction-prod/parse-results/s2orc_worker/b2c7a8648197f840299eae243e1c6dbc4479c6b8.txt", "contents": "\nThe Reachability Problem for Petri Nets is Not Primitive Recursive *\n2 Sep 2021\n\nJ\u00e9r\u00f4me Leroux jerome.leroux@labri.fr \nCNRS\nUniversity of Bordeaux\n\n\nThe Reachability Problem for Petri Nets is Not Primitive Recursive *\n2 Sep 2021\nWe provide an Ackermannian complexity lower bound for the reachability problem for checking programs, a model equivalent to Petri nets. Moreover in fixed dimension 2d + 4, we show that the problem is F d -hard. As a direct corollary, the reachability problem in dimension 10 is not elementary. * This research has been supported by ANR programme BraVAS (ANR-17-CE40-0028).\n\nIntroduction\n\nChecking programs [14], or equivalently vector addition systems with states [7], or vector addition systems [8], or Petri nets are one of the most popular formal methods for the representation and the analysis of parallel processes [5].\n\nThose equivalent models are acting on counters ranging over the natural numbers thanks to increment, decrement, and test commands (only at the end of an execution). The central algorithmic problem for checking programs is reachability: given a checking program, decide whether there exists an execution from an initial configuration to a final one. Many important computational problems in logic and complexity reduce or are even equivalent to this problem [21,6]. After an incomplete proof by Sacerdote and Tenney [20], decidability of the problem was established by Mayr [15,16], whose proof was then simplified by Kosaraju [9]. Building on the further refinements made by Lambert in the 1990s [10], in 2015, a first complexity upper bound of the reachability problem was provided [12] more than thirty years after the presentation of the algorithm introduced by Mayr [9,10]. The upper bound given in that paper is \"cubic Ackermannian\", i.e. in F \u03c9 3 (see [22]). This complexity bound is obtained by analyzing the Mayr algorithm. With a refined algorithm and a new ranking function for proving termination, an Ackermannian complexity upper bound was obtained [13] This means that the reachability problem can be solved in time bounded by A(p(n)) where p is a primitive recursive function and where A is the Ackermann function. This paper also showed that the reachability problem in fixed dimension d (the dimension is the number of used counters) is primitive recursive by bounding the length of executions by O(F d+4 (n)) where F d+4 is a primitive recursive function of the Grzegorczyk hierarchy (see Section 2 for the definition of those functions), and n is the size of the input.\n\nConcerning the complexity lower bound, in 1976, the reachability problem was proved to be ExpSpace-hard [2]. This bound used to be the best one for more than forty years until 2019 when it was improved to a Tower complexity lower bound [3], i.e. a non elementary complexity.\n\nContributions. In this paper we provide an Ackermannian complexity lower bound for the reachability problem for checking programs closing the gap with the Ackermannian complexity upper bound solving a 45 years old open problem. Moreover, in fixed dimension 2d + 4 with d \u2265 3, we prove that the reachability problem is hard for the complexity class F d introduced in [22] associated with the function F d . As a direct corollary, we derive that the reachability problem is not elementary in dimension 10. This paper provides the last piece leading to the exact complexity of the reachability problem for checking programs. As previously mentioned, it follows a long series of results. This piece of work is not the most difficult one but it is an important one since it closes a long standing open problem. Technically, the most difficult piece is the notion of K-amplifiers introduced in the Tower complexity lower bound paper [3] that provides a way to postpone at the end of an execution the tests commands of a Minsky machine (a machine like a VASS but with commands that can test to zero some counters) with counters bounded by K.\n\nIn this paper, we provide several gadgets for proving an F d complexity lower bound for the reachability problem in dimension 2d + 4. Recently and independently, other gadgets for implementing such a bound have been introduced in order to obtain the same complexity upper bound by Wojciech Czerwi\u0144ski, and Lukasz Orlikowski [4] in dimension 6d, by myself [14] in dimension 4d + 5, and by S lawomir Lasota [11] in dimension 3d + 2. We do not know if the lower bound provided in this paper, i.e. F d in dimension 2d + 4 is optimal since the complexity upper bound is F d+4 in dimension d. It follows that the parameterized complexity (i.e. in fixed dimension) of the reachability problem is still open.\n\nWe think that several different solutions to the complexity lower bound for the reachability problem is useful not only for the confidence in the claimed result but also for future work. In fact, the reachability problem for many extensions is open for almost all natural extensions except for vector addition systems with hierarchical zero tests [1,19]. Moreover, the best known complexity lower bounds for those models only come from checking programs. Finding gadgets that take benefits from the extra power given by the considered extensions is an open problem.\n\nOutline. In Section 2, we recall some properties satisfied by the fast growing functions F d and introduce a way to compute F d be iterating a reduction rule evalF d . In Section 3 we introduce the model of general programs, and the subclasses of test-free models that correspond to programs that cannot test counters to zero, and the checking programs that can only test counters at the end. Whereas the reachability problem for test-free program is equivalent to the so-called coverability problem for Petri nets (see [2,18] for complexity results), the reachability problem for checking program is equivalent to the so-called reachability problem for Petri nets. In Section 4 we provide tools to postpone at the end of an execution test commands of a general program. Those tools are used in Section 5 in order to simulate the bounded semantics of general programs thanks to the so-called preamplifiers. In Section 6 we provide tools for iterating a testfree program a fixed number of times that depends on the valuation of some counters. Those tools are used in Section 7 to implements evalF d thanks to a test-free program. By iterating this test-free program, we provide a way in Section 8 to implement an Ackermannian preamplifier. Finally, in Section 9 we collect intermediate results to provide complexity lower bounds for the reachability problem for checking programs.\n\n\nFast Growing Functions\n\nWe introduce the sequence (F d ) d\u2208N of functions F d : N \u2192 N defined by F 0 (n) = n + 1, and defined by induction on d \u2265 1 by F d (n) = F n+1 d\u22121 (n). Rather than take the original definition of Ackermann function, we let A(n) = F \u03c9 (n) defined by F \u03c9 (n) = F n+1 (n), which behaves like the classical function for our complexity-theoretical purpose. We introduce the function F v : N \u2192 N with v \u2208 N d , defined as follows for every n \u2208 N:\nF v (n) = F v[d] d \u2022 \u00b7 \u00b7 \u00b7 \u2022 F v[1] 1 (n)\nRemark 1. We have F 1 (n) = 2n + 1 and F 2 (n) = 2 n+1 (n + 1) \u2212 1 for every n \u2208 N. The function F 3 behaves like a tower of n exponential and it is not elementary. Each function F d is primitive recursive and F \u03c9 is not primitive recursive.\n\nLet us denote by 0 d the zero vector of N d , and by 1 d,i the ith unit vector of N d defined for\nevery 1 \u2264 j \u2264 d by 1 d,i [j] = 1 if j = i and 1 d,i [j] = 0 otherwise. The lexicographic (strict) order < lex over N d is defined by w < lex v if w = v and the maximal p \u2208 {1, . . . , d} such that w[p] = v[p] satisfies w[p] < v[p]. Let evalF d : N d \u00d7 N \u2192 N d \u00d7 N be the function partially defined over the pairs (v, n) \u2208 N d \u00d7 N such that v = 0 d as follows where p is the minimal index in {1, . . . , d} such that v[p] > 0: evalF d (v, n) = (v \u2212 1 d,p , 2n + 1) if p = 1 (v \u2212 1 d,p + (n + 1)1 d,p\u22121 , n) if p > 1\nSince F p (n) = F n+1 p\u22121 (n), one can easily prove (see [23] for more details) that if v = 0 d , then the pair (w, m) defined as evalF d (v, n) satisfies F w (m) = F v (n). It follows that the function that\nmaps (v, n) onto F v (n) is an invariant of evalF d .\nMoreover, as w < lex v, it follows that we can iterate the function evalF d on a pair (v, n) only a finite number of times (we use the well-foundedness of the lexicographic order). Let us introduce the function evalF max\nd : N d \u00d7 N \u2192 N d \u00d7 N defined by evalF max d (v, n) = evalF k d (v, n)\nwhere k is the maximal number of times (it can be zero) we can apply the function evalF d on (v, n). Notice that evalF max\nd (v, n) is a pair of the form (w, m) for some pair (w, m) \u2208 N d \u00d7 N. Moreover, by maximality of k, it follows that w = 0 d . Since the function (v, n) \u2192 F v (n) is an invariant of evalF d , we deduce that F 0 d (m) = F v (n)\n. It follows that the following equality holds (see [23] for more details):\nevalF max d (v, n) = (0 d , F v (n))\nAs a direct corollary, we deduce the following lemma.\n\nLemma 2. We have evalF max d ((n + 1)1 d,d , n) = (0 d , F d+1 (n)) for every n \u2265 0 and d \u2265 1.\n\nThe following lemma will be useful in the sequel. In that lemma, |v| is v [1] \n+ \u00b7 \u00b7 \u00b7 + v[d] for any vector v \u2208 N d .\nLemma 3. We have F v (n) \u2265 2 |v| n + |v| for every v \u2208 N d and for every n \u2208 N.\n\nProof. Let v \u2208 N d and n \u2208 N. Assume that for every w \u2208 N d such that w < lex v we have F w (m) \u2265 2 |w| m + |w| for every m \u2208 N. And let us prove that in that case F v (n) \u2265 2n |v| + |v| for every n \u2208 N. In fact, since the lexicographic order is well-founded, by induction the proof of the lemma reduces to that statement.\n\nNotice that if v = 0 d then F v (n) = n and we are done. So, we can assume that v = 0 d . In that case, let us introduce (w,\nm) = evalF d (v, n). Since w < lex v, it follows that F w (m) \u2265 2 |w| m+|w|. Since F w (m) = F v (n), we get F v (n) \u2265 2 |w| m + |w|. Let p \u2208 {1, .\n. . , d} be the minimal index such that v[p] > 0. Observe that if p = 1 then |w| = |v| \u2212 1 and m = 2n + 1. In particular 2 |w| m + |w| \u2265 2 |v| n + |v|. If p > 1 then |w| = |v| + n and m = n. Hence 2 |w| m + |w| \u2265 2 |v| n + |v|. We have proved that F v (n) \u2265 2 |v| n + |v| in any case.\n\nFormally, an implicit infinite countable set of elements called counters is given. A configuration is a function \u03c1 that maps every counter on a natural number in such a way that the set of counters c such that \u03c1(c) = 0 is finite. We denote by 0 the configuration \u03c1 such that \u03c1(c) = 0 for every counter c. The increment, decrement and test commands of a counter c are respectively denoted as inc(c), dec(c), and test(c). We associate with such a command cmd, the binary relation cmd \u2212 \u2212\u2212 \u2192 over the configurations defined by \u03b1 cmd \u2212 \u2212\u2212 \u2192 \u03b2 if \u03b1(x) = \u03b2(x) for every counter x = c, and satisfying additionally: \n\uf8f1 \uf8f4 \uf8f2 \uf8f4 \uf8f3 \u03b2(c) = \u03b1(c) + 1 if cmd is inc(c) \u03b2(c) = \u03b1(c) \u2212 1 if cmd is dec(c) \u03b2(c) = 0 = \u03b1(c) if cmd is test(c) A (general) program MM \u2212 \u2192 = \uf8f1 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f2 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f3 cmd \u2212 \u2212\u2212 \u2192 if M = cmd is a command ( M 0 \u2212 \u2212 \u2192) * if M = loop M 0 M 1 \u2212 \u2212 \u2192; M 2 \u2212 \u2212 \u2192 if M = M 1 ; M 2 M 1 \u2212 \u2212 \u2192 \u222a M 2 \u2212 \u2212 \u2192 if M = M 1 or M 2\nWhere (\u2192 0 ) * is the reflexive and transitive closure of \u2192 0 , and \u2192 1 ; \u2192 2 is defined by \u03b1 \u2192 1 ; \u2192 2 \u03b2 if there exists a configuration \u03c1 such that \u03b1 \u2192 1 \u03c1 and \u03c1 \u2192 2 \u03b2. Series compositions and non-deterministic choices are clearly associative with respect to the relation \u2192. We denote by M (n) the series composition of M by itself n times. We also denote by inc(c 1 , . . . , c n ) the program inc(c 1 ); . . . ; inc(c n ), by dec(c 1 , . . . , c n ) the program dec(c 1 ); . . . ; dec(c n ), and similarly test(c 1 , . . . , c n ) the program test(c 1 ); . . . ; test(c n ).\n\nWe say that a program is test-free if it does not use any test command. A checking program is a program of the form M ; test(c 1 , . . . , c n ) where M is a test-free program and c 1 , . . . , c n are some counters.\n\nThe reachability problem for general programs asks, given a general program M , whether there exists a configuration \u03b2 such that 0 M \u2212 \u2192 \u03b2. This problem is undecidable [17] even in dimension 2 but provides a way to define complexity classes beyond Elementary as recalled in Section 9. The reachability problem for test-free programs is equivalent (i.e. inter-reducible) to the so-called coverability problem for Petri nets (see [2,18] for the complexity of the problem), and the reachability problem for checking programs is equivalent (i.e. inter-reducible) to the so-called reachability problem for Petri nets.\n\nIn this paper, we use standard notions from model theory by considering counters as variables, and configurations as valuations of the variables. It means that a configuration is used to replace in an expression e over the counters, each occurrence of a counter c by \u03c1(c). We denote by \u03c1(e) the expression we obtain this way. When \u03c6 is a constraint over the counters, we also denote by \u03c1(\u03c6) the constraint we obtain by considering \u03c6 as an expression over the counters. We say that \u03c1 satisfies \u03c6 if the constraint \u03c1(\u03c6) is true. For instance we say that \u03c1 satisfies y = 2 c x where y, c and x are counters if \u03c1(y) = 2 \u03c1(c) \u03c1(x).\n\n\nSimulating Test Commands\n\nWe provide in this section the central idea for simulating test commands. Assume that B denotes a finite set of counters. The simulation of a test command test(c) for some counter c \u2208 B is using two distinct auxiliary counters x and y not in B. During the simulation, we consider configurations \u03c1 satisfying y \u2265 Kx where K = \u03c1( b\u2208B b). Intuitively, when the configuration satisfies y = Kx it means that all the previous simulation of test commands were correct and when y > Kx is means that at least one simulation was incorrect. Those simulations are obtained by introducing the following test-free program. This program is using any implicit enumeration b 0 , . . . , b d of the counters in B satisfying b 0 = c. Such an enumeration naturally depends on the counter c.\nsimtest y,B,x (c) = loop dec(b 1 );inc(b 0 );dec(y) . . . loop dec(b d );inc(b d\u22121 );dec(y) loop dec(b d\u22121 );inc(b d );dec(y) . . . loop dec(b 0 );inc(b 1 );dec(y) dec(x) (2)\nIntuitively this program is transferring the content of the counter b i into b i\u22121 thanks to the ith loop with i \u2208 {1, . . . , d}. Then the program is transferring back the contents of the counters thanks to the last d loops. During each step of the transfer, the counter y is decremented. Since K = b\u2208B b is an invariant, the counter y can be decremented by at most K in total with the first d loops, and by K as well in total with the last d loops. It follows that y can be decremented by at most 2K. Moreover, the only way to decrement y by exactly 2K is when initially c = 0 and when all loops are executed the maximal number of times, meaning that the transfers are total, and in particular that the initial and the final configurations coincide on the counters in B. Since x is decremented by 2, it follows that if y \u2265 Kx before the execution of the program, then the same constraint holds at the end. Moreover, if additionally y = Kx at the end, then necessarily the same constraint holds at the beginning and it means that y has been decremented by 2K, and in particular initially c = 0 and all the transfers were performed maximally. The following two lemmas formally proved those intuitions.\nLemma 4. Let \u03b1, \u03b2 be two configurations such that \u03b1 test(c);dec(y) (2K) dec(x) (2) \u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2192 \u03b2 with c \u2208 B and such that K = \u03b1( b\u2208B b). Then we have: \u03b1 simtest y,B,y (c) \u2212 \u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212 \u2192 \u03b2 Proof.\nWe are going to prove that there exists an execution in such a way the loops are executed m 1 , . . . , m d , n d , . . . , n 1 times (in that order), where m i = n i = \u03b1(b i ) for every 1 \u2264 i \u2264 d. Notice that the decrement commands dec(y) cannot prevent such an execution since \u03b1(y) \u2265 2K = d i=1 (n i + m i ). Moreover, the decrement commands dec(x) (2) are also executable at the end of the program since \u03b1(x) \u2265 2. So, for proving the existence of an execution of the program with the loops executed the right number of times, we can forget the decrement commands on the counters y and x.\n\nFor the first d loops, such an execution is possible by observing that the ith loop with i \u2208 {1, . . . , d} only decrements the counter b i (recall that we forget the counter y for the proof) that is untouched by the previous loops. After executing those d first loops, we get a configuration \u03c1 satisfying for every counter c the following equalities:\n\u03c1(c) = \uf8f1 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f2 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f3 \u03b1(b i+1 ) if c = b i with 0 \u2264 i < d 0 if c = b d \u03b1(y) \u2212 K if c = y \u03b1(c) otherwise\nStarting form \u03c1, the last d loops are symmetrical to the first d loops. In particular, the same argument as previously mentioned shows that there exists an execution from \u03c1 that executes the last d loops the right number of times. Now, just observe that with such an execution, we have proved the lemma. \n\u03b1 test(c);dec(y) (2K) dec(x) (2) \u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2192 \u03b2\nProof. Let us denote by m 1 , . . . , m d , n d , . . . , n 1 the number of times loops of the program are executed (in that order). Observe that the ith loop with i \u2208 {1, . . . , d} decrements the counter b i , and that counter is untouched by the previous loops. It follows that there exists a sequence r 1 , . . . , r d of natural numbers such that\nm i = \u03b1(b i ) \u2212 r i for every i \u2208 {1, . . . , d}. We derive the following equality by observing that d i=0 \u03b1(b i ) = K: d i=1 m i = K \u2212 \u03b1(b 0 ) \u2212 d i=1 r i\nLet us denote by \u03c1 the configuration we obtain just after executing those d first loops. Since d i=0 b i is an invariant of every line of the program, we get \u03b2( d i=0 b i ) = K and \u03c1( d i=0 b i ) = K. Now, observe that the argument used in the previous paragraph holds for the last d loops. It follows that there exists a sequence s 1 , . . . , s d of natural numbers such that n i = \u03c1(b i\u22121 ) \u2212 s i for every 1 \u2264 i \u2264 d, and we derive the following equality:\nd i=1 n i = K \u2212 \u03c1(b d ) \u2212 d i=1 s i From \u03b2(y) = \u03b1(y) \u2212 d i=1 (m i + n i ) and \u03b2(x) = \u03b1(x) \u2212 2,\nwe deduce the following equalities:\n\u03b2(y \u2212 Kx) = \u03b1(y \u2212 Kx) + 2K \u2212 n i=1 (m i + n i ) = \u03b1(y \u2212 Kx) + \u03b1(b 0 ) + \u03c1(b d ) + d i=1 (r i + s i )\nNow, assume that \u03b1 satisfies y \u2265 Kx. From the previous equality, we deduce that \u03b2(y \u2212 Kx) is a sum of natural numbers. In particular \u03b2 satisfies y \u2265 Kx. If additionally \u03b2 satisfies y = Kx the previous equality shows that \u03b1(y\n\u2212 Kx) = 0, \u03b1(b 0 ) = 0, \u03c1(b d ) = 0, and r i = s i = 0 for every 1 \u2264 i \u2264 d. From r i = 0 for every 1 \u2264 i \u2264 d, it follows that m i = \u03b1(c i ) for every 1 \u2264 i \u2264 d. We deduce that \u03c1(b i ) = \u03b1(b i+1 ) for every 0 \u2264 i < d. Now, from s i = 0 for every 1 \u2264 i \u2264 d, we deduce that n i = \u03b1(b i+1 ) for every 1 \u2264 i \u2264 d. In particular \u03b2(b i ) = \u03b1(b i ) for every 0 \u2264 i \u2264 d. Finally, just observe that from d i=1 m i = K and d i=1 n i = K, we deduce that \u03b2(y) = \u03b1(y) \u2212 2K.\nWe have proved the lemma.\n\n\nBounded Semantics and Preamplifiers\n\nWe introduce in this section the K-bounded semantics of general programs, where K is a natural number. Intuitively this semantics is obtained by bounding the sum of the counters by K. We also introduce the notion of K-preamplifiers that provides a way to simulate the Kbounded semantics of general programs thanks to checking programs equipped with the classical (unbounded) semantics.\n\nMore formally, we say that a configuration \u03c1 is K-bounded for some K \u2208 N if c \u03c1(c) \u2264 K.\n\nDenoting by Conf \u2264K the set of K-bounded configurations, we define the binary relation M \u2212 \u2192 \u2264K over Conf \u2264K where M is a general program inductively as follows: The K-bounded semantics can be simulated by checking programs thanks to the so-called K-preamplifiers. A K-preamplifier [3] for a triple of counters (x, y, b) is a checking program A such that:\nM \u2212 \u2192 \u2264K = \uf8f1 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f2 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f3 ( cmd \u2212 \u2212\u2212 \u2192) \u2229 (Conf \u2264K \u00d7 Conf \u2264K ) if M = cmd is a command ( M 0 \u2212 \u2212 \u2192 \u2264K ) * \u2229 (Conf \u2264K \u00d7 Conf \u2264K ) if M = loop M 0 M 1 \u2212 \u2212 \u2192 \u2264K ; M 2 \u2212 \u2212 \u2192 \u2264K if M = M 1 ; M 2 M 1 \u2212 \u2212 \u2192 \u2264K \u222a M 2 \u2212 \u2212 \u2192 \u2264K if M = M 1 or M 2 Intuitively \u03b1 M \u2212 \u2192 \u2264K \u03b2\n\u2022 For every configuration \u03b2 such that 0 A \u2212 \u2192 \u03b2 we have y \u2265 bx and \u03b2(c) = 0 for every counter c \u2208 {x, y, b}. Moreover, if \u03b2 satisfies y = bx then \u03b2(b) = K.\n\n\u2022 For every \u2113 \u2265 1 there exists a configuration \u03b2 satisfying 0 A \u2212 \u2192 \u03b2, y = bx, and x = \u2113. Remark 6. A K-amplifier [3] for a triple of counters (x, y, b) is a checking program A such that for any configuration \u03b2, we have 0 A \u2212 \u2192 \u03b2 if, and only if, there exists \u2113 > 0 such that \u03b2(x, y, b) = (\u2113, K\u2113, K) and such that \u03b2(c) = 0 for any counter c \u2208 {x, y, b}. From a Kpreamplifier, one can compute a K-amplifier by introducing some additional counters. We do not introduce K-amplifiers in this paper in order to reduce the number of counters used by the simulation. We say that a counter c used by the preamplifier A is unsafe (for the simulation), if it belongs to {x, y, b} or if it occurs in a test command at the end of A, and let us say it is safe if it is not unsafe. Then denoting by u and s respectively the number of unsafe and safe counters of A, the dimension of A \u22b2 M is equal to u + max(s, d).\n\nThe checking program A \u22b2 M is obtained as follows. By renaming the counters of A, we can assume without loss of generality that the unsafe counters of A are disjoint from the counters used by M . Moreover, with such a renaming we can additionally assume that the cardinal of the safe counters of A union the counters used by M is max(s, d). We assume that A is a checking program of the form A \u2032 ; test(c 1 , . . . , c n ) where A \u2032 is a test-free program. We can assume that b is not in {c 1 , . . . , c n } since otherwise K = 0 and in this case A can by replaced by the 0-preamplifier loop inc(x). We denote by B the counters used by M union {b}. By adding a test command test(c) for some counter c used by M , we can assume that M starts with a test command (notice that if M is not using any counter, then M is the empty program and the construction A \u22b2 M can be defined as M ).\n\nWe introduce the test-free program M \u2032 obtained from M by replacing each increment command inc(c) by inc(c); dec(b), each decrement command dec(c) by dec(c); inc(b), and each test command test(c) by simtest x,B,y (c). The checking program A \u22b2 M is then defined as follows:\nA \u22b2 M = A' M' loop dec(b) test(x, y, b, c 1 , . . . , c n ) For every configuration \u03b2, we have 0 M \u2212 \u2192 \u2264K \u03b2 if, and only if, 0 A\u22b2M \u2212\u2212\u2212\u2192 \u03b2.\nA formal proof for a variant construction of A \u22b2 M (that cannot reuse safe counters of A, that introduces several additional test commands, and that uses additional counters) is given in [3]. In the next two paragraphs, we just recall briefly the key ingredients used for the formal proof.\n\nFor one direction, assume that 0 M \u2212 \u2192 \u2264K \u03b2 for some configuration \u03b2 and let us consider an execution of M from 0 to \u03b2 such that every visited configuration including \u03b2 is K-bounded. Denoting by m the number of times this execution is using a test command, we introduce \u2113 = 2m. Since M starts with a test command, it follows that \u2113 > 0. We consider an execution of A \u2032 that leads to a configuration \u03c1 such that \u03c1(x, y, b) = (\u2113, K\u2113, K) and \u03c1(c) = 0 for every counter c \u2208 {x, y, b}. Observe that \u03c1 satisfies K = \u03c1( c\u2208B c). From the execution of M , we derive an execution of M \u2032 from \u03c1 to a configuration \u03b4 satisfying \u03b4(x) = 0, \u03b4(y) = 0, and \u03b4(c) = \u03b2(c) for every counter c used by M . In fact, every time a test command test(c) is executed, it is simulated by simtest x,B,y (c) using Lemma 4 that decrements x by 2, and y by 2K. Finally, from \u03b4 we iterate the last loop exactly \u03b4(b) times in such a way we get the configuration \u03b2. This configuration can then execute the last test commands of A \u22b2 M .\n\nFor the other direction, assume that 0 A\u22b2M \u2212\u2212\u2212\u2192 \u03b2 for some configuration \u03b2 and let us consider an execution of A \u22b2 M witnessing that property. In A \u22b2 M the test-free program A \u2032 is executed first and the test commands test(c 1 , . . . , c n ) of A are postponed at the end of A\u22b2M . Since those tested counters are no longer used in between, the execution of A \u2032 can only produce from the zero configuration a configuration \u03c1 satisfying y \u2265 bx and \u03c1(c) = 0 for every counter c \u2208 {x, y, b}. We denote by \u03b4 the configuration obtained from \u03c1 after executing M \u2032 . Let K \u2032 = \u03c1(b). Assume by contradiction that \u03c1 satisfies the strict constraint y > K \u2032 x. Lemma 5 shows that \u03b4 satisfies the same strict inequality. In particular \u03b2(y) = \u03b4(y) > 0 and the last test command test(y) fails on \u03b2. We get a contradiction. It follows that \u03b4 satisfies the equality y = bx and since A is a K-preamplifier, we get K \u2032 = K in that case. Lemma 5 shows that \u03b4 satisfies y \u2265 Kx. Moreover, since \u03b2(y) = \u03b2(x) = 0 we deduce that \u03b4 satisfies the equality y = Kx. From Lemma 5 we deduce that every execution of simtest x,B,y (c) in M \u2032 has the same effect as the execution of test(c); dec(y) (2K) ; dec(x) (2) . From the execution of M \u2032 we deduce that \u03b1 M \u2212 \u2192 \u2264K \u03b2.\n\nIt follows that the K-bounded semantics of general programs can be simulated by checking programs of small size as soon as there exists small size K-preamplifiers.\n\n\nLoop at Most\n\nIn this section we present a way to iterate test-free programs a numbers of times that depends on the valuation of some counters. Given two distinct counters c and c \u2032 , and a test-free program M , we introduce the following test-free program:\nLoop at most c + c \u2032 times M = loop dec(c);inc(c \u2032 ) loop\ndec(c \u2032 );inc(c);M Let us denote by C the counter expression c + c \u2032 . In the following lemmas, we assume that M is any test-free program that does not use the counters c and c \u2032 .\n\nLemma 7. For every configuration \u03b1, \u03b2, we have:\n\u03b1 Loop at most c + c \u2032 times M \u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2192 \u03b2\nif, and only if, there exists n, \u2113 \u2208 N such that n \u2264 \u03b1(c), \u2113 \u2264 n + \u03b1(c \u2032 ), and such that:\n\u03b1 (dec(c);inc(c \u2032 )) (n) ;(dec(c \u2032 );inc(c);M ) (\u2113) \u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2192 \u03b2\nIn particular \u2113 \u2264 \u03b1(C). If this inequality is an equality then \u03b2(c) = \u03b1(C) and \u03b2(c \u2032 ) = 0.\n\nProof. We denote by N and N n,\u2113 the following test-free programs where n, \u2113 \u2208 N:\nN = 1: loop 2: dec(c);inc(c \u2032 ) 3: loop 4: dec(c \u2032 );inc(c);M N n,\u2113 = (dec(c); inc(c \u2032 )) (n) (dec(c \u2032 ); inc(c); M ) (\u2113)\nLet \u03b1, \u03b2 be two configurations such that \u03b1 N \u2212 \u2192 \u03b2. We fix some execution witnessing that property. Let n be the number of times line 2 is executed and \u2113 be the number of times line 4 is executed. Since each execution of line 2 decrements c, we deduce that after executing the first loop we get a configuration \u03c1 satisfying \u03c1(c) = \u03b1(c) \u2212 n and \u03c1(c \u2032 ) = \u03b1(c \u2032 ) + n. In particular n \u2264 \u03b1(c). Symmetrically, since each execution of line 4 decrements c \u2032 , we deduce that \u03b2(c \u2032 ) = \u03c1(c \u2032 ) \u2212 \u2113 = \u03b1(c \u2032 ) + n \u2212 \u2113 and \u03b2(c) = \u03c1(c) + \u2113 = \u03b1(c) \u2212 n + \u2113. In particular \u2113 \u2264 n + \u03b1(c \u2032 ). Observe that \u03b1 N n,\u2113 \u2212 \u2212\u2212 \u2192 \u03b2. Moreover, we have \u2113 \u2264 \u03b1(c). Observe that if \u2113 = \u03b1(C), then from \u03b2(c \u2032 ) = \u03b1(c \u2032 ) + n \u2212 \u2113 we get \u03b2(c \u2032 ) = n \u2212 \u03b1(c). In particular n \u2265 \u03b1(c) and with n \u2264 \u03b1(c) we get n = \u03b1(c). We deduce that \u03b2(c) = \u03b1(C) and \u03b2(c \u2032 ) = 0.\n\nConversely, let \u03b1, \u03b2 be two configurations such that \u03b1 N n,\u2113 \u2212 \u2212\u2212 \u2192 \u03b2 for two natural numbers n, \u2113 \u2208 N such that n \u2264 \u03b1(c) and \u2113 \u2264 n + \u03b1(c \u2032 ). Just observe that from the execution witnessing  Let \u03b1, \u03b2 be two configurations such that \u03b1 N \u2212 \u2192 \u03b2. We fix some execution witnessing that property. Let n be the number of times line 2 is executed and \u2113 be the number of times line 4 is executed. Since each execution of line 2 decrements c, we deduce that after executing the first loop we get a configuration \u03c1 satisfying \u03c1(c) = \u03b1(c) \u2212 n and \u03c1(c \u2032 ) = \u03b1(c \u2032 ) + n. In particular n \u2264 \u03b1(c). Symmetrically, since each execution of line 4 decrements c \u2032 two times, we deduce that \u03b2(c \u2032 ) = \u03c1(c \u2032 ) \u2212 2\u2113 = \u03b1(c \u2032 ) + n \u2212 2\u2113 and \u03b2(c) = \u03c1(c) + \u2113 = \u03b1(c) \u2212 n + \u2113. In particular \u2113 \u2264 n+\u03b1(c \u2032 ) 2 .\n\nObserve that \u03b1 N n,\u2113 \u2212 \u2212\u2212 \u2192 \u03b2. Moreover, we have \u2113 \u2264 \u03b1(C) 2 . Observe that if \u2113 = \u03b1(C) 2 , then from \u03b2(c \u2032 ) = \u03b1(c \u2032 ) + n \u2212 2\u2113 we get \u03b2(c \u2032 ) = n \u2212 \u03b1(c). In particular n \u2265 \u03b1(c) and with n \u2264 \u03b1(c) we get n = \u03b1(c). We deduce that \u03b2(c) = \u03b1(C) 2 and \u03b2(c \u2032 ) = 0. Conversely, let \u03b1, \u03b2 be two configurations such that \u03b1 N n,\u2113 \u2212 \u2212\u2212 \u2192 \u03b2 for two natural numbers n, \u2113 \u2208 N such that n \u2264 \u03b1(c) and \u2113 \u2264 n+\u03b1(c \u2032 ) 2 . Just observe that from the execution witnessing Proof. The proof is very similar to the proof of Lemma 9.\n\n7 Implementing evalF d\n\nIn this section, we introduce a test-free program evalF d that implements the function evalF d . This program is using counters x, x \u2032 , x 1 , . . . , x d+1 , y, b, b \u2032 , c 0 , c \u2032 0 , c 1 , . . . , c d . We say that a configuration \u03c1 is good if it satisfies x \u2032 = y = b \u2032 = c \u2032 0 = 0, x > 0, b = 2 c 0 , x 1 = 2 c 0 x and x i = 2 c i\u22121 x i\u22121 for every i \u2208 {2, . . . , d + 1}. We say that a good configuration \u03c1 encodes a pair (v, n) \u2208 N d \u00d7 N if \u03c1(c 1 , . . . , c d ) = v and \u03c1(c 0 ) = n.\n\nRemark 11. The counters x and x \u2032 should have been denoted as x 0 and x \u2032 0 to simplify a little bit the definition of good configurations. However, since those two counters appear many times in the sequel, we prefer the notation without indexes. Moreover, this notation match the one used for preamplifiers. In fact, in the next section we introduce an Ackermannian preamplifier for the triple of counters (x, y, b) without any variable renaming.\n\nWe introduce the counter expressions C 0 , X and B defined as c 0 + c \u2032 0 , x + x \u2032 , and b + b \u2032 respectively.\n\nIntuitively, when the computation of evalF d is correct from a good configuration that encodes a pair (v, n) with v = 0 d then the computation terminates on a good configuration that encodes evalF d (v, n). When the computation is incorrect, we obtain a so-called bad configuration. Moreover, from a bad configuration any computation of evalF d leads to a bad configuration. Formally, we say that a configuration is i-bad for some i \u2208 {2, . . . , d + 1} if it satisfies\nx + x \u2032 > 0, x i + y > 2 c i\u22121 (x i\u22121 + y), and x j + y = 2 c j\u22121 (x j\u22121 + y) for every j \u2208 {i + 1, . . . , d + 1}. A configuration is 1-bad if is satisfies x \u2032 = y = 0, x > 0, b + b \u2032 < 2 c 0 +c \u2032 0 , x 1 = 2 c 0 +c \u2032 0 x, and x j = 2 c j\u22121 x j\u22121 for every j \u2208 {2, . . . , d + 1}.\nWe say that a configuration \u03b1 is bad if it is i-bad for some i. A configuration that is good or bad is said to be conform. We associate to any conform configuration \u03b1 its index of badness index(\u03b1) defined by index(\u03b1) = i if \u03b1 is i-bad, and by index(\u03b1) = 0 if \u03b1 is good. Intuitively, from any conform configuration \u03b1, the computation of evalF d can only produce conform configurations \u03b2 such that index(\u03b2) \u2265 index(\u03b1). In particular, if \u03b2 is good, then \u03b1 is good as well.\n\nThe program evalF d is defined as a non-deterministic choice of programs evalF d,p with p \u2208 {1, . . . , d}. Intuitively from a good configuration \u03b1 that encodes a pair (v, n) with v = 0 d , the computation of evalF d,p can lead to a good configuration only if p is the minimal index such that v[p] > 0. In that case the good configuration produced at the end of the computation encodes evalF d (v, n).\n\nWe introduce the following test-free program for p \u2208 {1, . . . , d}. The first loop at line 2 intuitively transfer min x 1 , . . . , x d into y. Thanks to Lemma 7, the second loop at line 6 transfer back from y the value of X. Notice that x p is incremented twice during each iteration of the loop. The loop at line 6 is interpreted thanks to Lemma 7 if p > 1 and Lemma 8 if p = 1 as a loop that is iterated C 0 times, the loop at line 8 is interpreted thanks to Lemma 9 as a loop that is iterated X times and that divides X by 2, and finally the loop at line 10 is interpreted thanks to Lemma 7 as a loop that is iterated B times. Proof. Let s be the number of times line 3 is executed. Lemma 10 shows that s \u2264 1+\u03b1(C 0 ) 2 (the 1 in the expression comes form the increment command at line 6). Let \u03c1 j\u22121 for j \u2208 {1, . . . , s} be the configuration just before executing that line the jth time. We also denote by \u03c1 s the configuration just before the execution of line 6. Lemma 8 shows that \u03c1 j (B) \u2264 \u03c1 j\u22121 (B) for every j \u2208 {1, . . . , s}. We deduce that the inequality (1) holds. If this inequality is an equality and \u03b1(B) > 0, then s = 1+\u03b1(C 0 ) 2 . Lemma 10 shows that \u03b2(c \u2032 0 ) = 0. Notice that since the inequality (1) is an equality, then the inequality \u03c1 j (B) \u2264 2\u03c1 j\u22121 (B) is also an equality for every j \u2208 {1, . . . , k}. In particular \u03c1 k (b \u2032 ) = 0 from Lemma 8. It follows that \u03b2(b \u2032 ) = 0. \n\u03b2(c) = \uf8f1 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f2 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f3 \u03b1(C 0 ) if c = c 0 0 if c = c \u2032 0 \u03b1(2 C 0 +1 2 B) if c = b 0 if c = b \u2032 \u03b1(c) otherwise\nProof. Just observe that we can apply Lemma 10 and Lemma 8.\n\n\nLemma 14.\n\nLet \u03b1 be a conform configuration and \u03b2 be any configuration such that \u03b1 evalF d,p \u2212 \u2212\u2212\u2212\u2212 \u2192 \u03b2 with p \u2208 {1, . . . , d}. Then \u03b2 is conform and index(\u03b2) \u2265 index(\u03b1). In particular, if \u03b2 is good then \u03b1 is good. In that case, \u03b1 satisfies b divides x, denoting by (v, n) the pair encoded by \u03b1 then v = 0 d , p is the minimal index such that v[p] > 0, evalF d (v, n) is encoded by \u03b2, and \u03b2(x d+1 ) = \u03b1(x d+1 ).\n\nProof. Let r, s, k, m and n be the number of times lines 3, 5, 7, 9, and 11 are executed respectively. Observe that r \u2264 min{\u03b1(x 1 ), . . . , \u03b1(x d+1 )} since every time line 3 is executed, the counters x 1 , . . . , x d+1 are decremented, s \u2264 \u03b1(X) thanks to Lemma 7, k \u2264 \u03b1(C 0 ), thanks to Lemma 7 if p > 1 and Lemma 8 if p = 1 (in fact in that case c p\u22121 = c 0 ), and n \u2264 \u03b1(B)m thanks to Lemma 7. Let us prove that \u03b2(X) > 0. Observe that \u03b1(X) > 0 since \u03b1 is conform. Moreover, line 9 is the unique line that may prevent \u03b2(X) > 0 holding. However, each time this line is executed, by definition of loop at most, notice that x is incremented just before. It follows that \u03b2(X) > 0.\n\nFor each j \u2208 {1, . . . , k}, let m j be the number of times line 9 is executed during the jth execution of the loop at line 6. We denote by \u03b1 j\u22121 the configuration just before the jth execution of line 9, and by \u03b1 k the configuration just before executing updateB d,p . Notice that \u03b1 0 (X) = \u03b1(X), 2m j \u2264 \u03b1 j\u22121 (X), and \u03b1 j (X) = \u03b1 j\u22121 (X) \u2212 m j for every j \u2208 {1, . . . , k}. Let us denote by h j the natural number such that \u03b1 j\u22121 (X) = 2m j + h j . By induction on i \u2208 {0, . . . , k}, we get the following equality:\ni j=1 m j = \u03b1(X)[1 \u2212 2 \u2212i ] \u2212 i j=1 2 j\u2212i\u22121 h j\nIn particular with i = k, since m = k j=1 m j , we get the following equality by introducing the non negative rational number h = k j=1 2 j\u2212k\u22121 h j :\n2 \u03b1(C 0 ) m = \u22122 \u03b1(C 0 ) h \u2212 1 2 k \u03b1(X)(2 \u03b1(C 0 ) \u2212 2 k ) + \u03b1((2 C 0 \u2212 1)X)(2)\nAssume first that \u03b1 is i-bad for some i \u2208 {p + 2, . . . , d + 1}. In that case \u03b1 satisfies x i + y > 2 c i\u22121 (x i\u22121 + y), and x j + y = 2 c j\u22121 (x j\u22121 + y) for every j \u2208 {i + 1, . . . , d + 1}. Notice that \u03b2 also satisfies the same constraints since x j + y for j \u2208 {i, . . . , d + 1}, and c j for j \u2208 {i, . . . , d} are invariant. Hence \u03b2 is i-bad in that case.\n\nSo we can assume that \u03b1 is not i-bad for every i \u2208 {p + 2, . . . , d + 1}. Since \u03b1 is conform, we deduce that \u03b1 satisfies x p+1 + y \u2265 2 cp (x p + y), and x j + y = 2 c j\u22121 (x j\u22121 + y) for every j \u2208 {p + 2, . . . , d + 1}. Since x j + y for j \u2208 {p + 1, . . . , d + 1}, and c j for j \u2208 {p + 1, . . . , d} are invariant, we deduce that \u03b2 satisfies x j + y = 2 c j\u22121 (x j\u22121 + y) for every j \u2208 {p + 2, . . . , d + 1}.\n\nObserve that we have the following equalities:\n\u03b2(x p+1 + y) = \u03b1(x p+1 + y) \u03b2(c p ) = \u03b1(c p ) \u2212 1 \u03b2(x p + y) = \u03b1(x p + y) + s + n \u03b2(y) = \u03b1(y) + r \u2212 (s + n)\nFrom those equalities, we derive:\n\n\u03b2(x p+1 + y \u2212 2 cp (x p + y)) = \u03b1(x p+1 + y \u2212 2 cp (x p + y))\n+ 2 \u03b1(cp)\u22121 (\u03b1(x p ) \u2212 r) + 2 \u03b1(cp)\u22121 \u03b2(y)\nNotice that the right hand-side of the last equality is a sum of three natural numbers. It means that if one of those numbers is strictly positive, then \u03b2 is (p + 1)-bad. So, we can assume that those three numbers are zero. It means that \u03b1 and \u03b2 satisfies x p+1 + y = 2 cp (x p + y), r = \u03b1(x p ), and \u03b2(y) = 0. In particular \u03b1 is not (p + 1)-bad. Assume by contradiction that \u03b1 is i-bad for some i \u2208 {2, . . . , p}. It means that \u03b1 satisfies x i + y > 2 c i\u22121 (x i\u22121 + y) and x j + y = 2 c j\u22121 (x j\u22121 + y) for every j \u2208 {i + 1, . . . , d + 1}. In particular \u03b1 satisfies x i > x i\u22121 and x j \u2265 x j\u22121 for every j \u2208 {i + 1, . . . , d}. We deduce that \u03b1 satisfies x i < x p . It follows that r \u2264 min{\u03b1(x 1 ), . . . , \u03b1(x d+1 )} < \u03b1(x p ) = r and we get a contradiction.\n\nSince \u03b1 is not i-bad for every i \u2208 {2, . . . , d + 1}, we deduce that \u03b1 is 1-bad or good. In both cases, \u03b1 satisfies x \u2032 = y = 0, B \u2264 2 C 0 , x 1 = 2 C 0 x, and x i = 2 c i\u22121 x i\u22121 for every i \u2208 {2, . . . , d + 1}. In particular \u03b1(x d+1 ) \u2265 \u00b7 \u00b7 \u00b7 \u2265 \u03b1(x) > 0. Notice that from \u03b1(y) = 0 and \u03b2(y) = 0, we deduce from \u03b2(y) = \u03b1(y) + r \u2212 (s + n) that r = s + n.\n\nAssume by contradiction that \u03b1(c i\u22121 ) > 0 for some i \u2208 {2, . . . , p}. Since \u03b1 satisfies\nx i = 2 c i\u22121 x i\u22121 , c i\u22121 > 0, and x i\u22121 > 0, we deduce that \u03b1(x i ) > \u03b1(x i\u22121 ). In particular, \u03b1(x p ) \u2265 \u03b1(x i ) > \u03b1(x i\u22121 )\n. Like in the previous paragraph we get a contradiction with r \u2264 min{\u03b1(x 1 ), . . . , \u03b1(x d+1 )} < \u03b1(x p ) = r. Therefore \u03b1(c i\u22121 ) = 0 for every i \u2208 {2, . . . , p}. We deduce that \u03b1(x 1 ) = \u00b7 \u00b7 \u00b7 = \u03b1(x p ). It follows from r = \u03b1(x p ) and r = s + n that \u03b1(x 1 ) = s + n.\n\nObserve that we have (by developing the equalities and replacing 2 \u03b1(C 0 ) m by using the equality 2):\nn = \u2212(\u03b1(B)m \u2212 n) \u2212 \u03b1(2 B 0 \u2212 B)m \u2212 2 \u03b1(C 0 ) h \u2212 1 2 k \u03b1(X)(2 \u03b1(C 0 ) \u2212 2 k ) + \u03b1((2 C 0 \u2212 1)X)) s = \u2212(\u03b1(X) \u2212 s) + \u03b1(X)\nIt follows that we have (we use the fact that \u03b1(x 1 \u2212 2 C 0 X) = 0):\n0 = \u03b1(x 1 ) \u2212 (s + n) =(\u03b1(B)m \u2212 n) + (2 \u03b1(C 0 ) \u2212 \u03b1(B))m + (\u03b1(X) \u2212 s) + 2 \u03b1(C 0 ) h + 1 2 k \u03b1(X)(2 \u03b1(C 0 ) \u2212 2 k )\nSince each term of the right hand side of the previous equality are non negative, we deduce that all the terms are zero. It means that n = \u03b1(B)m, (2 \u03b1(C 0 ) \u2212 \u03b1(B))m = 0, s = \u03b1(X), h = 0, 2 \u03b1(C 0 ) = 2 k (for the last equality, we use \u03b1(X) > 0). Since k \u2264 \u03b1(C 0 ) we derive from 2 \u03b1(C 0 ) = 2 k that k = \u03b1(C 0 ). By replacing h by 0, and k by \u03b1(C 0 ) in equation 2, we derive\nm = \u03b1((1 \u2212 2 \u2212C 0 )X).\nAssume that \u03b1 is 1-bad. In that case \u03b1(B) < 2 \u03b1(C 0 ) . It follows from (2 \u03b1(C 0 ) \u2212 \u03b1(B))m = 0 that m = 0. From m = \u03b1((1 \u2212 2 \u2212C 0 )X) and \u03b1(X) > 0 we get \u03b1(C 0 ) = 0. So, from \u03b1(B) < 2 \u03b1(C 0 ) we get \u03b1(B) = 0. Observe that in that case \u03b2 is 1-bad (the case p = 1 is obtained thanks to Lemma 12). So, we can now assume that \u03b1 is not 1-bad.\n\nSince \u03b1 is conform and not bad, we deduce that \u03b1 is good. Hence \u03b1 satisfies x \u2032 = c \u2032 0 = b \u2032 = y = 0 and b = 2 c 0 . It follows from n = \u03b1(B)m that n = \u03b1((2 C 0 \u22121)X). Let \u03c1 be the configuration we obtain just before executing updateB d,p . Since h = 0, then h k = 0. It follows that \u03c1(x \u2032 ) = 0. As s = \u03b1(X), Lemma 7 shows that \u03c1(x \u2032 ) = 0. Moreover, as n = \u03b1(B)m, Lemma 7 shows that \u03c1(b \u2032 ) = 0. It follows that \u03c1(x) = \u03b1(x) \u2212 m = \u03b1(2 \u2212c 0 x). Notice that \u03c1(x i ) with i \u2208 {1, . . . , p \u2212 1} is equal to \u03b1(x i ) \u2212 r + s = s = \u03b1(x). We also have \u03c1(x p ) = \u03b1(x p ) \u2212 r + 2s + 2n = 2\u03b1(x p ). Notice that \u03c1(x i ) with i \u2208 {p + 1, . . . , d + 1} is equal to \u03b1(x i ) since x i + y is an invariant and \u03b1(y) = \u03c1(y) = 0.\n\nIt follows that for every counter c, we have:\n\u03c1(c) = \uf8f1 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f2 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f3 0 if c \u2208 {x \u2032 , c \u2032 0 , b \u2032 , y} \u03b1(2 \u2212c 0 x) if c = x \u03b1(x) if c = x i with i \u2208 {1, . . . , p \u2212 1} 2\u03b1(x p ) if c = x p \u03b1(c p ) \u2212 1 if c = c p \u03b1(1 + c p\u22121 + c 0 ) if c = c p\u22121 \u03b1(c) otherwise\nNotice that if p > 1 then \u03b1(c p\u22121 ) = 0 and \u03b2 = \u03c1. In that case \u03b2 is good and satisfies the lemma. If p = 1, notice that \u03c1(c 0 ) = 1 + 2\u03b1(c 0 ). From Lemma 12 we deduce that \u03b2 is either 1-bad or good depending depending if the inequality of that lemma is strict or an equality. Notice that if the inequality is an equality, the configuration \u03b2 is good and it encodes evalF d (v, n). Proof. We are going to prove that there exists an execution of evalF d,p from \u03b1 such that lines 3, 5, 7 are executed r, s, k times with:\nr = \u03b1(x 1 ) s = \u03b1(x) k = \u03b1(c 0 )\nWe also introduce the configurations that will appear along the execution of loop at line 6. To do so, we introduce the configurations \u03b1 0 , . . . , \u03b1 k defined as follows for every counter c and for every j \u2208 {0, . . . , k}:\n\u03b1 j (c) = \u03b1 \uf8eb \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ed \uf8f1 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f2 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f3 x 2 j if c = x x if c = x i with i \u2208 {1, . . . , p \u2212 1} 2bx + 2x(1 \u2212 2 c 0 \u2212j ) if c = x p x i + x(1 \u2212 2 c 0 \u2212j ) if c = x i with i \u2208 {p + 1, . . . , d + 1} x(2 c 0 \u2212j \u2212 1) if c = y c p \u2212 1 if c = c p c p\u22121 + 1 + j if c = c p\u22121 and p > 1 c 0 \u2212 j if c = c \u2032 0 j if c = c 0 and p > 1 1 + 2j if c = c 0 and p = 1 c otherwise \uf8f6 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f8\nSince \u03b1 is good, it follows that \u03b1(x i ) \u2265 r for every i \u2208 {1, . . . , d + 1}, and r \u2265 \u03b1(x). In particular line 3 and 5 can be effectively executed r and s times respectively. Notice that \u03b1 0 is the configuration we obtain after executing those two loops and the hidden first loop of the loop at most at line 6 exactly \u03b1(x) times.\n\nWe introduce the test-free program N corresponding to the subprogram between line 7 and line 11 (including those those lines) and prefixed by dec(c \u2032 0 ); inc(c 0 ). Let us prove by induction on j \u2208 {1, . . . , k} that \u03b1 j\u22121 N \u2212 \u2192 \u03b1 j . To do so, we are going to prove that there exists an execution of N such that lines 9, 11 are executed m j , n j times with:\nm j = \u03b1 j\u22121 ( x 2 ) n j = \u03b1 j\u22121 (m j b)\nNotice that those three numbers are natural numbers since 2 k divides \u03b1(x). This execution is obtained thanks to Lemma 7 applied on line 11 in order to execute maximally the corresponding loop, and by applying Lemma 9 applied on line 9. We have proved that \u03b1 j\u22121 M \u2212 \u2192 \u03b1 j . In particular, by executing k times loop 6, we get the configuration \u03b1 k . Notice that this configuration satisfies for every counter c:\n\u03b1 k (c) = \u03b1 \uf8eb \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ed \uf8f1 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f2 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f3 x b if c = x x if c = x i with i \u2208 {1, . . . , p \u2212 1} 2bx if c = x p x i if c = x i with i \u2208 {p + 1, . . . , d + 1} 0 if c = y c p \u2212 1 if c = c p c p\u22121 + 1 + c 0 if c = c p\u22121 c otherwise \uf8f6 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f8\nIn particular, by executing updateB d,1 following Lemma 13 (if p = 1), we get from \u03b1 k a configuration \u03b2 satisfying the lemma.\n\nSince the test-free program evalF d is defined as evalF d,1 or \u00b7 \u00b7 \u00b7 or evalF d,d , we deduce from Lemma 14 and Lemma 15 the following two corollaries. \n\n\nAckermannian Preamplifiers\n\nIn this section we prove that the following checking program is a K-preamplifier for K = 2 F d+1 (n) of size O(d4 n ). Proof. Let \u2113 \u2265 1 and let \u03b2 be the configuration satisfying \u03b2(x, y, b) = (\u2113, K\u2113, K) and \u03b2(c) = 0 for every counter c \u2208 {x, y, b}. Let us prove that 0 Ack d,n \u2212\u2212\u2212\u2212\u2192 \u03b2. To do so, we consider an execution of Ack d,n defined as follows. We execute the first loop 2 F d+1 (n)\u22122n\u22121 \u2113 \u2212 1 times (recall that F d+1 (n) \u2265 2n + 1). Just after this loop we get a good configuration \u03c1 0 that encodes ((0, . . . , 0, n), n + 1) and such that \u03c1 0 (x d+1 ) = K\u2113. Then we iterate evalF d as many times as possible following Lemma 15. This way we get a sequence \u03c1 0 , . . . , \u03c1 k of good configurations such that \u03c1 j (x d+1 ) = 2 F d+1 (n) \u2113 and such that \u03c1 j encodes the pair (v j , n j ) defined as (v j , n j ) = evalF j d ((n + 1)1 d,d , n). Since F v j (n j ) does not depend on j, we deduce that\nAck d,n = 1: inc(c 0 ) (n) ; inc(c d ) (n+1) 2: inc(x); inc(x 1 , . . . , x d ) (2 n ) ; inc(x d+1 ) (2 2n+1 ) 3: loop 4: inc(x); inc(x 1 , . . . , x d ) (2 n ) ; inc(x d+1 ) (2 2n+1F v j (n j ) = F v 0 (n 0 ) = F n+1 d (n) = F d+1 (n).\nSince \u03c1 k is a good configuration, it follows that \u03c1 k satisfies b = 2 c 0 and x d+1 = 2 c d +\u00b7\u00b7\u00b7+c 0 x. As \u03c1 k encodes (v j , n j ), we deduce that \u03c1 k (b) = 2 n j and \u03c1 k (x) = 2 F d+1 (n)\u2212n j \u2212|v j | \u2113.\n\nWe have proved the following equality:\n\u03c1 k ( x b ) = 2 Fv k (n k )\u22122n k \u2212|v k | Lemma 3 shows that if v k = 0 d then \u03c1 k satisfies b divides x.\nIn particular from the good configuration \u03c1 k we can execute evalF d one more time following Lemma 15 and get a contradiction with the maximality of k. It follows that v k = 0 d . From F v k (n k ) = F d+1 (n), we deduce that n k = F d+1 (n). Hence \u03c1 k (b) = K.\n\nSince v k = 0 d and \u03c1 k is a good configuration, we deduce that \u03c1 k satisfies x d+1 = \u00b7 \u00b7 \u00b7 = x 1 . It follows that \u03c1 k (x i ) = K\u2113 for every i \u2208 {1, . . . , d + 1}. Based on this observation, from \u03c1 k we can execute the third loop K\u2113 times. Then we execute the last loop \u03c1 k (c 0 ) times. This way, we get the configuration \u03b2.\n\nFinally, let us consider a configuration \u03b2 such that 0 Ack d,n \u2212 \u2212\u2212\u2212 \u2192 \u03b2 and let us prove that \u03b2 satisfies y \u2265 bx and \u03b2(c) = 0 for every counter c \u2208 {x, y, b}. Moreover, if the inequality is an equality then let us prove that \u03b2(b) = K.\n\nWe denote by \u03c1 0 the configuration we obtain after executing the first loop. Let k be the number of times the second loop is executed and let us denote by \u03c1 j the configuration we obtain after the jth execution of the second loop for j \u2208 {1, . . . , k}. Lemma 14 shows that \u03c1 j is conform.\n\nAssume by contradiction that \u03c1 k is i-bad for i \u2208 {2, . . . , d + 1}. In that case \u03c1 k satisfies x i + y > 2 c i\u22121 (x i\u22121 + y) and x j + y = 2 c j (x j\u22121 + y) for every j \u2208 {i + 1, . . . , d + 1}. In particular \u03c1 k (x d+1 ) > \u03c1 k (x i\u22121 ). It follows that whatever the number of time the third loop is executed, the configuration \u03b2 satisfy \u03b2(x d+1 ) > \u03b2(x i\u22121 ) and the last test command test(x d+1 ) fails. We get a contradiction. It follows that \u03c1 k is 1-bad or good. Now, assume that \u03c1 k is 1-bad. In that case \u03c1 k satisfies x \u2032 = y = 0,\nx > 0, b + b \u2032 < 2 c 0 +c \u2032 0 , x 1 = 2 c 0 +c \u2032 0 x and x i = 2 c i\u22121 x i\u22121 for every i \u2208 {2, .\n. . , d+1}. Since the execution from \u03c1 k to \u03b2 only modify y, x 1 , . . . , x d+1 , c 0 , then \u03b2 and \u03c1 k coincides on the other counters. Since \u03b2 successfully execute the last test commands, we deduce that \u03c1 k satisfies b \u2032 = c \u2032 0 = c 1 = \u00b7 \u00b7 \u00b7 = c d = 0. It follows that \u03c1 k satisfies x d+1 = \u00b7 \u00b7 \u00b7 = x 1 . Since \u03b2(x d+1 ) = 0, it means that third loop was executed \u03c1 k (x d+1 ) times. We deduce that \u03b2(x i ) = 0 for every i \u2208 {1, . . . , d}. It follows that \u03b2 satisfies y > bx and \u03b2(c) = 0 for every counter c \u2208 {x, y, b}.\n\nFinally, assume that \u03c1 k is good. From Lemma 14 we deduce that \u03c1 j is good for every j \u2208 {1, . . . , k} and denoting by (v j , n j ) the pair encoded by \u03c1 j we have (v j , n j ) = evalF j d (v 0 , n 0 ). In particular F v j (n j ) = F d+1 (n). Since \u03c1 k is good it satisfies x \u2032 = y = b \u2032 = c \u2032 0 = 0, x > 0, b = 2 c 0 , x 1 = 2 c 0 x and x i = 2 c i\u22121 x i\u22121 for every i \u2208 {2, . . . , d + 1}. Since the execution from \u03c1 k to \u03b2 only modify y, x 1 , . . . , x d+1 , c 0 , then \u03b2 and \u03c1 k coincides on the other counters. Since \u03b2 successfully execute the last test commands, we deduce that \u03c1 k satisfies c 1 = \u00b7 \u00b7 \u00b7 = c d = 0. It follows that v k = 0 d and from F v k (n k ) = F d+1 (n) we get n k = F d+1 (n). Since \u03c1 k satisfies b = 2 c 0 we deduce that \u03c1 k (b) = K. Since \u03c1 k satisfies x d+1 = \u00b7 \u00b7 \u00b7 = x 1 and \u03b2(x d+1 ) = 0, it means that third loop was executed \u03c1 k (x d+1 ) times. We deduce that \u03b2(x i ) = 0 for every i \u2208 {1, . . . , d}. We have proved that \u03b2 satisfies y = bx, \u03c1 k (b) = K, and \u03c1 k (c) = 0 for every counter c \u2208 {x, y, b}.\n\nTherefore Ack d,n is a K-preamplifier.\n\nCorollary 19. We can compute in time O(nd4 n ) a K-preamplifier of size O(nd4 n ) with K = 2 F d+1 (n) using 2d + 6 counters such that d of them are safe.\n\nProof. The checking program Ack d,n is a K-preamplifier of size O(d4 n ) computable in time O(d4 d ) using 2d + 8 counters such that x \u2032 , x 1 , . . . , x d are safe counters. Notice that the counter c d is first initialized to n and then during an execution it is only decremented. It follows that its value can be encoded in the control structure of the program, i.e. by unfolding the program n times. Moreover, notice that during the execution, the value of x d + y can only increase. It follows that the counter x d can be removed as well by observing that its value (for good configuration) is in fact equals to x d+1 2 \u2212c d and the value of c d is hard coded in the control structure. This way, we get a K-preamplifier satisfying the lemma.\n\n\nComplexity Classes Beyond Elementary\n\nThe reachability problem for general programs equipped with the bounded semantics provides a way to define complexity classes beyond Elementary. In fact, following [22], the problem that asks, given a 2-dimensional general program M of size n, whether there exists \u03b2 such that 0 M \u2212 \u2192 \u2264K \u03b2 with K = 2 F d (n) is F d -complete for every d \u2265 3. We deduce as a direct corollary the following theorem.\n\nTheorem 20. The reachability problem for (2d + 4)-dimensional checking programs is F d -hard for any d \u2265 3. In particular the reachability problem for 10-dimensional checking programs is not Elementary.\n\nProof. Given a 2-dimensional program M , let n = size(M ). Corollary 19 shows that we can compute in time O(nd4 n ) a K-preamplifier A of size O(nd4 n ) with K = 2 F d (n) using 2(d \u2212 1) + 6 counters such that d \u2212 1 of them are safe. Now recall that the checking program N defined as A \u22b2 M is computable in time size(A) + O(size(M )). It follows that N is computable in time O(nd4 n ). Moreover, as the number of safe counters of A is larger than or equal to 2, we deduce that the dimension of N is bounded by 2d + 4. Finally, just observe that for every configuration \u03b2 we have 0 M \u2212 \u2192 \u2264K \u03b2 if, and only if, 0 N \u2212 \u2192 \u03b2.\n\nTheorem 21 is nearly optimal since in [13] it is proved that the reachability problem for d-dimensional checking programs is in F d+4 .\n\nFinally, let us recall [22] that the problem that asks, given a 2-dimensional general program M of size n, whether there exists a configuration \u03b2 such that 0 M \u2212 \u2192 \u2264K \u03b2 with K = 2 F\u03c9(n) is F \u03c9 -complete. We deduce as a direct corollary the following theorem. Theorem 21 is optimal since in [13] it is proved that the reachability problem for checking programs is in F \u03c9 .\n\n\nConclusion\n\nThis paper proves that the reachability problem for checking programs is Ackermannian-complete. It also reduces the gap for the parameterized complexity of the reachability problem in fixed dimension. In order to close this gap, we see two possible research directions:\n\n\u2022 Either we find a primitive recursive algorithm computing from d, n \u2208 N a K-preamplifier for K = F d (n) with a dimension d + O(1),\n\n\u2022 Or we find a new algorithm for deciding the reachability problem with a complexity upper bound in F d 2 +O(1) .\n\n\nis defined as an increment/decrement/test command, or inductively as a loop program loop M 0 , a series composition M 1 ; M 2 , or a non-deterministic choice M 1 or M 2 where M 0 , M 1 , M 2 are programs. The size of a program M is the number size(M ) defined inductively as 1 if M is a command, 1 + size(M 0 ) if M = loop M 0 , and 1 + size(M 1 ) + size(M 2 ) if M = M 1 ; M 2 or M = M 1 or M 2 . The dimension of M is the cardinal of the set of counters used by M , and formally defined as expected. We associate with every program M the binary relation M \u2212 \u2192 over the configurations defined as follows:\n\n\nIn particular given a sequence M 1 , . . . , M n of Minsky programs, the relations M 1 ;...;Mn \u2212 \u2212\u2212\u2212\u2212\u2212 \u2192 and M 1 or ... or Mn \u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2192 are well defined.\n\nLemma 5 .\n5Let \u03b1, \u03b2 be two configurations such that \u03b1 simtest y,B,x (c) \u2212 \u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212 \u2192 \u03b2 and let K = \u03b1( b\u2208B b). Then \u03b2( b\u2208B b) = K and if \u03b1 satisfies y \u2265 Kx then \u03b2 satisfies the same constraint. Moreover if additionally \u03b2 satisfies y = Kx then \u03b1 satisfies the same constraint and:\n\n\nfor two configurations \u03b1, \u03b2 if, and only if, there exists an execution of M such that every visited configuration including \u03b1 and \u03b2, during the computation is Kbounded. The relation M \u2212 \u2192 \u2264K is called the K-bounded semantics of M .\n\n\nGiven a K-preamplifier A and a general program M of dimension d, we can compute in time size(A) + O(d size(M )) a checking program A \u22b2 M such that for any configuration \u03b2, we have 0 M \u2212 \u2192 \u2264K \u03b2, if, and only if, 0 A\u22b2M \u2212\u2212\u2212\u2192 \u03b2. It follows that K-preamplifiers provide a way to postpone at the end of an execution test commands of general programs equipped with the K-bounded semantics. The size of A \u22b2 M is size(A) + O(d size(M )). Concerning the dimension of A \u22b2 M , let us first classify the counters used by A.\n\n\n\u03b2, we deduce an execution witnessing \u03b1 N \u2212 \u2192 \u03b2 by executing the first loop n times and the second loop \u2113 times.\n\nLemma 8 .\n8For every configuration \u03b1, \u03b2, we have: \u03b1 Loop at most c + c \u2032 times (inc(c); M ) \u2212 \u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212 \u2192 \u03b2if, and only if, there exists n, \u2113 \u2208 N such that n \u2264 \u03b1(c), \u2113 \u2264 n + \u03b1(c \u2032 ), and such that: \u03b1 (dec(c);inc(c \u2032 )) (n) ;(dec(c \u2032 );inc(c)(2) ;M ) (\u2113) \u2212 \u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212 \u2192 \u03b2In particular \u2113 \u2264 \u03b1(C) and \u03b2(C) \u2264 2\u03b1(C). If one of those two inequalities is an equality then \u2113 = \u03b1(C), \u03b2(c) = 2\u03b1(C), and \u03b2(c \u2032 ) = 0.Proof. The proof is very similar to the proof of Lemma 7.Lemma 9. For every configuration \u03b1, \u03b2, we have: \u03b1 Loop at most c + c \u2032 times (dec(c \u2032 ); M ) and only if, there exists n, \u2113 \u2208 N such that n \u2264 \u03b1(c), \u2113 \u2264 n+\u03b1(c \u2032 ) 2 , and such that: \u03b1 (dec(c);inc(c \u2032 )) (n) ;(dec(c \u2032 );inc(c);dec(c \u2032 );M )In particular \u2113 \u2264 \u03b1(C) 2 . If this inequality is an equality then \u03b2(c) = \u03b1(C) 2 , and \u03b2(c \u2032 ) = 0.Proof. We denote by N and N n,\u2113 the following test-free programs where n, \u2113 \u2208 N: c \u2032 );inc(c);dec(c \u2032 );M N n,\u2113 = (dec(c); inc(c \u2032 )) (n) (dec(c \u2032 ); inc(c); dec(c \u2032 ); M ) (\u2113)\n\n\n\u03b2, we deduce an execution witnessing \u03b1 N \u2212 \u2192 \u03b2 by executing the first loop n times and the second loop \u2113 times.Lemma 10. For every configuration \u03b1, \u03b2, we have:\u03b1 Loop at most c + c \u2032 times (dec(c \u2032 ); inc(c); M ) \u2212 \u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212 \u2192 \u03b2if, and only if, there exists n, \u2113 \u2208 N such that n \u2264 \u03b1(c), \u2113 \u2264 n+\u03b1(c \u2032 ) 2 , and such that: \u03b1 (dec(c);inc(c \u2032 )) (n) ;((dec(c \u2032 );inc(c))(2) ;M )In particular \u2113 \u2264 \u03b1(C) 2 . If this inequality is an equality then \u03b2(c) = \u03b1(C), and \u03b2(c \u2032 ) = 0.\n\n\nmost b + b \u2032 times11:    dec(y);inc(x p );inc(x p , . . . , x d+1 ) 12: updateB d,pWhere updateB d,p is the empty program if p > 1 and the following one if p = 1. Notice that the loop at line 2 can be interpreted thanks to Lemma 10 as a loop that is iterated C 0 2 times, and the loop at line 4 is interpreted thanks to Lemma 8 as a loop that multiply by 2 the value of B. provide two lemmas describing the behaviour of updateB d,1 .Lemma 12. Assume that \u03b1 updateB d,1 \u2212 \u2212\u2212\u2212\u2212\u2212\u2212 \u2192 \u03b2 for any two configurations \u03b1, \u03b2. Then \u03b2(C 0 ) = \u03b1(C 0 ) and we have: \u03b2(B) If the previous inequality is an equality and \u03b1(B) > 0 then \u03b2 satisfies b \u2032 = 0 and c \u2032 0 = 0.\n\nLemma 13 .\n13Let \u03b1 be any configuration satisfying \u03b1(C 0 ) is odd. Then \u03b1 updateB d,1 \u2212 \u2212\u2212\u2212\u2212\u2212\u2212 \u2192 \u03b2 where \u03b2 is the configuration defined for every counter c as follows:\n\nLemma 15 .\n15Let \u03b1 be a good configuration satisfying b divides x and that encodes a pair (v, n) with v = 0 d , and let p is the minimal index such that v[p] > 0. There exists a good configuration \u03b2 that encodes evalF d (v, n) satisfying \u03b2(x d+1 ) = \u03b1(x d+1 ), and such that \u03b1 evalF d,p \u2212 \u2212\u2212\u2212\u2212 \u2192 \u03b2.\n\nCorollary 16 .\n16Let \u03b1 be a conform configuration and \u03b2 be any configuration such that \u03b1 evalF d \u2212 \u2212\u2212\u2212 \u2192 \u03b2. Then \u03b2 is conform and index(\u03b2) \u2265 index(\u03b1). In particular, if \u03b2 is good then \u03b1 is good. In that case, \u03b1 satisfies b divides x, denoting by (v, n) the pair encoded by \u03b1 then v = 0 d , evalF d (v, n) is encoded by \u03b2, and \u03b2(x d+1 ) = \u03b1(x d+1 ). Corollary 17. Let \u03b1 be a good configuration satisfying b divides x and that encodes a pair (v, n) with v = 0 d . There exists a good configuration \u03b2 that encodes evalF d (v, n) satisfying \u03b2(x d+1 ) = \u03b1(x d+1 ), and such that \u03b1 evalF d \u2212 \u2212\u2212\u2212 \u2192 \u03b2.\n\n\ninc(y);dec(x 1 , . . . , x d+1 ) 9: loop 10:dec(c 0 ) 11: test(x d+1 , b \u2032 , c \u2032 0 , c 0 , . . . , c d )Lemma 18. The checking program Ack d,n is a K-preamplifier for K = 2 F d+1 (n) .\n\nTheorem 21 .\n21The reachability problem for checking programs is F \u03c9 -hard. Proof. Given a 2-dimensional program M , let n = size(M ). Corollary 19 shows that we can compute in time O(n 2 4 n ) a K-preamplifier A of size O(n 2 4 n ) with K = 2 F n+1 (n) = 2 F\u03c9(n) . Now recall that the checking program N defined as A \u22b2 M is computable in time size(A) + O(size(M )). It follows that N is computable in time O(n 2 4 n ). Finally, just observe that for every configuration \u03b2 we have 0 M \u2212 \u2192 \u2264K \u03b2 if, and only if, 0 N \u2212 \u2192 \u03b2.\nGeneral ProgramsWe introduce in the section the formal model of programs acting on counters ranging over the natural numbers.\nAcknowledgements I gratefully thank Philippe Schnoebelen for helpful comments and encouraging feedback.\nThe reachability problem for vector addition system with one zerotest. R\u00e9mi Bonnet, 10.1007/978-3-642-22993-0_16Mathematical Foundations of Computer Science 2011 -36th International Symposium, MFCS 2011. Filip Murlak and Piotr SankowskiWarsaw, PolandSpringer6907R\u00e9mi Bonnet. The reachability problem for vector addition system with one zero- test. In Filip Murlak and Piotr Sankowski, editors, Mathematical Foundations of Com- puter Science 2011 -36th International Symposium, MFCS 2011, Warsaw, Poland, August 22-26, 2011. Proceedings, volume 6907 of Lecture Notes in Computer Sci- ence, pages 145-157. Springer, 2011. doi: 10.1007/978-3-642-22993-0\\ 16. URL https://doi.org/10.1007/978-3-642-22993-0_16.\n\nExponential space complete problems for petri nets and commutative semigroups: Preliminary report. E Cardoza, R J Lipton, A R Meyer, 10.1145/800113.803630Proceedings of the 8th Annual ACM Symposium on Theory of Computing. the 8th Annual ACM Symposium on Theory of ComputingHershey, Pennsylvania, USAACME. Cardoza, R. J. Lipton, and A. R. Meyer. Exponential space complete problems for petri nets and commutative semigroups: Preliminary report. In Proceedings of the 8th Annual ACM Symposium on Theory of Computing, May 3-5, 1976, Hershey, Pennsylvania, USA, pages 50-54. ACM, 1976. doi: 10.1145/800113.803630.\n\nThe reachability problem for petri nets is not elementary. W Czerwi\u0144ski, S Lasota, R Lazi\u0107, J Leroux, F Mazowiecki, 10.1145/3313276.3316369Proceedings of the 51st Annual ACM SIGACT Symposium on Theory of Computing, STOC 2019. the 51st Annual ACM SIGACT Symposium on Theory of Computing, STOC 2019Phoenix, AZ, USAACMW. Czerwi\u0144ski, S. Lasota, R. Lazi\u0107, J. Leroux, and F. Mazowiecki. The reachability prob- lem for petri nets is not elementary. In Proceedings of the 51st Annual ACM SIGACT Symposium on Theory of Computing, STOC 2019, Phoenix, AZ, USA, June 23-26, 2019, pages 24-33. ACM, 2019. doi: 10.1145/3313276.3316369.\n\nReachability in vector addition systems is ackermann-complete. Wojciech Czerwinski, Lukasz Orlikowski, 62st IEEE Annual Symposium on Foundations of Computer Science, FOCS 2022. Denver, Colorado, USA2022To appearWojciech Czerwinski and Lukasz Orlikowski. Reachability in vector addition systems is ackermann-complete. In 62st IEEE Annual Symposium on Foundations of Computer Sci- ence, FOCS 2022, Denver, Colorado, USA, February 7-10 2022. IEEE, 2022. To appear.\n\nDecidability issues for petri nets -a survey. J Esparza, M Nielsen, Bulletin of the European Association for Theoretical Computer Science. 52J. Esparza and M. Nielsen. Decidability issues for petri nets -a survey. Bulletin of the European Association for Theoretical Computer Science, 52:245-262, 1994.\n\nDecidability questions for Petri nets. M H T Hack, MITPhD thesisM. H. T. Hack. Decidability questions for Petri nets. PhD thesis, MIT, 1975. URL http://publications.csail.mit.edu/lcs/pubs/pdf/MIT-LCS-TR-161.pdf.\n\nOn the reachability problem for 5-dimensional vector addition systems. J E Hopcroft, J.-J Pansiot, Theoritical Computer Science. 8J. E. Hopcroft and J.-J. Pansiot. On the reachability problem for 5-dimensional vector addition systems. Theoritical Computer Science, 8:135-159, 1979.\n\nParallel program schemata. R M Karp, R E Miller, 10.1016/S0022-0000(69)80011-5J. Comput. Syst. Sci. 32R. M. Karp and R. E. Miller. Parallel program schemata. J. Comput. Syst. Sci., 3(2): 147-195, 1969. doi: 10.1016/S0022-0000(69)80011-5.\n\nDecidability of reachability in vector addition systems (preliminary version). S R Kosaraju, 10.1145/800070.802201STOC. ACMS. R. Kosaraju. Decidability of reachability in vector addition systems (preliminary ver- sion). In STOC, pages 267-281. ACM, 1982. doi: 10.1145/800070.802201.\n\nA structure to decide reachability in Petri nets. J.-L Lambert, 10.1016/0304-3975(92)90173-DTheor. Comput. Sci. 991J.-L. Lambert. A structure to decide reachability in Petri nets. Theor. Comput. Sci., 99 (1):79-104, 1992. doi: 10.1016/0304-3975(92)90173-D.\n\nImproved ackermannian lower bound for the vass reachability problem. Lasota S Lawomir, S lawomir Lasota. Improved ackermannian lower bound for the vass reachability problem, 2021.\n\nDemystifying reachability in vector addition systems. J Leroux, S Schmitz, 10.1109/LICS.2015.1630th Annual ACM/IEEE Symposium on Logic in Computer Science, LICS 2015. Kyoto, JapanIEEE Computer SocietyJ. Leroux and S. Schmitz. Demystifying reachability in vector addition systems. In 30th Annual ACM/IEEE Symposium on Logic in Computer Science, LICS 2015, Kyoto, Japan, July 6-10, 2015, pages 56-67. IEEE Computer Society, 2015. doi: 10.1109/LICS.2015.16.\n\nReachability in vector addition systems is primitive-recursive in fixed dimension. J Leroux, S Schmitz, 10.1109/LICS.2019.878579634th Annual ACM/IEEE Symposium on Logic in Computer Science, LICS 2019. Vancouver, BC, CanadaIEEEJ. Leroux and S. Schmitz. Reachability in vector addition systems is primitive-recursive in fixed dimension. In 34th Annual ACM/IEEE Symposium on Logic in Computer Science, LICS 2019, Vancouver, BC, Canada, June 24-27, 2019, pages 1-13. IEEE, 2019. doi: 10.1109/LICS.2019.8785796.\n\nThe reachability problem for petri nets is not primitive recursive. J\u00e9r\u00f4me Leroux, 62st IEEE Annual Symposium on Foundations of Computer Science, FOCS 2022. Denver, Colorado, USA2022To appearJ\u00e9r\u00f4me Leroux. The reachability problem for petri nets is not primitive recursive. In 62st IEEE Annual Symposium on Foundations of Computer Science, FOCS 2022, Denver, Colorado, USA, February 7-10 2022. IEEE, 2022. To appear.\n\nAn algorithm for the general petri net reachability problem. E W Mayr, 10.1145/800076.802477Proceedings of the 13th Annual ACM Symposium on Theory of Computing. the 13th Annual ACM Symposium on Theory of ComputingMilwaukee, Wisconsin, USAACME. W. Mayr. An algorithm for the general petri net reachability problem. In Proceedings of the 13th Annual ACM Symposium on Theory of Computing, May 11-13, 1981, Milwaukee, Wisconsin, USA, pages 238-246. ACM, 1981. doi: 10.1145/800076.802477.\n\nAn algorithm for the general Petri net reachability problem. E W Mayr, 10.1137/0213029SIAM J. Comput. 133E. W. Mayr. An algorithm for the general Petri net reachability problem. SIAM J. Comput., 13(3):441-460, 1984. doi: 10.1137/0213029.\n\nComputation: finite and infinite machines. Marvin L Minsky, Prentice-Hall, IncMarvin L. Minsky. Computation: finite and infinite machines. Prentice-Hall, Inc., 1967. URL https://dl.acm.org/citation.cfm?id=1095587.\n\nThe covering and boundedness problems for vector addition systems. C Rackoff, 10.1016/0304-3975(78Theor. Comput. Sci. 6C. Rackoff. The covering and boundedness problems for vector addition systems. Theor. Comput. Sci., 6:223-231, 1978. doi: 10.1016/0304-3975(78)90036-1.\n\nKlaus Reinhardt, 10.1016/j.entcs.2008.12.042.URLhttps:/www.sciencedirect.com/science/article/pii/S15710661080050571571-0661Reachability in petri nets with inhibitor arcs. Electronic Notes in Theoretical Computer Science. 223Proceedings of the Second Workshop on Reachability Problems in Computational Models. RPKlaus Reinhardt. Reachability in petri nets with inhibitor arcs. Elec- tronic Notes in Theoretical Computer Science, 223:239-264, 2008. ISSN 1571-0661. doi: https://doi.org/10.1016/j.entcs.2008.12.042. URL https://www.sciencedirect.com/science/article/pii/S1571066108005057. Pro- ceedings of the Second Workshop on Reachability Problems in Computational Models (RP 2008).\n\nThe decidability of the reachability problem for vector addition systems (preliminary version). G S Sacerdote, R L Tenney, 10.1145/800105.803396Proceedings of the 9th Annual ACM Symposium on Theory of Computing. the 9th Annual ACM Symposium on Theory of ComputingBoulder, Colorado, USAACMG. S. Sacerdote and R. L. Tenney. The decidability of the reachability problem for vector addition systems (preliminary version). In Proceedings of the 9th Annual ACM Symposium on Theory of Computing, May 4-6, 1977, Boulder, Colorado, USA, pages 61-76. ACM, 1977. doi: 10.1145/800105.803396.\n\nThe complexity of reachability in vector addition systems. S Schmitz, SIGLOG News. 31S. Schmitz. The complexity of reachability in vector addition systems. SIGLOG News, 3 (1):4-21, 2016. URL https://dl.acm.org/citation.cfm?id=2893585.\n\n. Sylvain Schmitz, http:/doi.acm.org/10.1145/28587843:1-3:36Complexity hierarchies beyond elementary. TOCT. 81Sylvain Schmitz. Complexity hierarchies beyond elementary. TOCT, 8(1):3:1-3:36, 2016. URL http://doi.acm.org/10.1145/2858784.\n\nRevisiting ackermann-hardness for lossy counter machines and reset petri nets. Philippe Schnoebelen, 10.1007/978-3-642-15155-2_5435th International Symposium, MFCS 2010. Petr Hlinen\u00fd and Anton\u00edn KuceraBrno, Czech RepublicSpringer6281ProceedingsPhilippe Schnoebelen. Revisiting ackermann-hardness for lossy counter machines and reset petri nets. In Petr Hlinen\u00fd and Anton\u00edn Kucera, editors, Mathematical Foun- dations of Computer Science 2010, 35th International Symposium, MFCS 2010, Brno, Czech Republic, August 23-27, 2010. Proceedings, volume 6281 of Lecture Notes in Com- puter Science, pages 616-628. Springer, 2010. doi: 10.1007/978-3-642-15155-2\\ 54. URL https://doi.org/10.1007/978-3-642-15155-2_54.\n", "annotations": {"author": "[{\"end\":149,\"start\":82}]", "publisher": null, "author_last_name": "[{\"end\":95,\"start\":89}]", "author_first_name": "[{\"end\":88,\"start\":82}]", "author_affiliation": "[{\"end\":148,\"start\":120}]", "title": "[{\"end\":69,\"start\":1},{\"end\":218,\"start\":150}]", "venue": null, "abstract": "[{\"end\":602,\"start\":230}]", "bib_ref": "[{\"attributes\":{\"ref_id\":\"b13\"},\"end\":640,\"start\":636},{\"attributes\":{\"ref_id\":\"b6\"},\"end\":697,\"start\":694},{\"attributes\":{\"ref_id\":\"b7\"},\"end\":729,\"start\":726},{\"attributes\":{\"ref_id\":\"b4\"},\"end\":853,\"start\":850},{\"attributes\":{\"ref_id\":\"b20\"},\"end\":1317,\"start\":1313},{\"attributes\":{\"ref_id\":\"b5\"},\"end\":1319,\"start\":1317},{\"attributes\":{\"ref_id\":\"b19\"},\"end\":1375,\"start\":1371},{\"attributes\":{\"ref_id\":\"b14\"},\"end\":1433,\"start\":1429},{\"attributes\":{\"ref_id\":\"b15\"},\"end\":1436,\"start\":1433},{\"attributes\":{\"ref_id\":\"b8\"},\"end\":1485,\"start\":1482},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":1556,\"start\":1552},{\"attributes\":{\"ref_id\":\"b11\"},\"end\":1643,\"start\":1639},{\"attributes\":{\"ref_id\":\"b8\"},\"end\":1729,\"start\":1726},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":1732,\"start\":1729},{\"attributes\":{\"ref_id\":\"b21\"},\"end\":1818,\"start\":1814},{\"attributes\":{\"ref_id\":\"b12\"},\"end\":2021,\"start\":2017},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":2652,\"start\":2649},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":2784,\"start\":2781},{\"attributes\":{\"ref_id\":\"b21\"},\"end\":3191,\"start\":3187},{\"end\":3324,\"start\":3321},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":3751,\"start\":3748},{\"attributes\":{\"ref_id\":\"b3\"},\"end\":4284,\"start\":4281},{\"attributes\":{\"ref_id\":\"b13\"},\"end\":4316,\"start\":4312},{\"attributes\":{\"ref_id\":\"b10\"},\"end\":4366,\"start\":4362},{\"attributes\":{\"ref_id\":\"b0\"},\"end\":5009,\"start\":5006},{\"attributes\":{\"ref_id\":\"b18\"},\"end\":5012,\"start\":5009},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":5749,\"start\":5746},{\"attributes\":{\"ref_id\":\"b17\"},\"end\":5752,\"start\":5749},{\"attributes\":{\"ref_id\":\"b22\"},\"end\":8032,\"start\":8028},{\"attributes\":{\"ref_id\":\"b22\"},\"end\":8930,\"start\":8926},{\"attributes\":{\"ref_id\":\"b0\"},\"end\":9215,\"start\":9212},{\"attributes\":{\"ref_id\":\"b16\"},\"end\":12109,\"start\":12105},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":12368,\"start\":12365},{\"attributes\":{\"ref_id\":\"b17\"},\"end\":12371,\"start\":12368},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":15907,\"start\":15904},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":19675,\"start\":19672},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":20292,\"start\":20289},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":22564,\"start\":22561},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":24849,\"start\":24846},{\"end\":33362,\"start\":33354},{\"end\":38230,\"start\":38221},{\"attributes\":{\"ref_id\":\"b21\"},\"end\":48328,\"start\":48324},{\"attributes\":{\"ref_id\":\"b12\"},\"end\":49426,\"start\":49422},{\"attributes\":{\"ref_id\":\"b21\"},\"end\":49548,\"start\":49544},{\"attributes\":{\"ref_id\":\"b12\"},\"end\":49815,\"start\":49811},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":52592,\"start\":52589},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":53725,\"start\":53722}]", "figure": "[{\"attributes\":{\"id\":\"fig_0\"},\"end\":51033,\"start\":50426},{\"attributes\":{\"id\":\"fig_1\"},\"end\":51191,\"start\":51034},{\"attributes\":{\"id\":\"fig_2\"},\"end\":51471,\"start\":51192},{\"attributes\":{\"id\":\"fig_3\"},\"end\":51705,\"start\":51472},{\"attributes\":{\"id\":\"fig_4\"},\"end\":52218,\"start\":51706},{\"attributes\":{\"id\":\"fig_5\"},\"end\":52332,\"start\":52219},{\"attributes\":{\"id\":\"fig_6\"},\"end\":53336,\"start\":52333},{\"attributes\":{\"id\":\"fig_7\"},\"end\":53825,\"start\":53337},{\"attributes\":{\"id\":\"fig_8\"},\"end\":54478,\"start\":53826},{\"attributes\":{\"id\":\"fig_9\"},\"end\":54647,\"start\":54479},{\"attributes\":{\"id\":\"fig_10\"},\"end\":54947,\"start\":54648},{\"attributes\":{\"id\":\"fig_11\"},\"end\":55543,\"start\":54948},{\"attributes\":{\"id\":\"fig_12\"},\"end\":55730,\"start\":55544},{\"attributes\":{\"id\":\"fig_13\"},\"end\":56253,\"start\":55731}]", "paragraph": "[{\"end\":854,\"start\":618},{\"end\":2543,\"start\":856},{\"end\":2819,\"start\":2545},{\"end\":3955,\"start\":2821},{\"end\":4657,\"start\":3957},{\"end\":5224,\"start\":4659},{\"end\":6605,\"start\":5226},{\"end\":7072,\"start\":6632},{\"end\":7356,\"start\":7115},{\"end\":7455,\"start\":7358},{\"end\":8178,\"start\":7971},{\"end\":8453,\"start\":8233},{\"end\":8647,\"start\":8525},{\"end\":8949,\"start\":8874},{\"end\":9040,\"start\":8987},{\"end\":9136,\"start\":9042},{\"end\":9216,\"start\":9138},{\"end\":9336,\"start\":9257},{\"end\":9660,\"start\":9338},{\"end\":9786,\"start\":9662},{\"end\":10219,\"start\":9935},{\"end\":10829,\"start\":10221},{\"end\":11717,\"start\":11139},{\"end\":11935,\"start\":11719},{\"end\":12549,\"start\":11937},{\"end\":13177,\"start\":12551},{\"end\":13976,\"start\":13206},{\"end\":15353,\"start\":14152},{\"end\":16143,\"start\":15553},{\"end\":16496,\"start\":16145},{\"end\":16912,\"start\":16608},{\"end\":17317,\"start\":16966},{\"end\":17932,\"start\":17474},{\"end\":18063,\"start\":18028},{\"end\":18389,\"start\":18165},{\"end\":18874,\"start\":18849},{\"end\":19299,\"start\":18914},{\"end\":19388,\"start\":19301},{\"end\":19745,\"start\":19390},{\"end\":20173,\"start\":20018},{\"end\":21075,\"start\":20175},{\"end\":21960,\"start\":21077},{\"end\":22234,\"start\":21962},{\"end\":22663,\"start\":22374},{\"end\":23664,\"start\":22665},{\"end\":24906,\"start\":23666},{\"end\":25071,\"start\":24908},{\"end\":25331,\"start\":25088},{\"end\":25570,\"start\":25390},{\"end\":25619,\"start\":25572},{\"end\":25763,\"start\":25673},{\"end\":25935,\"start\":25844},{\"end\":26017,\"start\":25937},{\"end\":26965,\"start\":26140},{\"end\":27746,\"start\":26967},{\"end\":28256,\"start\":27748},{\"end\":28280,\"start\":28258},{\"end\":28771,\"start\":28282},{\"end\":29220,\"start\":28773},{\"end\":29333,\"start\":29222},{\"end\":29804,\"start\":29335},{\"end\":30556,\"start\":30087},{\"end\":30959,\"start\":30558},{\"end\":32364,\"start\":30961},{\"end\":32548,\"start\":32489},{\"end\":32963,\"start\":32562},{\"end\":33644,\"start\":32965},{\"end\":34163,\"start\":33646},{\"end\":34361,\"start\":34212},{\"end\":34803,\"start\":34441},{\"end\":35217,\"start\":34805},{\"end\":35265,\"start\":35219},{\"end\":35407,\"start\":35374},{\"end\":35470,\"start\":35409},{\"end\":36278,\"start\":35514},{\"end\":36635,\"start\":36280},{\"end\":36726,\"start\":36637},{\"end\":37127,\"start\":36856},{\"end\":37231,\"start\":37129},{\"end\":37420,\"start\":37352},{\"end\":37911,\"start\":37536},{\"end\":38274,\"start\":37935},{\"end\":38989,\"start\":38276},{\"end\":39036,\"start\":38991},{\"end\":39802,\"start\":39283},{\"end\":40061,\"start\":39836},{\"end\":40908,\"start\":40578},{\"end\":41271,\"start\":40910},{\"end\":41723,\"start\":41312},{\"end\":42175,\"start\":42049},{\"end\":42329,\"start\":42177},{\"end\":43262,\"start\":42360},{\"end\":43705,\"start\":43500},{\"end\":43745,\"start\":43707},{\"end\":44112,\"start\":43851},{\"end\":44441,\"start\":44114},{\"end\":44678,\"start\":44443},{\"end\":44969,\"start\":44680},{\"end\":45511,\"start\":44971},{\"end\":46133,\"start\":45609},{\"end\":47175,\"start\":46135},{\"end\":47215,\"start\":47177},{\"end\":47371,\"start\":47217},{\"end\":48119,\"start\":47373},{\"end\":48557,\"start\":48160},{\"end\":48761,\"start\":48559},{\"end\":49382,\"start\":48763},{\"end\":49519,\"start\":49384},{\"end\":49892,\"start\":49521},{\"end\":50176,\"start\":49907},{\"end\":50310,\"start\":50178},{\"end\":50425,\"start\":50312}]", "formula": "[{\"attributes\":{\"id\":\"formula_0\"},\"end\":7114,\"start\":7073},{\"attributes\":{\"id\":\"formula_1\"},\"end\":7970,\"start\":7456},{\"attributes\":{\"id\":\"formula_2\"},\"end\":8232,\"start\":8179},{\"attributes\":{\"id\":\"formula_3\"},\"end\":8524,\"start\":8454},{\"attributes\":{\"id\":\"formula_4\"},\"end\":8873,\"start\":8648},{\"attributes\":{\"id\":\"formula_5\"},\"end\":8986,\"start\":8950},{\"attributes\":{\"id\":\"formula_6\"},\"end\":9256,\"start\":9217},{\"attributes\":{\"id\":\"formula_7\"},\"end\":9934,\"start\":9787},{\"attributes\":{\"id\":\"formula_8\"},\"end\":10961,\"start\":10830},{\"attributes\":{\"id\":\"formula_9\"},\"end\":11138,\"start\":10961},{\"attributes\":{\"id\":\"formula_10\"},\"end\":14151,\"start\":13977},{\"attributes\":{\"id\":\"formula_11\"},\"end\":15552,\"start\":15354},{\"attributes\":{\"id\":\"formula_12\"},\"end\":16607,\"start\":16497},{\"attributes\":{\"id\":\"formula_13\"},\"end\":16965,\"start\":16913},{\"attributes\":{\"id\":\"formula_14\"},\"end\":17473,\"start\":17318},{\"attributes\":{\"id\":\"formula_15\"},\"end\":18027,\"start\":17933},{\"attributes\":{\"id\":\"formula_16\"},\"end\":18164,\"start\":18064},{\"attributes\":{\"id\":\"formula_17\"},\"end\":18848,\"start\":18390},{\"attributes\":{\"id\":\"formula_18\"},\"end\":20017,\"start\":19746},{\"attributes\":{\"id\":\"formula_19\"},\"end\":22373,\"start\":22235},{\"attributes\":{\"id\":\"formula_20\"},\"end\":25389,\"start\":25332},{\"attributes\":{\"id\":\"formula_21\"},\"end\":25672,\"start\":25620},{\"attributes\":{\"id\":\"formula_22\"},\"end\":25843,\"start\":25764},{\"attributes\":{\"id\":\"formula_23\"},\"end\":26139,\"start\":26018},{\"attributes\":{\"id\":\"formula_24\"},\"end\":30086,\"start\":29805},{\"attributes\":{\"id\":\"formula_25\"},\"end\":32488,\"start\":32365},{\"attributes\":{\"id\":\"formula_26\"},\"end\":34211,\"start\":34164},{\"attributes\":{\"id\":\"formula_27\"},\"end\":34440,\"start\":34362},{\"attributes\":{\"id\":\"formula_28\"},\"end\":35373,\"start\":35266},{\"attributes\":{\"id\":\"formula_29\"},\"end\":35513,\"start\":35471},{\"attributes\":{\"id\":\"formula_30\"},\"end\":36855,\"start\":36727},{\"attributes\":{\"id\":\"formula_31\"},\"end\":37351,\"start\":37232},{\"attributes\":{\"id\":\"formula_32\"},\"end\":37535,\"start\":37421},{\"attributes\":{\"id\":\"formula_33\"},\"end\":37934,\"start\":37912},{\"attributes\":{\"id\":\"formula_34\"},\"end\":39282,\"start\":39037},{\"attributes\":{\"id\":\"formula_35\"},\"end\":39835,\"start\":39803},{\"attributes\":{\"id\":\"formula_36\"},\"end\":40577,\"start\":40062},{\"attributes\":{\"id\":\"formula_37\"},\"end\":41311,\"start\":41272},{\"attributes\":{\"id\":\"formula_38\"},\"end\":42048,\"start\":41724},{\"attributes\":{\"id\":\"formula_39\"},\"end\":43445,\"start\":43263},{\"attributes\":{\"id\":\"formula_40\"},\"end\":43499,\"start\":43445},{\"attributes\":{\"id\":\"formula_41\"},\"end\":43850,\"start\":43746},{\"attributes\":{\"id\":\"formula_42\"},\"end\":45608,\"start\":45512}]", "table_ref": null, "section_header": "[{\"attributes\":{\"n\":\"1\"},\"end\":616,\"start\":604},{\"attributes\":{\"n\":\"2\"},\"end\":6630,\"start\":6608},{\"attributes\":{\"n\":\"4\"},\"end\":13204,\"start\":13180},{\"attributes\":{\"n\":\"5\"},\"end\":18912,\"start\":18877},{\"attributes\":{\"n\":\"6\"},\"end\":25086,\"start\":25074},{\"end\":32560,\"start\":32551},{\"attributes\":{\"n\":\"8\"},\"end\":42358,\"start\":42332},{\"attributes\":{\"n\":\"9\"},\"end\":48158,\"start\":48122},{\"attributes\":{\"n\":\"10\"},\"end\":49905,\"start\":49895},{\"end\":51202,\"start\":51193},{\"end\":52343,\"start\":52334},{\"end\":54490,\"start\":54480},{\"end\":54659,\"start\":54649},{\"end\":54963,\"start\":54949},{\"end\":55744,\"start\":55732}]", "table": null, "figure_caption": "[{\"end\":51033,\"start\":50428},{\"end\":51191,\"start\":51036},{\"end\":51471,\"start\":51204},{\"end\":51705,\"start\":51474},{\"end\":52218,\"start\":51708},{\"end\":52332,\"start\":52221},{\"end\":53336,\"start\":52345},{\"end\":53825,\"start\":53339},{\"end\":54478,\"start\":53828},{\"end\":54647,\"start\":54493},{\"end\":54947,\"start\":54662},{\"end\":55543,\"start\":54966},{\"end\":55730,\"start\":55546},{\"end\":56253,\"start\":55747}]", "figure_ref": null, "bib_author_first_name": "[{\"end\":56559,\"start\":56555},{\"end\":57291,\"start\":57290},{\"end\":57302,\"start\":57301},{\"end\":57304,\"start\":57303},{\"end\":57314,\"start\":57313},{\"end\":57316,\"start\":57315},{\"end\":57862,\"start\":57861},{\"end\":57876,\"start\":57875},{\"end\":57886,\"start\":57885},{\"end\":57895,\"start\":57894},{\"end\":57905,\"start\":57904},{\"end\":58496,\"start\":58488},{\"end\":58515,\"start\":58509},{\"end\":58935,\"start\":58934},{\"end\":58946,\"start\":58945},{\"end\":59232,\"start\":59231},{\"end\":59236,\"start\":59233},{\"end\":59477,\"start\":59476},{\"end\":59479,\"start\":59478},{\"end\":59494,\"start\":59490},{\"end\":59716,\"start\":59715},{\"end\":59718,\"start\":59717},{\"end\":59726,\"start\":59725},{\"end\":59728,\"start\":59727},{\"end\":60007,\"start\":60006},{\"end\":60009,\"start\":60008},{\"end\":60265,\"start\":60261},{\"end\":60544,\"start\":60538},{\"end\":60705,\"start\":60704},{\"end\":60715,\"start\":60714},{\"end\":61190,\"start\":61189},{\"end\":61200,\"start\":61199},{\"end\":61688,\"start\":61682},{\"end\":62094,\"start\":62093},{\"end\":62096,\"start\":62095},{\"end\":62579,\"start\":62578},{\"end\":62581,\"start\":62580},{\"end\":62805,\"start\":62799},{\"end\":62807,\"start\":62806},{\"end\":63039,\"start\":63038},{\"end\":63248,\"start\":63243},{\"end\":64024,\"start\":64023},{\"end\":64026,\"start\":64025},{\"end\":64039,\"start\":64038},{\"end\":64041,\"start\":64040},{\"end\":64568,\"start\":64567},{\"end\":64753,\"start\":64746},{\"end\":65068,\"start\":65060}]", "bib_author_last_name": "[{\"end\":56566,\"start\":56560},{\"end\":57299,\"start\":57292},{\"end\":57311,\"start\":57305},{\"end\":57322,\"start\":57317},{\"end\":57873,\"start\":57863},{\"end\":57883,\"start\":57877},{\"end\":57892,\"start\":57887},{\"end\":57902,\"start\":57896},{\"end\":57916,\"start\":57906},{\"end\":58507,\"start\":58497},{\"end\":58526,\"start\":58516},{\"end\":58943,\"start\":58936},{\"end\":58954,\"start\":58947},{\"end\":59241,\"start\":59237},{\"end\":59488,\"start\":59480},{\"end\":59502,\"start\":59495},{\"end\":59723,\"start\":59719},{\"end\":59735,\"start\":59729},{\"end\":60018,\"start\":60010},{\"end\":60273,\"start\":60266},{\"end\":60554,\"start\":60545},{\"end\":60712,\"start\":60706},{\"end\":60723,\"start\":60716},{\"end\":61197,\"start\":61191},{\"end\":61208,\"start\":61201},{\"end\":61695,\"start\":61689},{\"end\":62101,\"start\":62097},{\"end\":62586,\"start\":62582},{\"end\":62814,\"start\":62808},{\"end\":63047,\"start\":63040},{\"end\":63258,\"start\":63249},{\"end\":64036,\"start\":64027},{\"end\":64048,\"start\":64042},{\"end\":64576,\"start\":64569},{\"end\":64761,\"start\":64754},{\"end\":65080,\"start\":65069}]", "bib_entry": "[{\"attributes\":{\"doi\":\"10.1007/978-3-642-22993-0_16\",\"id\":\"b0\",\"matched_paper_id\":5213734},\"end\":57189,\"start\":56484},{\"attributes\":{\"doi\":\"10.1145/800113.803630\",\"id\":\"b1\",\"matched_paper_id\":15203635},\"end\":57800,\"start\":57191},{\"attributes\":{\"doi\":\"10.1145/3313276.3316369\",\"id\":\"b2\",\"matched_paper_id\":52301597},\"end\":58423,\"start\":57802},{\"attributes\":{\"id\":\"b3\",\"matched_paper_id\":233423456},\"end\":58886,\"start\":58425},{\"attributes\":{\"id\":\"b4\",\"matched_paper_id\":29126832},\"end\":59190,\"start\":58888},{\"attributes\":{\"id\":\"b5\"},\"end\":59403,\"start\":59192},{\"attributes\":{\"id\":\"b6\",\"matched_paper_id\":43372474},\"end\":59686,\"start\":59405},{\"attributes\":{\"doi\":\"10.1016/S0022-0000(69)80011-5\",\"id\":\"b7\",\"matched_paper_id\":31976931},\"end\":59925,\"start\":59688},{\"attributes\":{\"doi\":\"10.1145/800070.802201\",\"id\":\"b8\",\"matched_paper_id\":17177691},\"end\":60209,\"start\":59927},{\"attributes\":{\"doi\":\"10.1016/0304-3975(92)90173-D\",\"id\":\"b9\",\"matched_paper_id\":29728488},\"end\":60467,\"start\":60211},{\"attributes\":{\"id\":\"b10\"},\"end\":60648,\"start\":60469},{\"attributes\":{\"doi\":\"10.1109/LICS.2015.16\",\"id\":\"b11\",\"matched_paper_id\":11306975},\"end\":61104,\"start\":60650},{\"attributes\":{\"doi\":\"10.1109/LICS.2019.8785796\",\"id\":\"b12\",\"matched_paper_id\":84186333},\"end\":61612,\"start\":61106},{\"attributes\":{\"id\":\"b13\",\"matched_paper_id\":233393969},\"end\":62030,\"start\":61614},{\"attributes\":{\"doi\":\"10.1145/800076.802477\",\"id\":\"b14\",\"matched_paper_id\":5884932},\"end\":62515,\"start\":62032},{\"attributes\":{\"doi\":\"10.1137/0213029\",\"id\":\"b15\",\"matched_paper_id\":5884932},\"end\":62754,\"start\":62517},{\"attributes\":{\"id\":\"b16\"},\"end\":62969,\"start\":62756},{\"attributes\":{\"doi\":\"10.1016/0304-3975(78\",\"id\":\"b17\",\"matched_paper_id\":24271985},\"end\":63241,\"start\":62971},{\"attributes\":{\"doi\":\"10.1016/j.entcs.2008.12.042.URLhttps:/www.sciencedirect.com/science/article/pii/S1571066108005057\",\"id\":\"b18\"},\"end\":63925,\"start\":63243},{\"attributes\":{\"id\":\"b19\",\"matched_paper_id\":15994518},\"end\":64506,\"start\":63927},{\"attributes\":{\"id\":\"b20\",\"matched_paper_id\":18538649},\"end\":64742,\"start\":64508},{\"attributes\":{\"id\":\"b21\"},\"end\":64979,\"start\":64744},{\"attributes\":{\"id\":\"b22\",\"matched_paper_id\":14086694},\"end\":65688,\"start\":64981}]", "bib_title": "[{\"end\":56553,\"start\":56484},{\"end\":57288,\"start\":57191},{\"end\":57859,\"start\":57802},{\"end\":58486,\"start\":58425},{\"end\":58932,\"start\":58888},{\"end\":59474,\"start\":59405},{\"end\":59713,\"start\":59688},{\"end\":60004,\"start\":59927},{\"end\":60259,\"start\":60211},{\"end\":60702,\"start\":60650},{\"end\":61187,\"start\":61106},{\"end\":61680,\"start\":61614},{\"end\":62091,\"start\":62032},{\"end\":62576,\"start\":62517},{\"end\":63036,\"start\":62971},{\"end\":64021,\"start\":63927},{\"end\":64565,\"start\":64508},{\"end\":65058,\"start\":64981}]", "bib_author": "[{\"end\":56568,\"start\":56555},{\"end\":57301,\"start\":57290},{\"end\":57313,\"start\":57301},{\"end\":57324,\"start\":57313},{\"end\":57875,\"start\":57861},{\"end\":57885,\"start\":57875},{\"end\":57894,\"start\":57885},{\"end\":57904,\"start\":57894},{\"end\":57918,\"start\":57904},{\"end\":58509,\"start\":58488},{\"end\":58528,\"start\":58509},{\"end\":58945,\"start\":58934},{\"end\":58956,\"start\":58945},{\"end\":59243,\"start\":59231},{\"end\":59490,\"start\":59476},{\"end\":59504,\"start\":59490},{\"end\":59725,\"start\":59715},{\"end\":59737,\"start\":59725},{\"end\":60020,\"start\":60006},{\"end\":60275,\"start\":60261},{\"end\":60556,\"start\":60538},{\"end\":60714,\"start\":60704},{\"end\":60725,\"start\":60714},{\"end\":61199,\"start\":61189},{\"end\":61210,\"start\":61199},{\"end\":61697,\"start\":61682},{\"end\":62103,\"start\":62093},{\"end\":62588,\"start\":62578},{\"end\":62816,\"start\":62799},{\"end\":63049,\"start\":63038},{\"end\":63260,\"start\":63243},{\"end\":64038,\"start\":64023},{\"end\":64050,\"start\":64038},{\"end\":64578,\"start\":64567},{\"end\":64763,\"start\":64746},{\"end\":65082,\"start\":65060}]", "bib_venue": "[{\"end\":56734,\"start\":56720},{\"end\":57490,\"start\":57413},{\"end\":58114,\"start\":58028},{\"end\":58623,\"start\":58602},{\"end\":60829,\"start\":60817},{\"end\":61328,\"start\":61307},{\"end\":61792,\"start\":61771},{\"end\":62270,\"start\":62193},{\"end\":64212,\"start\":64139},{\"end\":65202,\"start\":65182},{\"end\":56686,\"start\":56596},{\"end\":57411,\"start\":57345},{\"end\":58026,\"start\":57941},{\"end\":58600,\"start\":58528},{\"end\":59025,\"start\":58956},{\"end\":59229,\"start\":59192},{\"end\":59532,\"start\":59504},{\"end\":59786,\"start\":59766},{\"end\":60045,\"start\":60041},{\"end\":60321,\"start\":60303},{\"end\":60536,\"start\":60469},{\"end\":60815,\"start\":60745},{\"end\":61305,\"start\":61235},{\"end\":61769,\"start\":61697},{\"end\":62191,\"start\":62124},{\"end\":62617,\"start\":62603},{\"end\":62797,\"start\":62756},{\"end\":63087,\"start\":63069},{\"end\":63462,\"start\":63366},{\"end\":64137,\"start\":64071},{\"end\":64589,\"start\":64578},{\"end\":64850,\"start\":64804},{\"end\":65149,\"start\":65110}]"}}}, "year": 2023, "month": 12, "day": 17}