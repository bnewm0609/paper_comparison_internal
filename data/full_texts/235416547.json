{"id": 235416547, "updated": "2022-09-30 04:28:13.669", "metadata": {"title": "No-FAT: architectural support for low overhead memory safety checks", "authors": "[{\"first\":\"Mohamed\",\"last\":\"Ziad\",\"middle\":[\"Tarek Ibn\"]},{\"first\":\"Miguel\",\"last\":\"Arroyo\",\"middle\":[\"A.\"]},{\"first\":\"Evgeny\",\"last\":\"Manzhosov\",\"middle\":[]},{\"first\":\"Ryan\",\"last\":\"Piersma\",\"middle\":[]},{\"first\":\"Simha\",\"last\":\"Sethumadhavan\",\"middle\":[]}]", "venue": null, "journal": "Proceedings of the 48th Annual International Symposium on Computer Architecture", "publication_date": {"year": 2021, "month": null, "day": null}, "abstract": "Memory safety continues to be a significant software reliability and security problem, and low overhead and low complexity hardware solutions have eluded computer designers. In this paper, we explore a pathway to deployable memory safety defenses. Our technique builds on a recent trend in software: the usage of binning memory allocators. We observe that if memory allocation sizes (e.g., malloc sizes) are made an architectural feature, then it is possible to overcome many of the thorny issues with traditional approaches to memory safety such as compatibility with unsecured software and significant performance degradation. We show that our architecture, No-FAT, incurs an overhead of 8% on SPEC CPU2017 benchmarks, and our VLSI measurements show low power and area overheads. Finally, as No-FAT's hardware is aware of the memory allocation sizes, it effectively mitigates certain speculative attacks (e.g., Spectre-V1) with no additional cost. When our solution is used for pre-deployment fuzz testing it can improve fuzz testing bandwidth by an order of magnitude compared to state-of-the-art approaches.", "fields_of_study": "[\"Computer Science\"]", "external_ids": {"arxiv": null, "mag": null, "acl": null, "pubmed": null, "pubmedcentral": null, "dblp": "conf/isca/ZiadAMPS21", "doi": "10.1109/isca52012.2021.00076"}}, "content": {"source": {"pdf_hash": "67009c8b64b46014165e91603f4950eb70a782ef", "pdf_src": "ACM", "pdf_uri": null, "oa_url_match": false, "oa_info": null}, "grobid": {"id": "5e0a7a148520237d75badd2d08a3ba12ddfedc87", "type": "plain-text", "url": "s3://ai2-s2-pdf-extraction-prod/parse-results/s2orc_worker/67009c8b64b46014165e91603f4950eb70a782ef.txt", "contents": "\nNo-FAT: Architectural Support for Low Overhead Memory Safety Checks\n\n\nMohamed Tarek mtarek@cs.columbia.edu \nDepartment of Computer Science\nColumbia University New York\nNYUSA\n\nIbn Ziad \nDepartment of Computer Science\nColumbia University New York\nNYUSA\n\nMiguel A Arroyo miguel@cs.columbia.edu \nDepartment of Computer Science\nColumbia University New York\nNYUSA\n\nEvgeny Manzhosov evgeny@cs.columbia.edu \nDepartment of Computer Science\nColumbia University New York\nNYUSA\n\nRyan Piersma ryan.piersma@cs.columbia.edu \nDepartment of Computer Science\nColumbia University New York\nNYUSA\n\nSimha Sethumadhavan \nDepartment of Computer Science\nColumbia University New York\nNYUSA\n\nNo-FAT: Architectural Support for Low Overhead Memory Safety Checks\n10.1109/ISCA52012.2021.00076Index Terms-Bounds CheckingFuzzingMemory SafetyMicroarchitectureSpectre-V1Systems Security\nMemory safety continues to be a significant software reliability and security problem, and low overhead and low complexity hardware solutions have eluded computer designers. In this paper, we explore a pathway to deployable memory safety defenses. Our technique builds on a recent trend in software: the usage of binning memory allocators. We observe that if memory allocation sizes (e.g., malloc sizes) are made an architectural feature, then it is possible to overcome many of the thorny issues with traditional approaches to memory safety such as compatibility with unsecured software and significant performance degradation. We show that our architecture, No-FAT, incurs an overhead of 8% on SPEC CPU2017 benchmarks, and our VLSI measurements show low power and area overheads. Finally, as No-FAT's hardware is aware of the memory allocation sizes, it effectively mitigates certain speculative attacks (e.g., Spectre-V1) with no additional cost. When our solution is used for predeployment fuzz testing it can improve fuzz testing bandwidth by an order of magnitude compared to state-of-the-art approaches.\n\nI. INTRODUCTION\n\nMemory safety violations in programs have provided a significant opportunity for exploitation by attackers. For instance, Microsoft recently revealed that the root cause of around 70% of all exploits targeting their products are software memory safety violations [37]. Similarly, the Project Zero team at Google reports that memory corruption issues are the rootcause of 68% of listed CVEs for zero-day vulnerabilities between 2014 and 2019 [22].\n\nTo address the threat of memory safety, software checking tools (e.g., AddressSanitizer [52]) and fuzz testing are widely deployed. In software fuzz testing, binaries are instrumented with a tool like AddressSanitizer to detect memory safety vulnerabilities and run with inputs mutated from a set of exemplary inputs in the hopes of detecting bugs before deployment. Google has reported that it has been fuzzing about 25,000 machines continuously since 2016, which has resulted in the identification of many critical bugs in software such as Google Chrome and several open source projects [7]. Assuming 15 cents per CPU hour for large memory machines-a requirement for reasonable performance on fuzz testing-the investment in software fuzzing for detecting memory errors could be close to a billion dollars at just one company. Despite a Herculean effort by software vendors, memory safety vulnerabilities continue to slip through, ending up in deployed systems. Recognizing that pre-deployment fuzz tests can never be complete, companies have also proposed postdeployment crowdsourced fuzz testing [38], [59]. For instance, Mozilla recently created a framework for fuzzing software using a cluster of fuzzers made by users who are willing to trade and contribute their CPU resources (e.g., using office workstations after-hours for fuzz testing) [38]. Assuming that many companies participate and these tests run for enough time, on a global scale, the amount of energy invested in producing reliable software may be even higher than the amount of time running the software with crowdsourced testing. Thus, increasing the efficiency of memory error detection can have significant green benefits in addition to improving security and reliability.\n\nResearchers and commercial vendors have also stepped up to the call to reduce inefficiencies in software testing and security. There is a long history of academic proposals that have continuously chipped away at these overheads for detecting memory safety vulnerabilities over the past 25 years ( [51], [3], [47], [26], [14], [39], [61], [56], [50], [55], [27]). Commercial vendors have also proposed or manufactured hardware with support to mitigate these overheads (Intel's MPX [43], ARM's MTE [2], and Oracle's ADI [45]).\n\nIn this paper, we show that the overheads of providing memory safety can be decreased even further with novel hardware support. Traditional memory safety techniques incur overheads from two sources: (1) storage of metadata to detect memory safety violations, and (2) computational overheads of memory safety checks based on the stored metadata. No-FAT 1 , our system, eliminates all metadata attached to pointers, and hides the computational overheads of the metadata checks by performing them in parallel with regular lookups.\n\nThe technological change that facilitates these improvements in No-FAT is the increasing adoption of binning allocators. Binning memory allocators use collections of pages (called bins), where each bin is used to allocate objects of the same size. Using bins enables the allocator to quickly serve ptr = malloc( ); ptr[1] = 'A';\n\n... memory allocation structures, and using that information to provide memory safety, have been very well tested with software implementations [1], [16], [19]. Moreover, No-FAT has three advantages over prior works. First, prior works suffer from high performance overheads (100%) which this work mitigates. Second, we show that a degree of temporal safety and intra-object spatial safety can be offered by our implementation over prior software works with simple modifications. Third, we improve over prior works by providing support for arbitrary sized allocations (as opposed to power-of-two allocation sizes). All of No-FAT's software transformations are performed using the Clang/LLVM compiler framework [32]. Our experimental results with the SPEC CPU2017 benchmark suite indicate that the overheads of No-FAT are on average 8% with very conservative measurements. Our VLSI implementation results with 45nm NangateOpenCell show that No-FAT can be efficiently added to modern processors with negligible performance, area, and power overheads.\n\nIn summary, this paper makes the case for standardizing memory allocation sizes and explicitly making this information available to the architecture. We observe at least three distinct benefits:\n\n\u2022 Improving fuzz-testing time. Currently companies spend hundreds of millions of dollars testing software programs for bugs. A majority of these bugs tend to be intricate memory safety bugs. Exposing allocation sizes to hardware simplifies the checks for memory safety and improves the fuzz testing bandwidth by over 10x based on state-of-the-art solutions (e.g., AddressSanitizer based fuzzing). \u2022 Improving run-time security. Despite the best effort of software engineers to produce bug-free code, some of these bugs do end up in production, and pose a risk to end users. If users wish to protect against remaining residual risk, our solution offers the lowest overhead protection among all published memory safety solutions that thwart data corruption attacks. \u2022 Improving resilience to Spectre-V1 attacks. Exposing allocation sizes to the hardware allows the hardware to effectively perform bounds checking even for speculative memory accesses.\n\n\nII. NO-FAT SYSTEM OVERVIEW\n\n\nA. Preliminaries\n\nBinning memory allocators have gained prominence in the past decade and are now widely used [21], [20], [18], [34]. In a binning alloctor, the heap is divided into regions where each region is used to allocate objects of a pre-determined size. Thus, the memory size returned to a program is rounded up to one of the standard sizes offered by the allocator. For example, allocation requests that are less than 16 bytes come from the first region, allocation requests for 16 to 32 bytes come from the second region and so on. In contrast, nonbinning allocators can provide the exact amount of memory requested by the program at the cost of an additional allocation header to store its size [33]. Binning allocators trade off a little memory fragmentation for faster allocation and deallocation times, and practically speaking, the fragmentation overheads tend to be negligible for most programs. In this paper, we expose the pre-determined sizes offered by a binning memory allocator to the hardware to provide memory safety. 2\n\n\nB. How does No-FAT provide Inter-allocation Spatial Memory Safety?\n\nThe goal of inter-allocation spatial memory safety is to be able to identify pointer-based accesses that access addresses outside the region of memory allocated to that pointer. To perform this check we need three pieces of information: (1) the starting address of the allocation, (2) the size of the space allocated to the pointer, and (3) the address of the pointerbased access. The benefit of binning allocators is that (1) and (2) can be computed from (3) using simple arithmetic and concurrently with the data access.\n\nGiven a pointer address, we determine the region that the pointer is from. Say each region is S GiB, and the heap starts at address H. Then the region of the pointer is (ptr \u2212 H) >> log 2 (S). Once the region is known, we can know the size of the allocation because all allocations from the region are of the same size. The base address of the allocation can be computed by (ptr/size) * size, whereas the combination of integer division and multiplication has the effect of rounding ptr down to the nearest size(ptr)-aligned boundary, which is the base address.\n\nFor example, let us assume that the heap starting address is H = 0x380000000000 and the memory allocator uses 64 bins (i.e., regions) each of size 32 GiB, where the third region is used to store allocations of size 32B. When the program executes char * A = malloc(32), the memory allocator might return the following base address: 0x381000000040. Now, given an arbitrary pointer ptr = 0x381000000045, the hardware computes the region number by subtracting the heap starting address (i.e., 0x001000000045) and ignoring the 35 LSBs (i.e., 0x002, which is the third region). Then, the hardware retrieves the allocation size from the hardware table. Finally, the base address can be computed as (0x381000000045/32) * 32 = 0x381000000040.\n\nHow does this information help protect against attacks? Let us say an attacker has the ability to control the index variable of a dynamically allocated array. With this ability, the attacker can cause the pointer to go out-of-bounds and subvert the memory instruction in order to read/write from a different allocation. If we simply calculated the base address from the attacker modified address we would not be able to catch the attack since we do not have an expectation of what the base address ought to have been. To avoid this case, No-FAT extends memory access instructions with an extra operand that carries a trusted base address. The trusted base address is simply the base address returned by malloc. This way we can verify the correctness of the access by computing the base address of the input pointer and matching it against the trusted base address, which is part of the instruction.\n\nComputing the base address of a pointer for every memory access instruction is a costly operation as it includes a 64-bit division operation followed by a 64-bit multiplication. Division is a relatively expensive operation even on modern CPUs. To simplify the bounds checking operation, No-FAT uses the following check isValid(ptr, base) = ptr \u2212 base < size(base). The idea is simple. As the instruction holds the trusted base address, we first compute its corresponding size by extracting the region number as explained before. Then, we compare this size to the difference between the input pointer and the trusted (i.e., instruction-based) base address. If the pointer overflows to an adjacent allocation, the difference will be larger than the computed difference. If the pointer underflows to a previous allocation, ptr \u2212 base will be a negative number that will be interpreted as a large positive number that is \u2265 size(base) as we use unsigned arithmetic.\n\nTo make No-FAT compatible with unprotected code, memory instructions that need to perform the check are emitted using special instructions. Specifically No-FAT uses Secure Load (secure_load) and Secure Store (secure_store) instructions (see Section III) that use the allocation base address as a distinct operand. This operand is propagated in the binary using a compiler pass (see Section V). This way secure_load and secure_store can verify access boundaries using the isValid check, as described above. On machines which do not have hardware support for No-FAT, secure_load can be interpreted as a regular load and the third operand will be ignored.\n\n\nC. How does No-FAT provide Intra-allocation Spatial Memory Safety?\n\nThe goal of intra-allocation spatial memory safety is to prevent overflows from one field to another within the same allocation. The strategy used by No-FAT for intra-allocation safety is to convert the intra-allocation memory safety problem to an inter-allocation problem. No-FAT uses a source-to-source transformation, Buf2Ptr, which has been previously used in the area of data layout optimizations for enhancing performance [25], [49], [66]. Buf2Ptr promotes buffer fields, which exist in C/C++ structs (or classes), into their own allocations. To illustrate Buf2Ptr, consider the example in Listing 2. The array field, buf [10], within the struct, Foo, is replaced with a promoted pointer, p_buf, and a new variable for the original array is defined (Foo_buf [10]). As a result of this transformation, allocations, deallocations, and usages of the original field must also be properly promoted. For example, an allocation for a composite data type (e.g., Foo) becomes separate allocations based on the number of fields promoted (e.g., Foo_buf). As the standalone allocations have their own base address, they can be protected with No-FAT, as described above. \n\n\nD. Temporal Memory Safety.\n\nTo enforce temporal memory safety, No-FAT tags the upper 16-bits of data pointers on 64-bit systems with a random value upon malloc. This value is propagated in our new instructions (i.e., secure_load and secure_store) as part of the memory address and the allocation base address. This way, comparing the tag of the memory address with the tag of the allocation base address catches temporal safety violation with a probability of 1 \u2212 (1/2 16 ) = 99.9984%. When a virtual memory region is reallocated to a different object it receives a new random tag, implicitly nullifying all dangling pointers which used to point to the old object, as they are likely to have different tags.\n\n\nE. Handling Procedure Calls and Nested Pointers\n\nConsider the following: q = p + 16; x = Bar(q);. Here, p is a pointer to a 32B allocation, and q is a derived pointer to a field within the allocation. In this case, the use of a pointer happens in a different function (aka context) than the one where it was originally created. Thus, all functions using the base pointer (i.e., p) or its derivatives (e.g., q) need to be given access to the base address. One way to do this would use a source-to-source transformation to add an extra operand to all functions that use pointer arguments. This way the address would be in the stack of the needed function. This solution requires changing the function signature and breaks compatibility with unprotected code. Instead, we use a different, simpler abstraction. Whenever a data pointer goes out of context (i.e., passed to another function or spilled to memory), we first verify that it is an inbounds pointer using a Verify Bounds (verify_bounds) instruction (see Section III). When a pointer is loaded from memory, we first compute its base address using a compute_base instruction and propagate this base address to all the following memory instructions as a third operand.\n\nWith this approach, can the attacker abuse pointers that escape to another function? This is not possible because (1) we verify the bounds of the pointer before spilling it to memory and (2) we protect the memory with No-FAT so we are assured that the pointer stored in memory cannot be overwritten. This abstraction also permits No-FAT to use only intra-procedural analysis, which simplifies the implementation. Going back to our example, we first verify the bounds of q before calling Bar(q). This is done with one verify_bounds instruction that takes the base address of q as an operand and matches it against the computed base address of p + 16. Inside Bar, we first call compute_base with q as an operand to retrieve its base address and propagate this base address to all memory instructions that uses q as an address.\n\n\nIII. ARCHITECTURE SUPPORT\n\nNo-FAT adds the following instructions to the ISA:\n\n\u2022 secure_store/secure_load <R1>, <R2>, <R3>: These instructions use three register operands. The values in registers R1 and R2 point to the store/load address and source/destination register as usual. The value in register R3 is reserved for the allocation base address and is propagated by the compiler. Upon executing this instruction, the hardware computes the allocation size of R3 and compares it to the difference between the address stored in R1 and R3. An exception is thrown in case of R1 \u2212 R3 \u2265 size(R3). Additionally, the hardware matches the upper 16 bits of R1 and R3 to detect temporal memory safety violations.\n\n\u2022 verify_bounds <R1>, <R2>: This instruction is used to check the bounds of pointers before storing them to memory (or passing them to a different function). It uses two register operands. The value in register R1 is a pointer whereas the value in register R2 is reserved for the allocation base address and is propagated by the compiler. Similar to secure_store and secure_load, upon executing this instruction, the hardware computes the allocation size of R2 and compares it to the difference between the address stored in R1 and R2. An exception is thrown in case of R1 \u2212 R2 \u2265 size(R2) to indicate that an out-of-bounds pointer is being stored to memory.\n\n\u2022 compute_base <R1>, <R2>: This instruction takes a memory address (i.e., pointer) as input in R1 and returns the allocation base address of this pointer in R2. This instruction is used to retrieve the correct base address of pointers that are passed to different contexts (e.g., through function calls).\n\n\nIV. MICROARCHITECTURE DESIGN\n\nIn this section, we describe the four hardware components that are needed to enable No-FAT. Table is a hardware structure, which is initialized at program startup with a process's allocation size configuration. The table is designed to work with binning allocators. The MAST enables No-FAT to support generic (i.e., non-powers-of-two) allocation sizes for each bin. 3 In this work, we use a simple binning allocator that divides the heap into N equally sized bins. Based on our experiments, using 64 distinct bins is sufficient to balance performance and memory utilization. Thus, we use a 64-entry MAST with an entry size of 16B resulting in a total size of 1KB. Each entry holds an 8B size field and an 8B inverse size field. The size field of the nth entry is used to hold the allocation size used for the nth allocator bin. The inverse size field is an optimization that is discussed later. As a program's heap is contiguous, we use a single hardware register to store the starting address of the program heap and use it to derive the starting address of all bins. Some binning allocators (e.g., TCmalloc [21] and Jemalloc [20]) may change the allocation size used by one bin at runtime if all objects in the bin are freed. In this case, the allocator can simply update the MAST entry with the new size. We leave the investigation of other memory allocators to future work. Bounds Checking Module. The bounds checking module takes two 64-bit operands, Ptr and Base Ptr . It subtracts the two operands and compares the result with the allocation size of Base Ptr . To compute the size of a given base pointer, the bounds checking module first maps the pointer to an allocation bin using simple subtract and shift operations followed by an access to the MAST to retrieve the allocation size. Next, the bounds checking module uses a subtraction operation (Ptr \u2212Base Ptr ) followed by a 64-bit unsigned comparison with the recently retrieved size (i.e., size(Base Ptr )). The last step is the temporal check, which is done with a 16-bit comparison operation between the upper 16 bits of Ptr and Base Ptr .\n\n\nMAST. The Memory Allocation Size\n\nThe bounds checking module is invoked during the secure_load and secure_store instructions to prevent out-of-bounds pointer dereference and during the verify_bounds instruction to prevent out-of-bounds pointers from escaping to memory. As shown in Figure 2, the check operation can be totally hidden within the access latency for the L1 data cache. Base Computing Module. As discussed in Section II-E, pointers can be passed from one context to another. As No-FAT relies on simple intra-procedural compiler analysis, it needs to recompute the base address every time a pointer is loaded from memory (e.g., double pointers) or used as a function argument. This feature is currently implemented with compute_base instruction that invokes the Base Computing Module. This module takes a 64-bit ptr operand and computes its base address using ptr/size(ptr) * size(ptr). While size(ptr) requires one MAST lookup, the division operation is costly. No-FAT uses a common optimization that replaces the expensive division (ptr/size(ptr)) with a cheaper multiplication (ptr * (1/size(ptr))) by using fixed-point arithmetic. This approach is feasible since the set of allocation sizes is constant, and thus the set of allocation size reciprocals can be pre-calculated and stored in the MAST along side with allocation size. Dedicated Register File. As our secure_load and secure_store instructions use a third register operand, they may introduce register pressure. Thus, No-FAT adds a set of architectural registers that the compiler can exclusively use for holding and propagating allocation base addresses. The new registers are saved in a separate register file that is accessed in parallel to the regular register file.\n\n\nV. SOFTWARE DESIGN\n\nIn this section, we describe the memory allocator, compiler and operating system changes to support No-FAT.\n\n\nA. Dynamic Memory Management\n\nOne of No-FAT's key contributions is making the allocation size an architectural feature (i.e., sharing the allocation size information between software and hardware). To enable this feature, No-FAT requires binning memory allocators, in which a memory page is used to allocate objects of the same size. No-FAT does not add any constraints on how the allocator manages its internal metadata (e.g., free lists). No-FAT only intercepts calls to common memory management operations. For example, No-FAT intercepts all calls to malloc/new and tags the returned pointer with a random 16-bit value for ensuring temporal memory safety. Upon deallocation, No-FAT intercepts the calls to free/delete and removes the tag bits before calling the allocator's own free/delete API. When pointers are passed to uninstrumented code, tags are ignored by the hardware to maintain compatibility.\n\n\nB. Compiler Support\n\nHeap Instrumentation. To guarantee spatial protection, we implement an instrumentation pass at the LLVM IR level that replaces program loads and stores with our new instructions, secure_load and secure_store. To prepare the allocation base address register operand, we use simple functionlevel analysis to propagate the pointers returned by malloc or new intra-procedurally. To handle out-of-context pointers (e.g., those that are loaded from memory or passed as function arguments), our compiler pass inserts compute_base instructions in the corresponding locations to resolve the allocation base address. Our pass inserts verify_bounds instructions in places where a pointer is stored to memory. This can happen due to (a) casting pointer (ptr) to an integer (i.e., i = (int)ptr), (b) storing ptr to memory (i.e., * r = ptr), (c) passing ptr to a function (f(ptr)), and (d) returning ptr from a function (i.e., return ptr). Source-to-Source Transformation. In order to achieve intraallocation memory safety, we use a source-to-source transformation (Buf2Ptr), as described in Section II-C. Buf2Ptr is implemented using Clang's rewriter interface. First, we perform an AST traversal over each translation unit to collect a whole program view of composite data types (e.g., structs) and their usages. Then, we perform a second traversal to perform the actual rewriting.\n\nStack & Global Instrumentation. In order to achieve full memory safety on all memory segments, we extend No-FAT to protect objects that are allocated on the stack and global memory. At compile time, No-FAT instruments all stack and global allocations (e.g., alloca) to use the same bins, which are used to satisfy heap allocations. This way No-FAT uses a unified method to enforce memory safety on all program memory segments. To avoid overheads related to allocating stack objects on the heap, we adopt the same pointer mirroring and memory aliasing techniques used in prior work [19].\n\n\nC. Operating System Support\n\nMAST Initialization. During program initialization, the memory allocator needs to pass the allocation size information to the hardware. This is a one time task that can be done with a special system call or by writing to a hardware-mapped memory region. The size of the table is fixed, as described in Section IV. Context Switching. Upon a context switch, No-FAT requires the operating system (OS) to store the MAST (and the dedicated register file contents) of the interrupted process and update the MAST and register file of the new process. Both the MAST and the register file contents are of fixed size and can be stored as part of the process control block. This step is likely to add minimal overhead (a few load and store instructions takes \u2264 0.1\u03bcS) to the OS context switch (typically 3 \u2212 5\u03bcS). Privileged Exceptions. When No-FAT's hardware detects an access violation, it throws a privileged exception once the instruction becomes non-speculative. The operating system needs to properly handle this exception as with other privileged exceptions (e.g., page faults). We also assume the faulting address is passed in an existing register so that it can be used for reporting/investigation purposes.\n\nFinally, as No-FAT uses regular data pointers and does not change an object's memory layout, it naturally supports key OS functionalities such as inter-process data sharing, copy-onwrite, and memory-mapped files. As No-FAT uses no per-word metadata, it does not require any changes to the page swapping subsystem.\n\n\nVI. SECURITY ANALYSIS\n\n\nA. Threat Model\n\nAdversarial Capabilities. We assume a threat model comparable to that used in contemporary related work on memory safety defenses [61], [56], [62], [55], [27]. We assume the victim program to have one or more vulnerabilities that an attacker can exploit to gain arbitrary read and write capabilities in the memory; our goal is to mitigate both spatial and temporal memory violations. Furthermore, we assume that the adversary is aware of No-FAT and has access to the source code, or binary image, of the target program. Finally, we assume that the attacker cannot tamper with the per-process size configurations as they are stored in the MAST and are kept as read-only in kernel memory upon context switch. Hardening Assumptions. We assume that all hardware components including the ones proposed in this work are trusted and tamper-resistant, and therefore consider attacks that exploit hardware vulnerabilities, such as rowhammer [28] and side-channel attacks [65], to be out of scope. For speculative execution attacks [29], we include Spectre-V1 (aka bounds checking bypass) in our threat model as it violates memory safety (speculatively). We do not include Spectre variants that manipulate branch predictor buffers as No-FAT does not affect program branch behavior.\n\n\nB. Security Discussion\n\nBuffer Under-/Over-flows. No-FAT defends against the exploitation of buffer overflows (and underflows) by detecting out-of-bounds pointers. No-FAT takes advantage of making the allocation size (per memory page) an architectural feature to enforce spatial memory safety. No-FAT not only protects heapbased allocations, but also stack and global memory regions. To do so, No-FAT reserves alias regions for stack and global objects such that both can use the same allocation size (per memory page) feature. No-FAT's protection applies to both inter-and intra-allocation safety (as Buf2Ptr reduces the intraallocation problem to inter-allocation). Use-after-frees. As described in Section II-D, No-FAT provides temporal memory safety by tagging data pointers and validating the tags as part of the spatial bounds checking process. The same allocated virtual/physical memory region can have up to 2 16 different tags, increasing the chances of catching dangling pointers (as dangling pointers use the old tags of the same allocated region).\n\nControl-Flow Hijacking Attacks. In many attack scenarios, corrupting code pointers becomes a preferred attack vector. For instance, control-flow hijacking attacks, such as ROP [54] and its variants [10], [6], corrupt the return address of a function (or a function pointer) to hijack the control flow of a program. As all of the aforementioned attacks typically start with a spatial/temporal memory safety violation, No-FAT effectively stops control-flow hijacking attacks by eliminating their root cause.\n\nData-Oriented Attacks. Given a memory safety vulnerability, attackers can launch a data-only attack [11], [24], [46], [12] without abusing any code pointer. No-FAT mitigates those attacks by ensuring that all loads/stores happen between their legitimate bounds. If attackers move a pointer out of bounds to write to a (non-)adjacent allocation, No-FAT throws an exception as the computed base address of the malicious pointer does not match the base address operand of the secure_load/secure_store instructions.\n\nUninitialized Reads. No-FAT does not explicitly mitigate uninitialized read attacks, in which attackers can leak information from stack/heap locations by loading from these locations before doing a store operation. To mitigate this attack vector, No-FAT requires that deallocated objects (heap or stack) be zeroed out. Prior work showed that this process can be done efficiently in software [36].\n\nThird-party Library Attacks. While No-FAT maintains full compatibility with third party libraries that are not instrumented with our compiler pass, we offer no security guarantees about vulnerabilities that exist in such uninstrumented code. To increase the security coverage, we create software wrappers for commonly used memory functions that appear in third-party libraries (e.g., memcpy, memset, and memove) to ensure that they cannot be used by an attacker to undermine No-FAT. For example, Listing 3 shows the pseudocode for our memcpy wrapper that first computes the base address of the source/destination pointer and ensures it matches the base address of the source/destination plus size before calling the original memcpy function. \n\n\nC. Spectre-V1 Resiliency\n\nA key advantage of No-FAT over prior memory safety defenses is its natural resiliency to certain classes of speculative side-channel attacks, namely Spectre-V1 (bounds checking bypass) [29]. We first summarize how Spectre-V1 works. Then, we show how it can undermine prior memory safety techniques. Finally, we describe how No-FAT mitigates it with no extra cost. Attack Summary. To better understand how Spectre-V1 works, let us consider the example shown in Listing 4, in which the attacker controls the index, i. The attacker first trains the branch predictor by supplying multiple valid values for i (i.e., less than a->length). Then, the attacker provides an out-of-bounds index i > a->length. While this index violates the software bounds check in Line 1, the hardware will mispredict the condition (i.e., branch is taken) and speculatively executes Lines 2 and 3. As a result, a speculative buffer overread occurs at Line 2 and the read value (secret) is used as an index at Line 3. The attacker finally leaks the secret value via a covert channel as speculative execution leaves traces in processor structures (e.g, data caches). For example, the address in Line 3 depends on the secret, thus flushing and reloading the L1 data cache will allow the attacker to find out which cache line was used and reveals the secret. Prior Work. Spectre-V1 is a main concern for prior memory safety techniques as it can be used to undermine their security guarantees. For example, attackers can infer the memory tag value of memory without triggering a memory tagging violation and use that to bypass memory tagging solutions (i.e., SPARC ADI [45] and ARM MTE [2]) [5]. To mitigate Spectre-V1, prior work suggested inserting serialization instructions (aka fences) at certain program points to prevent the processor from speculatively bypassing bounds checks [8]. This approach can result in up to 10x runtime overheads [44]. Another line of work proposed isolating speculatively accessed data to prevent leakage via covert-channels [67], [4]. While these defenses reduce the performance overheads, they add substantial complexities to the hardware design. No-FAT vs. Spectre-V1. No-FAT's secure_load and secure_store instructions are resilient against Spectre-V1 by construction. Even if the processor mispredicted the branch instruction in Line 1 of Listing 4, the secure_load that is used in Line 2 holds the legitimate base and bounds of a->data as a third operand. Thus, it immediately recognizes the speculative access as an out-of-bounds access and does not allow a->data[i] to access the cache (to avoid modifying the cache state). Hence, No-FAT is resilient against the recent Spectre attack, namely the \u03bcop Disclosure Primitive, which exploits the micro-op cache as a timing channel to transmit out-of-bounds secrets [48]. Additionally, No-FAT prevents the dependent load instruction from executing by unmarking the ready bit on the register that has the load value (then raising an exception when the out-of-bounds access is non-speculative). We delay raising the exception until the commit stage to avoid false alarms (i.e., if the out-of-bounds memory access happens due to a benign branch misprediction).\n\nOther Spectre Variants. As stated in Section VI-A, No-FAT does not protect against Spectre-variants other than V1 (bounds checking bypass) as the main focus in this work is memory safety. Examples of other Spectre variants include Spectre-V2 (aka branch target injection), which can be used by an attacker to pollute the branch target buffer and force the victim program to speculatively jump to an arbitrary sequence of instructions (called a Spectre gadget). If the Spectre gadget has memory access instructions (e.g., secure_loads), they will be speculatively executed based on the current contents of register R1 (memory address) and register R3 (allocation base address) even if those register contents belong to an incorrect execution context. The same argument applies if the Spectre gadget includes compute_base instructions. Other Spectre-V2 mitigations can be used to address this attack vector [30].\n\n\nVII. EVALUATION\n\nWe evaluate No-FAT across multiple dimensions. First, we measure the hardware overheads of No-FAT. Second, we compare the performance of No-FAT against state-of-the-art preand post-deployment memory safety solutions using SPEC CPU2017. Third, we analyze No-FAT's memory overheads. Fourth, we evaluate Buf2Ptr by estimating its memory and performance for all benchmarks.\n\n\nA. Hardware Overheads\n\nNo-FAT requires minimal hardware changes. Qualitatively, No-FAT requires a 1KB MAST and extra logic to compute the allocation base address (namely, one subtract, one shift, two 64-bit multipliers) and the bounds checking module (namely, one subtract, one shift, one 64-bit comparator, and one 16-bit comparator). As the bounds checking operations happen in parallel to the L1 data and tag accesses, processor clock frequency should not be impacted. We quantified these overheads by adding No-FAT to a typical energy optimized 32KB direct mapped L1 cache. We implement our modules using Verilog and synthesize them with the Synopsys design compiler and the 45nm NangateOpenCell library. We generate the SRAM arrays (for MAST and the tag/data arrays) with OpenRAM [23]. Table I summarizes our VLSI implementation results. The timing delay of the bounds checking module is minimal (0.81ns) as it uses a pipelined design that first fetches the allocation size from MAST and then does a subtraction followed by comparison operations. This latency can be overlapped with the access latency of L1 cache. The bounds checking module adds 6% additional area compared to the L1 data cache. This area is dominated by the SRAMs of MAST and the two comparators. On the other hand, the base computing module (which is invoked by the compute_base instruction) area is dominated by the 64-bit multiplier. The module latency can be further optimized with a more customized multiplier.\n\n\nB. Software Performance Overheads\n\nOur VLSI measurements show that No-FAT hardware modifications add no performance overhead. Here, we evaluate the software-based overheads. No-FAT instructions secure_load and secure_store are similar to regular loads and stores. Thus, they do not increase code size. While our instructions use one more register operand compared to regular memory instructions, the extra register pressure is compensated for by adding a No-FAT-specific register file (i.e., similar to Intel MPX). The additional functionality performed by our instructions can be totally hidden within the processor pipeline as shown in Section VII-A. However, No-FAT requires a binning memory allocator and invokes additional instructions (verify_bounds to verify pointer bounds before storing them to memory and compute_base to compute the allocation base address of arbitrary pointers when they are loaded from memory).\n\nWithout loss of generality, we implement No-FAT on top of a simple binning allocator (Binning-Malloc [18]) that divides the virtual memory into 64 regions, each of size 32GB. Each region is used to satisfy heap-allocation requests of a unique size. Stack and global memory allocations are satisfied using special carved out sections of the same 32GB regions.\n\nTo estimate the compute_base instruction overheads, we implement an IR pass using the LLVM/Clang compiler [32] to instrument the code and insert two mul instructions followed by a store instead of compute_base instructions in the corresponding locations. Similarly, we insert dummy store instructions in place of verify_bounds instructions. We use a store to make sure the instruction is not omitted by compiler optimizations. Evaluation Setup. We run our experiments on a bare-metal Intel Skylake-based Xeon Gold 6126 processor running at 2.6GHz with RHEL Linux 7.5 (kernel 3.10). We implement No-FAT using Clang 4.0.0 and compare it against AddressSanitizer (ASan) and Intel MPX, as representatives of pre-and post-deployment memory safety solutions, respectively. Each tool is run using its best recommended settings [43]. We run each tool such that it suppresses its warnings or errors so that benchmarks run to completion. Additionally, we disable any reporting to minimize the performance impact this functionality may have. Given the difference in compiler versions and optimization levels that each tool supports, we normalize each against their respective baselines for proper comparison. 4 To get better insight on No-FAT overheads, we also run a software-only version of No-FAT that explicitly checks pointer bounds in software with no hardware support (Software-EBB) and a malloc-only version that only uses the binning memory allocator with no bounds checking (Binning-Malloc). We use the SPEC CPU2017 benchmark suite with ref inputs and run to completion. To minimize variability, each benchmark is executed 5 times and the average of the execution times is reported. Performance Results. Figure 3 summarizes the performance overheads of SPEC CPU2017 for different tools normalized to their corresponding baseline. The geometric mean of each tool is as follows: ASan (2.07x), MPX (2.06x) 5 , Software-EBB (2.0x), Binning-Malloc (1.04x) and No-FAT (1.08x). The main reason for No-FAT overheads comes from the underlying memory allocator, which introduces 1.04x overheads. For example, gcc allocates many small objects that are padded to the nearest Binning-Malloc size. As a result it introduces 62% extra runtime with No-FAT, whereas its Binning-Malloc version has a 55% slowdown. Configuring the allocation sizes at program initialization should reduce the padding and the overheads.\n\n\nC. Software Memory Overheads\n\nTo accurately measure the memory usage of No-FAT, we use a Linux-based utility, Syrupy, that regularly takes snapshots of the memory of a running process [57]. We measure the peak resident set size (RSS) to get the actually used memory rather than virtual address space which is reserved. Table II shows that the No-FAT's binning allocator only adds 6.66% memory overheads on average compared to the stdlib allocator with gcc, parest, povray as outliers. We inspect those allocation intensive benchmarks by running them with six different memory allocators (including No-FAT). Figure 4 shows that No-FAT memory overheads are comparable to other binning (i.e., Jemalloc [20] and TCmalloc [21]) and nonbinning allocators (i.e., Dlmalloc [33] and Scudo [35]).  \n\n\nD. Buf2Ptr Analysis\n\nMemory. The memory overheads of Buf2Ptr are reported separately. As Buf2Ptr promotes intra-allocation buffers to standalone allocations, it adds additional heap allocations as reported between brackets in the last column of Table II. The majority of benchmarks add few extra allocations with the exception of parest, blender, and deepsjeng. The latter is interesting as it performs a single malloc call to 15 million structs, each with one intra-buffer. So, even though the extra allocations look large, the actual source code transformation is minimal as it only affects one struct.\n\nPerformance. The performance overheads of promoting intra-allocation fields to standalone allocations are amortized over program execution. For example, a buffer field of size 64B typically requires eight 8B loads in regular execution. With Buf2Ptr, one can argue that 16 8B loads will be needed as every load now passes through one level of indirection. However, as we implement Buf2Ptr as a source level transformation, we take advantage of the compiler to optimize the access to only 9 8B loads (i.e., one load to get the new base address followed by the original 8 loads with their address adjusted to the new base). We verify this hypothesis by measuring the overhead of implementing Buf2Ptr for the C programs in SPEC CPU2017 benchmarks. The overheads are less than 1% compared to a baseline that uses the same memory allocator (without Buf2Ptr).\n\nVIII. DEPLOYMENT CONSIDERATIONS In this section, we discuss the system requirements, strengths, and weaknesses of No-FAT. System Requirements. No-FAT requires the usage of binning memory allocators. While the internal details of the memory allocator are irrelevant to No-FAT design, the minimum requirement is to have allocations of the same sizes per any memory page. Some allocators (aka non-binning or headerbased allocators) violate the above requirement by allocating objects of different sizes in the same page. The non-binning allocators rely on an allocation header to keep track of each allocation size. These allocators are not protected by No-FAT as the cost of deriving allocation base addresses will be much higher (requiring a memory access to the allocation header every time any memory instruction is executed).\n\nAdditionally, while porting No-FAT's spatial memory protection to non-64-bit systems is possible, the temporal memory aspect strictly requires 64-bit systems in order to store the temporal tags in the upper bits of the data pointers. On non-64-bit systems, temporal memory safety can be achieved with less efficient approaches such as free list randomization and memory quarantining. Handling Gnarly, Gory C Idioms. Some C programmers have the propensity to exploit undefined behaviors. By undefined behaviors we mean behaviors that are not explicitly disallowed in the standard. These issues are documented in an excellent exposition by the authors of the CHERI system [13]. One of the most common of these idioms is the case of intentionally creating out-of-bounds pointers. Although it is unclear why programmers follow this idiom, it exists, and we strive to identify such cases.\n\nConsider the following: q = p + 100; x = Bar(q);. Here, p is a pointer to a 32B allocation. After the arithmetic operation, q is an out-of-bounds pointer that will be passed to function Bar. Inside Bar, the program may do z = q -100 before using z to access memory. Since No-FAT only uses intra-procedural analysis, Bar will recompute the base address for q at function entry using compute_base. However, as q is already an out-of-bounds pointer, the resultant base address will be wrong (i.e., it will not point to the original object pointed to by p). We refer to this case as a data pointer escape operation. If the compiler performs only intra-procedural analysis to determine and Hardbound [14] ASan [52] Softbound [41] Watchdog [39] Intel MPX [43] AOS [27] CHEx86 [55] \n\n\nInlined Metadata\n\nEffectiveSan [17] CHERI [61], [62] REST [56] In-Fat [64] Compact-Ptrs [31] Califorms [50] Co-joined Metadata ARM MTE [2] SPARC ADI [45] Implicit Metadata\n\nNative-Ptrs [16], [19] No-FAT encode pointers into checking loads and stores, it will result in an insufficient check. To handle this case, No-FAT uses verify_bounds to catch out-of-bounds pointers before they escape to memory (or a different function), as described in Section II-E. This functionality should help programmers catch undefined behavior and fix it.\n\nStrengths. Compared to many other systems, No-FAT provides deterministic memory safety guarantees at the finest granularity. No-FAT provides protection against a wide variety of spatial/temporal memory safety violations including control flow hijacking attacks, data oriented attacks, and pure data corruption. No-FAT's protection comes with minimal performance overheads and minor hardware changes. Furthermore, No-FAT naturally mitigates a common speculative execution threat (Spectre-V1) at no additional cost.\n\n\nWeaknesses.\n\nBuf2Ptr requires the precise type information of an allocated object. While this is guaranteed for C++ objects, it is not always possible in C-style programs where void * allocations may be used. In these cases, the compiler may not be able to infer the correct type, in which case intra-allocation support may be skipped. This is a common limitation for techniques that rely on source-level transformations for intra-allocation protection [50]. Our evaluation results in Section VII-D show that the number of intra-allocation buffers is minimal compared to total allocations. Cases with ambiguous types are not common and can be properly handled with program annotations, if needed. We leave this part to future work.\n\n\nIX. COMPARISON WITH PRIOR WORK\n\nIn this section, we summarize prior work related to memory safety mitigations and show how No-FAT is different. We first categorize prior work based on how they handle the metadata (e.g., base and bounds information), as shown in Table III. The metadata can be maintained in one of the following forms: disjoint, inlined, co-joined, or implicit. We then compare No-FAT with prior techniques in terms of security, hardware complexity, memory requirements, and performance overheads in Table IV. Explicit Base & Bounds. This class of memory safety defenses attaches bounds metadata to every pointer or allocation. The metadata can be stored in a shadow (aka disjoint) memory region (e.g., Hardbound [14], Softbound [41], Intel MPX [43], CHEx86 [55], and AOS [27]) or be marshaled with the pointer by extending its size (e.g., CHERI [61]). Temporal memory safety can be added to the above techniques by either storing an additional \"identifier\" along with the pointer metadata and verifying that no stale identifiers are ever retrieved (e.g., CETS [42], Watchdog [39], and WatchdogLite [40]) or invalidating all pointers to freed regions in the lookup tables (e.g., BOGO [68]).\n\nWhile explicit base and bounds systems offer similar security guarantees to No-FAT, our solution has the advantage of requiring simpler hardware modifications and being faster than prior systems [43], [62], [55], [27]. The above savings mainly stem from the fact that No-FAT uses no metadata for spatial/temporal memory safety. Disjointly storing the metadata in a shadow memory [14], [43], [27], [55] requires extra memory accesses to fetch and update the metadata and introduces atomicity problems for multithreading applications.\n\nOther base and bounds techniques, such as Softbound [41], can take advantage of hardware support (similar to No-FAT) by (1) encoding the pointer base and bounds in extra load/store register operands, (2) propagating them within function scope, and (3) performing the memory safety checks in hardware. Such hardware support can reduce the runtime overheads of Softbound by eliminating the need for performing the bounds checking in software and reducing the number of memory lookups to fetch the metadata from the disjoint memory structures. However, even with hardware support the aforementioned solution needs to perform two extra memory operations (to access the base and bounds) every time a pointer is loaded from memory (i.e., not within the same function scope in which the pointer was created). In contrast, No-FAT has high performance due to how it derives the base and bounds information from the pointer itself when it is loaded from memory. Specifically, No-FAT replaces the costly metadata memory accesses with simple arithmetic computations by using the compute_base instruction.\n\nOn the other hand, increasing the pointer width to include the metadata [61], [62] changes object layouts and breaks compatibility with the rest of the system (e.g., unprotected libraries). On the contrary, No-FAT performs simple arithmetic computations to derive the allocation bounds and uses a fixed area cost for MAST. Furthermore, the metadata-less aspect of our scheme allows us to support multi-threading applications with no false positives/negatives, which occur in disjoint metadata schemes (e.g., Intel MPX [43]). Additionally, our Buf2Ptr transformation implictly resolves the intra-allocation memory safety problem, which is overlooked by recent memory safety techniques [55], [27].\n\nSoftware-based Implicit Base & Bounds. The idea of deriving allocation bounds from the pointer itself is not new. For example, guarded pointers divided memory into powers-oftwo segments and encoded the segment size into the pointer's upper bits [9]. Similarly, baggy bounds [1] restricts allocation sizes to powers-of-two and encodes the binary logarithm of the allocation size in the pointer's upper bits. Unlike No-FAT, this design choice significantly increases the program's memory footprint due to padding allocations to the nearest powers-oftwo size. Moreover, neither guarded pointers nor baggy bounds offers temporal protection.\n\nCompact-pointers [31] tried to avoid the powers-of-two restriction by using a floating-point representation to encode allocation bounds in the pointer itself. CHERI-concentrate [62] adopts a similar approach to compress metadata to 128 bits (instead of 256 bits) by changing a pointer's layout and introducing instructions to manipulate them. Due to the pointer layout manipulation, both techniques neither support temporal memory safety nor maintain binary compatibility.\n\nSimilar to No-FAT's binning allocator, Native-Pointers [16], [18], [19] divides the program's virtual address space into several regions of equal size and uses each region to allocate objects of similar non powers-of-two sizes. As a software-only solution, Native-Pointers suffers from high performance overheads. Additionally, Native-Pointers does not naturally provide temporal protection. A follow-up work (EffectiveSan [17]) adds temporal protection (and intra-allocation memory safety) to Native-Pointers but with expensive per-allocation metadata. Concurrent to our work, Xu et al. add hardware support for EffectiveSan, dubbed In-Fat [64]. The key idea is to maintain a per-allocation metadata table and use the pointer's upper bits to index into this table for intra-allocation bounds retrieval. In-Fat uses different metadata schemes for different program objects (e.g., stack, heap, and globals) to reduce the lookup overhead. Unlike No-FAT, In-Fat does not provide temporal protection as it utilizes the pointer's upper bits for indexing into the metadata tables. A key advantage of No-FAT over EffectiveSan and In-Fat is that it does not require any per pointer/allocation metadata. Thus, it runs with almost native performance, making it best suited to be an always-on memory safety mitigation.\n\nMemory Tagging. This class of techniques associates a \"color\" with newly allocated memory, and stores the same color in the upper bits of the data pointer that is used to access the allocated memory. At runtime, the hardware enforces spatial memory safety by comparing the colors of the pointer and accessed memory. For example, SPARC ADI [45] assigns 4-bit colors to every 64B of memory (i.e., limiting the minimum allocation size to 64B), while ARM MTE [2] uses 8bit colors per every 16B of memory [53]. Since metadata bits are acquired along with the corresponding data, no extra memory operations are needed.\n\nTemporal safety is enforced by assigning a different color when memory regions are reused. Unlike No-FAT, which uses a 16-bit tag for temporal protection, the number of tag bits in memory tagging defenses is limited as the tags are used for pointers and memory locations. As a result, prior techniques offer less entropy for temporal protection. For example, in ARM MTE colors will be repeated every 255 allocations, while in SPARC ADI colors are repeated every 15 allocations, raising the attacker's chances of bypassing the defense.\n\nTripwires. This class of memory safety defenses aims to detect overflows by marking the memory regions on either side of an allocation, and flagging accesses to them. For example, REST [56] stores a predetermined 8-64B random number, dubbed a token, in the memory to be invalidated. Spatial memory safety violations are detected by comparing cache lines with the token when they are fetched. Due to its large token size, REST does not support intra-allocation memory safety. Califorms [50] solves this problem by inserting 1-7B hardware canaries between object fields and introducing cache line formats to inline metadata within the program data itself.\n\nWhile state-of-the-art tripwires systems (i.e., REST [56] and Califorms [50]) come with comparable performance overheads to No-FAT, our solution offers better security guarantees as it cannot be bypassed by non-adjacent buffer overflows, which represent 27% of Microsoft's memory safety CVEs [5].\n\nAdditionally, REST and Califorms demand a quarantine pool to provide temporal safety. Using memory quarantining typically increases performance overheads as it prevents the program from reusing recently freed memory to satisfy new allocation requests. No-FAT instead does not rely on memory quarantining to achieve temporal memory safety, effectively reducing the overheads for allocation intensive applications. Finally, attackers can bypass Califorms' intra-allocation protection if the binary is leaked as the locations of the hardware canaries are encoded in the binary itself, whereas No-FAT does not keep the binary secret as allocation information is derived and propagated at runtime.\n\n\nX. CONCLUSION\n\nIn this paper we proposed No-FAT, a secure architecture for implicitly deriving allocation bounds. No-FAT enforces spatial memory safety and a degree of temporal safety without increasing program memory footprint, while maintaining full compatibility with unprotected code. Overall, No-FAT incurs 8% performance degradation compared to a 100% slowdown for its software version, while providing extra security guarantees. This has the benefits of reducing fuzztesting overheads to improve pre-deployment software testing. Furthermore, if end users are willing to pay 8% performance degradation for memory safety protection, then No-FAT is an excellent solution. On the other hand, if users are willing to trade off some security features (e.g., non-pointer data corruption) for no performance degradation, lightweight exploit mitigation techniques, such as ZeR\u00d8 [58], can be used. The benefits of No-FAT go well beyond memory safety: for instance, having the allocation size as an architectural feature can help accelerate garbage collectors for memory safe languages; it also provides an opportunity for enhancing the predictability of memory prefetchers and DRAM controllers.\n\n\nType char Foo_buf[10]; struct Foo { char * p_buf; int value; }; // Promoted Allocations struct Foo * f = malloc( sizeof(struct Foo)); f->p_buf = malloc( sizeof(Foo_buf)); // Promoted Usages f->p_buf->buf[7] = 'A'; // Promoted Deallocations free(f->p_buf); free(f); (b) Transformed Listing 2: An example of Buf2Ptr transformation.\n\nFig. 2 :\n2Pipeline diagram for the L1 cache hit operation. The bounds checking operations (top) are pipelined to avoid adding any access latency to L1 data.\n\n1\nvoid * memcpy_wrap(void * dst, void * src, size_t nAssert(dst_base == dst_end_base) 8 return memcpy(dst, src, n); 9 } Listing 3: Example memcpy wrapper.\n\n1\nif (i < a->length) { // mispredicted branch 2 secret = a->data[i]; 3 val = b[64 * secret]; // secret is leaked 4 } Listing 4: Example speculative execution attack.\n\nFig. 3 :\n3Performance overheads of the SPEC CPU2017 benchmarks for different tools normalized to their corresponding baseline.\n\nFig. 4 :\n4Memory usage for the three allocation-intensive benchmarks with different memory allocators.\n\nTABLE I :\nIArea, delay and power overheads of No-FAT (GE represents gate equivalent).Hardware Structure \nArea (GE) Delay (ns) Power (mW ) \n\nBaseline L1 data cache \n503,914 \n1.99 \n29.7 \n\nBounds checking module \n32,130 \n0.81 \n1.16 \n\nBase computing module \n27,346 \n1.50 \n1.17 \n\n\n\nTABLE II :\nIIMemory usage for SPEC CPU2017.Bench. \nMemory usage (MB) \n# of Heap allocations \nNo-FAT \nBuf2Ptr \n\nperlbench \n[+3.27%] 160.80 \n[+48.7E0] 54.2E6 \ngcc \n[+20.96%] 1,555.57 \n[+199.3E3] 2.7E6 \nmcf \n[+0.07%] 610.64 \n[0.0E0] 495.4E3 \nnamd \n[-3.71%] 156.53 \n[0.0E0] 20.2E3 \nparest \n[+26.05%] 527.07 \n[+107.4E6] 265.1E6 \npovray \n[+35.04%] 8.75 \n[+10E0] 63.4E3 \nlbm \n[+0.04%] 411.66 \n[0.0E0] 2.0E0 \nomnetpp \n[+3.79%] 251.36 \n[+1.7E6] 454E6 \nxalancbmk \n[+6.95%] 512.83 \n[0.0E0] 138.4E6 \nx264 \n[+1.50%] 159.40 \n[+1.5E0] 2.2E3 \nblender \n[+12.42%] 710.61 \n[+3.4E6] 9.1E6 \ndeepsjeng \n[+0.25%] 702.54 \n[+15.0E6] 15.0E6 \nimagick \n[-0.91%] 285.05 \n[+1.0E0] 9.3E6 \nleela \n[-7.01%] 23.56 \n[+1.2E3] 53.8E6 \nnab \n[+7.74%] 159.03 \n[+38.1E3] 374.5E3 \nxz \n[+0.04%] 727.30 \n[+0.0E0] 41.0E0 \n\n\n\nTABLE III :\nIIICategorization of prior work on spatial memory safety based on how they handle the security metadata.Base & Bounds \nTripwires \nPer-Allocation \nPer-Pointer \n\nDisjoint \nMetadata \n\nBaggy Bounds [1] \n\n\n\nTABLE IV :\nIVComparison with prior works. No-FAT bounds checking & base computing 1KB per process Table \u221d padding objects \u221d # of ptr derefs modules and base address register file to the nearest size * -Complete (Linear and non-linear overflows); -Linear only; -No protection. \u00a7 -Complete; -Partial protection; -No protection. \u2020 -Fully compatible; -Execution compatible, but protection dropped when external modules modify pointer; -No support. \u00b6 -Supported (stateless); -Supported (requires synchronization on global metadata); -No support. \u2021 Achieved with bounds narrowing.Proposal \nSpatial Protection * Temp. \nBinary \nMT \nHardware \nMetadata \nMemory \nPerformance \nInter \nIntra \nProt.  \u00a7 Comp.  \u2020 Support  \u00b6 \nModifications \nOverhead \nOverhead \nOverhead \n\nHardbound [14] \n\n \u2021 \n\n\u03bcop injection, L1$ & TLB for tags \n0-2 words per ptr \n\u221d # of ptrs \n\u221d # of ptr derefs \n& 4 bits per word \nSoftbound [41] \n\n \u2021 \n\nN/A \n2 words per ptr \n\u221d # of ptrs \n\u221d # of ptr derefs \nBaggy Bounds [1] \nN/A \nN/A. \n\u221d padding objects \n\u221d # of ptr ops \nto the nearest size \nCompact-Ptrs [31] \nOne extra pipeline stage \nN/A \n\u221d padding objects \n\u221d # of ptr ops \nfor bounds check & update \nto the nearest size \nWatchdog [39] \n\n \u2021 \n\nRenaming logic, \u03bcop injection logic \n4 words per ptr \n\u221d # of ptrs and allocs \n\u221d # of ptr derefs \nand Lock location$ \nWatchdogLite [40] \n\n \u2021 \n\nN/A \n4 words per ptr \n\u221d # of ptrs and allocs \n\u221d # of ptr ops \nNative-Ptrs [16], [19] \nN/A \nN/A. \n\u221d padding objects \n\u221d # of ptr ops \nto the nearest size \nIn-Fat [64] \n32 96-bits bounds registers, a new \n16B per object \n\u221d # of objects \n\u221d # of ptr ops and \nexecution unit, and 10 instructions \n# of ptr derefs \nIntel MPX [43] \n\n \u2021 \n\nUnknown (closed platform) \n2 words per ptr \n\u221d # of ptrs \n\u221d # of ptr derefs \nBOGO [68] \n\n \u2021 \n\nUnknown (closed platform) \n2 words per ptr \n\u221d # of ptrs \n\u221d # of ptr derefs \nCHERI [61], [62] \n\n \u2021 \n\nCapability coprocessor, Tag$ \nPtr size is 2-4X \n\u221d # of ptrs \n\u221d # of ptr ops \nand Capability Unit \nCHERIvoke [63] \nCapability coprocessor, Tag$ \nPtr size is 2-4X \n\u221d # of ptrs \n\u221d # of ptr ops \nTag controller, and Capability Unit \nPUMP [15] \nExtend all data units by tag width, \n8B per cache line \n\u221d prog. mem. footprint \n\u221d # of ptr ops \nnew miss handler and Rule$ \nARM MTE [2] \nUnknown (closed platform) \n4 bits per 16B objects \n\u221d prog. mem. footprint \n\u221d # of tag (un)set ops \nREST [56] \n1-8B per L1D line, 1 comparator \n8-64B token \n\u221d blacklisted memory \n\u221d # of (dis)arm insns. \nCaliforms [50] \n8B per L1D line, 1 bit per L2/L3 line \n1-7B per critical field \n\u221d blacklisted memory \n\u221d # of BLOC insns. \nAOS [27] \nARM PAC instructions, memory check \n8B bounds per ptr \n\u221d # of ptrs \n\u221d # of ptr derefs \nqueue, bounds$, and bounds way buffer \nCHEx86 [55] \n\u03bcop injection logic, Alias$, Capability$, \n2 words per ptr \n\u221d # of allocs & ptrs \n\u221d # of ptr derefs \nand Speculative Pointer Tracker \n\n\nThe name is an allusion to No-Fat Milk, which has fewer calories. Also, closely related work in this area refer to their schemes as Fat and Low Fat pointers.\nA recent study[60] proposes passing semantic information from software to hardware to achieve better resource utilization and enhance performance. However, neither allocation size nor fine-grained security were included.\nUsing power-of-two sized objects can eliminate the need for MAST at the cost of additional memory overhead. This is a common optimization that was used in other systems such as Baggy bounds[1].\nWe use Clang 7.0 for ASan and GCC 7.3.1 for Intel MPX.5 gcc, perlbench, namd, and blender failed to run with MPX due to unrecoverable errors. Thus, we exclude them from MPX averages.\nACKNOWLEDGMENTThis work was partially supported by FA8750-20-C-0210, a Qualcomm Innovation Fellowship, and a gift from Bloomberg. Any opinions, findings, conclusions and recommendations expressed in this material are those of the authors and do not necessarily reflect the views of the US government or commercial entities. Simha Sethumadhavan has a significant financial interest in Chip Scan Inc.\nBaggy bounds checking: an efficient and backwards-compatible defense against out-of-bounds errors. P Akritidis, M Costa, M Castro, S Hand, Proceedings of the 18th USENIX Security Symposium. the 18th USENIX Security SymposiumP. Akritidis, M. Costa, M. Castro, and S. Hand, \"Baggy bounds checking: an efficient and backwards-compatible defense against out-of-bounds errors,\" in Proceedings of the 18th USENIX Security Symposium, 2009.\n\nMemory tagging extension: Enhancing memory safety through architecture. ARM. Online; accessed 01ARM, \"Memory tagging extension: Enhancing memory safety through architecture,\" https://community.arm.com/developer/ip-products/ processors/b/processors-ip-blog/posts/enhancing-memory-safety, 2019, [Online; accessed 01-May-2021].\n\nEfficient detection of all pointer and array access errors. T M Austin, S E Breach, G S Sohi, PLDI '94: Proceedings of the ACM SIGPLAN 1994 Conference on Programming Language Design and Implementation. Orlando, FL, USAT. M. Austin, S. E. Breach, and G. S. Sohi, \"Efficient detection of all pointer and array access errors,\" in PLDI '94: Proceedings of the ACM SIGPLAN 1994 Conference on Programming Language Design and Implementation, Orlando, FL, USA, 1994, pp. 290-301.\n\nIsolating speculative data to prevent transient execution attacks. K Barber, A Bacha, L Zhou, Y Zhang, R Teodorescu, IEEE Computer Architecture Letters. 182K. Barber, A. Bacha, L. Zhou, Y. Zhang, and R. Teodorescu, \"Isolating speculative data to prevent transient execution attacks,\" IEEE Computer Architecture Letters, vol. 18, no. 2, pp. 178-181, 2019.\n\nSecurity analysis of memory tagging. J Bialek, K Johnson, M Miller, T Chen, J. Bialek, K. Johnson, M. Miller, and T. Chen, \"Security analysis of memory tagging,\" 2020. [Online]. Available: https://github.com/microsoft/MSRC-Security-Research/blob/master/ papers/2020/Security%20analysis%20of%20memory%20tagging.pdf\n\nJump-oriented programming: A new class of code-reuse attack. T Bletsch, X Jiang, V W Freeh, Z Liang, ASIACCS '11: Proceedings of the 6th ACM Symposium on Information. Hong Kong, ChinaComputer and Communications SecurityT. Bletsch, X. Jiang, V. W. Freeh, and Z. Liang, \"Jump-oriented programming: A new class of code-reuse attack,\" in ASIACCS '11: Proceedings of the 6th ACM Symposium on Information, Computer and Communications Security, Hong Kong, China, 2011, pp. 30-40.\n\nFuzzing: On the exponential cost of vulnerability discovery. M B\u00f6hme, B Falk, Proceedings of the 28th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering. the 28th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software EngineeringM. B\u00f6hme and B. Falk, \"Fuzzing: On the exponential cost of vul- nerability discovery,\" in Proceedings of the 28th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering, 2020, pp. 713-724.\n\nRFC: Speculative load hardening (a spectre variant 1 mitigation). C Carruth, C. Carruth, \"RFC: Speculative load hardening (a spectre variant 1 mitigation),\" 2018. [Online]. Available: https://lists.llvm.org/pipermail/ llvm-dev/2018-March/122085.html\n\nHardware support for fast capability-based addressing. N P Carter, S W Keckler, W J Dally, SIGPLAN Not. 2911N. P. Carter, S. W. Keckler, and W. J. Dally, \"Hardware support for fast capability-based addressing,\" SIGPLAN Not., vol. 29, no. 11, pp. 319-327, Nov. 1994.\n\nReturn-oriented programming without returns. S Checkoway, L Davi, A Dmitrienko, A.-R Sadeghi, H Shacham, M Winandy, CCS '10: Proceedings of the 17th ACM Conference on Computer and Communications Security. Chicago, Illinois, USAS. Checkoway, L. Davi, A. Dmitrienko, A.-R. Sadeghi, H. Shacham, and M. Winandy, \"Return-oriented programming without returns,\" in CCS '10: Proceedings of the 17th ACM Conference on Computer and Communications Security, Chicago, Illinois, USA, September 2010, pp. 559-572.\n\nNon-controldata attacks are realistic threats. S Chen, J Xu, E C Sezer, P Gauriar, R K Iyer, SSYM '05: Proceedings of the 14th Conference on USENIX Security Symposium. Baltimore, MD, USA14S. Chen, J. Xu, E. C. Sezer, P. Gauriar, and R. K. Iyer, \"Non-control- data attacks are realistic threats,\" in SSYM '05: Proceedings of the 14th Conference on USENIX Security Symposium -Volume 14, Baltimore, MD, USA, 2005.\n\nExploitation techniques and defenses for data-oriented attacks. L Cheng, H Liljestrand, M S Ahmed, T Nyman, T Jaeger, N Asokan, D Yao, Proceedings of the 2019 IEEE Cybersecurity Development (SecDev). the 2019 IEEE Cybersecurity Development (SecDev)Tysons Corner, VA, USAL. Cheng, H. Liljestrand, M. S. Ahmed, T. Nyman, T. Jaeger, N. Asokan, and D. Yao, \"Exploitation techniques and defenses for data-oriented attacks,\" in Proceedings of the 2019 IEEE Cybersecurity Development (SecDev), Tysons Corner, VA, USA, September 2019, pp. 114-128.\n\nBeyond the PDP-11: Architectural support for a memory-safe c abstract machine. D Chisnall, C Rothwell, R N Watson, J Woodruff, M Vadera, S W Moore, M Roe, B Davis, P G Neumann, ASPLOS '15: Proceedings of the Twentieth International Conference on Architectural Support for Programming Languages and Operating Systems. Istanbul, TurkeyD. Chisnall, C. Rothwell, R. N. Watson, J. Woodruff, M. Vadera, S. W. Moore, M. Roe, B. Davis, and P. G. Neumann, \"Beyond the PDP- 11: Architectural support for a memory-safe c abstract machine,\" in ASPLOS '15: Proceedings of the Twentieth International Conference on Architectural Support for Programming Languages and Operating Systems, Istanbul, Turkey, 2015, pp. 117-130.\n\nHard-Bound: architectural support for spatial safety of the C programming language. J Devietti, C Blundell, M M K Martin, S Zdancewic, ASPLOS XIII: Proceedings of the 13th International Conference on Architectural Support for Programming Languages and Operating Systems. J. Devietti, C. Blundell, M. M. K. Martin, and S. Zdancewic, \"Hard- Bound: architectural support for spatial safety of the C programming language,\" in ASPLOS XIII: Proceedings of the 13th International Conference on Architectural Support for Programming Languages and Operating Systems, 2008.\n\nArchitectural support for software-defined metadata processing. U Dhawan, C Hritcu, R Rubin, N Vasilakis, S Chiricescu, J M Smith, T F Knight, B C Jr, A Pierce, Dehon, ASPLOS '15: Proceedings of the 20th International Conference on Architectural Support for Programming Languages and Operating Systems. U. Dhawan, C. Hritcu, R. Rubin, N. Vasilakis, S. Chiricescu, J. M. Smith, T. F. Knight, Jr, B. C. Pierce, and A. DeHon, \"Architectural support for software-defined metadata processing,\" in ASPLOS '15: Proceedings of the 20th International Conference on Architectural Support for Programming Languages and Operating Systems, 2015.\n\nHeap bounds protection with low fat pointers. G J Duck, R H C Yap, CC '16: Proceedings of the 25th International Conference on Compiler Construction. Barcelona, SpainG. J. Duck and R. H. C. Yap, \"Heap bounds protection with low fat pointers,\" in CC '16: Proceedings of the 25th International Conference on Compiler Construction, Barcelona, Spain, 2016, pp. 132-142.\n\nEffectiveSan: type and memory error detection using dynamically typed C/C++. G J Duck, R H C Yap, PLDI '18: Proceedings of the 39th ACM SIGPLAN Conference on Programming Language Design and Implementation. G. J. Duck and R. H. C. Yap, \"EffectiveSan: type and memory error detection using dynamically typed C/C++,\" in PLDI '18: Proceedings of the 39th ACM SIGPLAN Conference on Programming Language Design and Implementation, 2018.\n\nAn extended low fat allocator API and applications. G J Duck, R H C Yap, arXiv:1804.04812arXiv preprintG. J. Duck and R. H. C. Yap, \"An extended low fat allocator API and applications,\" arXiv preprint arXiv:1804.04812, 2018.\n\nStack bounds protection with low fat pointers. G J Duck, R H C Yap, L Cavallaro, NDSS '17: Proceedings of the 24th Annual Network and Distributed System Security Symposium. San Diego, CA, USAG. J. Duck, R. H. C. Yap, and L. Cavallaro, \"Stack bounds protection with low fat pointers,\" in NDSS '17: Proceedings of the 24th Annual Network and Distributed System Security Symposium, San Diego, CA, USA, February 2017.\n\nA scalable concurrent malloc(3) implementation for FreeBSD. J Evans, Proceedings of the Technical BSD Conferene. the Technical BSD ConfereneJ. Evans, \"A scalable concurrent malloc(3) implementation for FreeBSD,\" in Proceedings of the Technical BSD Conferene, 2006. [Online]. Available: https://www.bsdcan.org/2006/papers/jemalloc.pdf\n\nTCMalloc: Thread-caching malloc. S Ghemawat, P Menage, S. Ghemawat and P. Menage, \"TCMalloc: Thread-caching malloc,\" 2007. [Online]. Available: http://goog-perftools.sourceforge.net/doc/ tcmalloc.html\n\n0day in the wild. Googleprojectzero, GoogleProjectZero, \"0day in the wild,\" 2019. [Online]. Available: https://googleprojectzero.blogspot.com/p/0day.html\n\nOpenRAM: An open-source memory compiler. M R Guthaus, J E Stine, S Ataei, B Chen, B Wu, M Sarwar, ICCAD '16: Proceedings of the 35th International Conference on Computer-Aided Design. Austin, TX, USAM. R. Guthaus, J. E. Stine, S. Ataei, B. Chen, B. Wu, and M. Sar- war, \"OpenRAM: An open-source memory compiler,\" in ICCAD '16: Proceedings of the 35th International Conference on Computer-Aided Design, Austin, TX, USA, 2016.\n\nData-oriented programming: On the expressiveness of non-control data attacks. H Hu, S Shinde, S Adrian, Z L Chua, P Saxena, Z Liang, SP '16: Proceedings of the 2016 IEEE Symposium on Security and Privacy. San Jose, CA, USAH. Hu, S. Shinde, S. Adrian, Z. L. Chua, P. Saxena, and Z. Liang, \"Data-oriented programming: On the expressiveness of non-control data attacks,\" in SP '16: Proceedings of the 2016 IEEE Symposium on Security and Privacy, San Jose, CA, USA, May 2016, pp. 969-986.\n\nPractical structure layout optimization and advice. R Hundt, S Mannarswamy, D Chakrabarti, CGO '06: Proceedings of the International Symposium on Code Generation and Optimization. USAR. Hundt, S. Mannarswamy, and D. Chakrabarti, \"Practical structure layout optimization and advice,\" in CGO '06: Proceedings of the International Symposium on Code Generation and Optimization, USA, 2006, pp. 233-244.\n\nComprehensively and efficiently protecting the heap. M Kharbutli, X Jiang, Y Solihin, G Venkataramani, M Prvulovic, ASPLOS XII: Proceedings of the 12th International Conference on Architectural Support for Programming Languages and Operating Systems. San Jose, California, USAM. Kharbutli, X. Jiang, Y. Solihin, G. Venkataramani, and M. Prvulovic, \"Comprehensively and efficiently protecting the heap,\" in ASPLOS XII: Proceedings of the 12th International Conference on Architectural Support for Programming Languages and Operating Systems, San Jose, California, USA, 2006, pp. 207-218.\n\nHardware-based always-on heap memory safety. Y Kim, J Lee, H Kim, MICRO-53: Proceedings of the 53nd Annual IEEE/ACM International Symposium on Microarchitecture. Y. Kim, J. Lee, and H. Kim, \"Hardware-based always-on heap memory safety,\" in MICRO-53: Proceedings of the 53nd Annual IEEE/ACM International Symposium on Microarchitecture, Global Online Event, 2020, pp. 1153-1166.\n\nFlipping bits in memory without accessing them: An experimental study of dram disturbance errors. Y Kim, R Daly, J Kim, C Fallin, J H Lee, D Lee, C Wilkerson, K Lai, O Mutlu, ISCA '14: Proceeding of the 41st Annual International Symposium on Computer Architecuture. Y. Kim, R. Daly, J. Kim, C. Fallin, J. H. Lee, D. Lee, C. Wilkerson, K. Lai, and O. Mutlu, \"Flipping bits in memory without accessing them: An experimental study of dram disturbance errors,\" in ISCA '14: Proceeding of the 41st Annual International Symposium on Computer Architecuture, 2014, p. 361-372.\n\nSpectre attacks: Exploiting speculative execution. P Kocher, D Genkin, D Gruss, W Haas, M Hamburg, M Lipp, S Mangard, T Prescher, M Schwarz, Y Yarom, SP '19: Proceedings of the 40th IEEE Symposium on Security and Privacy. P. Kocher, D. Genkin, D. Gruss, W. Haas, M. Hamburg, M. Lipp, S. Mangard, T. Prescher, M. Schwarz, and Y. Yarom, \"Spectre attacks: Exploiting speculative execution,\" in SP '19: Proceedings of the 40th IEEE Symposium on Security and Privacy, May 2019.\n\nSpecCFI: Mitigating spectre attacks using CFI informed speculation. E M Koruyeh, S H A Shirazi, K N Khasawneh, C Song, N B Abu-Ghazaleh, SP '20: Proceedings of the IEEE Symposium on Security and Privacy. San Francisco, CA, USAE. M. Koruyeh, S. H. A. Shirazi, K. N. Khasawneh, C. Song, and N. B. Abu-Ghazaleh, \"SpecCFI: Mitigating spectre attacks using CFI informed speculation,\" in SP '20: Proceedings of the IEEE Symposium on Security and Privacy, San Francisco, CA, USA, May 2020, pp. 39-53.\n\nLow-fat pointers: compact encoding and efficient gate-level implementation of fat pointers for spatial safety and capability-based security. A Kwon, U Dhawan, J M Smith, T F Knight, A Jr, Dehon, CCS '13: Proceedings of the 20th ACM SIGSAC Conference on Computer and Communications Security. A. Kwon, U. Dhawan, J. M. Smith, T. F. Knight, Jr, and A. DeHon, \"Low-fat pointers: compact encoding and efficient gate-level implemen- tation of fat pointers for spatial safety and capability-based security,\" in CCS '13: Proceedings of the 20th ACM SIGSAC Conference on Computer and Communications Security, 2013.\n\nLLVM: a compilation framework for lifelong program analysis transformation. C Lattner, V Adve, CGO '04: Proceedings of the International Symposium on Code Generation and Optimization. San Jose, CA, USAC. Lattner and V. Adve, \"LLVM: a compilation framework for lifelong program analysis transformation,\" in CGO '04: Proceedings of the International Symposium on Code Generation and Optimization, San Jose, CA, USA, 2004, pp. 75-86.\n\nA memory allocator. D Lea, D. Lea, \"A memory allocator,\" 2000. [Online]. Available: http: //gee.cs.oswego.edu/dl/html/malloc.html\n\nMimalloc: Free list sharding in action. D Leijen, B Zorn, L De Moura, MSR-TR-2019-18Tech. Rep.D. Leijen, B. Zorn, and L. de Moura, \"Mimalloc: Free list sharding in action,\" Microsoft, Tech. Rep. MSR-TR-2019-18, June 2019. [Online]. Available: https://www.microsoft.com/en-us/research/ publication/mimalloc-free-list-sharding-in-action/\n\nScudo hardened allocator. LLVM. LLVM, \"Scudo hardened allocator.\" [Online]. Available: https: //llvm.org/docs/ScudoHardenedAllocator.html\n\nSafeInit: Comprehensive and practical mitigation of uninitialized read vulnerabilities. A Milburn, H Bos, C Giuffrida, NDSS '17: Proceedings of the 24th Annual Network and Distributed System Security Symposium. A. Milburn, H. Bos, and C. Giuffrida, \"SafeInit: Comprehensive and practical mitigation of uninitialized read vulnerabilities,\" in NDSS '17: Proceedings of the 24th Annual Network and Distributed System Security Symposium, February 2017.\n\nTrends, challenges, and strategic shifts in the software vulnerability mitigation landscape. M Miller, M. Miller, \"Trends, challenges, and strategic shifts in the software vulnerability mitigation landscape,\" 2019. [Online]. Available: https://github.com/microsoft/MSRC-Security-Research/blob/master/ presentations/2019 02 BlueHatIL/2019 01%20-%20BlueHatIL% 20-%20Trends%2C%20challenge%2C%20and%20shifts%20in% 20software%20vulnerability%20mitigation.pdf\n\nVIRGO: Crowdsourced fuzzing cluster. Mozillasecurity, MozillaSecurity, \"VIRGO: Crowdsourced fuzzing cluster,\" 2019. [Online]. Available: https://github.com/MozillaSecurity/virgo\n\nWatchdog: hardware for safe and secure manual memory management and full memory safety. S Nagarakatte, M M K Martin, S Zdancewic, ISCA '12: Proceedings of the 39th International Symposium on Computer Architecture. S. Nagarakatte, M. M. K. Martin, and S. Zdancewic, \"Watchdog: hardware for safe and secure manual memory management and full memory safety,\" in ISCA '12: Proceedings of the 39th International Symposium on Computer Architecture, 2012.\n\nWatchdogLite: hardware-accelerated compiler-based pointer checking. S Nagarakatte, M M K Martin, S Zdancewic, CGO '14: Proceedings of the 12th IEEE/ACM International Symposium on Code Generation and Optimization. S. Nagarakatte, M. M. K. Martin, and S. Zdancewic, \"WatchdogLite: hardware-accelerated compiler-based pointer checking,\" in CGO '14: Proceedings of the 12th IEEE/ACM International Symposium on Code Generation and Optimization, 2014.\n\nSoftBound: Highly compatible and complete spatial memory safety for C. S Nagarakatte, J Zhao, M M Martin, S Zdancewic, PLDI '09: Proceedings of the 30th ACM SIGPLAN Conference on Programming Language Design and Implementation. Dublin, IrelandS. Nagarakatte, J. Zhao, M. M. Martin, and S. Zdancewic, \"SoftBound: Highly compatible and complete spatial memory safety for C,\" in PLDI '09: Proceedings of the 30th ACM SIGPLAN Conference on Programming Language Design and Implementation, Dublin, Ireland, June 2009, pp. 245-258.\n\nCETS: Compiler enforced temporal safety for C. S Nagarakatte, J Zhao, M M Martin, S Zdancewic, ISMM '10: Proceedings of the 2010 International Symposium on Memory Management. Toronto, Ontario, CanadaS. Nagarakatte, J. Zhao, M. M. Martin, and S. Zdancewic, \"CETS: Compiler enforced temporal safety for C,\" in ISMM '10: Proceedings of the 2010 International Symposium on Memory Management, Toronto, Ontario, Canada, 2010, pp. 31-40.\n\nIntel mpx explained: A cross-layer analysis of the intel mpx system stack. O Oleksenko, D Kuvaiskii, P Bhatotia, P Felber, C Fetzer, Proceedings of the ACM on Measurement and Analysis of Computing Systems. 2228O. Oleksenko, D. Kuvaiskii, P. Bhatotia, P. Felber, and C. Fetzer, \"Intel mpx explained: A cross-layer analysis of the intel mpx system stack,\" Proceedings of the ACM on Measurement and Analysis of Computing Systems, vol. 2, no. 2, p. 28, 2018.\n\nYou shall not bypass: Employing data dependencies to prevent bounds check bypass. O Oleksenko, B Trach, T Reiher, M Silberstein, C Fetzer, arXiv:1805.08506arXiv preprintO. Oleksenko, B. Trach, T. Reiher, M. Silberstein, and C. Fetzer, \"You shall not bypass: Employing data dependencies to prevent bounds check bypass,\" arXiv preprint arXiv:1805.08506, 2018.\n\nHardware-assisted checking using silicon secured memory (SSM). Oracle, Oracle, \"Hardware-assisted checking using silicon secured memory (SSM),\" 2015. [Online]. Available: https://docs.oracle.com/cd/E37069 01/html/E37085/gphwb.html\n\nSTEROIDS for DOPed applications: A compiler for automated data-oriented programming. J Pewny, P Koppe, T Holz, EuroS&P '19: Proceedings of the 2019 IEEE European Symposium on Security and Privacy. Stockholm, SwedenJ. Pewny, P. Koppe, and T. Holz, \"STEROIDS for DOPed applications: A compiler for automated data-oriented programming,\" in EuroS&P '19: Proceedings of the 2019 IEEE European Symposium on Security and Privacy, Stockholm, Sweden, June 2019.\n\nSafeMem: exploiting ECC-memory for detecting memory leaks and memory corruption during production runs. F Qin, S Lu, Y Zhou, HPCA '05: Proceedings of the IEEE 11th International Symposium on High Performance Computer Architecture. F. Qin, S. Lu, and Y. Zhou, \"SafeMem: exploiting ECC-memory for detecting memory leaks and memory corruption during production runs,\" in HPCA '05: Proceedings of the IEEE 11th International Symposium on High Performance Computer Architecture, 2005.\n\nI see dead \u03bcops: Leaking secrets via Intel/AMD micro-op caches. X Ren, L Moody, M Taram, M Jordan, D M Tullsen, A Venkat, ISCA-48: Proceedings of the 48th Annual International Symposium on Computer Architecture, Worldwide Event. X. Ren, L. Moody, M. Taram, M. Jordan, D. M. Tullsen, and A. Venkat, \"I see dead \u03bcops: Leaking secrets via Intel/AMD micro-op caches,\" in ISCA-48: Proceedings of the 48th Annual International Symposium on Computer Architecture, Worldwide Event, June 2021.\n\nStructSlim: A lightweight profiler to guide structure splitting. P Roy, X Liu, CGO '16: Proceedings of the 2016 International Symposium on Code Generation and Optimization. Barcelona, SpainP. Roy and X. Liu, \"StructSlim: A lightweight profiler to guide structure splitting,\" in CGO '16: Proceedings of the 2016 International Sympo- sium on Code Generation and Optimization, Barcelona, Spain, March 2016, p. 36-46.\n\nPractical byte-granular memory blacklisting using Califorms. H Sasaki, M A Arroyo, M T I Ziad, K Bhat, K Sinha, S Sethumadhavan, MICRO-52: Proceedings of the 52nd Annual IEEE/ACM International Symposium on Microarchitecture. Columbus, OH, USAH. Sasaki, M. A. Arroyo, M. T. I. Ziad, K. Bhat, K. Sinha, and S. Sethumadhavan, \"Practical byte-granular memory blacklisting using Califorms,\" in MICRO-52: Proceedings of the 52nd Annual IEEE/ACM International Symposium on Microarchitecture, Columbus, OH, USA, October 2019, p. 558-571.\n\nD L Schacter, E Tulving, Memory Systems. MIT PressD. L. Schacter and E. Tulving, Memory Systems 1994. MIT Press, 1994.\n\nAddress-Sanitizer: a fast address sanity checker. K Serebryany, D Bruening, A Potapenko, D Vyukov, ATC '12: Proceedings of the 2012 USENIX Annual Technical Conference. K. Serebryany, D. Bruening, A. Potapenko, and D. Vyukov, \"Address- Sanitizer: a fast address sanity checker,\" in ATC '12: Proceedings of the 2012 USENIX Annual Technical Conference, 2012.\n\nMemory tagging and how it improves C/C++ memory safety. K Serebryany, E Stepanov, A Shlyapnikov, V Tsyrklevich, D Vyukov, arXiv:1802.09517v1arXiv preprintK. Serebryany, E. Stepanov, A. Shlyapnikov, V. Tsyrklevich, and D. Vyukov, \"Memory tagging and how it improves C/C++ memory safety,\" arXiv preprint arXiv:1802.09517v1, February 2018.\n\nThe geometry of innocent flesh on the bone: Return-intolibc without function calls (on the x86). H Shacham, CCS '07: Proceedings of the 14th ACM Conference on Computer and Communications Security. Alexandria, Virginia, USAH. Shacham, \"The geometry of innocent flesh on the bone: Return-into- libc without function calls (on the x86),\" in CCS '07: Proceedings of the 14th ACM Conference on Computer and Communications Security, Alexandria, Virginia, USA, 2007, pp. 552-561.\n\nCHEx86: Context-sensitive enforcement of memory safety via microcode-enabled capabilities. R Sharifi, A Venkat, ISCA '20: Proceedings of the 2020 ACM/IEEE 47th Annual International Symposium on Computer Architecture. Valencia, SpainR. Sharifi and A. Venkat, \"CHEx86: Context-sensitive enforcement of memory safety via microcode-enabled capabilities,\" in ISCA '20: Pro- ceedings of the 2020 ACM/IEEE 47th Annual International Symposium on Computer Architecture, Valencia, Spain, June 2020, pp. 762-775.\n\nPractical memory safety with REST. K Sinha, S Sethumadhavan, ISCA '18: Proceedings of the 45th Annual International Symposium on Computer Architecture. Los Angeles, CA, USAK. Sinha and S. Sethumadhavan, \"Practical memory safety with REST,\" in ISCA '18: Proceedings of the 45th Annual International Symposium on Computer Architecture, Los Angeles, CA, USA, 2018, pp. 600-611.\n\nSyrupy. J Sukumaran, J. Sukumaran, \"Syrupy,\" 2008. [Online]. Available: https://github.com/ jeetsukumaran/Syrupy\n\nZeR\u00d8: Zero-overhead resilient operation under pointer integrity attacks. M Tarek Ibn Ziad, M A Arroyo, E Manzhosov, S Sethumadhavan, ISCA-48: Proceedings of the 48th Annual International Symposium on Computer Architecture, Worldwide Event. M. Tarek Ibn Ziad, M. A. Arroyo, E. Manzhosov, and S. Sethumadha- van, \"ZeR\u00d8: Zero-overhead resilient operation under pointer integrity attacks,\" in ISCA-48: Proceedings of the 48th Annual International Symposium on Computer Architecture, Worldwide Event, June 2021.\n\nGWP-ASan: Sampling heap memory error detection in-the-wild. V Tsyrklevich, V. Tsyrklevich, \"GWP-ASan: Sampling heap memory error detection in-the-wild.\" [Online]. Available: https://www.chromium.org/Home/ chromium-security/articles/gwp-asan\n\nA case for richer cross-layer abstractions: Bridging the semantic gap with expressive memory. N Vijaykumar, A Jain, D Majumdar, K Hsieh, G Pekhimenko, E Ebrahimi, N Hajinazar, P B Gibbons, O Mutlu, ISCA '18: Proceedings of the 45th Annual International Symposium on Computer Architecture. Los Angeles, CA, USAN. Vijaykumar, A. Jain, D. Majumdar, K. Hsieh, G. Pekhimenko, E. Ebrahimi, N. Hajinazar, P. B. Gibbons, and O. Mutlu, \"A case for richer cross-layer abstractions: Bridging the semantic gap with expressive memory,\" in ISCA '18: Proceedings of the 45th Annual International Symposium on Computer Architecture, Los Angeles, CA, USA, 2018, pp. 207-220.\n\nCHERI: A hybrid capability-system architecture for scalable software compartmentalization. R N M Watson, J Woodruff, P G Neumann, S W Moore, J Anderson, D Chisnall, N H Dave, B Davis, K Gudka, B Laurie, S J Murdoch, R M Norton, M Roe, S D Son, M Vadera, SP '15: Proceedings of the 2015 IEEE Symposium on Security and Privacy. San Jose, CA, USAR. N. M. Watson, J. Woodruff, P. G. Neumann, S. W. Moore, J. An- derson, D. Chisnall, N. H. Dave, B. Davis, K. Gudka, B. Laurie, S. J. Murdoch, R. M. Norton, M. Roe, S. D. Son, and M. Vadera, \"CHERI: A hybrid capability-system architecture for scalable software compart- mentalization,\" in SP '15: Proceedings of the 2015 IEEE Symposium on Security and Privacy, San Jose, CA, USA, May 2015, pp. 20-37.\n\nCHERI concentrate: practical compressed capabilities. J Woodruff, A Joannou, H Xia, A Fox, R Norton, D Chisnall, B Davis, K Gudka, N W Filardo, A T Markettos, M Roe, P G Neumann, R N M Watson, S Moore, IEEE Transactions on Computers. 6810J. Woodruff, A. Joannou, H. Xia, A. Fox, R. Norton, D. Chisnall, B. Davis, K. Gudka, N. W. Filardo, , A. T. Markettos, M. Roe, P. G. Neumann, R. N. M. Watson, and S. Moore, \"CHERI concentrate: practical compressed capabilities,\" IEEE Transactions on Computers, vol. 68, no. 10, pp. 1455-1469, October 2019.\n\nCHERIvoke: Characterising pointer revocation using cheri capabilities for temporal memory safety. H Xia, J Woodruff, S Ainsworth, N W Filardo, M Roe, A Richardson, P Rugg, P G Neumann, S W Moore, R N M Watson, MICRO-52: Proceedings of the 52nd Annual IEEE/ACM International Symposium on Microarchitecture. Columbus, OH, USAH. Xia, J. Woodruff, S. Ainsworth, N. W. Filardo, M. Roe, A. Richard- son, P. Rugg, P. G. Neumann, S. W. Moore, R. N. M. Watson, and et al., \"CHERIvoke: Characterising pointer revocation using cheri capa- bilities for temporal memory safety,\" in MICRO-52: Proceedings of the 52nd Annual IEEE/ACM International Symposium on Microarchitecture, Columbus, OH, USA, October 2019, pp. 545-557.\n\nIn-Fat pointer: Hardware-assisted tagged-pointer spatial memory safety defense with subobject granularity protection. S Xu, W Huang, D Lie, ASPLOS '21: Proceedings of the 26th International Conference on Architectural Support for Programming Languages and Operating Systems, Virtual Event. S. Xu, W. Huang, and D. Lie, \"In-Fat pointer: Hardware-assisted tagged-pointer spatial memory safety defense with subobject granularity protection,\" in ASPLOS '21: Proceedings of the 26th International Conference on Architectural Support for Programming Languages and Operating Systems, Virtual Event, 2021.\n\nFLUSH+RELOAD: A high resolution, low noise, L3 cache side-channel attack. Y Yarom, K Falkner, SEC '14: Proceedings of the 23rd USENIX Conference on Security Symposium. San Diego, CA, USAY. Yarom and K. Falkner, \"FLUSH+RELOAD: A high resolution, low noise, L3 cache side-channel attack,\" in SEC '14: Proceedings of the 23rd USENIX Conference on Security Symposium, San Diego, CA, USA, 2014, pp. 719-732.\n\nLWPTool: A lightweight profiler to guide data layout optimization. C Yu, P Roy, Y Bai, H Yang, X Liu, IEEE Transactions on Parallel and Distributed Systems. 2911C. Yu, P. Roy, Y. Bai, H. Yang, and X. Liu, \"LWPTool: A lightweight profiler to guide data layout optimization,\" IEEE Transactions on Paral- lel and Distributed Systems, vol. 29, no. 11, pp. 2489-2502, November 2018.\n\nSpeculative taint tracking (STT): A comprehensive protection for speculatively accessed data. J Yu, M Yan, A Khyzha, A Morrison, J Torrellas, C W Fletcher, MICRO-52: Proceedings of the 52nd Annual IEEE/ACM International Symposium on Microarchitecture. Columbus, OH, USAJ. Yu, M. Yan, A. Khyzha, A. Morrison, J. Torrellas, and C. W. Fletcher, \"Speculative taint tracking (STT): A comprehensive protection for speculatively accessed data,\" in MICRO-52: Proceedings of the 52nd Annual IEEE/ACM International Symposium on Microarchitecture, Columbus, OH, USA, October 2019, pp. 954-968.\n\nBOGO: Buy spatial memory safety, get temporal memory safety (almost) free. T Zhang, D Lee, C Jung, ASPLOS '19: Proceedings of the Twenty-Fourth International Conference on Architectural Support for Programming Languages and Operating Systems. Providence, RI, USAT. Zhang, D. Lee, and C. Jung, \"BOGO: Buy spatial memory safety, get temporal memory safety (almost) free,\" in ASPLOS '19: Proceedings of the Twenty-Fourth International Conference on Architectural Support for Programming Languages and Operating Systems, Providence, RI, USA, 2019, p. 631-644.\n", "annotations": {"author": "[{\"end\":175,\"start\":71},{\"end\":252,\"start\":176},{\"end\":359,\"start\":253},{\"end\":467,\"start\":360},{\"end\":577,\"start\":468},{\"end\":665,\"start\":578}]", "publisher": null, "author_last_name": "[{\"end\":84,\"start\":79},{\"end\":184,\"start\":180},{\"end\":268,\"start\":262},{\"end\":376,\"start\":367},{\"end\":480,\"start\":473},{\"end\":597,\"start\":584}]", "author_first_name": "[{\"end\":78,\"start\":71},{\"end\":179,\"start\":176},{\"end\":259,\"start\":253},{\"end\":261,\"start\":260},{\"end\":366,\"start\":360},{\"end\":472,\"start\":468},{\"end\":583,\"start\":578}]", "author_affiliation": "[{\"end\":174,\"start\":109},{\"end\":251,\"start\":186},{\"end\":358,\"start\":293},{\"end\":466,\"start\":401},{\"end\":576,\"start\":511},{\"end\":664,\"start\":599}]", "title": "[{\"end\":68,\"start\":1},{\"end\":733,\"start\":666}]", "venue": null, "abstract": "[{\"end\":1963,\"start\":853}]", "bib_ref": "[{\"attributes\":{\"ref_id\":\"b36\"},\"end\":2249,\"start\":2245},{\"attributes\":{\"ref_id\":\"b21\"},\"end\":2427,\"start\":2423},{\"attributes\":{\"ref_id\":\"b51\"},\"end\":2522,\"start\":2518},{\"attributes\":{\"ref_id\":\"b6\"},\"end\":3022,\"start\":3019},{\"attributes\":{\"ref_id\":\"b37\"},\"end\":3533,\"start\":3529},{\"attributes\":{\"ref_id\":\"b58\"},\"end\":3539,\"start\":3535},{\"attributes\":{\"ref_id\":\"b37\"},\"end\":3781,\"start\":3777},{\"attributes\":{\"ref_id\":\"b50\"},\"end\":4479,\"start\":4475},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":4484,\"start\":4481},{\"attributes\":{\"ref_id\":\"b46\"},\"end\":4490,\"start\":4486},{\"attributes\":{\"ref_id\":\"b25\"},\"end\":4496,\"start\":4492},{\"attributes\":{\"ref_id\":\"b13\"},\"end\":4502,\"start\":4498},{\"attributes\":{\"ref_id\":\"b38\"},\"end\":4508,\"start\":4504},{\"attributes\":{\"ref_id\":\"b60\"},\"end\":4514,\"start\":4510},{\"attributes\":{\"ref_id\":\"b55\"},\"end\":4520,\"start\":4516},{\"attributes\":{\"ref_id\":\"b49\"},\"end\":4526,\"start\":4522},{\"attributes\":{\"ref_id\":\"b54\"},\"end\":4532,\"start\":4528},{\"attributes\":{\"ref_id\":\"b26\"},\"end\":4538,\"start\":4534},{\"attributes\":{\"ref_id\":\"b42\"},\"end\":4662,\"start\":4658},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":4677,\"start\":4674},{\"attributes\":{\"ref_id\":\"b44\"},\"end\":4700,\"start\":4696},{\"attributes\":{\"ref_id\":\"b0\"},\"end\":5710,\"start\":5707},{\"attributes\":{\"ref_id\":\"b15\"},\"end\":5716,\"start\":5712},{\"attributes\":{\"ref_id\":\"b18\"},\"end\":5722,\"start\":5718},{\"attributes\":{\"ref_id\":\"b31\"},\"end\":6277,\"start\":6273},{\"attributes\":{\"ref_id\":\"b20\"},\"end\":7903,\"start\":7899},{\"attributes\":{\"ref_id\":\"b19\"},\"end\":7909,\"start\":7905},{\"attributes\":{\"ref_id\":\"b17\"},\"end\":7915,\"start\":7911},{\"attributes\":{\"ref_id\":\"b33\"},\"end\":7921,\"start\":7917},{\"attributes\":{\"ref_id\":\"b32\"},\"end\":8499,\"start\":8495},{\"attributes\":{\"ref_id\":\"b24\"},\"end\":13742,\"start\":13738},{\"attributes\":{\"ref_id\":\"b48\"},\"end\":13748,\"start\":13744},{\"attributes\":{\"ref_id\":\"b65\"},\"end\":13754,\"start\":13750},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":13942,\"start\":13938},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":14078,\"start\":14074},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":19306,\"start\":19305},{\"attributes\":{\"ref_id\":\"b20\"},\"end\":20052,\"start\":20048},{\"attributes\":{\"ref_id\":\"b19\"},\"end\":20070,\"start\":20066},{\"attributes\":{\"ref_id\":\"b18\"},\"end\":25812,\"start\":25808},{\"attributes\":{\"ref_id\":\"b60\"},\"end\":27543,\"start\":27539},{\"attributes\":{\"ref_id\":\"b55\"},\"end\":27549,\"start\":27545},{\"attributes\":{\"ref_id\":\"b61\"},\"end\":27555,\"start\":27551},{\"attributes\":{\"ref_id\":\"b54\"},\"end\":27561,\"start\":27557},{\"attributes\":{\"ref_id\":\"b26\"},\"end\":27567,\"start\":27563},{\"attributes\":{\"ref_id\":\"b27\"},\"end\":28345,\"start\":28341},{\"attributes\":{\"ref_id\":\"b64\"},\"end\":28375,\"start\":28371},{\"attributes\":{\"ref_id\":\"b28\"},\"end\":28435,\"start\":28431},{\"attributes\":{\"ref_id\":\"b53\"},\"end\":29924,\"start\":29920},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":29946,\"start\":29942},{\"attributes\":{\"ref_id\":\"b5\"},\"end\":29951,\"start\":29948},{\"attributes\":{\"ref_id\":\"b10\"},\"end\":30355,\"start\":30351},{\"attributes\":{\"ref_id\":\"b23\"},\"end\":30361,\"start\":30357},{\"attributes\":{\"ref_id\":\"b45\"},\"end\":30367,\"start\":30363},{\"attributes\":{\"ref_id\":\"b11\"},\"end\":30373,\"start\":30369},{\"attributes\":{\"ref_id\":\"b35\"},\"end\":31159,\"start\":31155},{\"attributes\":{\"ref_id\":\"b28\"},\"end\":32122,\"start\":32118},{\"attributes\":{\"ref_id\":\"b44\"},\"end\":33574,\"start\":33570},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":33590,\"start\":33587},{\"attributes\":{\"ref_id\":\"b4\"},\"end\":33595,\"start\":33592},{\"attributes\":{\"ref_id\":\"b7\"},\"end\":33789,\"start\":33786},{\"attributes\":{\"ref_id\":\"b43\"},\"end\":33851,\"start\":33847},{\"attributes\":{\"ref_id\":\"b66\"},\"end\":33964,\"start\":33960},{\"attributes\":{\"ref_id\":\"b3\"},\"end\":33969,\"start\":33966},{\"attributes\":{\"ref_id\":\"b47\"},\"end\":34758,\"start\":34754},{\"attributes\":{\"ref_id\":\"b29\"},\"end\":36056,\"start\":36052},{\"attributes\":{\"ref_id\":\"b22\"},\"end\":37238,\"start\":37234},{\"attributes\":{\"ref_id\":\"b17\"},\"end\":38971,\"start\":38967},{\"attributes\":{\"ref_id\":\"b31\"},\"end\":39336,\"start\":39332},{\"attributes\":{\"ref_id\":\"b42\"},\"end\":40050,\"start\":40046},{\"attributes\":{\"ref_id\":\"b3\"},\"end\":40425,\"start\":40424},{\"attributes\":{\"ref_id\":\"b56\"},\"end\":41815,\"start\":41811},{\"attributes\":{\"ref_id\":\"b19\"},\"end\":42330,\"start\":42326},{\"attributes\":{\"ref_id\":\"b20\"},\"end\":42348,\"start\":42344},{\"attributes\":{\"ref_id\":\"b32\"},\"end\":42396,\"start\":42392},{\"attributes\":{\"ref_id\":\"b34\"},\"end\":42411,\"start\":42407},{\"attributes\":{\"ref_id\":\"b12\"},\"end\":45381,\"start\":45377},{\"attributes\":{\"ref_id\":\"b13\"},\"end\":46291,\"start\":46287},{\"attributes\":{\"ref_id\":\"b51\"},\"end\":46301,\"start\":46297},{\"attributes\":{\"ref_id\":\"b40\"},\"end\":46316,\"start\":46312},{\"attributes\":{\"ref_id\":\"b38\"},\"end\":46330,\"start\":46326},{\"attributes\":{\"ref_id\":\"b42\"},\"end\":46345,\"start\":46341},{\"attributes\":{\"ref_id\":\"b26\"},\"end\":46354,\"start\":46350},{\"attributes\":{\"ref_id\":\"b54\"},\"end\":46366,\"start\":46362},{\"attributes\":{\"ref_id\":\"b16\"},\"end\":46405,\"start\":46401},{\"attributes\":{\"ref_id\":\"b60\"},\"end\":46416,\"start\":46412},{\"attributes\":{\"ref_id\":\"b61\"},\"end\":46422,\"start\":46418},{\"attributes\":{\"ref_id\":\"b55\"},\"end\":46432,\"start\":46428},{\"attributes\":{\"ref_id\":\"b63\"},\"end\":46444,\"start\":46440},{\"attributes\":{\"ref_id\":\"b30\"},\"end\":46462,\"start\":46458},{\"attributes\":{\"ref_id\":\"b49\"},\"end\":46477,\"start\":46473},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":46508,\"start\":46505},{\"attributes\":{\"ref_id\":\"b44\"},\"end\":46523,\"start\":46519},{\"attributes\":{\"ref_id\":\"b15\"},\"end\":46559,\"start\":46555},{\"attributes\":{\"ref_id\":\"b18\"},\"end\":46565,\"start\":46561},{\"attributes\":{\"ref_id\":\"b49\"},\"end\":47881,\"start\":47877},{\"attributes\":{\"ref_id\":\"b13\"},\"end\":48891,\"start\":48887},{\"attributes\":{\"ref_id\":\"b40\"},\"end\":48907,\"start\":48903},{\"attributes\":{\"ref_id\":\"b42\"},\"end\":48923,\"start\":48919},{\"attributes\":{\"ref_id\":\"b54\"},\"end\":48936,\"start\":48932},{\"attributes\":{\"ref_id\":\"b26\"},\"end\":48950,\"start\":48946},{\"attributes\":{\"ref_id\":\"b60\"},\"end\":49024,\"start\":49020},{\"attributes\":{\"ref_id\":\"b41\"},\"end\":49239,\"start\":49235},{\"attributes\":{\"ref_id\":\"b38\"},\"end\":49254,\"start\":49250},{\"attributes\":{\"ref_id\":\"b39\"},\"end\":49277,\"start\":49273},{\"attributes\":{\"ref_id\":\"b67\"},\"end\":49362,\"start\":49358},{\"attributes\":{\"ref_id\":\"b42\"},\"end\":49565,\"start\":49561},{\"attributes\":{\"ref_id\":\"b61\"},\"end\":49571,\"start\":49567},{\"attributes\":{\"ref_id\":\"b54\"},\"end\":49577,\"start\":49573},{\"attributes\":{\"ref_id\":\"b26\"},\"end\":49583,\"start\":49579},{\"attributes\":{\"ref_id\":\"b13\"},\"end\":49749,\"start\":49745},{\"attributes\":{\"ref_id\":\"b42\"},\"end\":49755,\"start\":49751},{\"attributes\":{\"ref_id\":\"b26\"},\"end\":49761,\"start\":49757},{\"attributes\":{\"ref_id\":\"b54\"},\"end\":49767,\"start\":49763},{\"attributes\":{\"ref_id\":\"b40\"},\"end\":49956,\"start\":49952},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":50103,\"start\":50100},{\"attributes\":{\"ref_id\":\"b60\"},\"end\":51070,\"start\":51066},{\"attributes\":{\"ref_id\":\"b61\"},\"end\":51076,\"start\":51072},{\"attributes\":{\"ref_id\":\"b42\"},\"end\":51516,\"start\":51512},{\"attributes\":{\"ref_id\":\"b54\"},\"end\":51682,\"start\":51678},{\"attributes\":{\"ref_id\":\"b26\"},\"end\":51688,\"start\":51684},{\"attributes\":{\"ref_id\":\"b8\"},\"end\":51939,\"start\":51936},{\"attributes\":{\"ref_id\":\"b0\"},\"end\":51968,\"start\":51965},{\"attributes\":{\"ref_id\":\"b30\"},\"end\":52350,\"start\":52346},{\"attributes\":{\"ref_id\":\"b61\"},\"end\":52510,\"start\":52506},{\"attributes\":{\"ref_id\":\"b15\"},\"end\":52862,\"start\":52858},{\"attributes\":{\"ref_id\":\"b17\"},\"end\":52868,\"start\":52864},{\"attributes\":{\"ref_id\":\"b18\"},\"end\":52874,\"start\":52870},{\"attributes\":{\"ref_id\":\"b16\"},\"end\":53230,\"start\":53226},{\"attributes\":{\"ref_id\":\"b63\"},\"end\":53448,\"start\":53444},{\"attributes\":{\"ref_id\":\"b44\"},\"end\":54455,\"start\":54451},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":54570,\"start\":54567},{\"attributes\":{\"ref_id\":\"b52\"},\"end\":54616,\"start\":54612},{\"attributes\":{\"ref_id\":\"b55\"},\"end\":55451,\"start\":55447},{\"attributes\":{\"ref_id\":\"b49\"},\"end\":55751,\"start\":55747},{\"attributes\":{\"ref_id\":\"b55\"},\"end\":55974,\"start\":55970},{\"attributes\":{\"ref_id\":\"b49\"},\"end\":55993,\"start\":55989},{\"attributes\":{\"ref_id\":\"b4\"},\"end\":56212,\"start\":56209},{\"attributes\":{\"ref_id\":\"b57\"},\"end\":57790,\"start\":57786},{\"attributes\":{\"ref_id\":\"b59\"},\"end\":63442,\"start\":63438},{\"attributes\":{\"ref_id\":\"b0\"},\"end\":63837,\"start\":63834},{\"attributes\":{\"ref_id\":\"b4\"},\"end\":63894,\"start\":63893}]", "figure": "[{\"attributes\":{\"id\":\"fig_0\"},\"end\":58433,\"start\":58102},{\"attributes\":{\"id\":\"fig_1\"},\"end\":58591,\"start\":58434},{\"attributes\":{\"id\":\"fig_2\"},\"end\":58747,\"start\":58592},{\"attributes\":{\"id\":\"fig_3\"},\"end\":58914,\"start\":58748},{\"attributes\":{\"id\":\"fig_4\"},\"end\":59042,\"start\":58915},{\"attributes\":{\"id\":\"fig_5\"},\"end\":59146,\"start\":59043},{\"attributes\":{\"id\":\"tab_0\",\"type\":\"table\"},\"end\":59423,\"start\":59147},{\"attributes\":{\"id\":\"tab_1\",\"type\":\"table\"},\"end\":60203,\"start\":59424},{\"attributes\":{\"id\":\"tab_2\",\"type\":\"table\"},\"end\":60417,\"start\":60204},{\"attributes\":{\"id\":\"tab_3\",\"type\":\"table\"},\"end\":63265,\"start\":60418}]", "paragraph": "[{\"end\":2428,\"start\":1982},{\"end\":4176,\"start\":2430},{\"end\":4702,\"start\":4178},{\"end\":5231,\"start\":4704},{\"end\":5561,\"start\":5233},{\"end\":6611,\"start\":5563},{\"end\":6807,\"start\":6613},{\"end\":7757,\"start\":6809},{\"end\":8832,\"start\":7807},{\"end\":9425,\"start\":8903},{\"end\":9988,\"start\":9427},{\"end\":10723,\"start\":9990},{\"end\":11623,\"start\":10725},{\"end\":12585,\"start\":11625},{\"end\":13239,\"start\":12587},{\"end\":14474,\"start\":13310},{\"end\":15184,\"start\":14505},{\"end\":16408,\"start\":15236},{\"end\":17234,\"start\":16410},{\"end\":17314,\"start\":17264},{\"end\":17941,\"start\":17316},{\"end\":18600,\"start\":17943},{\"end\":18906,\"start\":18602},{\"end\":21044,\"start\":18939},{\"end\":22793,\"start\":21081},{\"end\":22923,\"start\":22816},{\"end\":23832,\"start\":22956},{\"end\":25225,\"start\":23856},{\"end\":25813,\"start\":25227},{\"end\":27050,\"start\":25845},{\"end\":27365,\"start\":27052},{\"end\":28680,\"start\":27409},{\"end\":29742,\"start\":28707},{\"end\":30249,\"start\":29744},{\"end\":30762,\"start\":30251},{\"end\":31160,\"start\":30764},{\"end\":31904,\"start\":31162},{\"end\":35145,\"start\":31933},{\"end\":36057,\"start\":35147},{\"end\":36446,\"start\":36077},{\"end\":37938,\"start\":36472},{\"end\":38864,\"start\":37976},{\"end\":39224,\"start\":38866},{\"end\":41624,\"start\":39226},{\"end\":42415,\"start\":41657},{\"end\":43022,\"start\":42439},{\"end\":43876,\"start\":43024},{\"end\":44705,\"start\":43878},{\"end\":45590,\"start\":44707},{\"end\":46367,\"start\":45592},{\"end\":46541,\"start\":46388},{\"end\":46906,\"start\":46543},{\"end\":47421,\"start\":46908},{\"end\":48155,\"start\":47437},{\"end\":49364,\"start\":48190},{\"end\":49898,\"start\":49366},{\"end\":50992,\"start\":49900},{\"end\":51689,\"start\":50994},{\"end\":52327,\"start\":51691},{\"end\":52801,\"start\":52329},{\"end\":54110,\"start\":52803},{\"end\":54724,\"start\":54112},{\"end\":55260,\"start\":54726},{\"end\":55915,\"start\":55262},{\"end\":56213,\"start\":55917},{\"end\":56907,\"start\":56215},{\"end\":58101,\"start\":56925}]", "formula": null, "table_ref": "[{\"attributes\":{\"ref_id\":\"tab_0\"},\"end\":19041,\"start\":19031},{\"attributes\":{\"ref_id\":\"tab_0\"},\"end\":37247,\"start\":37240},{\"attributes\":{\"ref_id\":\"tab_0\"},\"end\":41954,\"start\":41946},{\"attributes\":{\"ref_id\":\"tab_0\"},\"end\":42671,\"start\":42663},{\"attributes\":{\"ref_id\":\"tab_0\"},\"end\":48429,\"start\":48420},{\"attributes\":{\"ref_id\":\"tab_0\"},\"end\":48682,\"start\":48674}]", "section_header": "[{\"end\":1980,\"start\":1965},{\"end\":7786,\"start\":7760},{\"end\":7805,\"start\":7789},{\"end\":8901,\"start\":8835},{\"end\":13308,\"start\":13242},{\"end\":14503,\"start\":14477},{\"end\":15234,\"start\":15187},{\"end\":17262,\"start\":17237},{\"end\":18937,\"start\":18909},{\"end\":21079,\"start\":21047},{\"end\":22814,\"start\":22796},{\"end\":22954,\"start\":22926},{\"end\":23854,\"start\":23835},{\"end\":25843,\"start\":25816},{\"end\":27389,\"start\":27368},{\"end\":27407,\"start\":27392},{\"end\":28705,\"start\":28683},{\"end\":31931,\"start\":31907},{\"end\":36075,\"start\":36060},{\"end\":36470,\"start\":36449},{\"end\":37974,\"start\":37941},{\"end\":41655,\"start\":41627},{\"end\":42437,\"start\":42418},{\"end\":46386,\"start\":46370},{\"end\":47435,\"start\":47424},{\"end\":48188,\"start\":48158},{\"end\":56923,\"start\":56910},{\"end\":58443,\"start\":58435},{\"end\":58594,\"start\":58593},{\"end\":58750,\"start\":58749},{\"end\":58924,\"start\":58916},{\"end\":59052,\"start\":59044},{\"end\":59157,\"start\":59148},{\"end\":59435,\"start\":59425},{\"end\":60216,\"start\":60205},{\"end\":60429,\"start\":60419}]", "table": "[{\"end\":59423,\"start\":59233},{\"end\":60203,\"start\":59468},{\"end\":60417,\"start\":60321},{\"end\":63265,\"start\":60993}]", "figure_caption": "[{\"end\":58433,\"start\":58104},{\"end\":58591,\"start\":58445},{\"end\":58747,\"start\":58595},{\"end\":58914,\"start\":58751},{\"end\":59042,\"start\":58926},{\"end\":59146,\"start\":59054},{\"end\":59233,\"start\":59159},{\"end\":59468,\"start\":59438},{\"end\":60321,\"start\":60220},{\"end\":60993,\"start\":60432}]", "figure_ref": "[{\"attributes\":{\"ref_id\":\"fig_1\"},\"end\":21337,\"start\":21329},{\"attributes\":{\"ref_id\":\"fig_4\"},\"end\":40937,\"start\":40929},{\"attributes\":{\"ref_id\":\"fig_5\"},\"end\":42242,\"start\":42234}]", "bib_author_first_name": "[{\"end\":64521,\"start\":64520},{\"end\":64534,\"start\":64533},{\"end\":64543,\"start\":64542},{\"end\":64553,\"start\":64552},{\"end\":65242,\"start\":65241},{\"end\":65244,\"start\":65243},{\"end\":65254,\"start\":65253},{\"end\":65256,\"start\":65255},{\"end\":65266,\"start\":65265},{\"end\":65268,\"start\":65267},{\"end\":65722,\"start\":65721},{\"end\":65732,\"start\":65731},{\"end\":65741,\"start\":65740},{\"end\":65749,\"start\":65748},{\"end\":65758,\"start\":65757},{\"end\":66048,\"start\":66047},{\"end\":66058,\"start\":66057},{\"end\":66069,\"start\":66068},{\"end\":66079,\"start\":66078},{\"end\":66387,\"start\":66386},{\"end\":66398,\"start\":66397},{\"end\":66407,\"start\":66406},{\"end\":66409,\"start\":66408},{\"end\":66418,\"start\":66417},{\"end\":66861,\"start\":66860},{\"end\":66870,\"start\":66869},{\"end\":67469,\"start\":67468},{\"end\":67709,\"start\":67708},{\"end\":67711,\"start\":67710},{\"end\":67721,\"start\":67720},{\"end\":67723,\"start\":67722},{\"end\":67734,\"start\":67733},{\"end\":67736,\"start\":67735},{\"end\":67966,\"start\":67965},{\"end\":67979,\"start\":67978},{\"end\":67987,\"start\":67986},{\"end\":68004,\"start\":68000},{\"end\":68015,\"start\":68014},{\"end\":68026,\"start\":68025},{\"end\":68469,\"start\":68468},{\"end\":68477,\"start\":68476},{\"end\":68483,\"start\":68482},{\"end\":68485,\"start\":68484},{\"end\":68494,\"start\":68493},{\"end\":68505,\"start\":68504},{\"end\":68507,\"start\":68506},{\"end\":68898,\"start\":68897},{\"end\":68907,\"start\":68906},{\"end\":68922,\"start\":68921},{\"end\":68924,\"start\":68923},{\"end\":68933,\"start\":68932},{\"end\":68942,\"start\":68941},{\"end\":68952,\"start\":68951},{\"end\":68962,\"start\":68961},{\"end\":69454,\"start\":69453},{\"end\":69466,\"start\":69465},{\"end\":69478,\"start\":69477},{\"end\":69480,\"start\":69479},{\"end\":69490,\"start\":69489},{\"end\":69502,\"start\":69501},{\"end\":69512,\"start\":69511},{\"end\":69514,\"start\":69513},{\"end\":69523,\"start\":69522},{\"end\":69530,\"start\":69529},{\"end\":69539,\"start\":69538},{\"end\":69541,\"start\":69540},{\"end\":70169,\"start\":70168},{\"end\":70181,\"start\":70180},{\"end\":70193,\"start\":70192},{\"end\":70197,\"start\":70194},{\"end\":70207,\"start\":70206},{\"end\":70714,\"start\":70713},{\"end\":70724,\"start\":70723},{\"end\":70734,\"start\":70733},{\"end\":70743,\"start\":70742},{\"end\":70756,\"start\":70755},{\"end\":70770,\"start\":70769},{\"end\":70772,\"start\":70771},{\"end\":70781,\"start\":70780},{\"end\":70783,\"start\":70782},{\"end\":70793,\"start\":70792},{\"end\":70795,\"start\":70794},{\"end\":70801,\"start\":70800},{\"end\":71330,\"start\":71329},{\"end\":71332,\"start\":71331},{\"end\":71340,\"start\":71339},{\"end\":71344,\"start\":71341},{\"end\":71728,\"start\":71727},{\"end\":71730,\"start\":71729},{\"end\":71738,\"start\":71737},{\"end\":71742,\"start\":71739},{\"end\":72135,\"start\":72134},{\"end\":72137,\"start\":72136},{\"end\":72145,\"start\":72144},{\"end\":72149,\"start\":72146},{\"end\":72356,\"start\":72355},{\"end\":72358,\"start\":72357},{\"end\":72366,\"start\":72365},{\"end\":72370,\"start\":72367},{\"end\":72377,\"start\":72376},{\"end\":72784,\"start\":72783},{\"end\":73092,\"start\":73091},{\"end\":73104,\"start\":73103},{\"end\":73457,\"start\":73456},{\"end\":73459,\"start\":73458},{\"end\":73470,\"start\":73469},{\"end\":73472,\"start\":73471},{\"end\":73481,\"start\":73480},{\"end\":73490,\"start\":73489},{\"end\":73498,\"start\":73497},{\"end\":73504,\"start\":73503},{\"end\":73920,\"start\":73919},{\"end\":73926,\"start\":73925},{\"end\":73936,\"start\":73935},{\"end\":73946,\"start\":73945},{\"end\":73948,\"start\":73947},{\"end\":73956,\"start\":73955},{\"end\":73966,\"start\":73965},{\"end\":74380,\"start\":74379},{\"end\":74389,\"start\":74388},{\"end\":74404,\"start\":74403},{\"end\":74781,\"start\":74780},{\"end\":74794,\"start\":74793},{\"end\":74803,\"start\":74802},{\"end\":74814,\"start\":74813},{\"end\":74831,\"start\":74830},{\"end\":75361,\"start\":75360},{\"end\":75368,\"start\":75367},{\"end\":75375,\"start\":75374},{\"end\":75793,\"start\":75792},{\"end\":75800,\"start\":75799},{\"end\":75808,\"start\":75807},{\"end\":75815,\"start\":75814},{\"end\":75825,\"start\":75824},{\"end\":75827,\"start\":75826},{\"end\":75834,\"start\":75833},{\"end\":75841,\"start\":75840},{\"end\":75854,\"start\":75853},{\"end\":75861,\"start\":75860},{\"end\":76316,\"start\":76315},{\"end\":76326,\"start\":76325},{\"end\":76336,\"start\":76335},{\"end\":76345,\"start\":76344},{\"end\":76353,\"start\":76352},{\"end\":76364,\"start\":76363},{\"end\":76372,\"start\":76371},{\"end\":76383,\"start\":76382},{\"end\":76395,\"start\":76394},{\"end\":76406,\"start\":76405},{\"end\":76807,\"start\":76806},{\"end\":76809,\"start\":76808},{\"end\":76820,\"start\":76819},{\"end\":76824,\"start\":76821},{\"end\":76835,\"start\":76834},{\"end\":76837,\"start\":76836},{\"end\":76850,\"start\":76849},{\"end\":76858,\"start\":76857},{\"end\":76860,\"start\":76859},{\"end\":77375,\"start\":77374},{\"end\":77383,\"start\":77382},{\"end\":77393,\"start\":77392},{\"end\":77395,\"start\":77394},{\"end\":77404,\"start\":77403},{\"end\":77406,\"start\":77405},{\"end\":77416,\"start\":77415},{\"end\":77917,\"start\":77916},{\"end\":77928,\"start\":77927},{\"end\":78293,\"start\":78292},{\"end\":78444,\"start\":78443},{\"end\":78454,\"start\":78453},{\"end\":78462,\"start\":78461},{\"end\":78968,\"start\":78967},{\"end\":78979,\"start\":78978},{\"end\":78986,\"start\":78985},{\"end\":79423,\"start\":79422},{\"end\":80052,\"start\":80051},{\"end\":80067,\"start\":80066},{\"end\":80071,\"start\":80068},{\"end\":80081,\"start\":80080},{\"end\":80481,\"start\":80480},{\"end\":80496,\"start\":80495},{\"end\":80500,\"start\":80497},{\"end\":80510,\"start\":80509},{\"end\":80931,\"start\":80930},{\"end\":80946,\"start\":80945},{\"end\":80954,\"start\":80953},{\"end\":80956,\"start\":80955},{\"end\":80966,\"start\":80965},{\"end\":81432,\"start\":81431},{\"end\":81447,\"start\":81446},{\"end\":81455,\"start\":81454},{\"end\":81457,\"start\":81456},{\"end\":81467,\"start\":81466},{\"end\":81892,\"start\":81891},{\"end\":81905,\"start\":81904},{\"end\":81918,\"start\":81917},{\"end\":81930,\"start\":81929},{\"end\":81940,\"start\":81939},{\"end\":82355,\"start\":82354},{\"end\":82368,\"start\":82367},{\"end\":82377,\"start\":82376},{\"end\":82387,\"start\":82386},{\"end\":82402,\"start\":82401},{\"end\":82949,\"start\":82948},{\"end\":82958,\"start\":82957},{\"end\":82967,\"start\":82966},{\"end\":83422,\"start\":83421},{\"end\":83429,\"start\":83428},{\"end\":83435,\"start\":83434},{\"end\":83863,\"start\":83862},{\"end\":83870,\"start\":83869},{\"end\":83879,\"start\":83878},{\"end\":83888,\"start\":83887},{\"end\":83898,\"start\":83897},{\"end\":83900,\"start\":83899},{\"end\":83911,\"start\":83910},{\"end\":84350,\"start\":84349},{\"end\":84357,\"start\":84356},{\"end\":84761,\"start\":84760},{\"end\":84771,\"start\":84770},{\"end\":84773,\"start\":84772},{\"end\":84783,\"start\":84782},{\"end\":84787,\"start\":84784},{\"end\":84795,\"start\":84794},{\"end\":84803,\"start\":84802},{\"end\":84812,\"start\":84811},{\"end\":85231,\"start\":85230},{\"end\":85233,\"start\":85232},{\"end\":85245,\"start\":85244},{\"end\":85401,\"start\":85400},{\"end\":85415,\"start\":85414},{\"end\":85427,\"start\":85426},{\"end\":85440,\"start\":85439},{\"end\":85764,\"start\":85763},{\"end\":85778,\"start\":85777},{\"end\":85790,\"start\":85789},{\"end\":85805,\"start\":85804},{\"end\":85820,\"start\":85819},{\"end\":86143,\"start\":86142},{\"end\":86611,\"start\":86610},{\"end\":86622,\"start\":86621},{\"end\":87058,\"start\":87057},{\"end\":87067,\"start\":87066},{\"end\":87407,\"start\":87406},{\"end\":87586,\"start\":87585},{\"end\":87604,\"start\":87603},{\"end\":87606,\"start\":87605},{\"end\":87616,\"start\":87615},{\"end\":87629,\"start\":87628},{\"end\":88081,\"start\":88080},{\"end\":88357,\"start\":88356},{\"end\":88371,\"start\":88370},{\"end\":88379,\"start\":88378},{\"end\":88391,\"start\":88390},{\"end\":88400,\"start\":88399},{\"end\":88414,\"start\":88413},{\"end\":88426,\"start\":88425},{\"end\":88439,\"start\":88438},{\"end\":88441,\"start\":88440},{\"end\":88452,\"start\":88451},{\"end\":89013,\"start\":89012},{\"end\":89017,\"start\":89014},{\"end\":89027,\"start\":89026},{\"end\":89039,\"start\":89038},{\"end\":89041,\"start\":89040},{\"end\":89052,\"start\":89051},{\"end\":89054,\"start\":89053},{\"end\":89063,\"start\":89062},{\"end\":89075,\"start\":89074},{\"end\":89087,\"start\":89086},{\"end\":89089,\"start\":89088},{\"end\":89097,\"start\":89096},{\"end\":89106,\"start\":89105},{\"end\":89115,\"start\":89114},{\"end\":89125,\"start\":89124},{\"end\":89127,\"start\":89126},{\"end\":89138,\"start\":89137},{\"end\":89140,\"start\":89139},{\"end\":89150,\"start\":89149},{\"end\":89157,\"start\":89156},{\"end\":89159,\"start\":89158},{\"end\":89166,\"start\":89165},{\"end\":89722,\"start\":89721},{\"end\":89734,\"start\":89733},{\"end\":89745,\"start\":89744},{\"end\":89752,\"start\":89751},{\"end\":89759,\"start\":89758},{\"end\":89769,\"start\":89768},{\"end\":89781,\"start\":89780},{\"end\":89790,\"start\":89789},{\"end\":89799,\"start\":89798},{\"end\":89801,\"start\":89800},{\"end\":89812,\"start\":89811},{\"end\":89814,\"start\":89813},{\"end\":89827,\"start\":89826},{\"end\":89834,\"start\":89833},{\"end\":89836,\"start\":89835},{\"end\":89847,\"start\":89846},{\"end\":89851,\"start\":89848},{\"end\":89861,\"start\":89860},{\"end\":90312,\"start\":90311},{\"end\":90319,\"start\":90318},{\"end\":90331,\"start\":90330},{\"end\":90344,\"start\":90343},{\"end\":90346,\"start\":90345},{\"end\":90357,\"start\":90356},{\"end\":90364,\"start\":90363},{\"end\":90378,\"start\":90377},{\"end\":90386,\"start\":90385},{\"end\":90388,\"start\":90387},{\"end\":90399,\"start\":90398},{\"end\":90401,\"start\":90400},{\"end\":90410,\"start\":90409},{\"end\":90414,\"start\":90411},{\"end\":91044,\"start\":91043},{\"end\":91050,\"start\":91049},{\"end\":91059,\"start\":91058},{\"end\":91599,\"start\":91598},{\"end\":91608,\"start\":91607},{\"end\":91996,\"start\":91995},{\"end\":92002,\"start\":92001},{\"end\":92009,\"start\":92008},{\"end\":92016,\"start\":92015},{\"end\":92024,\"start\":92023},{\"end\":92402,\"start\":92401},{\"end\":92408,\"start\":92407},{\"end\":92415,\"start\":92414},{\"end\":92425,\"start\":92424},{\"end\":92437,\"start\":92436},{\"end\":92450,\"start\":92449},{\"end\":92452,\"start\":92451},{\"end\":92967,\"start\":92966},{\"end\":92976,\"start\":92975},{\"end\":92983,\"start\":92982}]", "bib_author_last_name": "[{\"end\":64531,\"start\":64522},{\"end\":64540,\"start\":64535},{\"end\":64550,\"start\":64544},{\"end\":64558,\"start\":64554},{\"end\":65251,\"start\":65245},{\"end\":65263,\"start\":65257},{\"end\":65273,\"start\":65269},{\"end\":65729,\"start\":65723},{\"end\":65738,\"start\":65733},{\"end\":65746,\"start\":65742},{\"end\":65755,\"start\":65750},{\"end\":65769,\"start\":65759},{\"end\":66055,\"start\":66049},{\"end\":66066,\"start\":66059},{\"end\":66076,\"start\":66070},{\"end\":66084,\"start\":66080},{\"end\":66395,\"start\":66388},{\"end\":66404,\"start\":66399},{\"end\":66415,\"start\":66410},{\"end\":66424,\"start\":66419},{\"end\":66867,\"start\":66862},{\"end\":66875,\"start\":66871},{\"end\":67477,\"start\":67470},{\"end\":67718,\"start\":67712},{\"end\":67731,\"start\":67724},{\"end\":67742,\"start\":67737},{\"end\":67976,\"start\":67967},{\"end\":67984,\"start\":67980},{\"end\":67998,\"start\":67988},{\"end\":68012,\"start\":68005},{\"end\":68023,\"start\":68016},{\"end\":68034,\"start\":68027},{\"end\":68474,\"start\":68470},{\"end\":68480,\"start\":68478},{\"end\":68491,\"start\":68486},{\"end\":68502,\"start\":68495},{\"end\":68512,\"start\":68508},{\"end\":68904,\"start\":68899},{\"end\":68919,\"start\":68908},{\"end\":68930,\"start\":68925},{\"end\":68939,\"start\":68934},{\"end\":68949,\"start\":68943},{\"end\":68959,\"start\":68953},{\"end\":68966,\"start\":68963},{\"end\":69463,\"start\":69455},{\"end\":69475,\"start\":69467},{\"end\":69487,\"start\":69481},{\"end\":69499,\"start\":69491},{\"end\":69509,\"start\":69503},{\"end\":69520,\"start\":69515},{\"end\":69527,\"start\":69524},{\"end\":69536,\"start\":69531},{\"end\":69549,\"start\":69542},{\"end\":70178,\"start\":70170},{\"end\":70190,\"start\":70182},{\"end\":70204,\"start\":70198},{\"end\":70217,\"start\":70208},{\"end\":70721,\"start\":70715},{\"end\":70731,\"start\":70725},{\"end\":70740,\"start\":70735},{\"end\":70753,\"start\":70744},{\"end\":70767,\"start\":70757},{\"end\":70778,\"start\":70773},{\"end\":70790,\"start\":70784},{\"end\":70798,\"start\":70796},{\"end\":70808,\"start\":70802},{\"end\":70815,\"start\":70810},{\"end\":71337,\"start\":71333},{\"end\":71348,\"start\":71345},{\"end\":71735,\"start\":71731},{\"end\":71746,\"start\":71743},{\"end\":72142,\"start\":72138},{\"end\":72153,\"start\":72150},{\"end\":72363,\"start\":72359},{\"end\":72374,\"start\":72371},{\"end\":72387,\"start\":72378},{\"end\":72790,\"start\":72785},{\"end\":73101,\"start\":73093},{\"end\":73111,\"start\":73105},{\"end\":73295,\"start\":73278},{\"end\":73467,\"start\":73460},{\"end\":73478,\"start\":73473},{\"end\":73487,\"start\":73482},{\"end\":73495,\"start\":73491},{\"end\":73501,\"start\":73499},{\"end\":73511,\"start\":73505},{\"end\":73923,\"start\":73921},{\"end\":73933,\"start\":73927},{\"end\":73943,\"start\":73937},{\"end\":73953,\"start\":73949},{\"end\":73963,\"start\":73957},{\"end\":73972,\"start\":73967},{\"end\":74386,\"start\":74381},{\"end\":74401,\"start\":74390},{\"end\":74416,\"start\":74405},{\"end\":74791,\"start\":74782},{\"end\":74800,\"start\":74795},{\"end\":74811,\"start\":74804},{\"end\":74828,\"start\":74815},{\"end\":74841,\"start\":74832},{\"end\":75365,\"start\":75362},{\"end\":75372,\"start\":75369},{\"end\":75379,\"start\":75376},{\"end\":75797,\"start\":75794},{\"end\":75805,\"start\":75801},{\"end\":75812,\"start\":75809},{\"end\":75822,\"start\":75816},{\"end\":75831,\"start\":75828},{\"end\":75838,\"start\":75835},{\"end\":75851,\"start\":75842},{\"end\":75858,\"start\":75855},{\"end\":75867,\"start\":75862},{\"end\":76323,\"start\":76317},{\"end\":76333,\"start\":76327},{\"end\":76342,\"start\":76337},{\"end\":76350,\"start\":76346},{\"end\":76361,\"start\":76354},{\"end\":76369,\"start\":76365},{\"end\":76380,\"start\":76373},{\"end\":76392,\"start\":76384},{\"end\":76403,\"start\":76396},{\"end\":76412,\"start\":76407},{\"end\":76817,\"start\":76810},{\"end\":76832,\"start\":76825},{\"end\":76847,\"start\":76838},{\"end\":76855,\"start\":76851},{\"end\":76873,\"start\":76861},{\"end\":77380,\"start\":77376},{\"end\":77390,\"start\":77384},{\"end\":77401,\"start\":77396},{\"end\":77413,\"start\":77407},{\"end\":77419,\"start\":77417},{\"end\":77426,\"start\":77421},{\"end\":77925,\"start\":77918},{\"end\":77933,\"start\":77929},{\"end\":78297,\"start\":78294},{\"end\":78451,\"start\":78445},{\"end\":78459,\"start\":78455},{\"end\":78471,\"start\":78463},{\"end\":78976,\"start\":78969},{\"end\":78983,\"start\":78980},{\"end\":78996,\"start\":78987},{\"end\":79430,\"start\":79424},{\"end\":79836,\"start\":79821},{\"end\":80064,\"start\":80053},{\"end\":80078,\"start\":80072},{\"end\":80091,\"start\":80082},{\"end\":80493,\"start\":80482},{\"end\":80507,\"start\":80501},{\"end\":80520,\"start\":80511},{\"end\":80943,\"start\":80932},{\"end\":80951,\"start\":80947},{\"end\":80963,\"start\":80957},{\"end\":80976,\"start\":80967},{\"end\":81444,\"start\":81433},{\"end\":81452,\"start\":81448},{\"end\":81464,\"start\":81458},{\"end\":81477,\"start\":81468},{\"end\":81902,\"start\":81893},{\"end\":81915,\"start\":81906},{\"end\":81927,\"start\":81919},{\"end\":81937,\"start\":81931},{\"end\":81947,\"start\":81941},{\"end\":82365,\"start\":82356},{\"end\":82374,\"start\":82369},{\"end\":82384,\"start\":82378},{\"end\":82399,\"start\":82388},{\"end\":82409,\"start\":82403},{\"end\":82700,\"start\":82694},{\"end\":82955,\"start\":82950},{\"end\":82964,\"start\":82959},{\"end\":82972,\"start\":82968},{\"end\":83426,\"start\":83423},{\"end\":83432,\"start\":83430},{\"end\":83440,\"start\":83436},{\"end\":83867,\"start\":83864},{\"end\":83876,\"start\":83871},{\"end\":83885,\"start\":83880},{\"end\":83895,\"start\":83889},{\"end\":83908,\"start\":83901},{\"end\":83918,\"start\":83912},{\"end\":84354,\"start\":84351},{\"end\":84361,\"start\":84358},{\"end\":84768,\"start\":84762},{\"end\":84780,\"start\":84774},{\"end\":84792,\"start\":84788},{\"end\":84800,\"start\":84796},{\"end\":84809,\"start\":84804},{\"end\":84826,\"start\":84813},{\"end\":85242,\"start\":85234},{\"end\":85253,\"start\":85246},{\"end\":85412,\"start\":85402},{\"end\":85424,\"start\":85416},{\"end\":85437,\"start\":85428},{\"end\":85447,\"start\":85441},{\"end\":85775,\"start\":85765},{\"end\":85787,\"start\":85779},{\"end\":85802,\"start\":85791},{\"end\":85817,\"start\":85806},{\"end\":85827,\"start\":85821},{\"end\":86151,\"start\":86144},{\"end\":86619,\"start\":86612},{\"end\":86629,\"start\":86623},{\"end\":87064,\"start\":87059},{\"end\":87081,\"start\":87068},{\"end\":87417,\"start\":87408},{\"end\":87601,\"start\":87587},{\"end\":87613,\"start\":87607},{\"end\":87626,\"start\":87617},{\"end\":87643,\"start\":87630},{\"end\":88093,\"start\":88082},{\"end\":88368,\"start\":88358},{\"end\":88376,\"start\":88372},{\"end\":88388,\"start\":88380},{\"end\":88397,\"start\":88392},{\"end\":88411,\"start\":88401},{\"end\":88423,\"start\":88415},{\"end\":88436,\"start\":88427},{\"end\":88449,\"start\":88442},{\"end\":88458,\"start\":88453},{\"end\":89024,\"start\":89018},{\"end\":89036,\"start\":89028},{\"end\":89049,\"start\":89042},{\"end\":89060,\"start\":89055},{\"end\":89072,\"start\":89064},{\"end\":89084,\"start\":89076},{\"end\":89094,\"start\":89090},{\"end\":89103,\"start\":89098},{\"end\":89112,\"start\":89107},{\"end\":89122,\"start\":89116},{\"end\":89135,\"start\":89128},{\"end\":89147,\"start\":89141},{\"end\":89154,\"start\":89151},{\"end\":89163,\"start\":89160},{\"end\":89173,\"start\":89167},{\"end\":89731,\"start\":89723},{\"end\":89742,\"start\":89735},{\"end\":89749,\"start\":89746},{\"end\":89756,\"start\":89753},{\"end\":89766,\"start\":89760},{\"end\":89778,\"start\":89770},{\"end\":89787,\"start\":89782},{\"end\":89796,\"start\":89791},{\"end\":89809,\"start\":89802},{\"end\":89824,\"start\":89815},{\"end\":89831,\"start\":89828},{\"end\":89844,\"start\":89837},{\"end\":89858,\"start\":89852},{\"end\":89867,\"start\":89862},{\"end\":90316,\"start\":90313},{\"end\":90328,\"start\":90320},{\"end\":90341,\"start\":90332},{\"end\":90354,\"start\":90347},{\"end\":90361,\"start\":90358},{\"end\":90375,\"start\":90365},{\"end\":90383,\"start\":90379},{\"end\":90396,\"start\":90389},{\"end\":90407,\"start\":90402},{\"end\":90421,\"start\":90415},{\"end\":91047,\"start\":91045},{\"end\":91056,\"start\":91051},{\"end\":91063,\"start\":91060},{\"end\":91605,\"start\":91600},{\"end\":91616,\"start\":91609},{\"end\":91999,\"start\":91997},{\"end\":92006,\"start\":92003},{\"end\":92013,\"start\":92010},{\"end\":92021,\"start\":92017},{\"end\":92028,\"start\":92025},{\"end\":92405,\"start\":92403},{\"end\":92412,\"start\":92409},{\"end\":92422,\"start\":92416},{\"end\":92434,\"start\":92426},{\"end\":92447,\"start\":92438},{\"end\":92461,\"start\":92453},{\"end\":92973,\"start\":92968},{\"end\":92980,\"start\":92977},{\"end\":92988,\"start\":92984}]", "bib_entry": "[{\"attributes\":{\"id\":\"b0\",\"matched_paper_id\":14320211},\"end\":64853,\"start\":64421},{\"attributes\":{\"id\":\"b1\"},\"end\":65179,\"start\":64855},{\"attributes\":{\"id\":\"b2\",\"matched_paper_id\":2237812},\"end\":65652,\"start\":65181},{\"attributes\":{\"id\":\"b3\",\"matched_paper_id\":182778753},\"end\":66008,\"start\":65654},{\"attributes\":{\"id\":\"b4\"},\"end\":66323,\"start\":66010},{\"attributes\":{\"id\":\"b5\",\"matched_paper_id\":13132108},\"end\":66797,\"start\":66325},{\"attributes\":{\"id\":\"b6\",\"matched_paper_id\":219781592},\"end\":67400,\"start\":66799},{\"attributes\":{\"id\":\"b7\"},\"end\":67651,\"start\":67402},{\"attributes\":{\"id\":\"b8\",\"matched_paper_id\":14864964},\"end\":67918,\"start\":67653},{\"attributes\":{\"id\":\"b9\",\"matched_paper_id\":207182734},\"end\":68419,\"start\":67920},{\"attributes\":{\"id\":\"b10\",\"matched_paper_id\":2211881},\"end\":68831,\"start\":68421},{\"attributes\":{\"id\":\"b11\",\"matched_paper_id\":67856750},\"end\":69372,\"start\":68833},{\"attributes\":{\"id\":\"b12\",\"matched_paper_id\":15356402},\"end\":70082,\"start\":69374},{\"attributes\":{\"id\":\"b13\"},\"end\":70647,\"start\":70084},{\"attributes\":{\"id\":\"b14\",\"matched_paper_id\":207221476},\"end\":71281,\"start\":70649},{\"attributes\":{\"id\":\"b15\",\"matched_paper_id\":15649474},\"end\":71648,\"start\":71283},{\"attributes\":{\"id\":\"b16\",\"matched_paper_id\":4918751},\"end\":72080,\"start\":71650},{\"attributes\":{\"doi\":\"arXiv:1804.04812\",\"id\":\"b17\"},\"end\":72306,\"start\":72082},{\"attributes\":{\"id\":\"b18\",\"matched_paper_id\":4960605},\"end\":72721,\"start\":72308},{\"attributes\":{\"id\":\"b19\",\"matched_paper_id\":15428939},\"end\":73056,\"start\":72723},{\"attributes\":{\"id\":\"b20\"},\"end\":73258,\"start\":73058},{\"attributes\":{\"id\":\"b21\"},\"end\":73413,\"start\":73260},{\"attributes\":{\"id\":\"b22\",\"matched_paper_id\":15510288},\"end\":73839,\"start\":73415},{\"attributes\":{\"id\":\"b23\",\"matched_paper_id\":978061},\"end\":74325,\"start\":73841},{\"attributes\":{\"id\":\"b24\",\"matched_paper_id\":13279722},\"end\":74725,\"start\":74327},{\"attributes\":{\"id\":\"b25\",\"matched_paper_id\":3156406},\"end\":75313,\"start\":74727},{\"attributes\":{\"id\":\"b26\",\"matched_paper_id\":222331525},\"end\":75692,\"start\":75315},{\"attributes\":{\"id\":\"b27\",\"matched_paper_id\":14508569},\"end\":76262,\"start\":75694},{\"attributes\":{\"id\":\"b28\",\"matched_paper_id\":373888},\"end\":76736,\"start\":76264},{\"attributes\":{\"id\":\"b29\",\"matched_paper_id\":174798341},\"end\":77231,\"start\":76738},{\"attributes\":{\"id\":\"b30\",\"matched_paper_id\":14648609},\"end\":77838,\"start\":77233},{\"attributes\":{\"id\":\"b31\",\"matched_paper_id\":978769},\"end\":78270,\"start\":77840},{\"attributes\":{\"id\":\"b32\"},\"end\":78401,\"start\":78272},{\"attributes\":{\"doi\":\"MSR-TR-2019-18\",\"id\":\"b33\"},\"end\":78738,\"start\":78403},{\"attributes\":{\"id\":\"b34\"},\"end\":78877,\"start\":78740},{\"attributes\":{\"id\":\"b35\",\"matched_paper_id\":28968350},\"end\":79327,\"start\":78879},{\"attributes\":{\"id\":\"b36\"},\"end\":79782,\"start\":79329},{\"attributes\":{\"id\":\"b37\"},\"end\":79961,\"start\":79784},{\"attributes\":{\"id\":\"b38\",\"matched_paper_id\":2215568},\"end\":80410,\"start\":79963},{\"attributes\":{\"id\":\"b39\",\"matched_paper_id\":12959177},\"end\":80857,\"start\":80412},{\"attributes\":{\"id\":\"b40\",\"matched_paper_id\":248719},\"end\":81382,\"start\":80859},{\"attributes\":{\"id\":\"b41\",\"matched_paper_id\":914358},\"end\":81814,\"start\":81384},{\"attributes\":{\"id\":\"b42\",\"matched_paper_id\":49233609},\"end\":82270,\"start\":81816},{\"attributes\":{\"doi\":\"arXiv:1805.08506\",\"id\":\"b43\"},\"end\":82629,\"start\":82272},{\"attributes\":{\"id\":\"b44\"},\"end\":82861,\"start\":82631},{\"attributes\":{\"id\":\"b45\",\"matched_paper_id\":201622960},\"end\":83315,\"start\":82863},{\"attributes\":{\"id\":\"b46\",\"matched_paper_id\":762879},\"end\":83796,\"start\":83317},{\"attributes\":{\"id\":\"b47\",\"matched_paper_id\":233473667},\"end\":84282,\"start\":83798},{\"attributes\":{\"id\":\"b48\",\"matched_paper_id\":13946207},\"end\":84697,\"start\":84284},{\"attributes\":{\"id\":\"b49\",\"matched_paper_id\":174799235},\"end\":85228,\"start\":84699},{\"attributes\":{\"id\":\"b50\"},\"end\":85348,\"start\":85230},{\"attributes\":{\"id\":\"b51\",\"matched_paper_id\":11024896},\"end\":85705,\"start\":85350},{\"attributes\":{\"doi\":\"arXiv:1802.09517v1\",\"id\":\"b52\"},\"end\":86043,\"start\":85707},{\"attributes\":{\"id\":\"b53\",\"matched_paper_id\":11639591},\"end\":86517,\"start\":86045},{\"attributes\":{\"id\":\"b54\",\"matched_paper_id\":218537479},\"end\":87020,\"start\":86519},{\"attributes\":{\"id\":\"b55\",\"matched_paper_id\":19177604},\"end\":87396,\"start\":87022},{\"attributes\":{\"id\":\"b56\"},\"end\":87510,\"start\":87398},{\"attributes\":{\"id\":\"b57\",\"matched_paper_id\":235415554},\"end\":88018,\"start\":87512},{\"attributes\":{\"id\":\"b58\"},\"end\":88260,\"start\":88020},{\"attributes\":{\"id\":\"b59\",\"matched_paper_id\":44087271},\"end\":88919,\"start\":88262},{\"attributes\":{\"id\":\"b60\",\"matched_paper_id\":7346980},\"end\":89665,\"start\":88921},{\"attributes\":{\"id\":\"b61\",\"matched_paper_id\":155740276},\"end\":90211,\"start\":89667},{\"attributes\":{\"id\":\"b62\",\"matched_paper_id\":202726723},\"end\":90923,\"start\":90213},{\"attributes\":{\"id\":\"b63\",\"matched_paper_id\":231183994},\"end\":91522,\"start\":90925},{\"attributes\":{\"id\":\"b64\",\"matched_paper_id\":5171267},\"end\":91926,\"start\":91524},{\"attributes\":{\"id\":\"b65\",\"matched_paper_id\":52984353},\"end\":92305,\"start\":91928},{\"attributes\":{\"id\":\"b66\",\"matched_paper_id\":204732730},\"end\":92889,\"start\":92307},{\"attributes\":{\"id\":\"b67\",\"matched_paper_id\":102347768},\"end\":93446,\"start\":92891}]", "bib_title": "[{\"end\":64518,\"start\":64421},{\"end\":65239,\"start\":65181},{\"end\":65719,\"start\":65654},{\"end\":66384,\"start\":66325},{\"end\":66858,\"start\":66799},{\"end\":67706,\"start\":67653},{\"end\":67963,\"start\":67920},{\"end\":68466,\"start\":68421},{\"end\":68895,\"start\":68833},{\"end\":69451,\"start\":69374},{\"end\":70166,\"start\":70084},{\"end\":70711,\"start\":70649},{\"end\":71327,\"start\":71283},{\"end\":71725,\"start\":71650},{\"end\":72353,\"start\":72308},{\"end\":72781,\"start\":72723},{\"end\":73454,\"start\":73415},{\"end\":73917,\"start\":73841},{\"end\":74377,\"start\":74327},{\"end\":74778,\"start\":74727},{\"end\":75358,\"start\":75315},{\"end\":75790,\"start\":75694},{\"end\":76313,\"start\":76264},{\"end\":76804,\"start\":76738},{\"end\":77372,\"start\":77233},{\"end\":77914,\"start\":77840},{\"end\":78764,\"start\":78740},{\"end\":78965,\"start\":78879},{\"end\":80049,\"start\":79963},{\"end\":80478,\"start\":80412},{\"end\":80928,\"start\":80859},{\"end\":81429,\"start\":81384},{\"end\":81889,\"start\":81816},{\"end\":82946,\"start\":82863},{\"end\":83419,\"start\":83317},{\"end\":83860,\"start\":83798},{\"end\":84347,\"start\":84284},{\"end\":84758,\"start\":84699},{\"end\":85398,\"start\":85350},{\"end\":86140,\"start\":86045},{\"end\":86608,\"start\":86519},{\"end\":87055,\"start\":87022},{\"end\":87583,\"start\":87512},{\"end\":88354,\"start\":88262},{\"end\":89010,\"start\":88921},{\"end\":89719,\"start\":89667},{\"end\":90309,\"start\":90213},{\"end\":91041,\"start\":90925},{\"end\":91596,\"start\":91524},{\"end\":91993,\"start\":91928},{\"end\":92399,\"start\":92307},{\"end\":92964,\"start\":92891}]", "bib_author": "[{\"end\":64533,\"start\":64520},{\"end\":64542,\"start\":64533},{\"end\":64552,\"start\":64542},{\"end\":64560,\"start\":64552},{\"end\":65253,\"start\":65241},{\"end\":65265,\"start\":65253},{\"end\":65275,\"start\":65265},{\"end\":65731,\"start\":65721},{\"end\":65740,\"start\":65731},{\"end\":65748,\"start\":65740},{\"end\":65757,\"start\":65748},{\"end\":65771,\"start\":65757},{\"end\":66057,\"start\":66047},{\"end\":66068,\"start\":66057},{\"end\":66078,\"start\":66068},{\"end\":66086,\"start\":66078},{\"end\":66397,\"start\":66386},{\"end\":66406,\"start\":66397},{\"end\":66417,\"start\":66406},{\"end\":66426,\"start\":66417},{\"end\":66869,\"start\":66860},{\"end\":66877,\"start\":66869},{\"end\":67479,\"start\":67468},{\"end\":67720,\"start\":67708},{\"end\":67733,\"start\":67720},{\"end\":67744,\"start\":67733},{\"end\":67978,\"start\":67965},{\"end\":67986,\"start\":67978},{\"end\":68000,\"start\":67986},{\"end\":68014,\"start\":68000},{\"end\":68025,\"start\":68014},{\"end\":68036,\"start\":68025},{\"end\":68476,\"start\":68468},{\"end\":68482,\"start\":68476},{\"end\":68493,\"start\":68482},{\"end\":68504,\"start\":68493},{\"end\":68514,\"start\":68504},{\"end\":68906,\"start\":68897},{\"end\":68921,\"start\":68906},{\"end\":68932,\"start\":68921},{\"end\":68941,\"start\":68932},{\"end\":68951,\"start\":68941},{\"end\":68961,\"start\":68951},{\"end\":68968,\"start\":68961},{\"end\":69465,\"start\":69453},{\"end\":69477,\"start\":69465},{\"end\":69489,\"start\":69477},{\"end\":69501,\"start\":69489},{\"end\":69511,\"start\":69501},{\"end\":69522,\"start\":69511},{\"end\":69529,\"start\":69522},{\"end\":69538,\"start\":69529},{\"end\":69551,\"start\":69538},{\"end\":70180,\"start\":70168},{\"end\":70192,\"start\":70180},{\"end\":70206,\"start\":70192},{\"end\":70219,\"start\":70206},{\"end\":70723,\"start\":70713},{\"end\":70733,\"start\":70723},{\"end\":70742,\"start\":70733},{\"end\":70755,\"start\":70742},{\"end\":70769,\"start\":70755},{\"end\":70780,\"start\":70769},{\"end\":70792,\"start\":70780},{\"end\":70800,\"start\":70792},{\"end\":70810,\"start\":70800},{\"end\":70817,\"start\":70810},{\"end\":71339,\"start\":71329},{\"end\":71350,\"start\":71339},{\"end\":71737,\"start\":71727},{\"end\":71748,\"start\":71737},{\"end\":72144,\"start\":72134},{\"end\":72155,\"start\":72144},{\"end\":72365,\"start\":72355},{\"end\":72376,\"start\":72365},{\"end\":72389,\"start\":72376},{\"end\":72792,\"start\":72783},{\"end\":73103,\"start\":73091},{\"end\":73113,\"start\":73103},{\"end\":73297,\"start\":73278},{\"end\":73469,\"start\":73456},{\"end\":73480,\"start\":73469},{\"end\":73489,\"start\":73480},{\"end\":73497,\"start\":73489},{\"end\":73503,\"start\":73497},{\"end\":73513,\"start\":73503},{\"end\":73925,\"start\":73919},{\"end\":73935,\"start\":73925},{\"end\":73945,\"start\":73935},{\"end\":73955,\"start\":73945},{\"end\":73965,\"start\":73955},{\"end\":73974,\"start\":73965},{\"end\":74388,\"start\":74379},{\"end\":74403,\"start\":74388},{\"end\":74418,\"start\":74403},{\"end\":74793,\"start\":74780},{\"end\":74802,\"start\":74793},{\"end\":74813,\"start\":74802},{\"end\":74830,\"start\":74813},{\"end\":74843,\"start\":74830},{\"end\":75367,\"start\":75360},{\"end\":75374,\"start\":75367},{\"end\":75381,\"start\":75374},{\"end\":75799,\"start\":75792},{\"end\":75807,\"start\":75799},{\"end\":75814,\"start\":75807},{\"end\":75824,\"start\":75814},{\"end\":75833,\"start\":75824},{\"end\":75840,\"start\":75833},{\"end\":75853,\"start\":75840},{\"end\":75860,\"start\":75853},{\"end\":75869,\"start\":75860},{\"end\":76325,\"start\":76315},{\"end\":76335,\"start\":76325},{\"end\":76344,\"start\":76335},{\"end\":76352,\"start\":76344},{\"end\":76363,\"start\":76352},{\"end\":76371,\"start\":76363},{\"end\":76382,\"start\":76371},{\"end\":76394,\"start\":76382},{\"end\":76405,\"start\":76394},{\"end\":76414,\"start\":76405},{\"end\":76819,\"start\":76806},{\"end\":76834,\"start\":76819},{\"end\":76849,\"start\":76834},{\"end\":76857,\"start\":76849},{\"end\":76875,\"start\":76857},{\"end\":77382,\"start\":77374},{\"end\":77392,\"start\":77382},{\"end\":77403,\"start\":77392},{\"end\":77415,\"start\":77403},{\"end\":77421,\"start\":77415},{\"end\":77428,\"start\":77421},{\"end\":77927,\"start\":77916},{\"end\":77935,\"start\":77927},{\"end\":78299,\"start\":78292},{\"end\":78453,\"start\":78443},{\"end\":78461,\"start\":78453},{\"end\":78473,\"start\":78461},{\"end\":78978,\"start\":78967},{\"end\":78985,\"start\":78978},{\"end\":78998,\"start\":78985},{\"end\":79432,\"start\":79422},{\"end\":79838,\"start\":79821},{\"end\":80066,\"start\":80051},{\"end\":80080,\"start\":80066},{\"end\":80093,\"start\":80080},{\"end\":80495,\"start\":80480},{\"end\":80509,\"start\":80495},{\"end\":80522,\"start\":80509},{\"end\":80945,\"start\":80930},{\"end\":80953,\"start\":80945},{\"end\":80965,\"start\":80953},{\"end\":80978,\"start\":80965},{\"end\":81446,\"start\":81431},{\"end\":81454,\"start\":81446},{\"end\":81466,\"start\":81454},{\"end\":81479,\"start\":81466},{\"end\":81904,\"start\":81891},{\"end\":81917,\"start\":81904},{\"end\":81929,\"start\":81917},{\"end\":81939,\"start\":81929},{\"end\":81949,\"start\":81939},{\"end\":82367,\"start\":82354},{\"end\":82376,\"start\":82367},{\"end\":82386,\"start\":82376},{\"end\":82401,\"start\":82386},{\"end\":82411,\"start\":82401},{\"end\":82702,\"start\":82694},{\"end\":82957,\"start\":82948},{\"end\":82966,\"start\":82957},{\"end\":82974,\"start\":82966},{\"end\":83428,\"start\":83421},{\"end\":83434,\"start\":83428},{\"end\":83442,\"start\":83434},{\"end\":83869,\"start\":83862},{\"end\":83878,\"start\":83869},{\"end\":83887,\"start\":83878},{\"end\":83897,\"start\":83887},{\"end\":83910,\"start\":83897},{\"end\":83920,\"start\":83910},{\"end\":84356,\"start\":84349},{\"end\":84363,\"start\":84356},{\"end\":84770,\"start\":84760},{\"end\":84782,\"start\":84770},{\"end\":84794,\"start\":84782},{\"end\":84802,\"start\":84794},{\"end\":84811,\"start\":84802},{\"end\":84828,\"start\":84811},{\"end\":85244,\"start\":85230},{\"end\":85255,\"start\":85244},{\"end\":85414,\"start\":85400},{\"end\":85426,\"start\":85414},{\"end\":85439,\"start\":85426},{\"end\":85449,\"start\":85439},{\"end\":85777,\"start\":85763},{\"end\":85789,\"start\":85777},{\"end\":85804,\"start\":85789},{\"end\":85819,\"start\":85804},{\"end\":85829,\"start\":85819},{\"end\":86153,\"start\":86142},{\"end\":86621,\"start\":86610},{\"end\":86631,\"start\":86621},{\"end\":87066,\"start\":87057},{\"end\":87083,\"start\":87066},{\"end\":87419,\"start\":87406},{\"end\":87603,\"start\":87585},{\"end\":87615,\"start\":87603},{\"end\":87628,\"start\":87615},{\"end\":87645,\"start\":87628},{\"end\":88095,\"start\":88080},{\"end\":88370,\"start\":88356},{\"end\":88378,\"start\":88370},{\"end\":88390,\"start\":88378},{\"end\":88399,\"start\":88390},{\"end\":88413,\"start\":88399},{\"end\":88425,\"start\":88413},{\"end\":88438,\"start\":88425},{\"end\":88451,\"start\":88438},{\"end\":88460,\"start\":88451},{\"end\":89026,\"start\":89012},{\"end\":89038,\"start\":89026},{\"end\":89051,\"start\":89038},{\"end\":89062,\"start\":89051},{\"end\":89074,\"start\":89062},{\"end\":89086,\"start\":89074},{\"end\":89096,\"start\":89086},{\"end\":89105,\"start\":89096},{\"end\":89114,\"start\":89105},{\"end\":89124,\"start\":89114},{\"end\":89137,\"start\":89124},{\"end\":89149,\"start\":89137},{\"end\":89156,\"start\":89149},{\"end\":89165,\"start\":89156},{\"end\":89175,\"start\":89165},{\"end\":89733,\"start\":89721},{\"end\":89744,\"start\":89733},{\"end\":89751,\"start\":89744},{\"end\":89758,\"start\":89751},{\"end\":89768,\"start\":89758},{\"end\":89780,\"start\":89768},{\"end\":89789,\"start\":89780},{\"end\":89798,\"start\":89789},{\"end\":89811,\"start\":89798},{\"end\":89826,\"start\":89811},{\"end\":89833,\"start\":89826},{\"end\":89846,\"start\":89833},{\"end\":89860,\"start\":89846},{\"end\":89869,\"start\":89860},{\"end\":90318,\"start\":90311},{\"end\":90330,\"start\":90318},{\"end\":90343,\"start\":90330},{\"end\":90356,\"start\":90343},{\"end\":90363,\"start\":90356},{\"end\":90377,\"start\":90363},{\"end\":90385,\"start\":90377},{\"end\":90398,\"start\":90385},{\"end\":90409,\"start\":90398},{\"end\":90423,\"start\":90409},{\"end\":91049,\"start\":91043},{\"end\":91058,\"start\":91049},{\"end\":91065,\"start\":91058},{\"end\":91607,\"start\":91598},{\"end\":91618,\"start\":91607},{\"end\":92001,\"start\":91995},{\"end\":92008,\"start\":92001},{\"end\":92015,\"start\":92008},{\"end\":92023,\"start\":92015},{\"end\":92030,\"start\":92023},{\"end\":92407,\"start\":92401},{\"end\":92414,\"start\":92407},{\"end\":92424,\"start\":92414},{\"end\":92436,\"start\":92424},{\"end\":92449,\"start\":92436},{\"end\":92463,\"start\":92449},{\"end\":92975,\"start\":92966},{\"end\":92982,\"start\":92975},{\"end\":92990,\"start\":92982}]", "bib_venue": "[{\"end\":64609,\"start\":64560},{\"end\":64925,\"start\":64855},{\"end\":65381,\"start\":65275},{\"end\":65805,\"start\":65771},{\"end\":66045,\"start\":66010},{\"end\":66490,\"start\":66426},{\"end\":67019,\"start\":66877},{\"end\":67466,\"start\":67402},{\"end\":67755,\"start\":67744},{\"end\":68123,\"start\":68036},{\"end\":68587,\"start\":68514},{\"end\":69031,\"start\":68968},{\"end\":69689,\"start\":69551},{\"end\":70353,\"start\":70219},{\"end\":70950,\"start\":70817},{\"end\":71431,\"start\":71350},{\"end\":71854,\"start\":71748},{\"end\":72132,\"start\":72082},{\"end\":72479,\"start\":72389},{\"end\":72834,\"start\":72792},{\"end\":73089,\"start\":73058},{\"end\":73276,\"start\":73260},{\"end\":73597,\"start\":73513},{\"end\":74044,\"start\":73974},{\"end\":74505,\"start\":74418},{\"end\":74976,\"start\":74843},{\"end\":75475,\"start\":75381},{\"end\":75958,\"start\":75869},{\"end\":76484,\"start\":76414},{\"end\":76940,\"start\":76875},{\"end\":77522,\"start\":77428},{\"end\":78022,\"start\":77935},{\"end\":78290,\"start\":78272},{\"end\":78441,\"start\":78403},{\"end\":78770,\"start\":78766},{\"end\":79088,\"start\":78998},{\"end\":79420,\"start\":79329},{\"end\":79819,\"start\":79784},{\"end\":80175,\"start\":80093},{\"end\":80623,\"start\":80522},{\"end\":81084,\"start\":80978},{\"end\":81557,\"start\":81479},{\"end\":82020,\"start\":81949},{\"end\":82352,\"start\":82272},{\"end\":82692,\"start\":82631},{\"end\":83058,\"start\":82974},{\"end\":83546,\"start\":83442},{\"end\":84025,\"start\":83920},{\"end\":84455,\"start\":84363},{\"end\":84922,\"start\":84828},{\"end\":85269,\"start\":85255},{\"end\":85516,\"start\":85449},{\"end\":85761,\"start\":85707},{\"end\":86240,\"start\":86153},{\"end\":86734,\"start\":86631},{\"end\":87172,\"start\":87083},{\"end\":87404,\"start\":87398},{\"end\":87750,\"start\":87645},{\"end\":88078,\"start\":88020},{\"end\":88549,\"start\":88460},{\"end\":89245,\"start\":89175},{\"end\":89899,\"start\":89869},{\"end\":90517,\"start\":90423},{\"end\":91213,\"start\":91065},{\"end\":91690,\"start\":91618},{\"end\":92083,\"start\":92030},{\"end\":92557,\"start\":92463},{\"end\":93132,\"start\":92990},{\"end\":64645,\"start\":64611},{\"end\":65399,\"start\":65383},{\"end\":66508,\"start\":66492},{\"end\":67148,\"start\":67021},{\"end\":68147,\"start\":68125},{\"end\":68607,\"start\":68589},{\"end\":69103,\"start\":69033},{\"end\":69707,\"start\":69691},{\"end\":71449,\"start\":71433},{\"end\":72499,\"start\":72481},{\"end\":72863,\"start\":72836},{\"end\":73614,\"start\":73599},{\"end\":74063,\"start\":74046},{\"end\":74510,\"start\":74507},{\"end\":75003,\"start\":74978},{\"end\":76964,\"start\":76942},{\"end\":78041,\"start\":78024},{\"end\":81101,\"start\":81086},{\"end\":81583,\"start\":81559},{\"end\":83077,\"start\":83060},{\"end\":84473,\"start\":84457},{\"end\":84941,\"start\":84924},{\"end\":86267,\"start\":86242},{\"end\":86751,\"start\":86736},{\"end\":87194,\"start\":87174},{\"end\":88571,\"start\":88551},{\"end\":89264,\"start\":89247},{\"end\":90536,\"start\":90519},{\"end\":91710,\"start\":91692},{\"end\":92576,\"start\":92559},{\"end\":93153,\"start\":93134}]"}}}, "year": 2023, "month": 12, "day": 17}