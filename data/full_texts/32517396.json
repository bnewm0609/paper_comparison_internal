{"id": 32517396, "updated": "2022-03-09 03:40:13.429", "metadata": {"title": "Comparing text\u2010based and dependence\u2010based approaches for determining the origins of bugs", "authors": "[{\"first\":\"Steven\",\"last\":\"Davies\",\"middle\":[]},{\"first\":\"Marc\",\"last\":\"Roper\",\"middle\":[]},{\"first\":\"Murray\",\"last\":\"Wood\",\"middle\":[]}]", "venue": null, "journal": "Journal of Software: Evolution and Process", "publication_date": {"year": 2014, "month": null, "day": null}, "abstract": "Identifying bug origins \u2013 the point where erroneous code was introduced \u2013 is crucial for many software engineering activities, from identifying process weaknesses to gathering data to support bug detection tools. Unfortunately, this information is not usually recorded when fixing bugs, and recovering it later is challenging. Recently, the text approach and the dependence approach have been developed to tackle this problem. Respectively, they examine textual and dependence\u2010related changes that occurred prior to a bug fix. However, only limited evaluation has been carried out, partially because of a lack of available implementations and of datasets linking bugs to origins. To address this, origins of 174 bugs in three projects were manually identified and compared to a simulation of the approaches. Both approaches were partially successful across a variety of bugs \u2013 achieving 29\u201379% precision and 40\u201370% recall. Results suggested the precise definition of program dependence could affect performance, as could whether the approaches identified a single or multiple origins. Some potential improvements are explored in detail and identify pragmatic strategies for combining techniques along with simple modifications. Even after adopting these improvements, there remain many challenges: large commits, unrelated changes and long periods between origins and fixes all reduce effectiveness. Copyright \u00a9 2013 John Wiley & Sons, Ltd.", "fields_of_study": "[\"Computer Science\"]", "external_ids": {"arxiv": null, "mag": "2118949539", "acl": null, "pubmed": null, "pubmedcentral": null, "dblp": "journals/smr/DaviesRW14", "doi": "10.1002/smr.1619"}}, "content": {"source": {"pdf_hash": "c38ab960ffea1685abefa3243367dd4337374629", "pdf_src": "Wiley", "pdf_uri": null, "oa_url_match": false, "oa_info": {"license": null, "open_access_url": "https://strathprints.strath.ac.uk/45285/1/Davies_etal_JOSEAP2015_determining_the_origins_of_bugs.pdf", "status": "GREEN"}}, "grobid": {"id": "0e8101bef0dd1d9739959ca82d7c791b524195db", "type": "plain-text", "url": "s3://ai2-s2-pdf-extraction-prod/parse-results/s2orc_worker/c38ab960ffea1685abefa3243367dd4337374629.txt", "contents": "\nComparing text-based and dependence-based approaches for determining the origins of bugs\n\n\nSteven Davies \nComputer and Information Sciences\nUniversity of Strathclyde\nGlasgowUK\n\nMarc Roper \nComputer and Information Sciences\nUniversity of Strathclyde\nGlasgowUK\n\nMurray Wood \nComputer and Information Sciences\nUniversity of Strathclyde\nGlasgowUK\n\nComparing text-based and dependence-based approaches for determining the origins of bugs\nReceived 14 March 2012; Revised 22 February 2013; Accepted 23 July 2013software maintenancebug originsmining software repositoriesprogram dependence graphversion controlbug tracking systems\nIdentifying bug originsthe point where erroneous code was introducedis crucial for many software engineering activities, from identifying process weaknesses to gathering data to support bug detection tools. Unfortunately, this information is not usually recorded when fixing bugs, and recovering it later is challenging. Recently, the text approach and the dependence approach have been developed to tackle this problem. Respectively, they examine textual and dependence-related changes that occurred prior to a bug fix. However, only limited evaluation has been carried out, partially because of a lack of available implementations and of datasets linking bugs to origins. To address this, origins of 174 bugs in three projects were manually identified and compared to a simulation of the approaches. Both approaches were partially successful across a variety of bugsachieving 29-79% precision and 40-70% recall. Results suggested the precise definition of program dependence could affect performance, as could whether the approaches identified a single or multiple origins. Some potential improvements are explored in detail and identify pragmatic strategies for combining techniques along with simple modifications. Even after adopting these improvements, there remain many challenges: large commits, unrelated changes and long periods between origins and fixes all reduce effectiveness.The systems under examination are Eclipse [31], an IDE and development platform, and Rachota [32], a time tracking application. These were selected as they vary considerably in size, maturity and usage, COMPARING APPROACHES FOR DETERMINING BUG ORIGINS Figure 13. Program dependence graph for VFSDirectoryEntryTable.processKeyEvent() which corresponds to the code in Figure 8 (many unchanged nodes and dependences have been omitted). Eclipse Bug 63753 -'Team\u2192Tag as Version w/ 'Move tag if it already exists' option does not work' Again, this bug had a fairly straightforward fix, for which the text approach could correctly identify the origin. A single line if (confirmDialog.getReturnCode() == IDialogConstants.OK_ID) { was changed to if (confirmDialog.getReturnCode() == IDialogConstants.YES_ID) { Like previous bugs, if these two lines are interpreted as not mapping to one another between dependence 124\n\nINTRODUCTION\n\nGiven the suggestion that software developers can spend nearly half their time fixing bugs [1] and the well-documented impact of bugs on software development cost and effort, it is not surprising that many techniques and tools have been developed which attempt to prevent bugs from being introduced in the first place. Often, this is carried out by inferring common patterns from code which contains bugs and then finding similar code. However, accurately identifying bug originsthe point in the codebase that a bug was introducedis particularly challenging because of factors such as the length of time between introducing and reporting a bug, and the potentially substantial changes that may have been made to the code in the meantime. Being able to automatically identify which changes actually introduced a bug could be useful in improving the accuracy of any of these bug prevention tools or enabling the introduction of more advanced techniques altogether. Software developers and managers would also stand to benefit from identifying when bugs were introduced and use such data to pinpoint potential weaknesses in their processes. Furthermore, identifying such changes also opens possibilities for researchers to more closely examine the nature of changes that can introduce bugs. Recently, two approaches that attempt to identify the origin of a bug based on the changes made to fix it have been proposed. Both start from the version of code containing the bug fix and progressively examine preceding versions until they find the one that introduced the code responsible for the bug. They differ primarily in how they examine the changes between versions and in the number of files returned: the text approach [2] uses only the change in the text itself and returns all files deemed to be relevant, while the dependence approach [3] uses changes in the relationships between control and data in the code and returns only the first relevant file. Unfortunately, as yet no implementations of either approach are readily available, which presents a significant challenge to assessing their effectiveness or even their viability. Furthermore, the effort required to create an implementation in both cases is non-trivial, and the dependence approach in particular poses a number of implementation challenges, as discussed in Section 2.4.\n\nAs a necessary precursor prior to embarking on an expensive implementation exercise, this paper presents the results of an investigation into the accuracy of both approaches and provides insights into their respective strengths and weaknesses. Three open-source systems were chosen, the origins of a number of bugs associated with each system were identified and the application of both the text approach and the dependence approach was then manually simulated. Comparing the results of this manual simulation with the true bug origins revealed a large variation in both the precision and recall of the approaches and also identified some key issues relating to factors such as unrelated changes, the number of versions between the bug introducing change and the fix, multiple files and the potential variability introduced by dependence graph implementations. In addition to these challenges, a range of possible improvements to both techniques are identified, and a number of these are explored in detail on a small subset of bugs. The results of this analysis show that with some simple modifications, it is possible to increase the effectiveness of both approaches substantially at a relatively small cost and also to combine the approaches in various ways that trade off effectiveness and efficiency. However, many of the key issues identified previously still remain.\n\n\nBACKGROUND AND RELATED WORK\n\n\nIdentifying bug origins\n\nTwo components of modern development are crucial to help identify the origin of a bug: software configuration management (SCM) and bug tracking systems (BTSs).\n\nThe SCM allows multiple developers to work on a project by coordinating their changes. Developers check out a copy of the code from a central repository, make changes on their own machine and then commit their changes back to the repository. When committing, developers usually include a comment describing the changes they have made. Each commit results in a new version of the code being stored in the SCM repository.\n\nThe BTSs store information about problems with the code, called issues. Usually, the information recorded for each issue includes the following: an ID; a description; how to reproduce the issue; and the current status, for example, fixed, invalid and in progress. Additionally, the BTS often records the type of issue. Many classifications exist, but two of the most common are enhancements, which are requests for new functionality, and bugs, which are areas where the software does not do what it is supposed to.\n\nWhile these systems are not usually integrated, techniques exist to combine their information [2]. When fixing bugs, developers often include the bug ID in their commit comment [2,4]. Bugs can therefore be linked to the commits that fix them by extracting the comments from the SCM repository and searching for bug IDs. While other techniques for this task have been proposed [5], they have not been applied in this work.\n\nUnfortunately, for this work, the relationship between bugs and commits is not a simple one:\n\n\u2022 Bug fixes may be relatively simple and may involve just a line or two in the system, and the corresponding commit may involve just one file. \u2022 Alternatively, bug fixes may involve a wider set of far more substantial changes. Consequently, a commit may be made up of one or more changes to one or more files.\n\n\u2022 A commit may also involve changes that are unrelated to the bug in question: they may be associated with a different bug, or with no bug at all (taking the form of opportunistic refactorings or enhancements for example). \u2022 A bug report may contain details about more than one bug. \u2022 Developers may make more than one attempt to fix a bug, in which case, there will be multiple commits associated with one bug report. \u2022 A commit may fix a bug, but make no mention of the bug ID at all.\n\nGiven this complex relationship, the assumption for this workthat commits and bugs can be automatically linked via IDsmay be regarded as a rather bold one, but it is also one that provides the greatest opportunity for automatically processing large numbers of bugs and their associated fixes. Many other researchers, dating back to Fischer et al. [6], have used this assumption as the basis of their work, although there is some evidence that these links are not entirely accurate [4]. Figure 1 shows four versions of the file NewProgressViewer.java. In version 1.39, the developers fixed a bug where, in certain scenarios, negative values were passed to the Color constructor causing an IllegalArgumentException. To remove the error, three of the lines were updated to wrap parameters with calls to Math.max(0, \u2026) and so avoid the negative numbers. Using the text approach first proposed by \u015aliwerski et al. [2], to determine when this bug was introduced, the cvs diff command is run on version 1.39. This command identifies all the lines that were added, removed or changed in that commit. The cvs annotate command is then run on the previous version, 1.38. This command displays the last version to change each line of code. For each line altered in the fix, the version it was previously altered in is considered a possible origin of the bug. In this example, each of the updated lines was last changed in version 1.8. Comparing version 1.8 to version 1.7 shows that this was indeed when the bug was introduced, as previously, these values were set to specific numbers.\n\n\nText approach\n\nVarious proposed improvements to the original approach are detailed in Section 2.5. Most pertinent to this study is that changes in formatting, whitespace and comments can be ignored, as they are unlikely to have been involved in causing or fixing a bug [7].\n\nUnfortunately, the text approach is not suitable for all bugs. Figure 2 shows a bug involving a NullPointerException in the file DecorationBuilder.java. The bug was fixed by surrounding existing code with an if-statement that checks whether the variable is null. As these added lines did not exist in the previous version of code, cvs annotate cannot be used and the text approach cannot therefore identify any origin for this type of bug. A potentially more serious flaw is that there is no guarantee that a bug was actually introduced at the same location as it was fixed. \n\n\nDependence approach\n\nThe dependence approach [3] attempts to address some of the text approach's shortcomings by examining changes in the behaviour of the code rather than simply the text, using a program dependence graph (PDG). The idea of using a PDG within software engineering was first proposed by Ottenstein and Ottenstein [8]. In this simplest definition of a dependence graph, each statement is represented by a node, and an additional unique entry node is added to identify the entry point of the program. Directed edges connect the nodes to identify the control dependences and the data dependences. A control dependence from node X to node Y (shown as X\u2192Y) exists if the execution of Y is conditional on the outcome of the execution of the predicate at X. A data dependence from node X to node Y (shown as X\u290dY) exists if Y references a variable which is defined in X. An example of a simple method dependence graph for version 1.7 of the code in Figure 2 is shown in Figure 3. There are two points worth mentioning in relation to this illustration: firstly, an additional node (labelled 0) has been introduced to represent the result parameter; and secondly, the method contains references to an instance variable desc, but as this is external to the method, there are no data dependences associated with it.\n\nTo determine the origin of the bug in Figure 2, the dependence approach compares the PDG for the fixed version to the PDG for the previous version. The approach first identifies any removed dependences. Added dependences are only examined if no dependences were removed. As shown in Figure 4, the control dependence of line 3 on method entry has been removed, and the line now has a control dependence on the new if-statement. The approach therefore builds the PDG for each preceding version until it finds when the removed control dependence was added. In this case, the dependence, as well as the bug, was introduced in version 1.5 when the method was created. If there are multiple dependences removed in the fix, the dependence approach returns the most recent version in which one of these dependences was introduced.   4 also shows that a new line 2 has been introduced, with two new corresponding control dependences and a new data dependence from line 1 to line 2. As discussed, the approach prioritises removed dependences, but if no dependences had been removed, the approach would have built PDGs for preceding versions until it found the most recent one that altered either the source or target line of any of the new dependences.\n\nThe dependence approach returns only a single version, the most recent version involved. The original rationale for this was that if multiple dependences were involved in a fix, each of which was added at a separate time, then the bug would not have actually exhibited itself until the last of these was added. This is in contrast to the text approach, where multiple versions can be returned, potentially a different one for each line in the fix. The rationale for this is that each line contributed to the bug initially. Both of these could be considered valid interpretations of the origin of the bug, but it should be noted that these assumptions are not actually inherent to the approaches in question. Either approach could be modified to return a single or multiple versions.\n\nThis work uses the decision of Sinha et al. [3], taking the last change involved to have been the one that introduced the bug. Note, however, that one bug report does not necessarily equate to one bug, and so for a single bug report, there can still be multiple versions in which a bug was introduced.\n\nThe dependence approach is not appropriate for all bugs. Using the approach described here, the bug fix in Figure 1 would not result in any change to the method's dependences. The approach could not therefore identify the origin of the bug.\n\n\nDependence graphs\n\nSince the introduction of the PDG, there have been numerous additions and refinements made. One of the first notable modifications was made by Horwitz et al. [9] who extended the representation to handle programs with multiple procedures (the original PDG was only designed to handle monolithic programs). Termed the system dependence graph (SDG) and created with the goal of inter-procedural slicing in mind, its aim was to capture both the direct and the transitive dependences that can occur as a consequence of procedure calls. This was achieved by the inclusion of additional graph elements to identify the callsites (the points in the program from which the procedure may be called) and the mapping between the formal, and the actual input and output parameters, which results in the creation of four nodes for every parameter (actual in , formal in , actual out and formal out ). These parameters may be further linked via summary edges, which define dependences between parameters such as when an actual in node may influence the value of an actual out node. The result is a collection of PDGs representing each procedure, linked via these additional control and data dependences from callsites to procedures.\n\nThe advent of popular object-oriented languages introduced further features that need to be captured by the SDG, most notably inheritance, dynamic binding and polymorphism, which create further possible transitive dependences. For instance, a reference in a program may be to an interface or to a class in an inheritance hierarchy, which means that any message sent via this reference at run time may be received by one of many possible objects. This binding is not known at the time the graph is created, so to capture the transitive dependences, the SDG needs to be extended to include every possible receiving type. Early representations of graphs for C++ were created by Larsen and Harrold [10] (and updated by Liang and Harrold [11]) and adapted by Kov\u00e1cs et al. [12] and Zhao [13] to capture Java-specific features. Walkinshaw et al. [14] describe these developments and the key components of the SDG for Java in more detail.\n\nAlthough the SDG for even a modest sized Java program is a complex structure, it is still capturing just control and data information, and its key components may be summarised as follows:\n\n\u2022 The atomic construct is the statement which is either a simple expression or a callsite if method invocations are involved. \u2022 Statements are collected together into methods, each of which is represented by its own graph and also includes formal and actual parameter information, and return value information, in a similar vein to procedures in the traditional SDG. \u2022 Methods are linked to classes, which may also include data members. Any dependences between these data members and statements within methods (either in the containing class or elsewhere) are identified. \u2022 Classes may exist within inheritance hierarchies, and any data dependences between these need to be identified. \u2022 Interfaces are modelled as separate graphs to identify the parameter and return type dependences between the interface and any potential implementation. \u2022 Callsites identify all receiver types (although in practice this may not be feasible because of the possibly very large number of potential receivers). \u2022 The treatment of type information is deserving of a special mention as it is often overlooked in the definitions of both the PDG and SDG. User-defined types (references to classes elsewhere in the system) will be captured via data dependences, but simple types and references to library classes will only appear as labels within the nodes which represent the variable declarations. The strategy taken by Apiwattanapong et al. [15] (upon whose work the graph differencing employed by Sinha et al. [3] is closely based) is to augment the name of scalar variables with type information (so a variable x of type int is identified as x_int). Userdefined types and library classes are referred to by their globally qualified name (such as java.lang.String). This ensures that any changes to the type of identifiers will be reflected in a change to the node label.\n\nFor the purposes of this paper, the focus of the analysis is on the method level which restricts the control and data dependences considered to just those within the method. This includes the formal parameters (but for input purposes onlyany data dependences exported via a parameter are not modelled) but excludes any calls to other methods or references to variables outside the method, such as class member data. The original paper [3] was evaluated using a similar implementation, although it did describe the implementation of a full approach using SDGs.\n\nAlthough tools to build the SDG of a Java system are not widely available, constructing them by combining the abstract syntax tree representation of a system available via the Eclipse Java development tools [16] along with a framework for performing dataflow analysis such as Wala [17] or Crystal [18] is now a realistic proposition (see for example the work of Luo et al. [19]). However, in this work, it was decided to proceed with a manual analysis. Even though constructing a tool to perform the dependence analysis was a feasible option, it would still probably have taken more time than to perform the analysis by hand. It must be stressed that the aim of this work is to gain insights into the approaches and, in particular, any problems associated with them, and without such insights, it is not possible to build an accurate analyser. Should the approaches prove both valuable and free from fundamental problems then investment in the construction of an analyser would be worthwhile.\n\n\nAdditional related work\n\nSeveral improvements have been suggested to the approaches. Williams and Spacco [20] built on the text approach using a Java-syntax aware differencing tool, DiffJ [21]. This tool reports changes in terms of operations to Java elements, such as renaming or reordering. As well as allowing changes that have no semantic effect to be ignored, this also means that some changes, such as parameter reordering, can be disregarded as being unlikely to fix a bug. They also developed the concept of line mapping [7] further. Jung et al. [22] detailed common patterns that can identify individual changes within a fixing commit which were not involved in the fix and proposed a tool for automatically detecting such patterns. These patterns included simple syntactically detectable patterns such as the addition or removal of unnecessary brackets and semicolons, or the renaming of methods. However, they also included those requiring further semantic analysis such as the replacement of constant values with variables of the same value or the addition and removal of temporary variables. The approaches also bear some resemblance to the concept of delta debugging [23], where failing test cases from a later version of code are used repeatedly on earlier versions in order to identify the last version where the test passed. This was extended further with iterative delta debugging [24], in which fixes for other bugs are backported to older versions to lessen the chances of the test cases failing for unrelated reasons.\n\nMany studies that attempt to examine and categorise bugs have been carried out. The most relevant to this work have studied the actual cause of bugs [25][26][27], but while these have yielded many insights into the huge variety of causes and fixes of bugs, they did not seek to find the originating version of code. Chou et al. [28] examined warnings found by 12 automated bug checkers across versions of Linux, but did not examine user-reported bugs. For all checkers, they found the median difference between the introduction and the fix to be around 1.25 years. However, this often varied by the type of warning: those related to potential deadlocks could last significantly longer.\n\nA number of practical tools have been built on top of the text approach. HATARI [29] is an Eclipse plugin which determines how risky it is to change an area of source code. For each bug in a project's BTS, it identifies the lines involved in the fix, using the techniques described earlier. Lines where a high proportion of changes lead to later fixes are identified as risky, and a visual indication of risk is presented to the developer. The developer can also view the history of each line and examine which changes lead to which bug. FixCache [30] has a similar aim. A cache of elements, either files or methods, is maintained. Whenever a bug is fixed, the cause of the bug is identified, and those elements are updated in the cache. The cache is then used to predict how likely changing an area is to cause another bug.\n\n\nEVALUATION\n\nAs stated previously, limited evaluation has so far been performed on the approaches. The original text approach [2] did not validate whether the commits identified by the approaches actually caused the bugs in question. Subsequent work on other refinements has focused on evaluating the difference between the results returned by the original approach and those of the refined approach. In particular, there has been no evaluation of false negatives: commits which introduced bugs but which are not identified by the approaches. Identifying whether a commit caused a bug is timeconsuming and subjective, as there is no one definition of bug, and there may well be multiple causes that could be said to introduce a bug. Additionally, implementations of the approaches are not readily available and are challenging to complete. There is a notable paucity of reliable and well-known implementations of tools to support the creation and analysis of Java PDGs or SDGs. Therefore, this section will evaluate a manual simulation of the approaches. This allows their expected effectiveness to be assessed prior to any implementation.\n\n\nSubjects\n\nalthough both are open-source, written in Java and use Concurrent Versions System (CVS) [33]. Bug and commit data for Eclipse were obtained from Promise [34], and contain a collection of fixes, each of which is a commit linked to a bug as described in Section 2.1. The set contains every fix which could be linked to a bug and which occurred from 6 months before the 3.0 release of Eclipse until 6 months afterwards. However, bugs may have been introduced in earlier releases, and all previous versions were included in the evaluation. A series of scripts was used to select a random sample of 100 bugs, out of 4136 in total. These were linked to 301 separate commits (from a total of 10402). While this sample size may be considered small, the time required for evaluation prohibited the study of a larger sample.\n\nThe data for Rachota were obtained from FLOSSMetrics [35]. By a manual examination, all issues raised before 3 September 2008 and fixed before 15 March 2011 were classified into bugs and enhancements, as the Rachota BTS does not record this information. Then 242 fixing commits were identified for each of the 66 bugs in Rachota. A number of these commits only modified plain text files. While the text approach can be used on these files, the dependence approach cannot. Therefore, only the 130 commits involving Java files will be considered in this evaluation.\n\nFurther evaluation was carried out on a sample of jEdit [36] bugs provided by Dit et al. [37]. jEdit is a text editor for programmers maintained by the free software community, which has been used as a case study in numerous research studies. jEdit was used by the authors to develop a common understanding of the application of the text and dependence approaches and to check that a third case study found the same kind of issues that arose with Eclipse and Rachota. It is used here to provide examples of qualitative insights into the application of the two techniques and also to provide a standardised process to document bugs and the outcome of the application of techniques in future studies. jEdit also uses Bugzilla, but unlike Eclipse or Rachota uses Apache Subversion (SVN) as its SCM. The approaches are applicable to any SCM, but there is one slight difference. In CVS, each file is committed individually, and a version number is maintained for each file individually. In SVN, all modified files are committed together, and a revision number is used, which identifies the state of the entire project, not just a single file.\n\nAll authors applied both approaches to eight selected jEdit bugs and then worked through each in detail to identify key decisions that needed to be made to ensure consistency of application, particularly with respect to the dependence approach. Some of the issues that arose are discussed in Sections 4 and 5, with some jEdit examples being used as detailed examples throughout the paper.\n\n\nResearch procedurea worked example\n\nThis section describes the research procedure used to simulate the text and dependence-based approaches. To demonstrate both of these, a detailed example of the analysis of jEdit bug 1965114 will be used.\n\nThe bug was related to the SVN revision that fixed the bug through the use of the bug ID in the commit comment, as provided by the original sample [37]. Additional scripts were written to parse the provided dataset into an HTML page with links to jEdit's Bugzilla [38] and ViewVC [39] servers to aid analysis. An example of the output from these scripts for bug 1965114 is shown in Figure 5.\n\nThe Bugzilla hyperlink in Figure 5 opens the bug description shown in Figure 6, and the ViewVC hyperlink opens the revision description shown in Figure 7. The bug is described as: \"Pressing 'n' with the file system browser dockable open, and the file list focused, opens a new file.\" The problem is that typing an n character in a filename opens a new file, making it impossible to open files with the letter n in their filename using the keyboard. The shortcut to open a new file is supposed to be Ctrl + n, not just n.\n\nThe SVN revision description ( Figure 7) identifies the jEdit commit that 'fixed' the bug (12672) and all the files that were modified during the fix. Often, there will be multiple source code (.java) files modified for one fix. In this example, the text file CHANGES.txt (the jEdit release history) has been updated to include a textual description of the bug fix, and the single file VFSDirectoryEntryTable.java has been modified.\n\nThere are now three stages of analysis to be performed using the SCM system: identifying the jEdit revision where the bug was introduced, simulating the text approach and simulating the dependence approach.\n\n\nOrigin identification.\n\nTo identify the origin of the bug, the BTS entry is read to see if there is any information that could aid understanding of the nature of the bug and its potential source. For bug 1965114, this helps because it indicates that the origin code is likely to be concerned with file shortcut options. This helps to focus the examination of the modified code.\n\nNext, the commit that fixed the bug, 12672, is examined. First, the CHANGES.txt file was checked in case it contained helpful information; no further information was gained in this case. Second, the source file involved was examined using the annotated view provided by ViewVC. This provides a side-by-side SVN diff comparison against the preceding version of this file highlighting each line added, removed or changed. Figure 8 shows a snapshot of the annotated view for revision 12672 compared to its predecessor 12671. The lines highlighted in yellow (326-328) have changed between revisions, and those in green (332) were added (any removed lines would be shown in red). Line 327 appears to be an added conditional to fix this bug.\n\nIn revision 12672 of VFSDirectoryEntryTable.java, there were many other changes: 10 different lines were changed in total, distributed throughout the file from line 128 to line 624. All of these changes must be considered as potential contributions to the bug fix. In this example, these  other changes appear to be concerned with opportunistic cleaning of the codereplacing a concrete LinkedList by the List interface and removing many unnecessary brackets. Such incidental changes can have unfortunate consequences for the two approaches.\n\nHaving determined that the fix is likely to be the changes at lines 326-332 in revision 12672 and that the erroneous code is therefore on line 326 of revision 12671, the task now is to identify the origin of this bugin what revision was the bug introduced? By examining the SVN annotated view of revision 12671 (shown in Figure 9), the last revisions to change the context around line 326 are highlighted.\n\nOpening the more recent revision 10326 associated with line 325 shows that there was only a change of layout in this revision, with no changes to the code. Opening revision 7998 reveals that all the code associated with this case branch was added in this revision, as shown in Figure 10. Revision 7998 is therefore deemed to be the origin of bug 1965114.\n\n\nText approach.\n\nThe second stage is to now simulate the text approach. This means going back to revision 12672 which was identified as containing the bug fix. The evaluation was carried out as if each version of the code had been run through a preprocessor to standardise whitespace and brace formatting, and remove comments. This meant changes in whitespace, formatting and comments were disregarded. Adding or removing comment markers around lines of codes was therefore treated as adding or removing those lines. Changes to import statements were also ignored as these were either accompanied by other changes or were unused and so unrelated to the bug. Otherwise, the text approach assumes that all other changes made in the revision that fixes the bug are part of the bug fix. Furthermore, as mentioned earlier, the text approach cannot deal with fixes that involve adding lines of code, and so the focus is only on removed and changed lines.\n\nThe text approach works by taking each line that has been changed or deleted in the revision that fixes the bug (subject to the exclusions just mentioned) and tracking back through the revision history to identify the revisions that previously altered these lines. The set of revisions identified is considered the potential origin of the bug in the text approach.\n\nRevision 12672 included 10 separate line changes and one line addition. The 10 line changes are therefore all traced back through the revision history as potential origins of bug 1965114. This is similar to the process described earlier to identify the origin of the bug. The problem is that the text Figure 8. ViewVC: bug jEdit 1965114 side-by-side comparison of revisions 12671 and 12672 (the corresponding dependence graphs may be seen in Figure 13). approach cannot distinguish amongst any of the 10 changes, as was carried out earlier where an understanding of code semantics was used to focus on the changes made around line 326 as being the actual bug fix. Tracking back for each of the 10 changes leads to a set of possible bug origins, potentially one origin for each change. In this case, the set of revisions identified is 4640, 4648, 5179, 5217, 7170, 7998, 9596, 10275 and 11009. This is a clear example of one of the limitations of the text approach. Notice that the set does include the origin, 7998, as a result of finding the revision that introduced the change at line 326.\n\n\nDependence approach.\n\nThe third stage is to simulate the dependence approach. The first step is to map methods between versions based on their name and signature. Although it did not occur in this case, this allows the dependence approach to handle methods which are relocated within the class (not true of the text approach). Next, each method of the bug fix version is compared to the preceding version, and any removed or added dependences are noted. In the case of removed dependences, each preceding version of an updated method is manually compared until the most recent version to add one of the dependences is found. If no dependences are removed, then the same process is performed searching for the most recent version to have altered either the source or target of any added data/control dependences. In contrast to the text approach, rather than identifying the full set of potential bug origins, the dependence approach identifies only the most recent revision associated with a removed/added dependence and assumes that revision is the single bug origin.\n\nThe dependence approach therefore starts with the SVN diff between revision 12672 and its predecessor 12671. Of the 10 changes and one addition, eight are concerned with the removal of unnecessary brackets, and one is the addition of a closing brace matching the new conditional at line 326. This leaves only two changes that could affect the data or control dependences. Only dependences on other lines within the same method were considered; dependences on other methods and on any fields were ignored.\n\nThe first change is line 128 which was altered from LinkedList < VFSFile > returnValue = new LinkedList < VFSFile > (); to java.util.List < VFSFile > returnValue = new LinkedList < VFSFile > (); the dependences within this method are shown in Figure 11(b) and the relevant sections of code in Figure 12. As shown, line 128 has a control dependence onto method entry, and lines 132 and 134 have data dependences on line 128.\n\nWhen comparing two methods, the first step of the dependence approach is to examine the graph for each version and determine which nodes in the first graph correspond to which nodes in the second graph, if any. This mapping is based on the similarity of the two lines and the lines surrounding them. Generally, this was straightforward to do, but where there were ambiguities, these were recorded and re-examined at the end in order to ensure that similar cases were treated in the same manner. Specifically, if changes were made to an object's type, or a method was added to or removed from a chain of method calls, then the two nodes were considered to not map to one another. Changes that were made to the condition of an if-statement were regarded as the nodes mapping to one another. These decisions are somewhat arbitrary, but are based on suggestions in the original description [3], and ensure consistency in the evaluation.\n\nAs such, as this is a change of type, the two nodes representing line 128 are not considered to match. Therefore, both the control and data dependences have been removed (and new ones added), as shown by the highlighted edges in Figure 11. The dependence approach then searches the previous revisions to determine where any of those dependences were originally added. This process is performed in a similar manner to the text approach described earlier, using ViewVC to track back through the jEdit revisions. In this case, the generic parameter VFSFile was introduced in revision 9596, which would be seen as the introduction of the dependence, although prior to that, the original data dependence was introduced in the baseline revision of jEdit, 4631. Had the two nodes representing line 128 instead been considered to match one another, then the two graphs would have been seen as identical: no dependences would have been seen as added or removed. This change would therefore not have led to any origin. The effects of these decisions are explored in more detail in Section 5.\n\nThe only other change is the code associated with the bug fix shown in Figure 8. Here, the control dependences of the three assignments (starting evt.consume();) onto line 320 are removed and replaced with control dependences onto the new if-statement, as shown in Figure 13. In addition, a new control dependence from the if-statement to the case-statement is introduced. As stated previously, changes within conditionals are regarded as lines mapping to each other in the PDG, so the change on line 320 can be disregarded. Therefore, the focus here is on the removed control dependences and the revision(s) in which they originated. As this is the code associated with the bug fix, tracking back to identify when these were introduced shows that they were all added in revision 7998.   Figure 11).\n\nAs mentioned earlier, the dependence approach only identifies one revision: the most recent based on removed dependences (or added dependences if none are removed). Here, the dependence approach will return revision 9596. Note though that if the two versions of line 128 had been considered to be the same node, by ignoring type changes, then the approach would have returned the actual origin, 7998. This example therefore highlights the major impact that subtle changes in the definition of PDG differences have on the dependence approach, particularly as it only returns a single revision. This is explored further in Section 5.\n\n\nRESULTS AND ANALYSIS\n\nBefore looking at the results of the Eclipse and Rachota evaluation, it is useful to highlight the breadth of issues raised by just the small sample of jEdit bugs.\n\n\nQualitative analysis -jEdit\n\nA small, qualitative analysis was carried out using jEdit bugs, which is part of ongoing research. This was used by the authors to cross-check and develop an agreed understanding of the application of the text and dependence approaches and also to develop a standard process for summarising the bugs, their origin and the outcome of applying the techniques. The eight bugs discussed in Table I were specifically selected to highlight some of the subtleties that arose in the application of the approaches, particularly the dependence approach, across all three case studies. All authors independently applied both approaches to eight selected jEdit bugs. One of the jEdit bugs (1965114) was used as a detailed example in Section 3.2. Some of the issues that arose are discussed in more detail in Section 5. Table I summarises the eight jEdit bugs. For each bug, it shows the jEdit bug identifier, gives a brief description of the bug, states the identified origin, lists the revision(s) identified by the text approach, lists the revision identified by the dependence approach and highlights any interesting observations. The jEdit study, although small, clearly demonstrates consistent findings with the main quantitative studies on Eclipse and Rachota which follow this section:\n\n\u2022 There are examples where each approach clearly works as intended.\n\n\u2022 Both approaches are impacted by intervening changes between the origin and the bug.\n\n\u2022 The dependence approach is sensitive to the definition of program (and system) dependence graph usedit is not clear, however, that one specific definition will consistently provide the best results. \u2022 Most bug fixes had many opportunistic modifications as well as the bug fix; this means that the text approach often returns many revisions (including the correct one), while the dependence approach is more likely to be misled because it only returns the most recent revision.\n\n\u2022 Bug fixes which involve changing surrounding context rather than the problematic lines can mislead the text approach; the dependence approach has more potential to identify the origin in these cases. \u2022 The text approach cannot deal with changes that only add code. Dependence approach works as intended and text approach fails because there is only added code.\n\nTA, text approach; DA, dependence approach.\n\n\nQuantitative results -Eclipse and rachota\n\nFor each approach, the predicted origins were compared to the manually identified origins. The predictions that the approach made correctly were recorded as true positives (TP). False positives (FP), versions that the approach predicted but which were not correct, and false negatives (FN), origins which were manually determined but the approach did not predict, were also recorded. \u2020 Table II shows a summary of where the origin of the bug lies for each of the bug fix commits in Eclipse and Rachota. The majority of commits fixed a single instance of a bug where the origin and the fix lay within the same file, shown as Single. Some commits contained fixes for more than one instance of the same bug, shown as Multiple. These bugs may have all originated at the same time or may have been introduced in different commits, but in all cases, the origin and the fix lay within the same file. A number of commits contained fixes for bugs for which the origin actually lay in a commit made to a separate file, and these are classed as Elsewhere. Finally, some commits which claimed to be bug fixes were not actually fixes but were instead consequences of the bug fix or unrelated changes, and these were classed as Related or Unrelated. Examples explaining the distinction between categories in greater detail will be given later in this section. For 20 commits, the origin could not be determined, as the changes made by developers were complex and it was not possible for the authors to understand them or to identify if they were related to the bug in question. These commits were classed as Unclear. Note that these 20 files relate to just three bugs. All files for these bugs have been omitted from the remainder of the evaluation.\n\nOnly for bugs classed as Single or Multiple could the two approaches potentially return the correct answer. Identifying the origin of Elsewhere bugs would require an analysis over the whole system, not just on one individual file. Commits classed as Related and Unrelated claim to be bug fixes, but there is actually no bug in the file; for these bugs, there is no origin, and therefore, any answer returned by either of the two approaches would be an error. Table III shows the results obtained by the text approach (TA) and dependence approach (DA). In order to help compare the performance of each, the commonly used measures of precision (P) and recall (R) are also shown, along with their harmonic mean F 1 -Score (F). As can be seen, for Eclipse, the text approach identifies more correct versions than the dependence approach. However, the text approach also generates a much larger number of false positives, as it can return multiple origins for each commit, while the dependence approach only returns a single origin. As to be expected from the lower number of false positives, the precision of the dependence approach is higher, at 44% compared to 29%, although the recall is only 40% compared to 48% for the text approach.\n\nA similar pattern is seen for Rachota, but the proportion of false positives compared to true positives is vastly reduced compared to Eclipse. This may be because of the relative simplicity of changes in Rachota. The bugs and their fixes, often seemed simpler than those in Eclipse, and there were often fewer versions between the origin of the bug and the fix. Unsurprisingly, given the smaller number of false positives, the precision and recall for Rachota are higher than for Eclipse.\n\n\nAnalysis of Eclipse and Rachota\n\nThe approaches successfully found origins for a variety of different types of bug. Of the 68 bugs in Eclipse for which at least one origin was successfully identified (out of a total of 100 bugs), around a third resulted in exceptions that either crashed the application, displayed an error to the user or appeared in logs. However, bugs in other areas were also successfully identified:\n\nUI Bug 63753 -'Checkbox being ignored' Tests Bug 74229 -'Failing automated tests' Code Reviews Bug 57670 -'Wrong subclass of InputStream was being used' Performance Bug 64531 -'Find/Replace operation using 100% CPU'\n\nThere was a similar diversity of bugs identified in Rachota, although there were a greater proportion of user interface bugs and an incorrect output rather than exceptions. Overall, the approaches did not seem to be more or less effective for any particular type of bug, but there were a number of factors that impacted on their performance. This section will highlight some of these with a number of illustrative examples of bugs. Although the description only mentions commit operations, the actual bug involved a number of different operations locking the entire Eclipse workspace, preventing other operations from accessing it, when it was only actually necessary to lock individual folders. One of the changes made to fix the bug was version 1.156 of CompilationUnit.java, in which a number of lines were changed from runOperation(operation, monitor) to operation.runOperation(monitor). This was carried out as the method JavaElement.runOperation had been moved, and during the move changed, to JavaModelOperation.runOperation. Each of the calls was used as part of a different operation, and therefore, each represents a separate instance of the bug. Some of these bugs were introduced in version 1.1 of the file, while others were introduced in version 1.98. 4.3.1.1. Graph matching. The text approach correctly identified both origins of this bug, as these lines had not been materially altered since the bug was introduced. However, as in jEdit bug 196511, the graph matching technique used has a major impact on what the dependence approach returns. If the line runOperation(operation, monitor) is considered to be the same node as operation.runOperation(monitor), then the dependence approach would not return anything at all. However, as the evaluation considered those two lines to be different, the dependence approach returned the most recent version to introduce one of the relevant dependences, version 1.140. The technique used to match nodes between different graphs has a major impact on the conclusions reached by the dependence approach. However, as later examples will show, there is not one definitive strategy which will always give the right answer. 4.3.1.2. Multiple bugs. Even if the dependence approach had returned a correct answer, it always only returns a single answer, so could not have hoped to identify both origins. This bug is an example of a number of bug reports in the Eclipse sample where one bug report actually represents multiple real bugs. As these were often introduced at different times, the dependence approach fared much worse at identifying these, as shown by the row for Multiple bugs in Table IV. 4.3.1.3. Age of origin. Quite a large number of versions passed between the bug being introduced and being fixed. While for this bug, and some others, the text approach was still successful, this was not generally truethe more versions passed between the introduction and the fix, the less likely it was the origin could successfully be found, as will be shown in Section 5.4.  CompilationUnit.java was only one of the files involved in this fix. In total, there were 13 files whose commit comments indicated they were related to this bug. However, the knockon effects of moving the runOperation() method described earlier were responsible for most of these.\n\nIn three of the files, there was no actual incidence of a bug, although the code changed was clearly involved in the fix. These commits were classed as Related. In an additional seven files, code that was not involved in the bug at all had to be altered, and these commits were classed as Unrelated. For both these types of change, as there was never any bug in the file, any result returned by an approach would be wrong. The ideal outcome in fact would be for the approaches to return nothing. This did not happen, however: these changes resulted in 19 false positives for the text approach and 7 for the dependence approach. This was often true of other bugs; as can be seen in Table IV, these types of commits are responsible for a significant number of false positives.\n\n\nUnrelated changes.\n\nEclipse Bug 49891 -'Problems launching a program, when using linked resources in CLASSPATH, which are not set' This bug is an example of a fairly straightforward fix for which the origin is easily identified but which can still result in issues for both approaches. In version 1.37 of RuntimeClasspathEntry.java, the line return res.getLocation().toOSString(); was altered to check first whether the value of res.getLocation() was null. This possibility had existed since version 1.1, the origin of the bug, but version 1.8 of the file had changed the line to its current version from the previous return new String[] {res.getLocation().toOSString()}; Both approaches therefore returned version 1.8 of the file as the incorrect origin. Unrelated changes often tripped up both approaches, although in general, the dependence approach appeared to handle them slightly better. In particular, because it explicitly mapped methods between versions, it could handle code being relocated within a file where the text approach could not.\n\nIt is difficult to see here how either approach could account for this problem, however. The change in version 1.8 is indeed a semantic change and cannot simply be disregarded, as it is entirely possible that the same scenario could be the fix for another bug under different circumstances.\n\n\nBugs caused by changes to other files.\n\nEclipse Bug 54538 -'Bundle-SymbolicName value has changed' Not all bugs were caused by a change made earlier in the same file. This bug was raised as the class BundleManifest.java was not correctly parsing the value of a String. It was fixed in version 1.6 of the file. However, the bug was originally caused by a change that was made elsewhere in the system to change the format of the String, not in the BundleManifest.java itself. At that time, a number of classes which parsed this value were updated, but this class was incorrectly omitted, and this was bug then raised at a later date when the problem was discovered. As the origin lies in another class, this commit was therefore classed as Elsewhere, and neither the text approach nor the dependence approach could correctly identify the origin.\n\n\nCoincidental correctness.\n\nEclipse Bug 65354 -'[Perspectives] Perspective bar incorrectly updated when opening new perspective' The fix for this bug was in version 1.11 of PerspectiveBarManager.java. Here, two lines were updated from if (coolBar ! = null) LayoutUtil.resize(coolBar); to if (getControl() ! = null) LayoutUtil.resize(getControl()); However, as neither coolBar or getControl() are local variables, their dependences are not included in either graph, and the intra-procedural dependence approach would therefore not be able to determine their origin (although it is possible an inter-procedural approach could have).\n\nAn additional change was also made before those lines to remove a call to updateCoolBar(); (that method was also removed). However, the updateCoolBar() method did not actually do anything: its entire contents had been commented out in an earlier version. The removed control dependence on the call, however, causes the dependence approach to return the correct origin for the bug. In effect, the approach is only correct because of the developer making an unnecessary change.\n\nAs this bug shows, developer behaviour has a major effect on the quality of the two approaches. They may be more effective for projects which have a strict policy on making one commit per logical change and less so for projects where developers tend to commit a large variety of changes all in one go. It also raises the question: even if a way could be found to ignore changes which are incidental or unrelated to the main fix, should they be, or are these still useful clues to help discover the origin? Here, for instance, it was only due to the unrelated change that the dependence approach worked. After all, developers usually only change code if it is at least tangentially related to the code they need to fix; they are less likely to make changes to code which is totally disconnected from that involved in the bug.\n\nIt is also useful to note that the intended use of the approaches will have an effect on how useful they are perceived to be. If a developer for example selects a bug report and wants to know what caused it, issues like these will trip up the approaches. If on the other hand the developer identifies an individual change known to be the bug fix and wants to know the same thing, the approaches may be more useful. For many bugs, although not this one, the approaches could often identify the correct version if not for the presence of other changes in the file.\n\n\nNumber of changes.\n\nEclipse Bug 55640 -'[FastView] Screen cheese after Fastview resize' Firstly, this bug highlights a major problem with trying to interpret developer changes through bug and commit data. The commit comment for this fix, version 1.56 of ViewPane.java, was 'fix for bug 55640: views with custom titles were wasting space'. The developer is fairly unequivocally claiming to have fixed a bug with the correct ID, and the code is clearly in the same area as that described by the bug. However, the description of the commit and the description of the bug do not entirely match up, and it is not clear whether they are definitely referring to the same thing. It is indeed possible that the developer used the wrong bug number when committing the fix or that the bug report was not a true description of what the problem actually was. Alternatively, this could simply be a problem of understanding caused by the analysis not being performed by a developer of the system. Regardless, it was fairly straightforward to identify the origin of the bug fixed by the developer as version 1.33 of the file. The fix itself involved the deletion (or commenting out) of 32 lines of code and modification of another two, spread throughout the class. However, these lines of code were last changed in a variety of different versions: 1 in 1.22, 27 in 1.33, 1 in 1.34, 1 in 1.38, 1 in 1.48 and 3 in 1.53. This results in the text approach identifying the correct answer, but with an additional 5 false positives. The dependence approach identifies the most recent of these changes, 1.53, as the source and so obtains the incorrect answer. The interesting point here is that the source of the bug was not the most recent change to the code (nor was it the oldest), but it was the version in which the majority of lines had last been changed. graphs, then the dependence approach would also return the correct answer. If however, as was assumed here, these lines do map, then the dependences within the method have not changed at all. The only change that has been made is a dependence on a static variable. This highlights additional possibilities for altering the dependence approach. Even if a full inter-procedural analysis is not feasible, extending the dependence analysis to take into account constant or field declarations may still improve the recall of the approaches. It is not clear, however, how many bugs would be affected this way, and there may be bugs where doing so would cause the wrong version to be returned. It is not at all clear whether the prioritisation of removed dependences over added dependences in the dependence approach is necessarily the correct technique. In the fix for this bug, version 1.66 of KeysPreferencePage.java, there were two lines removed, with corresponding control and data dependences removed. The most recent of these was introduced in version 1.63, which is what the dependence approach returned as the incorrect answer. However, there was also one line added. The corresponding control dependence, onto method entry, would have led the approach to return version 1.60, the actual origin of the bug.\n\n\nSummary\n\nA number of key points can be taken from the examples given here and earlier:\n\n\u2022 For many bugs, only one of the approaches gains the correct answer, or indeed any answer at all. \u2022 The decisions taken by the dependence approach on graph matching, depth of analysis and priority of dependences have the potential to hugely affect its performance. \u2022 Large fixes and the number of versions between a bug and a fix can reduce the effectiveness of the approaches. \u2022 Unrelated changes have an impact on the results returned, but this can sometimes be to the approaches' benefit. \u2022 Taking the most recent version as that which introduced the bug may not be the most effective technique.\n\n\nPOTENTIAL IMPROVEMENTS\n\nIt is obvious from the sample and from the examples highlighted earlier that there are a number of areas in which the approaches could be improved. It is worth considering first why the approaches, or variations on them, should work at all. After all, it is not hard to construct theoretical examples of bugs for which neither approach would ever be successful, but these bugs do not appear to be frequent in the sample that was examined. Almost every bug fix involves either a textual change or a correction of an aberrant dependence. Using a theoretical extension of the dependence approach, with a richer variation of SDG, even bugs which are fixed in other classes or by changes to inheritance hierarchies could be seen as dependence changes. If the approaches were to consider every change, whether textual, added dependence or removed dependence and then to consider every previous version which affected these lines or dependences, it would seem very likely that the full set would include the bug origin. To do so would of course have huge costs, both in the large number of false positives and in the prohibitive time that would be required to run such a technique.\n\nIn a sense, however, the various decisions taken by the two approaches can be seen as attempts to reduce both of these costs:\n\n\u2022 Choosing to use just one of the approaches rather than both.\n\n\u2022 Ignoring changes to whitespace or formatting.\n\n\u2022 Only returning the most recent version.\n\n\u2022 Ignoring added dependences if dependences have been removed.\n\nIt is not clear, however, if these are the most appropriate ways to improve the approaches. This section will present a number of other possible improvements or changes that could be made.\n\n\nFalse negatives\n\nThe idealised description of the approaches given previously is just that: an ideal. In reality, there are a large number of false negatives returned by each approach. In a very small minority of cases, these occurred when a bug had multiple origins of which the approaches only identified some, but for 70 commits in Eclipse classed as Single or Multiple, the text approach returned nothing at all. As stated earlier, this was usually due to fixes which only involved lines being added. For the dependence approach, the equivalent figure was 58 commits, where the fix usually contained no changed dependences.\n\nThe original authors proposed that in the cases where the dependence approach found no altered dependences, it would fall back to using the text approach [3]. However, this could equally be applied in the other direction, with the text approach given first preference. In fact, this may well be preferable because of the extra computational effort required for the dependence approach. The original paper reported the dependence approach to take around 7.2 times as long as the text approach on average, in the worst case taking over 12 hours to analyse 129 fixing commits where the text approach took around 1 hour.\n\nA technique of using both strategies may well be viable. The most common result was for the two approaches to return the same outcome. However, in a significant number of cases, one approach identified the correct version, while the other did not, as already discussed. Obviously, however, it is also possible for one approach to return the incorrect answer where the other returned nothing. Table V shows the effect of returning the result of the second approach if the first approach returns nothing. For both Eclipse and Rachota, the change to the dependence approach is the same: a slight increase in both true and false positives, with a corresponding rise in recall but drop in precision. The change for the text approach is more pronounced, however, increasing both precision and recall. The difference in F1-score between the approaches has now reduced, and in fact, for Rachota applying the text approach first gives the highest value. Given the potential time saving and the similarity in effectiveness, using the text approach first could benefit some applications.\n\nThere are perhaps more effective ways of combining the two approaches and of taking further evidence into account. As the earlier examples should have illustrated, there are often a number of decisions that need to be taken in each approach; there is not one correct way for every bug. Sometimes the most recent change is the one that introduced the bug, sometimes it is the first. Sometimes dependences are removed to fix the bugs, sometimes they are added. Sometimes type changes cause the bug, other times they are irrelevant. One potential way to approach handling this would be to aggregate this information and combine it in a probabilistic manner.\n\nAs a simplistic example, a fix in 1.7 involving 10 lines of code, two of which were changed in version 1.5 and eight in 1.4, could imply that the bug was 80% likely to have been introduced in version 1.4. However, the fact that 1.5 was more recent could suggest that the bug is 66% likely to have originated in version 1.5. Multiplying these probabilities would say that the cause was version 1.4 with 65% probability. Obviously, the examples given here are arbitrary, but the exact values could be determined empirically and additional evidence could also be taken into account.\n\nIn a way, some of the current decisions taken by the approaches can be seen as a blunt form of this: choosing to favour the most recent change is saying that there is a 100% probability it was in that version and 0% probability it was in any preceding version. \n\n\nInter-procedural analysis\n\nEven after combining the two approaches, there are still 62 commits for which no result would be returned. In some cases, this is desirablewhere the file did not actually have a bug in itbut often this is due to the dependence approach not being capable of detecting the dependences that have been changed. However, there are a number of additions that could be made to it in order to increase the number of dependences it considers. Starting from the basic intra-procedural approach used in the evaluation, a simple step would be to take into consideration dependences on fields, static values or constants. Slightly more complex would be to add in dependences on other methods within the same class, then more complex still to include other classes. Finally, other information could be added in until there is a full SDG as presented earlier: synchronisation, exception handling, inheritance hierarchies and so on. Each of these layers adds on more information and brings the system closer to that described at the beginning of this section, both in terms of being more likely to find the origin and of having more false positives and a longer runtime. However, it may be that there is a level between the basic one used here and the full SDG which proves to be the most balanced of solutions.\n\nAnother way to increase the number of potential results discovered by the dependence approach is to consider all the dependences, rather than stopping at the one which had the most recent change. This would in effect make it more similar to the text approach, with similar downsides.\n\nAnother possible investigation is into the graph matching techniques used. The original source does not fully explain the technique used [3], but is suggested as being similar to that used in JDiff [15]. In that technique, graphs are broken down into smaller subgraphs called hammocks, and nodes are matched by their structural properties or textual equalitynodes which are textually similar but not exactly equal are not considered to match. However, there are many other graph or tree differencing techniques. In ChangeDistiller [40] for example, n-grams are used to determine whether the labels of leaf nodes are above a certain threshold of similarity. Whether a node in one version is matched to a node in a subsequent version or not has a major effect on how these techniques work, as two nodes which do not match can result in many removed dependences. Using a technique which gives a more accurate decision on whether a line has been updated or instead entirely removed and a new one added could give fewer false positives. Conversely, however, using a less accurate technique may actually increase the number of dependences altered, which if multiple dependences are taken into account may give the approach more chance of finding the correct answer.\n\n\nFalse positives\n\nA significant proportion of the responses for the text approach were false positives. While most occurred when the approach could not identify the correct answer, a total of 41 false positives occurred where the approach identified the correct version along with one or more false positives, shown by the highlighted cells in Table VI. For example, there were six instances of commits which caused one true positive and two false positives, and 98 commits which caused 0 of each; nothing at all was returned for these commits. In addition, the bold cells show the large number of cases where more than one false positive occurred, for a total of 164 false positives.\n\nOne technique to reduce the number of these responses would be to return a single version, similar to the dependence approach. Doing so would reduce the maximum possible number of false positives per commit to one and would hopefully also result in discarding the false positive in favour of the true positive. Two ways to do so are to return the most recent version in which anything changed or to return the version in which the majority of the lines last changed.  Table VII shows the effect of such a change. As shown, the false positives have decreased significantly. Unfortunately, the true positives have also decreased, as the approach no longer returns some of the correct versions it previously would have. This is especially true for bugs classed as Multiple, where it is no longer possible to correctly identify all of the origins. However, selecting the version in which most lines were last changed does significantly increase the precision at the cost of a smaller decrease in recall. Selecting the most recent version is similar but for a lesser benefit and larger downside.\n\n\nUnrelated changes\n\nIn total, there were 34 fixes containing unrelated changes, of which 20 fixed multiple different bugs. An automated tool could potentially ignore these commits by checking the commit message for multiple bug IDs. Unfortunately, 13 of these commits were for a bug that was classed as Unclear, and the remaining sample did not allow conclusions to be drawn about such a change.\n\nOne situation where this could be improved is where multiple commits are made to fix a bug, often because the first attempt was incorrect. One improvement would be to ignore changes made in versions that were linked to the bug other than the latest. This is in effect similar to the suggested improvement to remove all versions after the bug was raised as possible origins [7].\n\nPossibly because of the increased chance of unrelated changes, the approaches tended to be less effective as the time between the bug being introduced and being fixed increased. Figure 14 shows the effects on F if fixes more than a given number of versions after the origin were to be ignored. Larger values have been omitted from the chart as the values remain largely stable, but the maximum difference between a bug being introduced and being found in Eclipse was 267 versions. Note that these figures only include bugs for which an origin actually existed so will not correspond with those given earlier in Table III.   Figure 14 also illustrates that bugs were often fixed shortly after being introduced. For Eclipse, 12.8% of bugs were fixed within one version after the bug was introduced with 50% of bugs being fixed within 12 versions.\n\nAnother, more complex, way of removing false positives would be to ignore changes to code that had no semantic effects. A number of common patterns were identified by Jung et al. [22], from simple renames or deletions of lines with no effect, to deep semantic analysis. Some of these are already carried out, while others could perhaps be easily achieved by using abstract syntax trees rather than straight textual differencing, but detection of other patterns would be challenging. While Jung et al. only considered ignoring these changes in the fix itself, it would also be possible to apply such techniques to changes in intervening versions.\n\n\nLarge commits\n\nEclipse Bug 49561 showed a large number of false positives being returned when there were many files involved in the bug fix. This appeared to be common: often bug fixes which involved many files had a large number of unrelated changes, leading to an increase in false positives. One proposal is to ignore fixes that change a large number of files [7]. The number of bugs of each size in Eclipse is shown in Table VIII. Figure 15 illustrates F if bugs with more than the given number of commits were to be ignored. Similar trends are present for P and R. As seen here, the vast majority of bugs were small, and the scores are much better for smaller commits. For the few larger bugs, the scores decrease. The same was not necessarily true for Rachota; there, the largest bugs were smaller, and the scores stayed largely constant.\n\nGiven the results for Eclipse, ignoring bugs with more than a certain number of commits may increase effectiveness without reducing applicability significantly. This might be appropriate for some use cases, but further study would be needed to determine a threshold, and it is likely this may vary by project.  \n\n\nIncorporating users\n\nWhile automated methods to reduce false positives are desirable, they are unlikely to be highly accurate, and in some cases, they may not be necessary. Depending on the desired use of the approaches, it may be that users could be available to manually remove false positives and to assist the approaches in other ways. If the approaches are being used to assist a developer with finding the origin of a specific bug, then a reasonable first step would be to present the developer with a list of all changes in the fix. From there, the developer could select any changes which are obviously not related to the bug. This could easily reduce the number of false positives quite significantly as a number of irrelevant changes could be ignored. This process could also be carried out throughout the search by presenting the user with a list of proposed origins. Again, the user could select some as being irrelevant, and the approaches could then follow the trail back through older versions.\n\nAs well as potentially being more useful for a developer, such a technique could also lead to a better understanding of what type of changes are responsible for causing or fixing bugs. This information could then be incorporated into the approaches to improve them, learning from the developer's feedback. As an example, there is a variable in Rachota which is displayed on screen to the user and indicates the version of the software. This variable is updated with every release and alone is responsible for 14 false positives in the Rachota sample. Being able to learn to eliminate these types of change would improve their accuracy.\n\n\nAnalysis of potential improvements\n\nAs a way of assessing the likely impact of several of these suggested improvements, a diverse set of bugs was selected in order to investigate in detail the consequences of a number of possible changes. Five bugs were randomly chosen from the set of Rachota bugs, two from Eclipse, and all eight of the jEdit bugs previously examined. Although this is a small set and not one which could be argued as representative, the differences between the bugs and the insights obtained from the process give some very clear pointers about which approaches are likely to yield substantial benefits and which are not worth considering. Selection of the potential improvements was based on what could be feasibly investigated and objectively evaluated, and consequently tended to include changes in the applications of the two strategies and exclude larger, more amorphous, amendments such as investigating user involvement (such modifications would need to be the subject of a larger, separate study). 5.7.1. Modifications studied. The modifications studied for the text approach were the following:\n\n\u2022 Return just the most recent revision.\n\n\u2022 Return just the largest revision (that with the most substantial number of modifications in terms of added/deleted/changed lines). \u2022 Consider the impact of additions by looking at where the surrounding block was introduced (i.e. treat the enclosing block as if it was the subject of some change). The modifications for the dependence approach were the following:\n\n\u2022 Return all revisions that could be identified by examining changes in dependences.\n\n\u2022 Return just the largest revision (that with the most substantial number of modifications).\n\n\u2022 Take in account additions even when there are removed dependences and return the most recent revision. \u2022 Return all revisions taking into account any extra ones identified after considering additions.\n\n\u2022 Return just the largest revision taking into account any extra ones identified after considering additions.\n\n\u2022 Widen the scope of dependences considered to include -intra-class dependences, -inter-class dependences and -system-wide dependences (library classes etc.) and for each case, again, consider the impact of returning all revisions and just the largest revision, as well as the standard approach of just the most recent revision. Some of these changes are fairly trivial to implement (for example, selecting either the most recent or the largest revision for the text approach), whereas others (such as those considering text addition, and widening the scope of dependences) involved a considerable amount of additional analysis of code to identify the associated revisions. All these modifications were applied manually by the second and third authors to the selected bugs: five bugs were analysed independently by both researchers and subsequently discussed in order to ensure agreement on the application of the modifications, and the remainder were investigated by one or other researcher alone. 5.7.2. Results of applying potential improvements. The results of applying these potential improvements to the selection of bugs are shown in Tables IX and XI. These tables present the results (in terms of TP, FP and FN) for each of the standard (i.e. original) approaches, followed by the results of examining each of the potential improvements. In the tables, an empty cell indicates that there was no additional information to consider. This covers cases such as the following:\n\n\u2022 The text approach only returning one result, so there are no other revisions to classify as either largest or most recent. \u2022 There are no additions for the text approach to consider. \u2022 The dependence approach has already considered additions (in the case where there are no removed dependences) or there are no added dependences to consider.\n\nWhere there is any new information to consider, the results are reported, even if they do not produce any different values. This strategy clearly distinguishes between the consequence of considering the improvement and the case where the improvement cannot be applied. Tables X and XII summarise the results from Tables IX and XI by using the F 1 -Score. Individual table cells are also shaded, relative to the standard approaches, to visualise the benefits or otherwise of the potential improvements: in cases where there is no change, the cells remain the same shade as the standard approach, but where there are improvements (deteriorations) in performance, then the table entries are lighter (darker) than the standard approach.\n\nThe results of widening the scope of dependences are not shown in the table as overall, this had very little impact. Any additional dependences either tended to identify no new revisions on top of those identified by the local changes or resulted in a large number of false positives (and a great deal more analysis). There were no cases where consideration of a widened dependence resulted in the identification of a new true positive. Investigating this further would appear that the only case where a remote change is likely to be the source of a bug fixed locally is where the invoked method causes a side-effect, either by modifying some class-level state (a field for example) or by mutating a parameter in some way. None of the 15 cases investigated involved such side-effects, which is not to suggest that this would never happen; on the contrary, Section 5.2 suggests that there are several cases where the inability to follow dependences results in nothing being returned. From this limited analysis, a full-blown SDG-based analysis would not appear to be worthwhile when extending the analysis to consider only class-level or global state manipulation may be just as effective. This is something which may differ for projects which have a different coding style; perhaps as a consequence of the functionality demands of the system, the preference of the developers or the choice of implementation language for example.\n\n\nAnalysis of results.\n\nConsidering the improvements to the text approach, it is apparent that taking into account additions has a clear benefit in correctly identifying a further four revisions (with few false positives). This is a clear deficiency of the text approach, so it is perhaps unsurprising that the impact should be so substantial. The fixes for three of the bugs (R1551008, J1542026 and J1834620) took the form of pure additions and so moved from returning nothing to correctly identifying the origin of the bug. For bug E50549, an addition was one of several fixes, and so considering this correctly identified the origin. Bug R1356348 was similar, but the correct location was masked by intermediate fixes which prevented it from being identified. For bugs where the text approach had already correctly identified, the source, considering additions tend to either have no detrimental effects or slightly increase the numbers of false positives. Filtering these results further by looking at either the largest or most recent revision does not produce any clear benefits (losing a correct result in one case), and filtering the original standard results yields substantial losses -findings that are in line with the earlier analysis in Section 5.3. Only in one case (bug R1734799) is there a substantial gain in the form of a large reduction in false positives from considering just the largest change. However, this is a slightly unusual bug in that the majority of changes are unrelated modifications to property files and an example of where user involvement would be by far the most effective mechanism for filtering out such irrelevant changes. For the dependence approach, the biggest benefit comes from returning all revisions identified rather than the most recent, yielding an additional six correct revisions in addition to the seven initially identified by the original approach. This naturally results in an increase in the number of false positives, but not a substantial one in this sample. Considering just the largest revision from this wider set is successful in four cases but loses the correct revision in the remaining two, so if false positives were a significant issue, this could represent an efficient, but more risky, approach. Taking into account additional dependences even where there are deleted ones would not appear to be worthwhile; the consequences are a marginal increase in the number of false positives in one case and no observable changes in the other two. The origins of two bugs remained undetected in spite of all these improvements. For bug R1356348, as with the text approach, the presence of intermediate changes prevented the correct location from being identified. For this bug, there were also a number of additional wider dependences to consider, but none of these returned any new possible sources. Bug J1584436 (as noted when the jEdit bugs were originally considered) involved the failure to decrement a local variable and the fix did not involve any changes to either data or control dependences; such cases will always be missed by the dependence approach.\n\nConsidering both approaches together, on this sample, the dependence approach performs far better than the text approach and detects seven of the 15 bugs using the standard approach against the four returned by the text approach (which are also in the set detected by the dependence approach). Furthermore, three of the five revisions that would be correctly identified by the improvements in the text approach were already detected by the standard DA; these three are the cases where the fix involved straightforward additions, so it is no surprise that the dependence approach would also detect these (in general, one would expect the dependence approach to detect all textual changes except where the modification is minor and there is no change in dependences, such as in the case of bug J1584436 mentioned earlier).\n\n\nPossible combined strategies.\n\nCombining this information would suggest that the following three-step strategy would be most likely to provide the best results for the least cost:\n\n1. Apply the standard dependence approach and inspect the revision returned. 2. If the revision identified by step 1 is incorrect, then apply standard dependence (largest) and\n\ninspect the revision returned. 3. If the revision identified by step 2 is incorrect, then apply standard dependence (all) and inspect the revision returned.\n\nFor the bugs considered here, this would correctly identify 13 (seven from step 1, plus four from step 2, plus two from step 3) of the 15 revisions at a cost of examining only 19 false positives (eight in step 1, four in step 2, and seven in the final step). However, other strategies could give similar results for slightly different costs: for example, applying standard text followed by standard dependence and finally by largest dependence would also produce the same number of revisions at the cost of examining a larger number of false positives but with the benefit of having to carry out less in the way of expensive dependence analyses. Furthermore, this combined approach offsets some of the dangers of investing in a single strategy: as mentioned in Section 5.1, 70 of the commits in Eclipse returned nothing at all (being typically just additions), and 58 contained no changes to dependences. An approach which combines techniques would appear to be ultimately more effective, if slightly more expensive, in the light of such figures. Such trade-offs also have to take into consideration the technology available to support the analysis. Finally, it is important to stress that these findings are not readily generalisable from this small sample and require wider empirical investigation in the future.\n\n\nRecommendations\n\nEven with this additional analysis, the question of which approach is appropriate for use is not a simple one and may come down more to the intended use and time available rather than accuracy. Generally speaking, if the most important issue is accuracy, then combining the two approaches in some way and including the fairly straightforward improvements presented here (primarily considering additions for the text approach and extending the dependence approach to include multiple results, which both result in quite substantial gains) is likely to be the most effective tactic. However, if only one can be used, then the dependence approach (again with some of the identified improvements) tends to generate far fewer false positives, whereas the text approach has speed advantages, both in use and in likely implementation time.\n\nEven though the dependence approach appears to perform well in this detailed analysis (particularly taking into consideration the improvements), the results of the evaluation in Section 4 would suggest that it does not appear to be sufficiently more accurate than the text approach to justify its sole use in most cases (note that this is based on the dependence approach as it was simulated here). There does appear to be more scope for improvement in the dependence approach than in the text approach which could lead to it becoming sufficiently more accurate in the form of widening the scope of the analysis. However, these changes were not particularly fruitful and are only likely to exacerbate the differences in time required. Widening the dependence scope to consider field variables, statics and constants may be an effective compromise.\n\n\nTHREATS TO VALIDITY\n\nThere are a number of threats to the reliability and generalisability of the findings from this evaluation. These include the manual application of both the text and the dependence approaches, challenges in interpreting the dependence approach, researcher consistency, the accurate determination of bug origins, and potential limitations caused by the particular software systems and bugs selected for analysis.\n\nFor the main evaluation both the text and the dependence approach were manually applied as described in Section 3.2. As well as having the potential for human error in their application, there were also occasional difficulties in determining precisely how they would perform when automated, particularly with regard to the dependence approach. As discussed earlier, there are different possible interpretations of data and control dependence, including issues associated with intra-and inter-procedural dependences, type changes and changes within conditional statements. Furthermore, the handling of constructs such as fields, synchronised blocks and try-catch blocks were not discussed in the original work. To maintain consistency, scenarios involving such constructs were noted as encountered and then revisited as a group at the end of analysis.\n\nThe analysis of Eclipse and Rachota was carried out by one researcher (the first author). To try to ensure clear and consistent application of the research procedure, all three researchers independently applied the procedure to eight jEdit bugs (Section 4.1). The researchers then met and performed a detailed group walkthrough of the analysis of each of these bugs to clarify all the issues raised and to ensure consistency of application. The correct identification of the origin of each bug is also a potential threat, especially as none of the researchers were developers of the software systems that were being studied. This threat could not be avoided altogether but was lessened by noting related and similar commits and again revisiting them at the end of analysis. Also, as described in Section 3.2, where possible, commit logs and bug report comments were used to support identification of bug origins.\n\nFor Eclipse and Rachota, the analysis only ever finds a bug origin in the file where the fix was applied. However, as discussed, the origin to a bug sometimes lay elsewhere. This limitation is partially due to the SCM, CVS, used in these studies, which considers each file in a commit as a separate transaction. This threat could partially be addressed by further studying projects that use other SCMs which assign revision numbers to the entire project, such as with the use of SVN in the jEdit study, or to use techniques that reconstruct project versions [41].\n\nParticular threats to the generalisability of the results are associated with the systems studied, the relatively small number of bugs analysed and the particular bugs that were selected for analysis. With regard to the number of bugs selected from Eclipse (100 from a possible set of just over 4000), if a medium effect size is assumed (clearly a matter of judgement but arguably reasonable from inspection of the various graphs in the paper), then this sample of 100 from 4000 is enough to give any statistical test carried out a power of just less than 0.95. The manual analysis of bug origins and application of both approaches is quite time-consumingabout 30-60 minutes per bug on average. The only criteria used for selecting bugs to be analysed was that they could be linked via a bug identifier to a fixing commit, and so these may not be representative of all bugs in the three systems [4]. Similarly, the three software systems studied Eclipse, Rachota and jEdit, and their bugs may not be representative of all software systems.\n\nFor the analysis of improvements, both the text and the dependence approaches were again manually applied as described in Section 3.2 and also took into account a number of possible improvements. In terms of application of the approaches, the most significant of these was consideration of the wider set of dependence approaches which typically involved a good deal more analysis. For the detailed examination of all these potential improvements to be feasible, it was only possible to explore their impact on a small set of bugs, and consequently, these findings are only indicative and not necessarily generalisable.\n\nIn considering the aforementioned threats, it is important to note that the aim of this study was to gain a deeper insight into how the text and dependence approaches may actually perform when applied to real software systems. The goal has not been to investigate whether one approach is 'better' than the other but to identify their apparent strengths and weaknesses, the key issues that arise with their use in practice and to determine the extent which bug origins might be automatically identified. Some confidence in the findings can be derived from the fact that same key issues repeatedly arose across the wide variety of bugs that were studied.\n\n\nCONCLUSIONS\n\nThe aim of this study was to investigate the practical application of the text and dependence approaches for discovering the origins of bugs. The study was performed by manually simulating both of the approaches on sets of bugs from three case studies: Eclipse, Rachota and jEdit. The research goals included identifying the strengths and weaknesses of both approaches when applied to real systems, determining how effective both approaches are in identifying bug origins and suggesting refinements that could improve the overall effectiveness of the two approaches. The motivation for this research is that automated bug origin discovery can then feed into research on bug prediction and prevention based on common patterns or code locations, and analysis of the development process that leads to the introduction of bugs.\n\nThe study manually investigated the origins of 174 bugs and analysed the potential of the text and dependence approaches to correctly identify these origins. The quantitative evaluation based on Eclipse and Rachota found that both approaches often performed as intended, identifying the bug origin with a precision in the range 29-79% and an recall in the range 40-70%. The evidence suggests that text approach is more likely to identify the correct origin than the dependence approach but at the cost of reduced precisionthis is due to the text approach, as currently described, identifying all possible origins, while the dependence approach seeks to identify a single origin. This choice of all versus single is actually independent of the approach used, and either approach could choose to adopt one strategy or the other.\n\nOther key lessons derived from this study include the following:\n\n\u2022 The accuracy of using both approaches together was at least as good as, and mostly better than, using either on its own. \u2022 Both approaches are likely to provide inaccurate results when other 'opportunistic' changes are made coincident to the fix. The text approach can accommodate this, at a cost to precision, because, as currently specified, it returns all possible origins. \u2022 Unrelated changes made between the origin and the fix often caused incorrect resultsthis is a particularly difficult issue for both approaches. \u2022 Both approaches became less accurate as more versions passed between the bug origin and the fix, although, in the systems studied, most bugs were fixed soon after their origin. \u2022 Most bugs required changes to only a few files; bugs which required many changes could often not be resolved, particularly those where the fixes involved multiple files. \u2022 The dependence approach is sensitive to the definition of program (and system) dependence graph used. It is not clear that one particular definition will consistently provide the best results. Nor is it clear that inter-procedural dependence provides benefits that outweigh the associated complexity and, likely, high execution time.\n\n\u2022 The text approach, as originally defined, cannot cope with bug fixes that only add code.\n\n\u2022 Bug fixes that modify the context of the origin rather than the same lines as the origin are more likely to mislead the text approach than the dependence approach.\n\nThere are a number of threats to these findings mainly concerned with the manual simulation of the approaches by one individual applied to only three case studies and involving a relatively small number of bugs. However, the fact that the key findings listed previously were repeatedly discovered across different bugs and the different systems, supported by a documented, repeatable research procedure should provide confidence in these results.\n\nThe level of precision and recall discovered for the systems studied would seem reasonable for some applications, especially if it is sufficient to return a relatively small set of files which is likely to contain the bug origin. Other applications may demand higher levels of precision and recall, and to investigate this, a number of refinements were identified and their impact explored by the manual application of the techniques on a small range of previously examined bugs. The findings of this detailed analysis were as follows:\n\n\u2022 The two approaches may be used together and, along with the suggested improvements, combined in various ways. The authors of the dependence approach [3] suggested that dependence might be followed by text when there were no altered dependences. The research here also suggests that it is likely to be more efficient and only marginally less effective to apply text first and then dependence. Alternatively, both approaches might be applied simultaneously and results determined based on either the union or intersection of their results. \u2022 The dependence approach, as originally defined, only returns one potential origin, the most recent.\n\nWhen it works as intended, this will help precision; however, the bug fixes studied here suggest this is often unlikely. If high recall is important, then the dependence approach should be altered to return a range of possible origins. This is a relatively simple extension (although there is the cost of the additional dependence analysis), but one which yielded noticeable benefits in the analysis of improvements. \u2022 A fundamental weakness of the text approach, as originally defined, is that it cannot deal with fixes that only add code. A simple extension to the text approach which considered the enclosing block to be the subject of a change proved very effective on the small number of bugs examined in detail. \u2022 Extending the dependence approach to include all dependences within the SDG does not appear to be worthwhile from this limited study. Widening the strategy to include references to class-level state may be worthwhile but needs further investigation.\n\nThis research has also identified a number of other refinements that may be worth exploring, either manually using the procedure adopted here or via an implementation:\n\n\u2022 Both approaches, as well as potential refinements, are misled by unrelated changes made simultaneous to the bug fix. In an environment where automatic discovery of bug origins was of some importance, it would help if developers submitted bug fixes and other changes in distinct commits. \u2022 More ambitiously, precision may be improved by exploring techniques which could distinguish changes that had semantic impact and disregarded syntactic only change (part of the motivation for the dependence approach). \u2022 A further refinement is to ignore bug fixes that involve multiple files, which causes problems for both approaches. However, this would mean disregarding a well-defined category of bugs potentially skewing further bug-related analyses. \u2022 Finally, there is very good potential to improve the approaches by involving users in the process.\n\nRelatively easily, users could quickly eliminate changes in the bug fix files that are clearly not associated with the fix. Similarly, as the search for the origin proceeds, the user could interactively exclude versions that are clearly not the source of the bug.\n\nTo conclude, there is scope for further research in this area prior to experimenting with fullyfunctional implementations of the approaches. The refinements identified could be manually explored following the research procedure adopted in this study, although experience tells us that this is a time-consuming activity and any larger-scale analysis is best supported by some form of implementation. If the dependence approach is to be pursued, then further work is required to methodically explore the range of possible program and SDGs (although the initial findings here suggest that this is best investigated incrementally, rather than starting with a full-blown SDG implementation), and the precise definition of change to data and control dependences, and their potential impact. Finally, if these refinements are to be pursued, then the case studies used here -Eclipse, Rachota and jEditare useful starting points, but there would also be value in exploring other systems and their bugs to ensure consistency of findings and to aid the longer term understanding of the bug life cycle.\n\n*\nCorrespondence to: Steven Davies, Computer and Information Sciences, University of Strathclyde, Glasgow, UK.\n\nFigure 1 .\n1Eclipse Bug 63216 -NewProgressViewer.java. Names and formatting altered for clarity. COMPARING APPROACHES FOR DETERMINING BUG ORIGINS\n\nFigure 2 .\n2Eclipse Bug 66653 -DecorationBuilder.java. Names and formatting altered for clarity.\n\nFigure 3 .\n3Program dependence graph for DecorationBuilder.java v1.7(Figure 2).\n\nFigure\nFigure 4 also shows that a new line 2 has been introduced, with two new corresponding control dependences and a new data dependence from line 1 to line 2. As discussed, the approach prioritises removed dependences, but if no dependences had been removed, the approach would have built PDGs for preceding versions until it found the most recent one that altered either the source or target line of any of the new dependences. The dependence approach returns only a single version, the most recent version involved. The original rationale for this was that if multiple dependences were involved in a fix, each of which was added at a separate time, then the bug would not have actually exhibited itself until the last of these was added. This is in contrast to the text approach, where multiple versions can be returned, potentially a different one for each line in the fix. The rationale for this is that each line contributed to the bug initially. Both of these could be considered valid interpretations of the origin of the bug, but it should be noted that these assumptions are not actually inherent to the approaches in question. Either approach could be modified to return a single or multiple versions. This work uses the decision of Sinha et al. [3], taking the last change involved to have been the one that introduced the bug. Note, however, that one bug report does not necessarily equate to one bug, and so for a single bug report, there can still be multiple versions in which a bug was introduced. The dependence approach is not appropriate for all bugs. Using the approach described here, the bug fix in Figure 1 would not result in any change to the method's dependences. The approach could not therefore identify the origin of the bug.\n\nFigure 5 .\n5Bug summary relating Bugzilla description to Apache Subversion revision.\n\nFigure 6 .\n6Bugzilla: description for bug 1965114.\n\nFigure 7 .\n7ViewVC: Apache Subversion revision description for 'fix' to bug 1965114. COMPARING APPROACHES FOR DETERMINING BUG ORIGINS\n\nFigure 9 .\n9ViewVC: annotated revision viewthe numbers in column 3 are hyperlinks to the last revisions that modified the lines in column 1.\n\nFigure 10 .\n10ViewVC: code containing bug 1965114 was added in revision 7998. COMPARING APPROACHES FOR DETERMINING BUG ORIGINS\n\nFigure 11 .\n11PDGs for VFSDirectoryEntryTable.getSelectedFiles().\n\nFigure 12 .\n12ViewVC: difference between revisions 12671 and 12672 in jEdit (corresponding PDGs shown in\n\n\n4.3.1. Graph matching, multiple bugs, age of origin and large fixes. Eclipse Bug 49561 -'Commit should only lock parent's folder' Some bugs demonstrated a wide range of issues.\n\n\n50549 -'[Dialogs] Pref Page Workbench/Keys/Advanced does not use dialog font'\n\nFigure 14 .\n14Effect on F of ignoring fixes more than a given number of revisions after origin (Eclipse).\n\nFigure 15 .\n15Performance of different sized fixes (Eclipse). COMPARING APPROACHES FOR DETERMINING BUG ORIGINS\n\n\u2022\nReturn just the most recent revision taking into account any extra revisions identified from considering the impact of additions. \u2022 Return just the largest revision taking into account any extra revisions identified from considering the impact of additions.\n\nTable I .\nI8 jEdit bugs. Bug 1965114shortcut to create a new file in VFSBroswer is n rather than Ctrl + n Origin Revision 7998 -Shortcut code originally added TA Nine revisions including 7998 DA Revision 9596 Notes Text approach identifies many revisions due to multiple opportunistic changes in bug fix file. Subtle questions raised for dependence approach: do type and generic type parameter changes cause program dependence graph (PDG) changes? Notes Bug caused by change in context which misleads text approach. No change to data/control dependences in actual fix but changes elsewhere mislead dependence approach. Notes Intervening changes between origin and fix cause difficulties for both approaches. Fix includes changes to multiple filesone file relevant, one not. Bug 1600401long lines cause editor to hang when enter pressed on them. Origin Revision 8103 where the original condition added without length check TA Revision 8107 DA Nothing Notes Intervening change causes difficulty for text approach. Questions raised about dependence approach: if adding conjunct to if-statement causes control change, then it finds the wrong revision; if data change only then finds correct revision Bug 1571629issue with filtering files in Windows, looks like was a problem with Windows from original Origin Revision 6808problem with Windows OS since beginning TA Revision 6808 DA Revision 6808 Notes Good example of both approaches performing correctlyall changes lead to origin. Bug 1548902formatting empty paragraph throws exception, size is not checked changing StringBuffer to StringBuilder, mean that text approach gathers many revisions. Dependence approach depends on PDG subtletiestype change gets wrong revision, otherwise correct. Bug 1542026manipulating menus using keyboardcharacters going into text file.Bug \n1584436 -off-by-one error, local variable i should have been decremented \nOrigin \nRevision 5216 -updated one use of i but not the others \nTA \nRevision 5173 \nDA \nRevision 5173 \nBug \n1834620 -lexer problem -only seems to recognise one character after $ \nOrigin \nRevision 4826 -original functionality added here \nTA \nNothing \nDA \nRevision 4826 \nNotes \nText approach cannot deal with only added code. For dependence approach, data and control changes \nboth lead to origin. \n\nBug \n1541372 -caret positioning on text folding. \nOrigin \nRevision 3791 -functionality introduced \nTA \nFour revisions including 3791 \nDA \nRevision 4567 \nOrigin \nRevision 5196 -move caret position introduced \nTA \nMany revisions including 5196 \nDA \nRevision 5324 \nNotes \nOpportunistic changes, Origin \nRevision 5114 -original coded added \nTA \nNothing \nDA \nRevision 5114 \nNotes \n\n\nTable III .\nIIIOverall results.TP \nFP \nFN \nP \nR \nF \n\nEclipse \nTA \n91 \n220 \n100 \n0.29 \n0.48 \n0.36 \nDA \n77 \n98 \n114 \n0.44 \n0.40 \n0.42 \nRachota \nTA \n89 \n39 \n38 \n0.70 \n0.70 \n0.70 \nDA \n85 \n23 \n42 \n0.79 \n0.67 \n0.72 \n\nTP, true positives; FP, false positives; FN, false negatives; P, precision; R recall; F, F 1 -Score; TA, text approach; \nDA, dependence approach. \n\n\n\nTable II .\nIICount of commits by classification of origin.Eclipse \nRachota \n\nSingle \n161 \n88 \nMultiple \n19 \n21 \nRelated \n57 \n6 \nElsewhere \n6 \n1 \nUnrelated \n38 \n14 \nUnclear \n20 \n0 \n\nTotal \n301 \n130 \n4.3.1.4. Large fixes. \n\nTable IV .\nIVResults by origin (Eclipse).TA \nDA \n\nTP \nFP \nFN \nTP \nFP \nFN \n\nSingle \n79 \n75 \n82 \n73 \n41 \n88 \nMultiple \n12 \n5 \n18 \n4 \n4 \n26 \nRelated \n0 \n88 \n0 \n0 \n29 \n0 \nElsewhere \n0 \n10 \n0 \n0 \n4 \n0 \nUnrelated \n0 \n42 \n0 \n0 \n20 \n0 \n\nTA, text approach; DA, dependence approach; TP, true positives; FP, false positives; FN, false negatives. \n\nCOMPARING APPROACHES FOR DETERMINING BUG ORIGINS \n\n\nTable V .\nVCombining approaches.TP \nFP \nFN \nP \nR \nF \n\nEclipse \nTA \n91 \n220 \n100 \n0.29 \n0.48 \n0.36 \nTA, DA \n116 \n231 \n75 \n0.33 \n0.61 \n0.43 \nDA \n77 \n98 \n114 \n0.44 \n0.40 \n0.42 \nDA, TA \n96 \n127 \n95 \n0.43 \n0.50 \n0.46 \n\nRachota \nTA \n89 \n39 \n38 \n0.70 \n0.70 \n0.70 \nTA, DA \n109 \n43 \n18 \n0.72 \n0.86 \n0.78 \nDA \n85 \n23 \n42 \n0.79 \n0.67 \n0.72 \nDA, TA \n95 \n34 \n32 \n0.74 \n0.75 \n0.74 \n\nTP, true positives; FP, false positives; FN, false negatives; P, precision; R recall; F, S 1 -Score; TA, text approach; \nDA, dependence approach. \n\n\nTable VI .\nVICommits classified by number of true and false positives for text approach (Eclipse).COMPARING APPROACHES FOR DETERMINING BUG ORIGINS \n\n\nTable VII .\nVIIReturning single version for text approach (Eclipse).TP \nFP \nFN \nP \nR \nF \n\nTA \n91 \n220 \n100 \n0.29 \n0.48 \n0.36 \nMajority of lines \n75 \n103 \n116 \n0.42 \n0.39 \n0.41 \nMost recent \n66 \n112 \n125 \n0.37 \n0.35 \n0.36 \n\nTP, true positives; FP, false positives; FN, false negatives; P, precision; R recall; F, S 1 -Score; TA, text approach. \n\n\n\nTable VIII .\nVIIINumber of files per bug (Eclipse).Number of bugs \nNumber of bugs \n\n\n\nTable X .\nXF-Scores for text approach modifications (lighter grey indicates improvement, darker grey indicates deterioration).\nACKNOWLEDGMENTSThis work was supported by the Engineering and Physical Sciences Research Council (grant number EP/P505747/1). We would like to thank the anonymous reviewers for their constructive comments.\nMaintaining mental models: a study of developer work habits. T Latoza, G Venolia, R Deline, 10.1145/1134285.1134355Proc. ICSE. ICSELaToza T, Venolia G, DeLine R. Maintaining mental models: a study of developer work habits. In Proc. ICSE, 2006. DOI:10.1145/1134285.1134355.\n\nWhen do changes induce fixes?. J \u015aliwerski, T Zimmermann, A Zeller, Proc. MSR. MSR\u015aliwerski J, Zimmermann T, Zeller A. When do changes induce fixes? In Proc. MSR, 2005.\n\nBUGINNINGS: identifying the origins of a bug. V Sinha, S Sinha, S Rao, Proc. ISEC. ISECSinha V, Sinha S, Rao S. BUGINNINGS: identifying the origins of a bug. In Proc. ISEC, 2010.\n\nFair and balanced?: bias in bug-fix datasets. C Bird, A Bachmann, E Aune, J Duffy, A Bernstein, V Filkov, P Devanbu, Proc. ESEC/FSE. ESEC/FSEBird C, Bachmann A, Aune E, Duffy J, Bernstein A, Filkov V, Devanbu P. Fair and balanced?: bias in bug-fix datasets. In Proc. ESEC/FSE, 2009.\n\nRecovering traceability links between source code and fixed bugs via patch analysis. C Corley, N Kraft, L Etzkorn, S Lukins, Proc. TEFSE. TEFSECorley C, Kraft N, Etzkorn L, Lukins S. Recovering traceability links between source code and fixed bugs via patch analysis. In Proc. TEFSE, 2011.\n\nPopulating a Release History Database from version control and bug tracking systems. M Fischer, M Pinzger, H Gall, 10.1109/ICSM.2003.1235403Proc. ICSM. ICSMFischer M. Pinzger M, Gall H. Populating a Release History Database from version control and bug tracking systems. In Proc. ICSM, 2003. DOI:10.1109/ICSM.2003.1235403.\n\nAutomatic identification of bug-introducing changes. S Kim, T Zimmermann, K Pan, E J WhiteheadJr, Proc. ASE. ASEKim S, Zimmermann T, Pan K, Whitehead Jr EJ. Automatic identification of bug-introducing changes. In Proc. ASE, 2006.\n\nThe program dependence graph in a software development environment. K Ottenstein, L Ottenstein, ACM Sigplan Notices. 195Ottenstein K, Ottenstein L. The program dependence graph in a software development environment. ACM Sigplan Notices 1984; 19(5): 177-184.\n\nInterprocedural slicing using dependence graphs. S Horwitz, T Reps, D Binkley, ACM Transactions on Programming Languages and Systems. 121Horwitz S, Reps T, Binkley D. Interprocedural slicing using dependence graphs. ACM Transactions on Programming Languages and Systems 1990; 12(1): 229-243.\n\nSlicing object-oriented software. L Larsen, M Harrold, Proc. ICSE. ICSELarsen L, Harrold M. Slicing object-oriented software. In Proc. ICSE, 1996.\n\nSlicing objects using system dependence graphs. D Liang, M Harrold, Proc. ICSM. ICSMLiang D, Harrold M. Slicing objects using system dependence graphs. In Proc. ICSM, 1998.\n\nStatic slicing of java programs. G Kov\u00e1cs, F Magyar, T Gyim\u00f3thy, Technical ReportKov\u00e1cs G, Magyar F, Gyim\u00f3thy T. Static slicing of java programs. Technical Report December, 1996.\n\nApplying program dependence analysis to Java software. J Zhao, Proceedings of Workshop on Software Engineering and Database. Workshop on Software Engineering and DatabaseZhao J. Applying program dependence analysis to Java software. In Proceedings of Workshop on Software Engineering and Database, 1998.\n\nThe Java system dependence graph. N Walkinshaw, M Roper, M Wood, Proc. SCAM. SCAMWalkinshaw N, Roper M, Wood M. The Java system dependence graph. In Proc. SCAM, 2003.\n\nJDiff: a differencing technique and tool for object-oriented programs. T Apiwattanapong, A Orso, M Harrold, 10.1007/s10515-006-0002-0Automated Software Engineering. 141Apiwattanapong T, Orso A, Harrold M. JDiff: a differencing technique and tool for object-oriented programs. Automated Software Engineering 2006; 14(1). DOI:10.1007/s10515-006-0002-0.\n\nEffective static analysis to find concurrency bugs in Java. Z Luo, L Hillis, R Das, Y Qi, 10.1109/SCAM.2010.20Proc. SCAM. SCAMLuo Z, Hillis L, Das R, Qi Y. Effective static analysis to find concurrency bugs in Java. In Proc. SCAM, September 2010. DOI:10.1109/SCAM.2010.20.\n\nSZZ revisited: verifying when changes induce fixes. C Williams, J Spacco, Proc. DEFECTS. DEFECTS21Williams C, Spacco J. SZZ revisited: verifying when changes induce fixes. In Proc. DEFECTS, 2008. 21. [online]Available from: http://www.incava.org/projects/1042574828.\n\nIdentifying static analysis techniques for finding non-fix hunks in fix revisions. Y Jung, H Oh, K Yi, 10.1145/1651309.1651313Proc. DSMM. DSMMJung Y, Oh H, Yi K. Identifying static analysis techniques for finding non-fix hunks in fix revisions. In Proc. DSMM, 2009. DOI:10.1145/1651309.1651313.\n\nSimplifying and isolating failure-inducing input. A Zeller, R Hildebrandt, IEEE TSE. 282Zeller A, Hildebrandt R. Simplifying and isolating failure-inducing input. IEEE TSE 2002; 28(2): 183-200.\n\nIterative delta debugging. C Artho, 10.1007/978-3-642-01702-5_13LNCS. 5394Artho C. Iterative delta debugging. LNCS 2009; 5394. DOI:10.1007/978-3-642-01702-5_13.\n\nAn analysis of errors and their causes in system programs. A Endres, 10.1145/390016.808455ACM SIGPLAN Notices. 106Endres A. An analysis of errors and their causes in system programs. ACM SIGPLAN Notices 1975; 10(6). DOI:10.1145/390016.808455.\n\nSoftware errors and complexity: an empirical investigation. V Basili, B Perricone, DOI:10.1145/ 69605.2085CACM. 271Basili V, Perricone B. Software errors and complexity: an empirical investigation. CACM 1984; 27(1). DOI:10.1145/ 69605.2085.\n\nA comparison of software defects in database management systems and operating systems. M Sullivan, R Chillarege, 10.1109/FTCS.1992.243586FTCS-22. Digest of Papers. Sullivan M, Chillarege R. A comparison of software defects in database management systems and operating systems. In FTCS-22. Digest of Papers., 1992. DOI:10.1109/FTCS.1992.243586.\n\nAn empirical study of operating systems errors. A Chou, J Yang, B Chelf, S Hallem, D Engler, 10.1145/502034.502042Proc. SOSP. SOSP5Chou A, Yang J, Chelf B, Hallem S, Engler D. An empirical study of operating systems errors. In Proc. SOSP, 2001 5. DOI:10.1145/502034.502042.\n\nHATARI: raising risk awareness. T Zimmermann, A Zeller, DOI:10.1145/ 1095430.1081725Proc. ESEC/FSE, 2005. ESEC/FSE, 2005Zimmermann T, Zeller A. HATARI: raising risk awareness. In Proc. ESEC/FSE, 2005. DOI:10.1145/ 1095430.1081725.\n\nPredicting faults from cached history. S Kim, T Zimmermann, Whitehead EjJr, A Zeller, 10.1109/ICSE.2007.66Proc. ICSE. ICSEKim S, Zimmermann T, Whitehead Jr. EJ, Zeller A. Predicting faults from cached history. In Proc. ICSE, May 2007. DOI:10.1109/ICSE.2007.66.\n\nPROMISE Repository of empirical software engineering data. G Boetticher, T Menzies, T Ostrand, Boetticher G, Menzies T, Ostrand T. PROMISE Repository of empirical software engineering data, 2007. Available from: http://promisedata.org/?p=17.\n\nFeature location in source code: a taxonomy and survey. B Dit, M Revelle, M Gethers, D Poshyvanyk, 10.1002/smr.567JSME. Dit B, Revelle M, Gethers M, Poshyvanyk D. Feature location in source code: a taxonomy and survey. JSME, November 2011. DOI:10.1002/smr.567.\n\nChange distilling: tree differencing for fine-grained source code change extraction. B Fluri, M Wuersch, M Pinzger, H Gall, 10.1109/TSE.2007.70731IEEE TSE. 3311Fluri B, Wuersch M, Pinzger M, Gall H. Change distilling: tree differencing for fine-grained source code change extraction. IEEE TSE 2007; 33(11). DOI:10.1109/TSE.2007.70731.\n\nMining version histories to guide software changes. T Zimmermann, P Wei\u00dfgerber, S Diehl, A Zeller, 10.1109/TSE.2005.72IEEE TSE. 631Zimmermann T, Wei\u00dfgerber P, Diehl S, Zeller A. Mining version histories to guide software changes. IEEE TSE 2005; 31(6). DOI:10.1109/TSE.2005.72.\n", "annotations": {"author": "[{\"end\":177,\"start\":92},{\"end\":260,\"start\":178},{\"end\":344,\"start\":261}]", "publisher": null, "author_last_name": "[{\"end\":105,\"start\":99},{\"end\":188,\"start\":183},{\"end\":272,\"start\":268}]", "author_first_name": "[{\"end\":98,\"start\":92},{\"end\":182,\"start\":178},{\"end\":267,\"start\":261}]", "author_affiliation": "[{\"end\":176,\"start\":107},{\"end\":259,\"start\":190},{\"end\":343,\"start\":274}]", "title": "[{\"end\":89,\"start\":1},{\"end\":433,\"start\":345}]", "venue": null, "abstract": "[{\"end\":2922,\"start\":624}]", "bib_ref": "[{\"attributes\":{\"ref_id\":\"b0\"},\"end\":3032,\"start\":3029},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":4659,\"start\":4656},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":4778,\"start\":4775},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":7906,\"start\":7903},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":7989,\"start\":7986},{\"attributes\":{\"ref_id\":\"b3\"},\"end\":7991,\"start\":7989},{\"attributes\":{\"ref_id\":\"b4\"},\"end\":8188,\"start\":8185},{\"attributes\":{\"ref_id\":\"b5\"},\"end\":9475,\"start\":9472},{\"attributes\":{\"ref_id\":\"b3\"},\"end\":9609,\"start\":9606},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":10037,\"start\":10034},{\"attributes\":{\"ref_id\":\"b6\"},\"end\":10973,\"start\":10970},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":11602,\"start\":11599},{\"attributes\":{\"ref_id\":\"b7\"},\"end\":11886,\"start\":11883},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":14950,\"start\":14947},{\"attributes\":{\"ref_id\":\"b8\"},\"end\":15629,\"start\":15626},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":17385,\"start\":17381},{\"attributes\":{\"ref_id\":\"b10\"},\"end\":17424,\"start\":17420},{\"attributes\":{\"ref_id\":\"b11\"},\"end\":17459,\"start\":17455},{\"attributes\":{\"ref_id\":\"b12\"},\"end\":17473,\"start\":17469},{\"attributes\":{\"ref_id\":\"b13\"},\"end\":17531,\"start\":17527},{\"attributes\":{\"ref_id\":\"b14\"},\"end\":19236,\"start\":19232},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":19305,\"start\":19302},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":20103,\"start\":20100},{\"end\":20511,\"start\":20507},{\"attributes\":{\"ref_id\":\"b15\"},\"end\":20603,\"start\":20599},{\"attributes\":{\"ref_id\":\"b16\"},\"end\":21330,\"start\":21326},{\"end\":21413,\"start\":21409},{\"attributes\":{\"ref_id\":\"b6\"},\"end\":21753,\"start\":21750},{\"attributes\":{\"ref_id\":\"b17\"},\"end\":21779,\"start\":21775},{\"attributes\":{\"ref_id\":\"b18\"},\"end\":22406,\"start\":22402},{\"attributes\":{\"ref_id\":\"b19\"},\"end\":22624,\"start\":22620},{\"attributes\":{\"ref_id\":\"b20\"},\"end\":22914,\"start\":22910},{\"attributes\":{\"ref_id\":\"b21\"},\"end\":22918,\"start\":22914},{\"attributes\":{\"ref_id\":\"b22\"},\"end\":22922,\"start\":22918},{\"attributes\":{\"ref_id\":\"b23\"},\"end\":23093,\"start\":23089},{\"attributes\":{\"ref_id\":\"b24\"},\"end\":23532,\"start\":23528},{\"attributes\":{\"ref_id\":\"b25\"},\"end\":23999,\"start\":23995},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":24403,\"start\":24400},{\"end\":25518,\"start\":25514},{\"attributes\":{\"ref_id\":\"b26\"},\"end\":25583,\"start\":25579},{\"end\":26299,\"start\":26295},{\"attributes\":{\"ref_id\":\"b27\"},\"end\":26900,\"start\":26896},{\"attributes\":{\"ref_id\":\"b27\"},\"end\":28730,\"start\":28726},{\"end\":28847,\"start\":28843},{\"end\":28863,\"start\":28859},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":37858,\"start\":37855},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":62252,\"start\":62249},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":67041,\"start\":67038},{\"attributes\":{\"ref_id\":\"b14\"},\"end\":67103,\"start\":67099},{\"attributes\":{\"ref_id\":\"b28\"},\"end\":67436,\"start\":67432},{\"attributes\":{\"ref_id\":\"b6\"},\"end\":70713,\"start\":70710},{\"attributes\":{\"ref_id\":\"b17\"},\"end\":71745,\"start\":71741},{\"attributes\":{\"ref_id\":\"b6\"},\"end\":72576,\"start\":72573},{\"attributes\":{\"ref_id\":\"b29\"},\"end\":91280,\"start\":91276},{\"attributes\":{\"ref_id\":\"b3\"},\"end\":92181,\"start\":92178},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":97942,\"start\":97939}]", "figure": "[{\"attributes\":{\"id\":\"fig_0\"},\"end\":101886,\"start\":101775},{\"attributes\":{\"id\":\"fig_1\"},\"end\":102033,\"start\":101887},{\"attributes\":{\"id\":\"fig_2\"},\"end\":102131,\"start\":102034},{\"attributes\":{\"id\":\"fig_3\"},\"end\":102212,\"start\":102132},{\"attributes\":{\"id\":\"fig_4\"},\"end\":103971,\"start\":102213},{\"attributes\":{\"id\":\"fig_5\"},\"end\":104057,\"start\":103972},{\"attributes\":{\"id\":\"fig_6\"},\"end\":104109,\"start\":104058},{\"attributes\":{\"id\":\"fig_7\"},\"end\":104244,\"start\":104110},{\"attributes\":{\"id\":\"fig_8\"},\"end\":104386,\"start\":104245},{\"attributes\":{\"id\":\"fig_9\"},\"end\":104514,\"start\":104387},{\"attributes\":{\"id\":\"fig_10\"},\"end\":104581,\"start\":104515},{\"attributes\":{\"id\":\"fig_11\"},\"end\":104687,\"start\":104582},{\"attributes\":{\"id\":\"fig_12\"},\"end\":104866,\"start\":104688},{\"attributes\":{\"id\":\"fig_13\"},\"end\":104946,\"start\":104867},{\"attributes\":{\"id\":\"fig_14\"},\"end\":105053,\"start\":104947},{\"attributes\":{\"id\":\"fig_15\"},\"end\":105165,\"start\":105054},{\"attributes\":{\"id\":\"fig_16\"},\"end\":105426,\"start\":105166},{\"attributes\":{\"id\":\"tab_0\",\"type\":\"table\"},\"end\":108095,\"start\":105427},{\"attributes\":{\"id\":\"tab_1\",\"type\":\"table\"},\"end\":108456,\"start\":108096},{\"attributes\":{\"id\":\"tab_2\",\"type\":\"table\"},\"end\":108678,\"start\":108457},{\"attributes\":{\"id\":\"tab_3\",\"type\":\"table\"},\"end\":109067,\"start\":108679},{\"attributes\":{\"id\":\"tab_4\",\"type\":\"table\"},\"end\":109585,\"start\":109068},{\"attributes\":{\"id\":\"tab_5\",\"type\":\"table\"},\"end\":109735,\"start\":109586},{\"attributes\":{\"id\":\"tab_6\",\"type\":\"table\"},\"end\":110082,\"start\":109736},{\"attributes\":{\"id\":\"tab_7\",\"type\":\"table\"},\"end\":110168,\"start\":110083},{\"attributes\":{\"id\":\"tab_8\",\"type\":\"table\"},\"end\":110296,\"start\":110169}]", "paragraph": "[{\"end\":5278,\"start\":2938},{\"end\":6653,\"start\":5280},{\"end\":6870,\"start\":6711},{\"end\":7291,\"start\":6872},{\"end\":7807,\"start\":7293},{\"end\":8230,\"start\":7809},{\"end\":8324,\"start\":8232},{\"end\":8635,\"start\":8326},{\"end\":9123,\"start\":8637},{\"end\":10698,\"start\":9125},{\"end\":10974,\"start\":10716},{\"end\":11551,\"start\":10976},{\"end\":12873,\"start\":11575},{\"end\":14117,\"start\":12875},{\"end\":14901,\"start\":14119},{\"end\":15204,\"start\":14903},{\"end\":15446,\"start\":15206},{\"end\":16685,\"start\":15468},{\"end\":17618,\"start\":16687},{\"end\":17807,\"start\":17620},{\"end\":19663,\"start\":17809},{\"end\":20224,\"start\":19665},{\"end\":21218,\"start\":20226},{\"end\":22759,\"start\":21246},{\"end\":23446,\"start\":22761},{\"end\":24272,\"start\":23448},{\"end\":25413,\"start\":24287},{\"end\":26240,\"start\":25426},{\"end\":26805,\"start\":26242},{\"end\":27944,\"start\":26807},{\"end\":28334,\"start\":27946},{\"end\":28577,\"start\":28373},{\"end\":28970,\"start\":28579},{\"end\":29492,\"start\":28972},{\"end\":29926,\"start\":29494},{\"end\":30134,\"start\":29928},{\"end\":30514,\"start\":30161},{\"end\":31251,\"start\":30516},{\"end\":31793,\"start\":31253},{\"end\":32200,\"start\":31795},{\"end\":32556,\"start\":32202},{\"end\":33506,\"start\":32575},{\"end\":33872,\"start\":33508},{\"end\":34965,\"start\":33874},{\"end\":36036,\"start\":34990},{\"end\":36542,\"start\":36038},{\"end\":36967,\"start\":36544},{\"end\":37901,\"start\":36969},{\"end\":38984,\"start\":37903},{\"end\":39785,\"start\":38986},{\"end\":40418,\"start\":39787},{\"end\":40606,\"start\":40443},{\"end\":41918,\"start\":40638},{\"end\":41987,\"start\":41920},{\"end\":42074,\"start\":41989},{\"end\":42554,\"start\":42076},{\"end\":42918,\"start\":42556},{\"end\":42963,\"start\":42920},{\"end\":44744,\"start\":43009},{\"end\":45980,\"start\":44746},{\"end\":46470,\"start\":45982},{\"end\":46893,\"start\":46506},{\"end\":47110,\"start\":46895},{\"end\":50421,\"start\":47112},{\"end\":51197,\"start\":50423},{\"end\":52249,\"start\":51220},{\"end\":52541,\"start\":52251},{\"end\":53387,\"start\":52584},{\"end\":54019,\"start\":53417},{\"end\":54496,\"start\":54021},{\"end\":55322,\"start\":54498},{\"end\":55886,\"start\":55324},{\"end\":59035,\"start\":55909},{\"end\":59124,\"start\":59047},{\"end\":59725,\"start\":59126},{\"end\":60926,\"start\":59752},{\"end\":61053,\"start\":60928},{\"end\":61117,\"start\":61055},{\"end\":61166,\"start\":61119},{\"end\":61209,\"start\":61168},{\"end\":61273,\"start\":61211},{\"end\":61463,\"start\":61275},{\"end\":62093,\"start\":61483},{\"end\":62711,\"start\":62095},{\"end\":63789,\"start\":62713},{\"end\":64445,\"start\":63791},{\"end\":65026,\"start\":64447},{\"end\":65289,\"start\":65028},{\"end\":66614,\"start\":65319},{\"end\":66899,\"start\":66616},{\"end\":68160,\"start\":66901},{\"end\":68846,\"start\":68180},{\"end\":69938,\"start\":68848},{\"end\":70335,\"start\":69960},{\"end\":70714,\"start\":70337},{\"end\":71560,\"start\":70716},{\"end\":72207,\"start\":71562},{\"end\":73054,\"start\":72225},{\"end\":73367,\"start\":73056},{\"end\":74379,\"start\":73391},{\"end\":75016,\"start\":74381},{\"end\":76142,\"start\":75055},{\"end\":76183,\"start\":76144},{\"end\":76549,\"start\":76185},{\"end\":76635,\"start\":76551},{\"end\":76729,\"start\":76637},{\"end\":76933,\"start\":76731},{\"end\":77044,\"start\":76935},{\"end\":78525,\"start\":77046},{\"end\":78870,\"start\":78527},{\"end\":79604,\"start\":78872},{\"end\":81035,\"start\":79606},{\"end\":84159,\"start\":81060},{\"end\":84981,\"start\":84161},{\"end\":85163,\"start\":85015},{\"end\":85340,\"start\":85165},{\"end\":85498,\"start\":85342},{\"end\":86814,\"start\":85500},{\"end\":87666,\"start\":86834},{\"end\":88515,\"start\":87668},{\"end\":88950,\"start\":88539},{\"end\":89802,\"start\":88952},{\"end\":90716,\"start\":89804},{\"end\":91281,\"start\":90718},{\"end\":92322,\"start\":91283},{\"end\":92942,\"start\":92324},{\"end\":93596,\"start\":92944},{\"end\":94435,\"start\":93612},{\"end\":95263,\"start\":94437},{\"end\":95329,\"start\":95265},{\"end\":96542,\"start\":95331},{\"end\":96634,\"start\":96544},{\"end\":96801,\"start\":96636},{\"end\":97249,\"start\":96803},{\"end\":97786,\"start\":97251},{\"end\":98429,\"start\":97788},{\"end\":99400,\"start\":98431},{\"end\":99569,\"start\":99402},{\"end\":100417,\"start\":99571},{\"end\":100682,\"start\":100419},{\"end\":101774,\"start\":100684}]", "formula": null, "table_ref": "[{\"attributes\":{\"ref_id\":\"tab_0\"},\"end\":41031,\"start\":41024},{\"attributes\":{\"ref_id\":\"tab_0\"},\"end\":41452,\"start\":41445},{\"attributes\":{\"ref_id\":\"tab_0\"},\"end\":43403,\"start\":43395},{\"attributes\":{\"ref_id\":\"tab_0\"},\"end\":45214,\"start\":45205},{\"attributes\":{\"ref_id\":\"tab_0\"},\"end\":49762,\"start\":49753},{\"attributes\":{\"ref_id\":\"tab_0\"},\"end\":51112,\"start\":51104},{\"attributes\":{\"ref_id\":\"tab_4\"},\"end\":63112,\"start\":63105},{\"attributes\":{\"ref_id\":\"tab_0\"},\"end\":68514,\"start\":68506},{\"attributes\":{\"ref_id\":\"tab_0\"},\"end\":69325,\"start\":69316},{\"attributes\":{\"ref_id\":\"tab_0\"},\"end\":71336,\"start\":71327},{\"attributes\":{\"ref_id\":\"tab_0\"},\"end\":72643,\"start\":72633}]", "section_header": "[{\"attributes\":{\"n\":\"1.\"},\"end\":2936,\"start\":2924},{\"attributes\":{\"n\":\"2.\"},\"end\":6683,\"start\":6656},{\"attributes\":{\"n\":\"2.1.\"},\"end\":6709,\"start\":6686},{\"attributes\":{\"n\":\"2.2.\"},\"end\":10714,\"start\":10701},{\"attributes\":{\"n\":\"2.3.\"},\"end\":11573,\"start\":11554},{\"attributes\":{\"n\":\"2.4.\"},\"end\":15466,\"start\":15449},{\"attributes\":{\"n\":\"2.5.\"},\"end\":21244,\"start\":21221},{\"attributes\":{\"n\":\"3.\"},\"end\":24285,\"start\":24275},{\"attributes\":{\"n\":\"3.1.\"},\"end\":25424,\"start\":25416},{\"attributes\":{\"n\":\"3.2.\"},\"end\":28371,\"start\":28337},{\"attributes\":{\"n\":\"3.2.1.\"},\"end\":30159,\"start\":30137},{\"attributes\":{\"n\":\"3.2.2.\"},\"end\":32573,\"start\":32559},{\"attributes\":{\"n\":\"3.2.3.\"},\"end\":34988,\"start\":34968},{\"attributes\":{\"n\":\"4.\"},\"end\":40441,\"start\":40421},{\"attributes\":{\"n\":\"4.1.\"},\"end\":40636,\"start\":40609},{\"attributes\":{\"n\":\"4.2.\"},\"end\":43007,\"start\":42966},{\"attributes\":{\"n\":\"4.3.\"},\"end\":46504,\"start\":46473},{\"attributes\":{\"n\":\"4.3.2.\"},\"end\":51218,\"start\":51200},{\"attributes\":{\"n\":\"4.3.3.\"},\"end\":52582,\"start\":52544},{\"attributes\":{\"n\":\"4.3.4.\"},\"end\":53415,\"start\":53390},{\"attributes\":{\"n\":\"4.3.5.\"},\"end\":55907,\"start\":55889},{\"attributes\":{\"n\":\"4.4.\"},\"end\":59045,\"start\":59038},{\"attributes\":{\"n\":\"5.\"},\"end\":59750,\"start\":59728},{\"attributes\":{\"n\":\"5.1.\"},\"end\":61481,\"start\":61466},{\"attributes\":{\"n\":\"5.2.\"},\"end\":65317,\"start\":65292},{\"attributes\":{\"n\":\"5.3.\"},\"end\":68178,\"start\":68163},{\"attributes\":{\"n\":\"5.4.\"},\"end\":69958,\"start\":69941},{\"attributes\":{\"n\":\"5.5.\"},\"end\":72223,\"start\":72210},{\"attributes\":{\"n\":\"5.6.\"},\"end\":73389,\"start\":73370},{\"attributes\":{\"n\":\"5.7.\"},\"end\":75053,\"start\":75019},{\"attributes\":{\"n\":\"5.7.3.\"},\"end\":81058,\"start\":81038},{\"attributes\":{\"n\":\"5.7.4.\"},\"end\":85013,\"start\":84984},{\"attributes\":{\"n\":\"5.8.\"},\"end\":86832,\"start\":86817},{\"attributes\":{\"n\":\"6.\"},\"end\":88537,\"start\":88518},{\"attributes\":{\"n\":\"7.\"},\"end\":93610,\"start\":93599},{\"end\":101777,\"start\":101776},{\"end\":101898,\"start\":101888},{\"end\":102045,\"start\":102035},{\"end\":102143,\"start\":102133},{\"end\":102220,\"start\":102214},{\"end\":103983,\"start\":103973},{\"end\":104069,\"start\":104059},{\"end\":104121,\"start\":104111},{\"end\":104256,\"start\":104246},{\"end\":104399,\"start\":104388},{\"end\":104527,\"start\":104516},{\"end\":104594,\"start\":104583},{\"end\":104959,\"start\":104948},{\"end\":105066,\"start\":105055},{\"end\":105168,\"start\":105167},{\"end\":105437,\"start\":105428},{\"end\":108108,\"start\":108097},{\"end\":108468,\"start\":108458},{\"end\":108690,\"start\":108680},{\"end\":109078,\"start\":109069},{\"end\":109597,\"start\":109587},{\"end\":109748,\"start\":109737},{\"end\":110096,\"start\":110084},{\"end\":110179,\"start\":110170}]", "table": "[{\"end\":108095,\"start\":107243},{\"end\":108456,\"start\":108128},{\"end\":108678,\"start\":108516},{\"end\":109067,\"start\":108721},{\"end\":109585,\"start\":109101},{\"end\":109735,\"start\":109685},{\"end\":110082,\"start\":109805},{\"end\":110168,\"start\":110135}]", "figure_caption": "[{\"end\":101886,\"start\":101778},{\"end\":102033,\"start\":101900},{\"end\":102131,\"start\":102047},{\"end\":102212,\"start\":102145},{\"end\":103971,\"start\":102221},{\"end\":104057,\"start\":103985},{\"end\":104109,\"start\":104071},{\"end\":104244,\"start\":104123},{\"end\":104386,\"start\":104258},{\"end\":104514,\"start\":104402},{\"end\":104581,\"start\":104530},{\"end\":104687,\"start\":104597},{\"end\":104866,\"start\":104690},{\"end\":104946,\"start\":104869},{\"end\":105053,\"start\":104962},{\"end\":105165,\"start\":105069},{\"end\":105426,\"start\":105169},{\"end\":107243,\"start\":105439},{\"end\":108128,\"start\":108112},{\"end\":108516,\"start\":108471},{\"end\":108721,\"start\":108693},{\"end\":109101,\"start\":109080},{\"end\":109685,\"start\":109600},{\"end\":109805,\"start\":109752},{\"end\":110135,\"start\":110101},{\"end\":110296,\"start\":110181}]", "figure_ref": "[{\"attributes\":{\"ref_id\":\"fig_1\"},\"end\":9619,\"start\":9611},{\"attributes\":{\"ref_id\":\"fig_2\"},\"end\":11047,\"start\":11039},{\"attributes\":{\"ref_id\":\"fig_2\"},\"end\":12519,\"start\":12511},{\"attributes\":{\"ref_id\":\"fig_3\"},\"end\":12540,\"start\":12532},{\"attributes\":{\"ref_id\":\"fig_2\"},\"end\":12921,\"start\":12913},{\"end\":13166,\"start\":13158},{\"attributes\":{\"ref_id\":\"fig_1\"},\"end\":15321,\"start\":15313},{\"attributes\":{\"ref_id\":\"fig_5\"},\"end\":28969,\"start\":28961},{\"attributes\":{\"ref_id\":\"fig_5\"},\"end\":29006,\"start\":28998},{\"attributes\":{\"ref_id\":\"fig_6\"},\"end\":29050,\"start\":29042},{\"attributes\":{\"ref_id\":\"fig_7\"},\"end\":29125,\"start\":29117},{\"attributes\":{\"ref_id\":\"fig_7\"},\"end\":29533,\"start\":29525},{\"end\":30944,\"start\":30936},{\"attributes\":{\"ref_id\":\"fig_8\"},\"end\":32124,\"start\":32116},{\"attributes\":{\"ref_id\":\"fig_1\"},\"end\":32488,\"start\":32479},{\"end\":34183,\"start\":34175},{\"attributes\":{\"ref_id\":\"fig_1\"},\"end\":34325,\"start\":34316},{\"attributes\":{\"ref_id\":\"fig_1\"},\"end\":36796,\"start\":36787},{\"attributes\":{\"ref_id\":\"fig_1\"},\"end\":36846,\"start\":36837},{\"attributes\":{\"ref_id\":\"fig_1\"},\"end\":38141,\"start\":38132},{\"end\":39065,\"start\":39057},{\"attributes\":{\"ref_id\":\"fig_1\"},\"end\":39260,\"start\":39251},{\"attributes\":{\"ref_id\":\"fig_1\"},\"end\":39783,\"start\":39774},{\"attributes\":{\"ref_id\":\"fig_1\"},\"end\":70903,\"start\":70894},{\"attributes\":{\"ref_id\":\"fig_1\"},\"end\":71349,\"start\":71340},{\"attributes\":{\"ref_id\":\"fig_1\"},\"end\":72654,\"start\":72645}]", "bib_author_first_name": "[{\"end\":110565,\"start\":110564},{\"end\":110575,\"start\":110574},{\"end\":110586,\"start\":110585},{\"end\":110809,\"start\":110808},{\"end\":110822,\"start\":110821},{\"end\":110836,\"start\":110835},{\"end\":110994,\"start\":110993},{\"end\":111003,\"start\":111002},{\"end\":111012,\"start\":111011},{\"end\":111174,\"start\":111173},{\"end\":111182,\"start\":111181},{\"end\":111194,\"start\":111193},{\"end\":111202,\"start\":111201},{\"end\":111211,\"start\":111210},{\"end\":111224,\"start\":111223},{\"end\":111234,\"start\":111233},{\"end\":111497,\"start\":111496},{\"end\":111507,\"start\":111506},{\"end\":111516,\"start\":111515},{\"end\":111527,\"start\":111526},{\"end\":111788,\"start\":111787},{\"end\":111799,\"start\":111798},{\"end\":111810,\"start\":111809},{\"end\":112080,\"start\":112079},{\"end\":112087,\"start\":112086},{\"end\":112101,\"start\":112100},{\"end\":112108,\"start\":112107},{\"end\":112110,\"start\":112109},{\"end\":112326,\"start\":112325},{\"end\":112340,\"start\":112339},{\"end\":112566,\"start\":112565},{\"end\":112577,\"start\":112576},{\"end\":112585,\"start\":112584},{\"end\":112844,\"start\":112843},{\"end\":112854,\"start\":112853},{\"end\":113006,\"start\":113005},{\"end\":113015,\"start\":113014},{\"end\":113165,\"start\":113164},{\"end\":113175,\"start\":113174},{\"end\":113185,\"start\":113184},{\"end\":113367,\"start\":113366},{\"end\":113651,\"start\":113650},{\"end\":113665,\"start\":113664},{\"end\":113674,\"start\":113673},{\"end\":113856,\"start\":113855},{\"end\":113874,\"start\":113873},{\"end\":113882,\"start\":113881},{\"end\":114197,\"start\":114196},{\"end\":114204,\"start\":114203},{\"end\":114214,\"start\":114213},{\"end\":114221,\"start\":114220},{\"end\":114463,\"start\":114462},{\"end\":114475,\"start\":114474},{\"end\":114762,\"start\":114761},{\"end\":114770,\"start\":114769},{\"end\":114776,\"start\":114775},{\"end\":115025,\"start\":115024},{\"end\":115035,\"start\":115034},{\"end\":115197,\"start\":115196},{\"end\":115391,\"start\":115390},{\"end\":115636,\"start\":115635},{\"end\":115646,\"start\":115645},{\"end\":115905,\"start\":115904},{\"end\":115917,\"start\":115916},{\"end\":116211,\"start\":116210},{\"end\":116219,\"start\":116218},{\"end\":116227,\"start\":116226},{\"end\":116236,\"start\":116235},{\"end\":116246,\"start\":116245},{\"end\":116470,\"start\":116469},{\"end\":116484,\"start\":116483},{\"end\":116709,\"start\":116708},{\"end\":116716,\"start\":116715},{\"end\":116738,\"start\":116729},{\"end\":116746,\"start\":116745},{\"end\":116991,\"start\":116990},{\"end\":117005,\"start\":117004},{\"end\":117016,\"start\":117015},{\"end\":117231,\"start\":117230},{\"end\":117238,\"start\":117237},{\"end\":117249,\"start\":117248},{\"end\":117260,\"start\":117259},{\"end\":117522,\"start\":117521},{\"end\":117531,\"start\":117530},{\"end\":117542,\"start\":117541},{\"end\":117553,\"start\":117552},{\"end\":117825,\"start\":117824},{\"end\":117839,\"start\":117838},{\"end\":117853,\"start\":117852},{\"end\":117862,\"start\":117861}]", "bib_author_last_name": "[{\"end\":110572,\"start\":110566},{\"end\":110583,\"start\":110576},{\"end\":110593,\"start\":110587},{\"end\":110819,\"start\":110810},{\"end\":110833,\"start\":110823},{\"end\":110843,\"start\":110837},{\"end\":111000,\"start\":110995},{\"end\":111009,\"start\":111004},{\"end\":111016,\"start\":111013},{\"end\":111179,\"start\":111175},{\"end\":111191,\"start\":111183},{\"end\":111199,\"start\":111195},{\"end\":111208,\"start\":111203},{\"end\":111221,\"start\":111212},{\"end\":111231,\"start\":111225},{\"end\":111242,\"start\":111235},{\"end\":111504,\"start\":111498},{\"end\":111513,\"start\":111508},{\"end\":111524,\"start\":111517},{\"end\":111534,\"start\":111528},{\"end\":111796,\"start\":111789},{\"end\":111807,\"start\":111800},{\"end\":111815,\"start\":111811},{\"end\":112084,\"start\":112081},{\"end\":112098,\"start\":112088},{\"end\":112105,\"start\":112102},{\"end\":112120,\"start\":112111},{\"end\":112337,\"start\":112327},{\"end\":112351,\"start\":112341},{\"end\":112574,\"start\":112567},{\"end\":112582,\"start\":112578},{\"end\":112593,\"start\":112586},{\"end\":112851,\"start\":112845},{\"end\":112862,\"start\":112855},{\"end\":113012,\"start\":113007},{\"end\":113023,\"start\":113016},{\"end\":113172,\"start\":113166},{\"end\":113182,\"start\":113176},{\"end\":113194,\"start\":113186},{\"end\":113372,\"start\":113368},{\"end\":113662,\"start\":113652},{\"end\":113671,\"start\":113666},{\"end\":113679,\"start\":113675},{\"end\":113871,\"start\":113857},{\"end\":113879,\"start\":113875},{\"end\":113890,\"start\":113883},{\"end\":114201,\"start\":114198},{\"end\":114211,\"start\":114205},{\"end\":114218,\"start\":114215},{\"end\":114224,\"start\":114222},{\"end\":114472,\"start\":114464},{\"end\":114482,\"start\":114476},{\"end\":114767,\"start\":114763},{\"end\":114773,\"start\":114771},{\"end\":114779,\"start\":114777},{\"end\":115032,\"start\":115026},{\"end\":115047,\"start\":115036},{\"end\":115203,\"start\":115198},{\"end\":115398,\"start\":115392},{\"end\":115643,\"start\":115637},{\"end\":115656,\"start\":115647},{\"end\":115914,\"start\":115906},{\"end\":115928,\"start\":115918},{\"end\":116216,\"start\":116212},{\"end\":116224,\"start\":116220},{\"end\":116233,\"start\":116228},{\"end\":116243,\"start\":116237},{\"end\":116253,\"start\":116247},{\"end\":116481,\"start\":116471},{\"end\":116491,\"start\":116485},{\"end\":116713,\"start\":116710},{\"end\":116727,\"start\":116717},{\"end\":116741,\"start\":116739},{\"end\":116753,\"start\":116747},{\"end\":117002,\"start\":116992},{\"end\":117013,\"start\":117006},{\"end\":117024,\"start\":117017},{\"end\":117235,\"start\":117232},{\"end\":117246,\"start\":117239},{\"end\":117257,\"start\":117250},{\"end\":117271,\"start\":117261},{\"end\":117528,\"start\":117523},{\"end\":117539,\"start\":117532},{\"end\":117550,\"start\":117543},{\"end\":117558,\"start\":117554},{\"end\":117836,\"start\":117826},{\"end\":117850,\"start\":117840},{\"end\":117859,\"start\":117854},{\"end\":117869,\"start\":117863}]", "bib_entry": "[{\"attributes\":{\"doi\":\"10.1145/1134285.1134355\",\"id\":\"b0\",\"matched_paper_id\":8485237},\"end\":110775,\"start\":110503},{\"attributes\":{\"id\":\"b1\",\"matched_paper_id\":5832984},\"end\":110945,\"start\":110777},{\"attributes\":{\"id\":\"b2\",\"matched_paper_id\":43741178},\"end\":111125,\"start\":110947},{\"attributes\":{\"id\":\"b3\",\"matched_paper_id\":6545957},\"end\":111409,\"start\":111127},{\"attributes\":{\"id\":\"b4\",\"matched_paper_id\":15267734},\"end\":111700,\"start\":111411},{\"attributes\":{\"doi\":\"10.1109/ICSM.2003.1235403\",\"id\":\"b5\",\"matched_paper_id\":17716088},\"end\":112024,\"start\":111702},{\"attributes\":{\"id\":\"b6\",\"matched_paper_id\":14788283},\"end\":112255,\"start\":112026},{\"attributes\":{\"id\":\"b7\",\"matched_paper_id\":17846352},\"end\":112514,\"start\":112257},{\"attributes\":{\"id\":\"b8\",\"matched_paper_id\":2679690},\"end\":112807,\"start\":112516},{\"attributes\":{\"id\":\"b9\",\"matched_paper_id\":806823},\"end\":112955,\"start\":112809},{\"attributes\":{\"id\":\"b10\",\"matched_paper_id\":18160599},\"end\":113129,\"start\":112957},{\"attributes\":{\"id\":\"b11\"},\"end\":113309,\"start\":113131},{\"attributes\":{\"id\":\"b12\",\"matched_paper_id\":2294333},\"end\":113614,\"start\":113311},{\"attributes\":{\"id\":\"b13\",\"matched_paper_id\":5096173},\"end\":113782,\"start\":113616},{\"attributes\":{\"doi\":\"10.1007/s10515-006-0002-0\",\"id\":\"b14\",\"matched_paper_id\":29397709},\"end\":114134,\"start\":113784},{\"attributes\":{\"doi\":\"10.1109/SCAM.2010.20\",\"id\":\"b15\",\"matched_paper_id\":24518526},\"end\":114408,\"start\":114136},{\"attributes\":{\"id\":\"b16\",\"matched_paper_id\":10755249},\"end\":114676,\"start\":114410},{\"attributes\":{\"doi\":\"10.1145/1651309.1651313\",\"id\":\"b17\",\"matched_paper_id\":8363452},\"end\":114972,\"start\":114678},{\"attributes\":{\"id\":\"b18\",\"matched_paper_id\":6302370},\"end\":115167,\"start\":114974},{\"attributes\":{\"doi\":\"10.1007/978-3-642-01702-5_13\",\"id\":\"b19\",\"matched_paper_id\":7497644},\"end\":115329,\"start\":115169},{\"attributes\":{\"doi\":\"10.1145/390016.808455\",\"id\":\"b20\",\"matched_paper_id\":11039900},\"end\":115573,\"start\":115331},{\"attributes\":{\"doi\":\"DOI:10.1145/ 69605.2085\",\"id\":\"b21\",\"matched_paper_id\":208948890},\"end\":115815,\"start\":115575},{\"attributes\":{\"doi\":\"10.1109/FTCS.1992.243586\",\"id\":\"b22\",\"matched_paper_id\":28623643},\"end\":116160,\"start\":115817},{\"attributes\":{\"doi\":\"10.1145/502034.502042\",\"id\":\"b23\",\"matched_paper_id\":1146793},\"end\":116435,\"start\":116162},{\"attributes\":{\"doi\":\"DOI:10.1145/ 1095430.1081725\",\"id\":\"b24\",\"matched_paper_id\":8194569},\"end\":116667,\"start\":116437},{\"attributes\":{\"doi\":\"10.1109/ICSE.2007.66\",\"id\":\"b25\",\"matched_paper_id\":47388286},\"end\":116929,\"start\":116669},{\"attributes\":{\"id\":\"b26\"},\"end\":117172,\"start\":116931},{\"attributes\":{\"doi\":\"10.1002/smr.567\",\"id\":\"b27\",\"matched_paper_id\":7630279},\"end\":117434,\"start\":117174},{\"attributes\":{\"doi\":\"10.1109/TSE.2007.70731\",\"id\":\"b28\",\"matched_paper_id\":13659557},\"end\":117770,\"start\":117436},{\"attributes\":{\"doi\":\"10.1109/TSE.2005.72\",\"id\":\"b29\",\"matched_paper_id\":47037250},\"end\":118048,\"start\":117772}]", "bib_title": "[{\"end\":110562,\"start\":110503},{\"end\":110806,\"start\":110777},{\"end\":110991,\"start\":110947},{\"end\":111171,\"start\":111127},{\"end\":111494,\"start\":111411},{\"end\":111785,\"start\":111702},{\"end\":112077,\"start\":112026},{\"end\":112323,\"start\":112257},{\"end\":112563,\"start\":112516},{\"end\":112841,\"start\":112809},{\"end\":113003,\"start\":112957},{\"end\":113364,\"start\":113311},{\"end\":113648,\"start\":113616},{\"end\":113853,\"start\":113784},{\"end\":114194,\"start\":114136},{\"end\":114460,\"start\":114410},{\"end\":114759,\"start\":114678},{\"end\":115022,\"start\":114974},{\"end\":115194,\"start\":115169},{\"end\":115388,\"start\":115331},{\"end\":115633,\"start\":115575},{\"end\":115902,\"start\":115817},{\"end\":116208,\"start\":116162},{\"end\":116467,\"start\":116437},{\"end\":116706,\"start\":116669},{\"end\":117228,\"start\":117174},{\"end\":117519,\"start\":117436},{\"end\":117822,\"start\":117772}]", "bib_author": "[{\"end\":110574,\"start\":110564},{\"end\":110585,\"start\":110574},{\"end\":110595,\"start\":110585},{\"end\":110821,\"start\":110808},{\"end\":110835,\"start\":110821},{\"end\":110845,\"start\":110835},{\"end\":111002,\"start\":110993},{\"end\":111011,\"start\":111002},{\"end\":111018,\"start\":111011},{\"end\":111181,\"start\":111173},{\"end\":111193,\"start\":111181},{\"end\":111201,\"start\":111193},{\"end\":111210,\"start\":111201},{\"end\":111223,\"start\":111210},{\"end\":111233,\"start\":111223},{\"end\":111244,\"start\":111233},{\"end\":111506,\"start\":111496},{\"end\":111515,\"start\":111506},{\"end\":111526,\"start\":111515},{\"end\":111536,\"start\":111526},{\"end\":111798,\"start\":111787},{\"end\":111809,\"start\":111798},{\"end\":111817,\"start\":111809},{\"end\":112086,\"start\":112079},{\"end\":112100,\"start\":112086},{\"end\":112107,\"start\":112100},{\"end\":112124,\"start\":112107},{\"end\":112339,\"start\":112325},{\"end\":112353,\"start\":112339},{\"end\":112576,\"start\":112565},{\"end\":112584,\"start\":112576},{\"end\":112595,\"start\":112584},{\"end\":112853,\"start\":112843},{\"end\":112864,\"start\":112853},{\"end\":113014,\"start\":113005},{\"end\":113025,\"start\":113014},{\"end\":113174,\"start\":113164},{\"end\":113184,\"start\":113174},{\"end\":113196,\"start\":113184},{\"end\":113374,\"start\":113366},{\"end\":113664,\"start\":113650},{\"end\":113673,\"start\":113664},{\"end\":113681,\"start\":113673},{\"end\":113873,\"start\":113855},{\"end\":113881,\"start\":113873},{\"end\":113892,\"start\":113881},{\"end\":114203,\"start\":114196},{\"end\":114213,\"start\":114203},{\"end\":114220,\"start\":114213},{\"end\":114226,\"start\":114220},{\"end\":114474,\"start\":114462},{\"end\":114484,\"start\":114474},{\"end\":114769,\"start\":114761},{\"end\":114775,\"start\":114769},{\"end\":114781,\"start\":114775},{\"end\":115034,\"start\":115024},{\"end\":115049,\"start\":115034},{\"end\":115205,\"start\":115196},{\"end\":115400,\"start\":115390},{\"end\":115645,\"start\":115635},{\"end\":115658,\"start\":115645},{\"end\":115916,\"start\":115904},{\"end\":115930,\"start\":115916},{\"end\":116218,\"start\":116210},{\"end\":116226,\"start\":116218},{\"end\":116235,\"start\":116226},{\"end\":116245,\"start\":116235},{\"end\":116255,\"start\":116245},{\"end\":116483,\"start\":116469},{\"end\":116493,\"start\":116483},{\"end\":116715,\"start\":116708},{\"end\":116729,\"start\":116715},{\"end\":116745,\"start\":116729},{\"end\":116755,\"start\":116745},{\"end\":117004,\"start\":116990},{\"end\":117015,\"start\":117004},{\"end\":117026,\"start\":117015},{\"end\":117237,\"start\":117230},{\"end\":117248,\"start\":117237},{\"end\":117259,\"start\":117248},{\"end\":117273,\"start\":117259},{\"end\":117530,\"start\":117521},{\"end\":117541,\"start\":117530},{\"end\":117552,\"start\":117541},{\"end\":117560,\"start\":117552},{\"end\":117838,\"start\":117824},{\"end\":117852,\"start\":117838},{\"end\":117861,\"start\":117852},{\"end\":117871,\"start\":117861}]", "bib_venue": "[{\"end\":110634,\"start\":110630},{\"end\":110859,\"start\":110856},{\"end\":111034,\"start\":111030},{\"end\":111268,\"start\":111260},{\"end\":111554,\"start\":111549},{\"end\":111858,\"start\":111854},{\"end\":112138,\"start\":112135},{\"end\":112880,\"start\":112876},{\"end\":113041,\"start\":113037},{\"end\":113481,\"start\":113436},{\"end\":113697,\"start\":113693},{\"end\":114262,\"start\":114258},{\"end\":114506,\"start\":114499},{\"end\":114820,\"start\":114816},{\"end\":116292,\"start\":116288},{\"end\":116557,\"start\":116543},{\"end\":116791,\"start\":116787},{\"end\":110628,\"start\":110618},{\"end\":110854,\"start\":110845},{\"end\":111028,\"start\":111018},{\"end\":111258,\"start\":111244},{\"end\":111547,\"start\":111536},{\"end\":111852,\"start\":111842},{\"end\":112133,\"start\":112124},{\"end\":112372,\"start\":112353},{\"end\":112648,\"start\":112595},{\"end\":112874,\"start\":112864},{\"end\":113035,\"start\":113025},{\"end\":113162,\"start\":113131},{\"end\":113434,\"start\":113374},{\"end\":113691,\"start\":113681},{\"end\":113947,\"start\":113917},{\"end\":114256,\"start\":114246},{\"end\":114497,\"start\":114484},{\"end\":114814,\"start\":114804},{\"end\":115057,\"start\":115049},{\"end\":115237,\"start\":115233},{\"end\":115440,\"start\":115421},{\"end\":115685,\"start\":115681},{\"end\":115979,\"start\":115954},{\"end\":116286,\"start\":116276},{\"end\":116541,\"start\":116521},{\"end\":116785,\"start\":116775},{\"end\":116988,\"start\":116931},{\"end\":117292,\"start\":117288},{\"end\":117590,\"start\":117582},{\"end\":117898,\"start\":117890}]"}}}, "year": 2023, "month": 12, "day": 17}