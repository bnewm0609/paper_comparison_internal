{"id": 527633, "updated": "2023-09-27 22:52:38.651", "metadata": {"title": "Autofolding for Source Code Summarization", "authors": "[{\"first\":\"Jaroslav\",\"last\":\"Fowkes\",\"middle\":[]},{\"first\":\"Razvan\",\"last\":\"Ranca\",\"middle\":[]},{\"first\":\"Miltiadis\",\"last\":\"Allamanis\",\"middle\":[]},{\"first\":\"Mirella\",\"last\":\"Lapata\",\"middle\":[]},{\"first\":\"Charles\",\"last\":\"Sutton\",\"middle\":[]}]", "venue": "ArXiv", "journal": "ArXiv", "publication_date": {"year": 2014, "month": 3, "day": 18}, "abstract": "We present a novel fully unsupervised method for the automatic summarization of source code text. On large projects, developers spend much of their time reading and browsing code, raising new opportunities for summarization methods. Indeed, modern code editors contain a feature called code folding, which allows one to selectively hide blocks of code. But this feature is cumbersome because currently folding decisions must be done manually. We introduce the autofolding problem, which is to automatically create a code summary by folding non-essential code blocks. We present a novel solution to the autofolding problem by formulating it as a subtree optimization problem and making use of a scoped topic model for source code. On a set of popular open source projects from GitHub, we show that our formulation outperforms simpler baselines at meeting human judgements, yielding a 77% accuracy and a 28% error reduction. Furthermore by conducting a case study we find that our formulation is strongly preferred by experienced developers. More broadly, we hope that this work will aid program comprehension by turning code folding into a usable and valuable tool.", "fields_of_study": "[\"Computer Science\"]", "external_ids": {"arxiv": "1403.4503", "mag": "1875990341", "acl": null, "pubmed": null, "pubmedcentral": null, "dblp": "journals/tse/FowkesCRALS17", "doi": "10.1109/tse.2017.2664836"}}, "content": {"source": {"pdf_hash": "428ee7e920f01b12f792f6252669295d2779c4f1", "pdf_src": "Arxiv", "pdf_uri": "[\"https://arxiv.org/pdf/1403.4503v2.pdf\"]", "oa_url_match": true, "oa_info": {"license": null, "open_access_url": "https://www.pure.ed.ac.uk/ws/files/30908556/tse_1.pdf", "status": "GREEN"}}, "grobid": {"id": "d6aff4e06ae45b2aa42039349433ed8b9cb816f2", "type": "plain-text", "url": "s3://ai2-s2-pdf-extraction-prod/parse-results/s2orc_worker/428ee7e920f01b12f792f6252669295d2779c4f1.txt", "contents": "\nAutofolding for Source Code Summarization\n\n\nJaroslav Fowkes jfowkes@ed.ac.uk \nRazvan Ranca \nMiltiadis Allamanis m.allamanis@ed.ac.uk \nMirella Lapata \nCharles Sutton csutton@ed.ac.uk \n\nSchool of Informatics \u2021 Computer Laboratory\nUniversity of Edinburgh\nEH8 9ABEdinburghUK\n\n\nUniversity of Cambridge\nCB3 0FDCambridgeUK\n\nAutofolding for Source Code Summarization\n\nWe present a novel fully unsupervised method for the automatic summarization of source code text. On large projects, developers spend much of their time reading and browsing code, raising new opportunities for summarization methods. Indeed, modern code editors contain a feature called code folding, which allows one to selectively hide blocks of code. But this feature is cumbersome because currently folding decisions must be done manually.We introduce the autofolding problem, which is to automatically create a code summary by folding non-essential code blocks. We present a novel solution to the autofolding problem by formulating it as a subtree optimization problem and making use of a comprehensive source code content model. On a set of popular open source projects from GitHub, we show that our formulation significantly outperforms simpler baselines at meeting human judgements, yielding an 84% accuracy and a 43% error reduction. More broadly, we hope that this work will aid program comprehension by turning code folding into a usable and valuable tool.\n\nINTRODUCTION\n\nEngineering large software systems presents many challenges due to the inherent complexity of software. Because of this complexity, programmers tend to spend more time reading and browsing code than actually writing it [22,20]. Despite much research [42], there is still a large need for better tools that aid program comprehension, thereby reducing the cost of software development.\n\nA key insight is that source code is written to be understood not only by machines, but also by humans. Programmers devote significant time and attention to writing their code in an idiomatic and intuitive way that can be easily understood by others -source code is a means of human communication. This fact raises the intriguing possibility that technology from the natural language processing (NLP) community can be adapted to help developers make sense of large repositories of code. A common problem in program comprehension is that developers are faced with two extremes: skimming the code or reading it in depth [14]. A good summary of the source code would alleviate this problem by providing a compromise: it could be read quickly and would lead to better understanding than simply skimming the code.\n\nSource code summarization has potential for valuable applications in many software engineering tasks, such as: (a) Understanding new code bases. Often developers need to quickly familiarize themselves with the core parts of a large code base. This can happen when a developer is joining an existing open source project, or when a developer is evaluating whether to use a new software library. (b) Code reviews. Reviewers need to quickly understand the key changes before reviewing the details. (c) Locating relevant code segments. During program maintenance, developers often tend to skim source code, reading only a couple lines at a time, while searching for the code region they are interested in [40].\n\nFor this reason, many code editors include a feature called code folding, which allows developers to selectively display or hide blocks of the source code. This feature is commonly supported in editors and is familiar to developers [16,21,35]. But in current Integrated Development Environments (IDEs), folding quickly becomes cumbersome because the folding decisions must be done manually by the programmer. This creates an obvious chicken-and-egg problem, because the developer must already understand the source file to decide what should be folded.\n\nIn this paper, we propose that code folding can be a valuable tool for aiding program comprehension, provided that folding decisions are made automatically. We introduce the autofolding problem, in which the goal is to automatically create a code summary by folding non-essential code elements that are not useful on first viewing. An illustrative example is shown in Figure 1. To any Java developer the function of the StatusLine constructor and the clone, getCode, getReason and toString methods are obvious even without seeing their method bodies. One possible summary of this source file is shown in Figure 2.\n\nOur contributions in this paper are as follows:\n\n\u2022 We introduce a novel autofolding method for source code summarization based on optimizing the similarity between the summary and the full source file. Because of certain constraints among the folding decisions, we formulate this method as a contiguous rooted subtree problem (Section 3.3). This is, to our knowledge, the first method for code summarization to use autofolding.\n\n\u2022 In order to determine which non-essential code regions our summarizer should fold, we adapt a content model from the NLP community and thereby create a novel topic model for code that is of independent interest (Section 3.2). The key feature of our topic model is that it is scoped, allowing every project and file to be endowed with its own particular topic.\n\n\u2022 We perform a comprehensive evaluation of our method on a set of popular open source projects from GitHub  44 public String toString() { 45 return \"SIP/2.0 \" + code + \" \" + reason + \"\\r\\n\"; 46 } 47 } Figure 1: Original source code. A snippet from bigbluebutton's StatusLine.java. We use this as a running example of code summarization.\n\n(Section 4), and find that our formulation performs significantly better than simpler baselines (Section 5). Furthermore, our proposed method is able to match human judgements with an accuracy of 84%.\n\nMore broadly, we hope that this work will aid program comprehension by turning code folding, perhaps an overlooked feature, into a useful, usable and valuable tool.\n\n\nRELATED WORK\n\nThe application of NLP methods to the analysis of source code text is only just beginning to be explored. Recent work has applied language modelling [2,17,18,23,32], natural language generation [38,39], machine translation [31], and topic modelling [30] to the text of source code from large software projects.\n\nOne of the main challenges in this area is to adapt ex-  isting NLP techniques to source code text. In contrast to natural languages, programming languages are unambiguous, employ little redundancy, are meant to be interpreted literally, and consist of strictly structured text. To exploit these features of the problem, we perform the summarization at the code block level, leveraging the fact that source code is syntactically unambiguous.\n\nThere is some existing work on the use of manual code folding to aid comprehension. In particular, Rugaber et al. [35] consider a conceptual model for manual folding, extending it to non-contiguous regions of code. Kullbach et al. [21] develop the GUPRO IDE to aid in the comprehension of C preprocessor code by folding macro expansions and file includes. Also, Hendrix et al. develop the GRASP program comprehension tool, combining control structure diagramming with folding [16].\n\nHowever, to best of our knowledge, the autofolding problem is novel. We are aware of only a few previous methods that consider the problem of summarizing code artifacts. Most similar to our work are Haiduc et al. [14,15] and the follow up work by Eddy et al. [9], who also consider the problem of summarizing source code, particularly methods and classes, but in their work code fragments are summarized by a short list of keywords. For example, the equals method in Figure 1 might be summarized by the list of terms (equals, code, reason, Status). In our work, we summarize code with code, which we would argue has the potential to provide a much richer and more informative summary.\n\nAlso, Ying et al. [47] consider the problem of summarizing a list of code fragments, such as those returned by a code search engine. They use a supervised learning approach at the level of lines of code. Because they consider the results of code search, their classifier uses query-level features, e.g., whether a line of code uses any identifiers that were present in the query. This is a source of information that is not available in our problem setting. In contrast, we target use cases in which the developer is skimming the source code to get an overview of its operation, rather than performing a directed keyword search. Kim et al. [19] develop a system that augments API documentation with code example summaries but these are mined from the web and are therefore limited to APIs which have examples already written for themour summarization approach is applicable to any source file.\n\nOn a more technical level, our work is distinguished from this previous work in our use of content selection at the level of syntactic blocks. This results in a summary that is coherent with respect to the programming language's syntax. The previous approaches perform content selection at the line level or the term level, running the risk of producing summaries that consist of disjoint sections of code. Indeed, Eddy et al. [9] observe that developers prefer summaries with a natural structure. Folding on code blocks also enables us to retain method headers in the summary -identified by Haiduc et al. [15] as highly relevant to developers and accounting for the high scores of their best performing method.\n\nAdditionally, our method leverages a cross-project corpus during the summarization process, allowing us to detect coding patterns which are common among many projects and which are therefore less likely to be part of the core logic of any one project.\n\nThe task of natural language summarization has been studied extensively [37], mostly focusing on extractive summarization -the problem of extracting the most relevant text segments from documents. Source code identifiers (e.g., variable names) are information-rich and have been shown to be important for tasks such as feature location [1,7]. NLP techniques have been used on these identifiers, for information retrieval tasks such as automatically selecting labels for software artifacts [5]. Extractive summarization has also been applied for the automatic summarization of bug reports [25,34].\n\nIn addition to extractive summarization methods, abstractive techniques have also been used in software engineering research. Work in this area includes the synthesis of API usage examples [4], the extraction of API usage patterns [45,46], and the generation of natural language summaries for source code [29,38].\n\nThe use of topic models for source code has also been studied in depth [5,11,36,43]. Marcus et al. [26,27] used Latent Semantic Indexing (LSI) [6] for identifying traceability links and concept location in source code. More closely related to our work, Haiduc et al. [15] used LSI as a content model for their keyword-based source code summarizer. In their follow up paper, Eddy et al. additionally used a hierarchical pachinko allocation model (hPAM) [28], a family of generative topic models that build on Latent Dirichlet Allocation (LDA) [3] with a hierarchical topic structure. Also, Movshovitz et al. [30] successfully used LDA and link-LDA [10] for predicting class comments from source file text.\n\nWe cast autofolding as an instance of the general problem of selecting an optimal subtree given a certain budget. This problem has been studied theoretically by [12], who propose a dynamic programming solution, but this is only pseudopolynomial time, and so is unlikely to scale well in practice.\n\n\nPROBLEM FORMULATION\n\nOur aim in this paper is to summarize source code so that it conveys the most important aspects of its intended function. We envisage our proposed Tree-based Software Summarization Algorithm (TSSA) being embedded in a programming language Integrated Development Environment (IDE), providing real-time summaries to the user of selected files. The summarization could be useful at multiple levels, ranging from a single source file to a whole corpus. For the purposes of this paper, we will focus on the Java programming language as it is a popular, high-level, platformindependent language. However, since TSSA works entirely with the source code's Abstract Syntax Tree (AST), it can be applied to any programming language.\n\nThe usage scenario we envisage for TSSA is that of a developer not familiar with a project wishing to see the most relevant methods and classes in a given project file. For example, a developer who is considering using a new project on GitHub and would like to get an overview of the algorithms used in the project. In the future, we would like to extend this to aid developers undertaking other software engineering tasks such as program maintenance, exception handling and code reviews.\n\n\nProblem Definition\n\nMost modern IDEs and text editors already have extensive support for manual folding of code but to the best of our knowledge the problem of doing so automatically is novel. When we say that we fold a source code region we mean that the region is replaced by a one line summary and a symbol indicating that the region was folded. We define the autofolding problem as that of choosing a set of code regions to fold, such that the total length of the folded file as a fraction of the original is below a user-specified compression ratio, and the remaining, unfolded, text captures the most important aspects of the file in question.\n\nTo provide the most intuitive summary to the end-user, we allow the system to preform folding only on code blocks (regions of source code delimited by { , }), comment blocks (regions delimited by /*(*) , */), and import statements. We call these the foldable regions of the code. Our reasoning for this is that it is a summary many programmers are familiar with as these are precisely the regions that can be manually folded in the majority of modern IDEs. Moreover, code blocks are natural units for extractive summarization since they take advantage of the code structure specified by the programmer. In keeping with the conventions established by manual folding in IDEs, the one line summary we display for a folded region consists of the first non-empty line of the code block, then a symbol denoting the folded region (an ellipsis), and finally the right delimiter of the region. See Figure 2 for an example of how folded text appears in an IDE.\n\nWe formalize the autofolding problem by using the AST representation of the source code 1 . Given a program's AST, we define the program's foldable nodes as those AST nodes which correspond to a foldable region of code (a code/com-  Figure 3: Partial foldable tree constructed for StatusLine.java ( Figure 1). Numbered breadth-first with labels denoting block types and line numbers in brackets, cf. the source code snippet in Figure 1. Note that we have omitted some nodes for clarity. ment block or import statement). By starting at the root of an AST and sequentially extracting all foldable nodes, we construct a directed foldable tree, containing just the AST nodes we are interested in. Figure 3 shows a partial foldable tree for the running example. Constructing a foldable tree enables us to formulate the summarization problem mathematically as finding the best contiguous rooted subtree that takes up no more than a predefined number of lines of source code (LOC). That is to say, we unfold all nodes in the best subtree and fold the remaining nodes in the tree. Note that we require the tree to be rooted and contiguous as otherwise this would lead to confusing situations where we would have a deep node present in the summary with no context. We will describe the precise formulation in the next two sections: we begin by presenting a content selection model for choosing the best nodes to retain in the subtree (Section 3.2) before describing a greedy approximation algorithm to solve the contiguous rooted subtree problem (Section 3.3).\n\n\nContent Model\n\nIn order to determine which nodes of the foldable tree should be unfolded we require a content selection method for choosing the best nodes to retain in the summary. Intuitively, one would like to retain the most informative nodes and a natural approach, as in text summarization, is to tokenize the node text and select the nodes with the most representative tokens. For this reason we make use of an LDA-style Topic Model, an extension of the TopicSum model [13]. The high-level idea is to extend LDA with topics that are specific to particular projects, files and methods. Note that we do not use an n-gram language model as we require a global model of the distribution of code across files rather than a local model based on nearby tokens.\n\nIn NLP, a topic model is a generative probabilistic model which captures the distribution of words in documents by associating each word with a number of topics. Each topic is modelled as a distribution \u03c6 k over words which enables each document to be modelled as a distribution over topics \u03b8 d . Thus, one can generate a document simply by choosing each word w in the document from a topic \u03c6z, where the topic assignment z is selected according to the document's topic distribution \u03b8 d [41].\n\nTopicSum is a scoped topic model and extends this simple yet powerful idea to multiple levels. The key difference is that each topic can be one of three kinds, a distribution over words in: the document, the document collection and background words. The intention is that the background topic models stop words, the document collection topic represents significant content and the document topic very specific document words [13]. We have adapted TopicSum to source code so that each file and project have their own private topic. Further, we have introduced several background topics. Our TSSA content model is best illustrated by example (cf. Figure 4). A file F in our topic model is generated as follows: each token w in every foldable node N of the file is chosen from a topic \u03c6z, where the topic assignment z is selected according to \u03b8N the distribution over topics in the node. For example, the topic assignment z = 1 means that w is chosen from the file token distribution \u03c6F . Specifically, we consider five different kinds of topic: for each file (\u03c6F ), for the project containing the file (\u03c6P ) and three background topics shared across projects (\u03c6B) as depicted in Figure 4. Although the model isn't aware of this, in practice we find that the three background topics correspond to common Java tokens (\u03c6B J ) and background doc comment (\u03c6B D ) and header comment tokens (\u03c6B H ).\n\nFor the purposes of code summarization, we need to evaluate whether a block of code belongs in the summary (cf. Section 3.3) and our means to achieve this goal depends on measuring whether the code is representative of its file as a whole, its project, and of idiomatic source code more generally. The TopicSum model is ideally suited to this task and enables us to directly calculate the value of including each node in the summary and assign a 'score' based on this to each node, as will be described in Section 3.3. Note that we do not use a stoplist because we expect that the set of appropriate stop words for program text would be different to those for natural language text. Moreover, the Java, doc comment and header comment background distributions \u03c6B J , \u03c6B D , \u03c6B H are intended to capture stop words from Java tokens and comment tokens which do not contribute to the content. We can then construct the topic model by sampling topics from a suitable conditional probability distribution and so infer the topic assignments for our corpus. That is, we consider each individual token in the corpus in turn, and estimate the probability of assigning the current token to each topic, conditioned on the topic assignments to all other tokens. We can then sample a topic from this conditional distribution and store it as the new topic assignment for this token [41]. It can be shown that this process converges to the distribution of topics for the corpus and we are thus able to predict the most likely tokens for each topic.\n\nThe conditional distribution used for sampling is a simple extension of the standard equations for LDA [41]: letting z (nf p) i = k denote the topic assignment of token i (in node n, file f project p) to topic k and w (nf p) i = t denote token i taking on the value t, we obtain\nP (z (nf p) i = k |Z \\i , W, \u03b1m, \u03b2) = P (w (nf p) i = t |z (nf p) i = k, Z \\i , W, \u03b2)P (z (nf p) i = k |Z \\i , \u03b1m) \u221d N \\i t|k + \u03b2 k T t=1 N \\i t|k + \u03b2 k N \\i k|n f p + \u03b1m k K k=1 N \\i k|n f p + \u03b1m k\nwhere Z, W denote the assignments of all topics and tokens, N \\i t|k denotes the number of times token t is assigned to topic k, not including the current instance i, and similarly N \\i k|n f p denotes the number of times topic k is assigned to some token in node n f p , excluding instance i. Further, \u03b1m, \u03b2 denote hyperparameters for the prior distributions of topics and tokens, i.e. the initial topic and token assignments. Additionally, unlike the original TopicSum model which used fixed hyperparameters, we incorporate efficient hyperparameter optimization, namely MacKay and Peto's method with histogram based computation of the necessary counts as described in [44].\n\nTokenization A first idea would be to have one token in the topic model for each Java token in the code base. However there are a few problems with this. First, some tokens, like operators and delimiters, are not informative about the program content. Second, identifier names have substructure that we wish to exploit. For example, in Figure 1, the getCode method name is closely related to the code member variable, which becomes apparent to the Topic Model only if it is split into two tokens get and code.\n\nFor these reasons, we preprocess the Java tokens before incorporating them into the topic model. Given a code block, first we tokenize it into a set of Java tokens using standard tools for the Java programming language. Then we remove all tokens except for identifiers, i.e., programmer assigned names of variables, methods, classes, etc. Finally, we convert each of the identifiers into a new set of tokens by splitting on camel case and underscores, and converting to lowercase (e.g., FooBarBaz becomes three tokens foo, bar, and baz, as would foo_bar_baz). Additionally, we include the text of all program comments in the topic model, splitting the comment text based on words, again applying the identifier splitting procedure on any comment tokens that contain camel case or underscores. The resulting tokens are used as the tokens in the vocabulary for the topic model.\n\n\nOptimization Method\n\nNow that we have defined a content model for source code, we need an algorithm that extracts the most relevant summary by selecting suitable AST nodes in the foldable tree. To this end, we propose an iterative greedy optimization algorithm to extract the most relevant rooted contiguous subtree from the foldable tree given constraints on the subtree size.\n\nIn order to decide whether a given node of the foldable tree is relevant and should be included in our summary, we consider the candidate summary, i.e., the subtree we have gathered so far, together with the node under consideration. Using our topic model, we are then able to assign probabilities to the candidate summary and measure its similarity to the file token distribution \u03c6F . A suitable informationtheoretic measure for this is the Kullback-Lieber (KL) divergence, which is a measure of the difference between two probability distributions. We can therefore assign the node a score based on the KL divergence between the corresponding file token distribution \u03c6F and the empirical unigram distribution of the candidate summary. This is similar to the summary selection criterion proposed in the original TopicSum model [13], except that Haghighi et al. used the project token distribution and our summary distribution backs off to the Java token distribution \u03c6B J rather than a constant. The intuition here is that we would like our summary to contain nodes with tokens which are representative of the file but not common in the project or corpus as we believe that these tend to be the most relevant.\n\nFormally, for each node i let ui \u2208 {0, 1} indicate whether it is unfolded, with 1 corresponding to true (i.e. unfolded) and let u be the vector containing all the ui (so that u contains ui at position i). We then define the score as\n\u03c3(u) = \u2212KL(\u03c6F |Pu) (3.1)\nwhere \u03c6F denotes the file token distribution, Pu the empirical unigram distribution over tokens in the candidate summary and KL(\u00b7|\u00b7) the KL divergence. We adjust this score down for nodes consisting of Java import statements and block comments along with empty blocks so that these are never unfolded as developers generally prefer not to see import statements, file header comments and internal block comments in the summary -the Eclipse IDE for example automatically folds import statements and file header comments by default. We do not, however, impose this condition on Javadoc comments as studies [15,9] have indicated that developers like to see good method/class comments.\n\nWe are now in a position to formulate the summarization problem as finding the optimal rooted contiguous subtree. Note that this formulation is necessary as we wish to present a summary of the foldable tree -this requires finding a subtree that is both rooted and contiguous so that its unfolded nodes are all visible in the summary. Suppose we wish to summarize a file using a line-level compression ratio of p%, i.e., we would like to compress the file to p% of its original size in LOC. We can then define Lmax, the maximum number of lines of code that are allowed in the summary, as\nLmax := p 100 L0 (3.2)\nwhere L0 denotes the LOC in the original file. Note that since we are folding on a block level, a line-level compression ratio of p% does not mean that p% of the blocks are compressed, in fact for small files all the blocks are often folded at 50% compression. Let G = (V, E) be the foldable tree, that is, a directed tree with a set of AST nodes V = {1, . . . , N } consisting of the aforementioned foldable regions and E a set of directed edges between the nodes, where it is understood that (i, j) \u2208 E means that i is the parent node of j (cf. Figure 3). Furthermore, for a node i \u2208 V let Li denote the LOC underneath node i. We then define Ci, the cost of unfolding node i as the LOC unique to node i, i.e., underneath node i but not any of its children. Formally,\nCi := (Li \u2212 1) \u2212 j:(i,j)\u2208E (Lj \u2212 1) (3.3)\nRecall that the first line of a node is never folded (cf. Figure 2), hence the minus one. Let \u03c3(z) denote the score obtained from the summary nodes u1, . . . , uN as defined in (3.1). The optimal rooted contiguous subtree problem is then defined as\nmax u \u03c3(u) (3.4a) s.t. N i=1 Ciui \u2264 Lmax (3.4b) ui \u2265 uj if (i, j) \u2208 E (3.4c) ui \u2208 {0, 1} \u2200 i \u2208 V. (3.4d)\nThat is, we wish to unfold the nodes which maximise the total score (3.4a) subject to staying below the maximum allowed LOC (3.4b) and retaining a rooted contiguous subtree (3.4c). As the score (3.1) is nonlinear we approximate this problem using a greedy approximation algorithm: that is we unfold the next available node that will give the maximum score (3.1) per cost (3.3) increase, honoring the cost constraint (3.4b). That is, starting from all the nodes being folded (i.e. u = 0), iteratively choose the node that maximizes\n\u03c3(u + e i )/Ci while N i=1 Ciui \u2264 Lmax.\nHere e i denotes the i-th unit vector, which is 1 at position i and 0 everywhere else.\n\n\nEXPERIMENTAL SETUP\n\nIn the previous section, we described source code summarization as a folding problem and presented a greedy algorithm that performs the summarization. In this section, we describe how we obtain a gold standard summary on real code. The gold standard allows automatic evaluation, which is the de facto standard in NLP summarization [24]. Automatic evaluation is vital to applied AI because it leads to a rapid development cycle. In particular, it enables us to perform a comprehensive evaluation of the summarization method in the next section. Data To evaluate the performance of TSSA we obtained the source code for the top six Java projects on the popular GitHub service for hosting open source code repositories. The top six projects were determined by a popularity score, which is the sum of the number of forks and the number of watchers, where each is separately normalized into a z-score. We selected the projects with the highest score that were greater than 100,000 KB in size as of December 1st 2013. These are given in Table 1 along with a brief description of their domains.\n\nFor each of these six projects, we divided the project files into quartiles by file size, and sampled four files from each quartile, to obtain a total of 96 files each one of which was annotated by two human annotators. Only .java files were considered (excluding the package-info.java files, which only contain package-level documentation). Figure 5 shows the distribution of file sizes across the top projects.\n\n\nAnnotation Procedure\n\nHuman annotators were given specific guidelines prior to performing the annotation. Annotators were asked, for each source code file, to manually fold the file in the Eclipse IDE until they reached a compression ratio of 75%, save their work, and then to continue folding until they reached a ratio of 50%. 2 Thus each annotator produced two sets of folding decisions for each file. Each annotator annotated all 96 files in our dataset at 75% and 50% compression ratios. Although 50% may not seem like a dramatic compression, in fact many of the remaining lines are block headers or blank (cf. the running example in Figure 2). We found that on average across all 96 files in dataset, over half (56%) of the LOC in the folded file were blank or block headers.\n\nAnnotators were allowed to browse the full source code of the project while annotating each file. In order to obtain a high quality gold standard we required human annotators who were conversant with the Java programming language and for this reason we chose two of the authors as annotators. Note that we performed our annotation prior to the development of our summarization system so it was impos-   Table 2: The top ten tokens in each topic-type as found by our topic model. sible for the annotators to unconsciously favor the system's output in their judgements.\n\nAnnotators were asked to always fold import statements and header comments (such as copyright notices). Empty and one-line blocks were also folded by default. Setters and getters along with other I/O methods were asked to be folded, unless they contained core logic of the code. Similarly, annotators were asked to fold overridden and overloaded methods unless they provide sufficient new information about the functionality of the code. Finally, Javadoc and block comments were left unfolded if they were informative and succinctly explained the function of the associated class or method. Comments whose text spanned only one line were folded by default.\n\nIt is certainly true that developers who are familiar with the projects could favor a different type of summary than the annotators, and this could be seen as a threat to validity. However, recall that in this initial study, our target use case focuses on developers who are new to the projects, for which we would argue our annotators are good representatives.\n\n\nAnnotation Statistics\n\nBecause autofolding is a new task, we need to verify that the task is well-defined. We therefore calculated the agreement between annotators and found that it was substantial, with Fleiss' Kappa values of 0.72 at 75% and 0.64 at 50% compression, averaged across all files.\n\n\nRESULTS\n\nIn this section, we evaluate the performance of TSSA against our annotated test set from Section 4. We begin by training and assessing the quality of TSSA's underlying topic model before moving on to a comprehensive evaluation of TSSA itself. As our method is fully unsupervised, we use all 96 annotated files from the six projects in our corpus for evaluation.\n\n\nTopic Model\n\nWe train TSSA's topic model on all 12,093 .java files from the six projects in our corpus -this enables the topic model to automatically discern common coding patterns, such as common libraries, and thus allows TSSA to recognize unimportant code. To this end, we run the topic sampling algorithm for 5,000 iterations, performing hyperparameter optimization every 10 iterations, to infer our trained model. To highlight the validity of our topic model, we show the top ten tokens in each of the five topic types (Java background, header comment, doc comment, project and file) in Table 2. Note that background tokens which are very common in a file/project can also appear among the top ten file/project tokens. One can clearly see that these are very representative of their respective topics: the Java background topic contains common Java generics such as get, set, to and object. The background comment topics on the other hand contain common English stop words such as the, a, or and one can clearly see the distinction between the topics, i.e., words that commonly appear in headers (such as license, distributed) are found in the header comment topic whereas those that appear in code comments (link, code) are found in the doc comment topic. Looking at the topics for the spring-framework project one can see that it contains the fully resolved project name org.springframework as well as common project-specific tokens such as bean, context and factory. Similarly, the bigbluebutton project contains the specific tokens sip, event, message and gnu. Looking at selected files from both projects, the DataSourceUtils file topic contains tokens specific to the function of that file, e.g. connection, data, synchronization and transaction. Finally, the QuaLsp file topic, a codec implementation, contains the very function-specific tokens lsp and ld8. This illustrates the quality of our proposed topic model and suggests that it can distinguish fileand project-specific tokens from those that are common across all Java projects. This raises the exciting possibility that our topic model is robust enough for wider applications and not merely restricted to summarization.\n\nBaselines To provide a comprehensive performance comparison of our proposed summarization method, we also evaluate four alternative baseline methods that represent more na\u00efve approaches for summarizing source code. All baselines start from a fully folded tree and gradually unfold nodes, making local decisions, until they reach the required compression ratio. A brief description and example behavior  on the folded tree in Figure 3 follows. Note that if a node is to be unfolded all of its parent nodes are also unfolded so that it is visible in the summary.\n\nShallowest unfold the shallowest available node first, choosing randomly if there is more than one. This would unfold node 1 in Figure 3 first, followed by either node 2 and 3 or node 3 and 2, etc.\n\nLargest unfold the largest available node first, as measured by the number of tokens, breaking ties randomly. In Figure 3, this would unfold the class block (node 3) first, followed by the class Javadoc (node 4), etc.\n\nJavadoc first unfold all Javadoc comments (in random order) and then fallback at random to an available node, unfolding methods last. This would unfold the Javadoc nodes 4, 6 in Figure 3 first and the method nodes 5, 8, 9 last (7 would already be unfolded as it is the parent of 10 and 11).\n\nEach of the baselines represents a possible assumption that we can make about summarizing source code. Shallower nodes may be more important for the core meaning of the source code (Shallowest baseline) or that the largest nodes are more valuable in a summary (Largest baseline). The Javadoc baseline is representative of the de facto summarization method used in current IDEs such as Eclipse. Finally, we compare against our TSSA summarization method as formulated in Section 3.\n\n\nPerformance\n\nTo assess the performance of our TSSA summarization system and baselines we randomly chose one of our two annotators and used their annotated test set (at both 75% and 50% compression ratios) as our gold standard for each file. This measures whether the output of the summarizer matches human judgements. For each file in the test set, we treated the folding problem as a binary classification, classifying each line of code as either unfolded (positive) or folded (negative). This enabled us to calculate the average accuracy, precision and recall of our summarizer across all test files and also F1 as the harmonic mean of the average precision and recall. The resulting average performance metrics, at both 75% and 50% compression ratios, are given in Tables 3 and 4, respectively. As one can clearly see from the results, our proposed summarization system outperformed all the baselines, by a margin of about 15% when compared against the best performing baseline (Javadoc).\n\nMoreover, our summarizer has very fast runtime, needing only a few seconds of CPU time to summarize an average file in the data set on a 2.66GHz Core 2 Quad machine.\n\nFurthermore, in Table 5 we show the accuracy of the summarization methods averaged across the files for each test project. Once again, one can clearly see that for each project our TSSA summarizer significantly outperforms all the other     As a further test of whether the proposed summaries are plausible, we consider several classes of methods that are likely to be uninteresting, and verify that TSSA usually folds them. We show the percentage of times constructors, getters, setters and other generally uninteresting patternbased method types were folded at 50% compression in Table 7. As one can see from the table, our summarizer folds these methods in most cases. Furthermore, when such methods are included in the summary, these exceptional methods turn out to be qualitatively more interesting, as we verify by manual examination. We show example snippets in Figures    Table 6: AUC for the ROC curve in Figure 7.\n\nconstruct get set put is read write 74.6% 76% 92% 100% 100% 87.5% 70% Table 7: The percentage of times specific method types in the test set were folded at 50% compression by our summarizer.\n\n8-10. As one can see, the unfolded methods tend to exhibit unusual or non-standard behaviour in the method body, so much so that they cannot be easily summarized by their signature alone. This lends further evidence to the credibility and usefulness of our summarization approach. It is also evident from the results that the Shallowest and Largest baselines perform poorly and it is not difficult to see why. The shallowest nodes tend to be code blocks delimiting methods and classes, which rarely contain core logic. Rather, the core logic tends to be nested in if-else statements, for/while loops and try-catch blocks. The Largest nodes may contain a substantial amount of code but rarely the core logic as the number of tokens is a bad indicator of code importance. To see this, consider header comments which contain many tokens (words) often stating the code copyright, or common class methods such as the equals method in Figure 1 which perform routine functions yet contain blocks with many identifiers. The Javadoc baseline, on the other hand, represents the de facto summarization method currently used in IDEs and therefore performs much better as one would expect.\n\nAs for statistical significance, we calculated two-tailed pvalues using sigf [33]. We find that the difference between TSSA and the other methods is significant, obtaining values of p < 0.01 at both 75% and 50% compression ratios.\n\nFinally, we compared the performance of the baselines and our summarization system at a range of compression ratios (effectively treating it as a threshold) against the gold standard at the fixed compression ratios of 75% and 50%. Figures  6 and 7 show the ROC curves with corresponding AUC values for Figure 7 in Table 6. Once again, we can see that our proposed summarization system substantially outperforms all the baselines with an AUC of 0.89 at 50% and a similar AUC at 75%.\n\n\nCONCLUSIONS\n\nWe presented a novel fully unsupervised approach for extractive source code summarization formulating it as an optimal subtree problem on the source code's abstract syntax tree. Our proposed method builds on previous work using disjoint line-and term-level code summaries and introduces a new contiguous parse subtree as its summary. Moreover, in the process we develop a novel topic model for source code which has the potential for wider-ranging applications.\n\nOur evaluation demonstrates that our proposed summarizer outperforms existing baselines, achieving an error reduction of 43% and even outperforming methods used as standard in modern IDEs, highlighting the immediate usefulness of our method.\n\nIn the future, we would like to extend our method to the summarization of multiple files. Furthermore, we are inter-ested in integrating the term-based summaries developed by Haiduc et al. [15] with our own autofolding based summaries to obtain even better performance.\n\nFigure 2 :\n2Summarized source code. A summary of the file in Figure 1 (left) which results from folding lines 1, 4-5, 11-14, 21-22, 31-33, 36-38 and 40-42.\n\nFigure 4 :\n4Graphical model depiction of the TSSA content model (with K = 3). The plates denote repeated groups of variables. Note that hyperparameters have been omitted for clarity.\n\nFigure 5 :\n5Histogram of file sizes across the top projects (red vertical lines denote quartiles).\n\nFigure 6 :\n6Averaged 11-point ROC curve for the summarizers at 0-100% compression ratios evaluated against the gold standard at 75%.\n\nFigure 7 :\n7Averaged 11-point ROC curve for the summarizers at 0-100% compression ratios evaluated against the gold standard at 50%. methods, showing that our proposed summarization method is not domain-dependent.\n\nFigure 10 :\n10Snippets of readers and writers that were unfolded at 50% compression by our summarizer.\n\nTable 1 :\n1The top Java projects on GitHub, used in the current work. Ordered by popularity.Background \nProject \nFile \n\nJava \nheader comments doc comments spring-framework bigbluebutton DataSourceUtils QuaLsp \n\nget \nthe \nthe \norg \norg \nconnection \nlsp \nstring license \na \nspringframework \nsip \nsource \nj \nname \nor \nto \nbean \nlog \ndata \nconstants \nvalue \nunder \nof \ntest \njava \ncon \nk \ntype \nyou \nis \ncontext \nevent \nholder \nld8 \nset \ndistributed \nlink \nexception \nmessage \nsynchronization mode \nobject of \nfor \nfactory \ngnu \ntransaction \nindex \nfield \nis \nthis \nrequest \nit \nisolation \ntmp \nto \n0 \nand \njava \nlistener \norder \nvalue \ni \n2 \ncode \nweb \npublic \nlevel \nwegt \n\n\n\nTable 3 :\n3Per-line evaluation statistics for the summarizers at a compression ratio of 75%. Averaged across all test files, ordered best first.\n\nTable 4 :\n4Per-line evaluation statistics for the summarizers evaluated at a compression ratio of 50%. Averaged across all test files, ordered best first.\n\nproject :\nprojectstorm elasticsearch spring-framework libgdx bigbluebutton nettyTSSA \n0.86 \n0.78 \n0.86 \n0.88 \n0.75 \n0.83 \nJavadocs \n0.70 \n0.70 \n0.71 \n0.70 \n0.58 \n0.76 \nShallowest \n0.57 \n0.53 \n0.49 \n0.51 \n0.56 \n0.62 \nLargest \n0.73 \n0.43 \n0.49 \n0.54 \n0.52 \n0.54 \n\n\n\nTable 5 :\n5Comparison of per-line F1 score across different open source projects, at a compression ratio of 50%. Averaged across project files, ordered best first.Figure 8: Snippets of constructors that were unfolded at 50% compression by our summarizer. int maxX = min(cols -1, cellX(r.x + r.width)); int minY = max(0, cellY(r.y)); int maxY = min(rows -1, cellY(r.y + r.height)); for (int y = minY; y <= maxY; y++) { for (int x = minX; x <= maxX; x++) { int shv = getGridCell(x, y); result.addAll(grid.get(shv));Figure 9: Snippets of getters and setters that were unfolded at 50% compression by our summarizer. ] outbuf = new byte[length]; ByteArrayOutputStream bos = new ByteArrayOutputStream(); int len; while ((len = gzi.read(outbuf, 0, outbuf.length)) != -1) { bos.write(outbuf, 0, len); } byte[] decompressed = bos.toByteArray();public IndifferentAccessMap(IPersistentMap map) { \nsetMap(map); \n} \n\nIndexTemplateAlreadyExistsException(String name) { \nsuper(\"index_template [\" + name \n+ \"] already exists\"); \nthis.name = name; \n} \n\nEsThreadPoolExecutor(int corePoolSize, \nint maximumPoolSize, long keepAliveTime, \nTimeUnit unit, BlockingQueue<Runnable> workQueue, \nThreadFactory threadFactory) { \nthis(corePoolSize, maximumPoolSize, keepAliveTime, \nunit, workQueue, threadFactory, new EsAbortPolicy()); \n} \n\npublic PolygonMapObject(float[] vertices) { \npolygon = new Polygon(vertices); \n} \n\npublic Array<Rectangle> get(Rectangle r) { \nresult.clear(); \nint minX = max(0, cellX(r.x)); \n} \n} \nreturn result; \n} \n\npublic <T> T getOption(ChannelOption<T> option) { \nif (option == SO_TIMEOUT) { \nreturn (T) Integer.valueOf(getSoTimeout()); \n} \nreturn super.getOption(option); \n} \n\npublic void set(final ContactID c) { \nindexA = c.indexA; \nindexB = c.indexA; \ntypeA = c.typeA; \ntypeB = c.typeB; \n} \n\npublic <T> boolean \nsetOption(ChannelOption<T> option, T value) { \nvalidate(option, value; \n\nif (option == SO_TIMEOUT) { \nsetSoTimeout((Integer) value); \n} else { \nreturn super.setOption(option, value); \n} \nreturn true; \n} \n\npublic static byte[] \nreadCompressedByteArray(DataInput in) \nthrows IOException { \nint length = in.readInt(); \nif (length == -1) \nreturn null; \nbyte[] buffer = new byte[length]; \nin.readFully(buffer); \nGZIPInputStream gzi \n= new GZIPInputStream(new ByteArrayInputStream( \nbuffer, 0, buffer.length)); \nbyte[bos.close(); \ngzi.close(); \nreturn decompressed; \n} \n\npublic void writeTo(StreamOutput out) \nthrows IOException { \nsuper.writeTo(out); \nif (out.getVersion().onOrBefore(Version.V_0_90_3)) { \nout.writeBoolean(false); // refresh flag \n} \nout.writeBoolean(full); \nout.writeBoolean(force); \n} \n\n\nThe AST representation can be built by the Eclipse JDT parser[8].\nA compression ratio of 25% was not used as this would result in most files being entirely folded because we are folding on a block level.\nACKNOWLEDGMENTSThis work was supported by Microsoft Research through its PhD Scholarship Programme and by the Engineering and Physical Sciences Research Council (grant number EP/K024043/1). We are also grateful to Rebecca Mason for allowing us to adapt her TopicSum implementation and would like to thank Brian Doll for useful discussions.\nThe effect of lexicon bad smells on concept location in source code. S L Abebe, S Haiduc, P Tonella, A Marcus, International Working Conference on Source Code Analysis and Manipulation (SCAM). IEEES. L. Abebe, S. Haiduc, P. Tonella, and A. Marcus. The effect of lexicon bad smells on concept location in source code. In International Working Conference on Source Code Analysis and Manipulation (SCAM), pages 125-134. IEEE, 2011.\n\nMining source code repositories at massive scale using language modeling. M Allamanis, C Sutton, International Workshop on Mining Software Repositories (MSR). IEEEM. Allamanis and C. Sutton. Mining source code repositories at massive scale using language modeling. In International Workshop on Mining Software Repositories (MSR), pages 207-216. IEEE, 2013.\n\nLatent Dirichlet allocation. D M Blei, A Y Ng, M I Jordan, Journal of machine Learning research. 3D. M. Blei, A. Y. Ng, and M. I. Jordan. Latent Dirichlet allocation. Journal of machine Learning research, 3:993-1022, 2003.\n\nSynthesizing API usage examples. R P Buse, W Weimer, International Conference on Software Engineering (ICSE). IEEER. P. Buse and W. Weimer. Synthesizing API usage examples. In International Conference on Software Engineering (ICSE), pages 782-792. IEEE, 2012.\n\nLabeling source code with information retrieval methods: an empirical study. A De Lucia, M Di Penta, R Oliveto, A Panichella, S Panichella, Empirical Software Engineering. A. De Lucia, M. Di Penta, R. Oliveto, A. Panichella, and S. Panichella. Labeling source code with information retrieval methods: an empirical study. Empirical Software Engineering, pages 1-38, 2013.\n\nIndexing by latent semantic analysis. S C Deerwester, S T Dumais, T K Landauer, G W Furnas, R A Harshman, JASIS. 416S. C. Deerwester, S. T. Dumais, T. K. Landauer, G. W. Furnas, and R. A. Harshman. Indexing by latent semantic analysis. JASIS, 41(6):391-407, 1990.\n\nFeature location in source code: a taxonomy and survey. B Dit, M Revelle, M Gethers, D Poshyvanyk, Journal of Software: Evolution and Process. 251B. Dit, M. Revelle, M. Gethers, and D. Poshyvanyk. Feature location in source code: a taxonomy and survey. Journal of Software: Evolution and Process, 25(1):53-95, 2013.\n\n. Eclipse-Contributors, Jdt Eclipse, Eclipse-Contributors. Eclipse JDT. http://www.eclipse.org/jdt/, 2013. Visited December 21, 2013.\n\nEvaluating source code summarization techniques: Replication and expansion. B P Eddy, J A Robinson, N A Kraft, J C Carver, International Conference on Program Comprehension (ICPC). IEEEB. P. Eddy, J. A. Robinson, N. A. Kraft, and J. C. Carver. Evaluating source code summarization techniques: Replication and expansion. In International Conference on Program Comprehension (ICPC), pages 13-22. IEEE, 2013.\n\nMixed-membership models of scientific publications. E Erosheva, S Fienberg, J Lafferty, Proceedings of the National Academy of Sciences of the United States of America. 1011SupplE. Erosheva, S. Fienberg, and J. Lafferty. Mixed-membership models of scientific publications. Proceedings of the National Academy of Sciences of the United States of America, 101(Suppl 1):5220-5227, 2004.\n\nCodeTopics: which topic am I coding now. M Gethers, T Savage, M Di Penta, R Oliveto, D Poshyvanyk, A De Lucia, International Conference on Software Engineering (ICSE). ACMM. Gethers, T. Savage, M. Di Penta, R. Oliveto, D. Poshyvanyk, and A. De Lucia. CodeTopics: which topic am I coding now? In International Conference on Software Engineering (ICSE), pages 1034-1036. ACM, 2011.\n\nEfficient recovery from power outage. S Guha, A Moss, J S Naor, B Schieber, Symposium on Theory of Computing (STOC). S. Guha, A. Moss, J. S. Naor, and B. Schieber. Efficient recovery from power outage. In Symposium on Theory of Computing (STOC), pages 574-582.\n\nExploring content models for multi-document summarization. A Haghighi, L Vanderwende, Association for Computational Linguistics (ACL). ACLA. Haghighi and L. Vanderwende. Exploring content models for multi-document summarization. In Association for Computational Linguistics (ACL), pages 362-370. ACL, 2009.\n\nSupporting program comprehension with source code summarization. S Haiduc, J Aponte, A Marcus, International Conference on Software Engineering (ICSE). IEEE2S. Haiduc, J. Aponte, and A. Marcus. Supporting program comprehension with source code summarization. In International Conference on Software Engineering (ICSE), volume 2, pages 223-226. IEEE, 2010.\n\nOn the use of automated text summarization techniques for summarizing source code. S Haiduc, J Aponte, L Moreno, A Marcus, Working Conference on Reverse Engineering (WCRE). S. Haiduc, J. Aponte, L. Moreno, and A. Marcus. On the use of automated text summarization techniques for summarizing source code. In Working Conference on Reverse Engineering (WCRE), pages 35-44, 2010.\n\nVisual support for incremental abstraction and refinement in Ada 95. T D Hendrix, J H Cross, I I , L A Barowski, K S Mathias, In ACM SIGAda Ada Letters. 18ACMT. D. Hendrix, J. H. Cross II, L. A. Barowski, and K. S. Mathias. Visual support for incremental abstraction and refinement in Ada 95. In ACM SIGAda Ada Letters, volume 18, pages 142-147. ACM, 1998.\n\nOn the naturalness of software. A Hindle, E T Barr, Z Su, M Gabel, P Devanbu, International Conference on Software Engineering (ICSE). IEEEA. Hindle, E. T. Barr, Z. Su, M. Gabel, and P. Devanbu. On the naturalness of software. In International Conference on Software Engineering (ICSE), pages 837-847. IEEE, 2012.\n\nCode template inference using language models. F Jacob, R Tairas, Proceedings of the 48th Annual Southeast Regional Conference. the 48th Annual Southeast Regional ConferenceACM104F. Jacob and R. Tairas. Code template inference using language models. In Proceedings of the 48th Annual Southeast Regional Conference, page 104. ACM, 2010.\n\nEnriching documents with examples: A corpus mining approach. J Kim, S Lee, S.-W Hwang, S Kim, Transactions on Information Systems (TOIS). 311J. Kim, S. Lee, S.-W. Hwang, and S. Kim. Enriching documents with examples: A corpus mining approach. Transactions on Information Systems (TOIS), 31(1):1, 2013.\n\nAn exploratory study of how developers seek, relate, and collect relevant information during software maintenance tasks. A J Ko, B A Myers, M J Coblenz, H H Aung, IEEE Transactions on Software Engineering. 3212A. J. Ko, B. A. Myers, M. J. Coblenz, and H. H. Aung. An exploratory study of how developers seek, relate, and collect relevant information during software maintenance tasks. IEEE Transactions on Software Engineering, 32(12):971-987, 2006.\n\nFolding: An approach to enable program understanding of preprocessed languages. B Kullbach, V Riediger, Working Conference on Reverse Engineering (WCRE). IEEEB. Kullbach and V. Riediger. Folding: An approach to enable program understanding of preprocessed languages. In Working Conference on Reverse Engineering (WCRE), pages 3-12. IEEE, 2001.\n\nMaintaining mental models: a study of developer work habits. T D Latoza, G Venolia, R Deline, International Conference on Software Engineering (ICSE). ACMT. D. LaToza, G. Venolia, and R. DeLine. Maintaining mental models: a study of developer work habits. In International Conference on Software Engineering (ICSE), pages 492-501. ACM, 2006.\n\nWhat's in a name? A study of identifiers. D Lawrie, C Morrell, H Feild, D Binkley, International Conference on Program Comprehension (ICPC). IEEED. Lawrie, C. Morrell, H. Feild, and D. Binkley. What's in a name? A study of identifiers. In International Conference on Program Comprehension (ICPC), pages 3-12. IEEE, 2006.\n\nROUGE: A package for automatic evaluation of summaries. C.-Y. Lin, Text Summarization Branches Out: Proceedings of the ACL-04 Workshop. C.-Y. Lin. ROUGE: A package for automatic evaluation of summaries. In Text Summarization Branches Out: Proceedings of the ACL-04 Workshop, pages 74-81, 2004.\n\nAusum: approach for unsupervised bug report summarization. S Mani, R Catherine, V S Sinha, A Dubey, Foundations of Software Engineering (FSE). ACM11S. Mani, R. Catherine, V. S. Sinha, and A. Dubey. Ausum: approach for unsupervised bug report summarization. In Foundations of Software Engineering (FSE), page 11. ACM, 2012.\n\nRecovering documentation-to-source-code traceability links using latent semantic indexing. A Marcus, J I Maletic, International Conference on Software Engineering (ICSE). Washington, DC, USAIEEEA. Marcus and J. I. Maletic. Recovering documentation-to-source-code traceability links using latent semantic indexing. In International Conference on Software Engineering (ICSE), pages 125-135, Washington, DC, USA, 2003. IEEE.\n\nAn information retrieval approach to concept location in source code. A Marcus, A Sergeyev, V Rajlich, J I Maletic, Working Conference on Reverse Engineering (WCRE). IEEEA. Marcus, A. Sergeyev, V. Rajlich, and J. I. Maletic. An information retrieval approach to concept location in source code. In Working Conference on Reverse Engineering (WCRE), pages 214-223. IEEE, 2004.\n\nMixtures of hierarchical topics with pachinko allocation. D Mimno, W Li, A Mccallum, International Conference on Machine Learning (ICML). ACMD. Mimno, W. Li, and A. McCallum. Mixtures of hierarchical topics with pachinko allocation. In International Conference on Machine Learning (ICML), pages 633-640. ACM, 2007.\n\nAutomatic generation of natural language summaries for Java classes. L Moreno, J Aponte, G Sridhara, A Marcus, L Pollock, K Vijay-Shanker, International Conference on Program Comprehension (ICPC). IEEEL. Moreno, J. Aponte, G. Sridhara, A. Marcus, L. Pollock, and K. Vijay-Shanker. Automatic generation of natural language summaries for Java classes. In International Conference on Program Comprehension (ICPC), pages 23-32. IEEE, 2013.\n\nNatural language models for predicting programming comments. D Movshovitz-Attias, W W Cohen, Association for Computational Linguistics (ACL). D. Movshovitz-Attias and W. W. Cohen. Natural language models for predicting programming comments. In Association for Computational Linguistics (ACL), 2013.\n\nLexical statistical machine translation for language migration. A T Nguyen, T T Nguyen, T N Nguyen, Joint Meeting on Foundations of Software Engineering (FSE). ACMA. T. Nguyen, T. T. Nguyen, and T. N. Nguyen. Lexical statistical machine translation for language migration. In Joint Meeting on Foundations of Software Engineering (FSE). ACM, 2013.\n\nA statistical semantic language model for source code. T T Nguyen, A T Nguyen, H A Nguyen, T N Nguyen, Joint Meeting on Foundations of Software Engineering (FSE). ACMT. T. Nguyen, A. T. Nguyen, H. A. Nguyen, and T. N. Nguyen. A statistical semantic language model for source code. In Joint Meeting on Foundations of Software Engineering (FSE), pages 532-542. ACM, 2013.\n\nUser's guide to sigf: Significance testing by approximate randomisation. S Pad\u00f3, S. Pad\u00f3. User's guide to sigf: Significance testing by approximate randomisation, 2006.\n\nSummarizing software artifacts: a case study of bug reports. S Rastkar, G C Murphy, G Murray, International Conference on Software Engineering (ICSE). ACMS. Rastkar, G. C. Murphy, and G. Murray. Summarizing software artifacts: a case study of bug reports. In International Conference on Software Engineering (ICSE), pages 505-514. ACM, 2010.\n\nA conceptual model for folding. S Rugaber, N Chainani, O Nnadi, K Stirewalt, GT-CS-08-09Georgia Institute of TechnologyTechnical ReportS. Rugaber, N. Chainani, O. Nnadi, and K. Stirewalt. A conceptual model for folding. Technical Report GT-CS-08-09, Georgia Institute of Technology, 2008.\n\nTopic XP: Exploring topics in source code using latent Dirichlet allocation. T Savage, B Dit, M Gethers, D Poshyvanyk, International Conference on Software Maintenance (ICSM). IEEET. Savage, B. Dit, M. Gethers, and D. Poshyvanyk. Topic XP: Exploring topics in source code using latent Dirichlet allocation. In International Conference on Software Maintenance (ICSM), pages 1-6. IEEE, 2010.\n\nAutomatic summarising: The state of the art. Information Processing & Management. K , Sp\u00e4rck Jones, 43K. Sp\u00e4rck Jones. Automatic summarising: The state of the art. Information Processing & Management, 43(6):1449-1481, 2007.\n\nTowards automatically generating summary comments for Java methods. G Sridhara, E Hill, D Muppaneni, L Pollock, K Vijay-Shanker, International Conference on Automated Software Engineering (ASE). ACMG. Sridhara, E. Hill, D. Muppaneni, L. Pollock, and K. Vijay-Shanker. Towards automatically generating summary comments for Java methods. In International Conference on Automated Software Engineering (ASE), pages 43-52. ACM, 2010.\n\nAutomatically detecting and describing high level actions within methods. G Sridhara, L Pollock, K Vijay-Shanker, International Conference on Software Engineering (ICSE). G. Sridhara, L. Pollock, and K. Vijay-Shanker. Automatically detecting and describing high level actions within methods. In International Conference on Software Engineering (ICSE), pages 101-110, 2011.\n\nSearching and skimming: An exploratory study. J Starke, C Luce, J Sillito, International Conference on Software Maintenance (ICSM). IEEEJ. Starke, C. Luce, and J. Sillito. Searching and skimming: An exploratory study. In International Conference on Software Maintenance (ICSM), pages 157-166. IEEE, 2009.\n\nProbabilistic topic models. Handbook of latent semantic analysis. M Steyvers, T Griffiths, 427M. Steyvers and T. Griffiths. Probabilistic topic models. Handbook of latent semantic analysis, 427(7):424-440, 2007.\n\nTheories, methods and tools in program comprehension: Past, present and future. M.-A Storey, International Workshop on Program Comprehension (IWPC). IEEEM.-A. Storey. Theories, methods and tools in program comprehension: Past, present and future. In International Workshop on Program Comprehension (IWPC), pages 181-191. IEEE, 2005.\n\nMining software repositories using topic models. S W Thomas, International Conference on Software Engineering (ICSE). ACMS. W. Thomas. Mining software repositories using topic models. In International Conference on Software Engineering (ICSE), pages 1138-1139. ACM, 2011.\n\nStructured topic models for language. H M Wallach, PhD thesisH. M. Wallach. Structured topic models for language. PhD thesis, 2008.\n\nMining succinct and high-coverage API usage patterns from source code. J Wang, Y Dang, H Zhang, K Chen, T Xie, D Zhang, International Workshop on Mining Software Repositories (MSR). IEEE PressJ. Wang, Y. Dang, H. Zhang, K. Chen, T. Xie, and D. Zhang. Mining succinct and high-coverage API usage patterns from source code. In International Workshop on Mining Software Repositories (MSR), pages 319-328. IEEE Press, 2013.\n\nMAPO: Mining API usages from open source repositories. T Xie, J Pei, International Workshop on Mining Software Repositories (MSR). ACMT. Xie and J. Pei. MAPO: Mining API usages from open source repositories. In International Workshop on Mining Software Repositories (MSR), pages 54-57. ACM, 2006.\n\nCode fragment summarization. A T T Ying, M P Robillard, Joint Meeting on Foundations of Software Engineering (FSE). ACMA. T. T. Ying and M. P. Robillard. Code fragment summarization. In Joint Meeting on Foundations of Software Engineering (FSE), pages 655-658. ACM, 2013.\n", "annotations": {"author": "[{\"end\":78,\"start\":45},{\"end\":92,\"start\":79},{\"end\":134,\"start\":93},{\"end\":150,\"start\":135},{\"end\":183,\"start\":151},{\"end\":272,\"start\":184},{\"end\":317,\"start\":273}]", "publisher": null, "author_last_name": "[{\"end\":60,\"start\":54},{\"end\":91,\"start\":86},{\"end\":112,\"start\":103},{\"end\":149,\"start\":143},{\"end\":165,\"start\":159}]", "author_first_name": "[{\"end\":53,\"start\":45},{\"end\":85,\"start\":79},{\"end\":102,\"start\":93},{\"end\":142,\"start\":135},{\"end\":158,\"start\":151}]", "author_affiliation": "[{\"end\":271,\"start\":185},{\"end\":316,\"start\":274}]", "title": "[{\"end\":42,\"start\":1},{\"end\":359,\"start\":318}]", "venue": null, "abstract": "[{\"end\":1427,\"start\":361}]", "bib_ref": "[{\"attributes\":{\"ref_id\":\"b21\"},\"end\":1666,\"start\":1662},{\"attributes\":{\"ref_id\":\"b19\"},\"end\":1669,\"start\":1666},{\"attributes\":{\"ref_id\":\"b41\"},\"end\":1697,\"start\":1693},{\"attributes\":{\"ref_id\":\"b13\"},\"end\":2450,\"start\":2446},{\"attributes\":{\"ref_id\":\"b39\"},\"end\":3342,\"start\":3338},{\"attributes\":{\"ref_id\":\"b15\"},\"end\":3581,\"start\":3577},{\"attributes\":{\"ref_id\":\"b20\"},\"end\":3584,\"start\":3581},{\"attributes\":{\"ref_id\":\"b34\"},\"end\":3587,\"start\":3584},{\"attributes\":{\"ref_id\":\"b43\"},\"end\":5416,\"start\":5414},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":6179,\"start\":6176},{\"attributes\":{\"ref_id\":\"b16\"},\"end\":6182,\"start\":6179},{\"attributes\":{\"ref_id\":\"b17\"},\"end\":6185,\"start\":6182},{\"attributes\":{\"ref_id\":\"b22\"},\"end\":6188,\"start\":6185},{\"attributes\":{\"ref_id\":\"b31\"},\"end\":6191,\"start\":6188},{\"attributes\":{\"ref_id\":\"b37\"},\"end\":6225,\"start\":6221},{\"attributes\":{\"ref_id\":\"b38\"},\"end\":6228,\"start\":6225},{\"attributes\":{\"ref_id\":\"b30\"},\"end\":6254,\"start\":6250},{\"attributes\":{\"ref_id\":\"b29\"},\"end\":6280,\"start\":6276},{\"attributes\":{\"ref_id\":\"b34\"},\"end\":6900,\"start\":6896},{\"attributes\":{\"ref_id\":\"b20\"},\"end\":7017,\"start\":7013},{\"attributes\":{\"ref_id\":\"b15\"},\"end\":7262,\"start\":7258},{\"attributes\":{\"ref_id\":\"b13\"},\"end\":7482,\"start\":7478},{\"attributes\":{\"ref_id\":\"b14\"},\"end\":7485,\"start\":7482},{\"attributes\":{\"ref_id\":\"b8\"},\"end\":7527,\"start\":7524},{\"attributes\":{\"ref_id\":\"b46\"},\"end\":7973,\"start\":7969},{\"attributes\":{\"ref_id\":\"b18\"},\"end\":8595,\"start\":8591},{\"attributes\":{\"ref_id\":\"b8\"},\"end\":9276,\"start\":9273},{\"attributes\":{\"ref_id\":\"b14\"},\"end\":9456,\"start\":9452},{\"attributes\":{\"ref_id\":\"b36\"},\"end\":9888,\"start\":9884},{\"attributes\":{\"ref_id\":\"b0\"},\"end\":10151,\"start\":10148},{\"attributes\":{\"ref_id\":\"b6\"},\"end\":10153,\"start\":10151},{\"attributes\":{\"ref_id\":\"b4\"},\"end\":10304,\"start\":10301},{\"attributes\":{\"ref_id\":\"b24\"},\"end\":10404,\"start\":10400},{\"attributes\":{\"ref_id\":\"b33\"},\"end\":10407,\"start\":10404},{\"attributes\":{\"ref_id\":\"b3\"},\"end\":10602,\"start\":10599},{\"attributes\":{\"ref_id\":\"b44\"},\"end\":10645,\"start\":10641},{\"attributes\":{\"ref_id\":\"b45\"},\"end\":10648,\"start\":10645},{\"attributes\":{\"ref_id\":\"b28\"},\"end\":10719,\"start\":10715},{\"attributes\":{\"ref_id\":\"b37\"},\"end\":10722,\"start\":10719},{\"attributes\":{\"ref_id\":\"b4\"},\"end\":10799,\"start\":10796},{\"attributes\":{\"ref_id\":\"b10\"},\"end\":10802,\"start\":10799},{\"attributes\":{\"ref_id\":\"b35\"},\"end\":10805,\"start\":10802},{\"attributes\":{\"ref_id\":\"b42\"},\"end\":10808,\"start\":10805},{\"attributes\":{\"ref_id\":\"b25\"},\"end\":10828,\"start\":10824},{\"attributes\":{\"ref_id\":\"b26\"},\"end\":10831,\"start\":10828},{\"attributes\":{\"ref_id\":\"b5\"},\"end\":10871,\"start\":10868},{\"attributes\":{\"ref_id\":\"b14\"},\"end\":10996,\"start\":10992},{\"attributes\":{\"ref_id\":\"b27\"},\"end\":11181,\"start\":11177},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":11270,\"start\":11267},{\"attributes\":{\"ref_id\":\"b29\"},\"end\":11336,\"start\":11332},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":11376,\"start\":11372},{\"attributes\":{\"ref_id\":\"b11\"},\"end\":11596,\"start\":11592},{\"attributes\":{\"ref_id\":\"b12\"},\"end\":16602,\"start\":16598},{\"attributes\":{\"ref_id\":\"b40\"},\"end\":17375,\"start\":17371},{\"attributes\":{\"ref_id\":\"b12\"},\"end\":17807,\"start\":17803},{\"attributes\":{\"ref_id\":\"b40\"},\"end\":20141,\"start\":20137},{\"attributes\":{\"ref_id\":\"b40\"},\"end\":20411,\"start\":20407},{\"attributes\":{\"ref_id\":\"b43\"},\"end\":21456,\"start\":21452},{\"attributes\":{\"ref_id\":\"b12\"},\"end\":24059,\"start\":24055},{\"attributes\":{\"ref_id\":\"b14\"},\"end\":25304,\"start\":25300},{\"attributes\":{\"ref_id\":\"b8\"},\"end\":25306,\"start\":25304},{\"attributes\":{\"ref_id\":\"b23\"},\"end\":28169,\"start\":28165},{\"attributes\":{\"ref_id\":\"b32\"},\"end\":39864,\"start\":39860},{\"attributes\":{\"ref_id\":\"b14\"},\"end\":41411,\"start\":41407},{\"attributes\":{\"ref_id\":\"b7\"},\"end\":46306,\"start\":46303}]", "figure": "[{\"attributes\":{\"id\":\"fig_0\"},\"end\":41644,\"start\":41488},{\"attributes\":{\"id\":\"fig_1\"},\"end\":41828,\"start\":41645},{\"attributes\":{\"id\":\"fig_2\"},\"end\":41928,\"start\":41829},{\"attributes\":{\"id\":\"fig_4\"},\"end\":42062,\"start\":41929},{\"attributes\":{\"id\":\"fig_5\"},\"end\":42277,\"start\":42063},{\"attributes\":{\"id\":\"fig_6\"},\"end\":42381,\"start\":42278},{\"attributes\":{\"id\":\"tab_4\",\"type\":\"table\"},\"end\":43055,\"start\":42382},{\"attributes\":{\"id\":\"tab_6\",\"type\":\"table\"},\"end\":43201,\"start\":43056},{\"attributes\":{\"id\":\"tab_8\",\"type\":\"table\"},\"end\":43357,\"start\":43202},{\"attributes\":{\"id\":\"tab_9\",\"type\":\"table\"},\"end\":43621,\"start\":43358},{\"attributes\":{\"id\":\"tab_10\",\"type\":\"table\"},\"end\":46241,\"start\":43622}]", "paragraph": "[{\"end\":1826,\"start\":1443},{\"end\":2636,\"start\":1828},{\"end\":3343,\"start\":2638},{\"end\":3897,\"start\":3345},{\"end\":4512,\"start\":3899},{\"end\":4561,\"start\":4514},{\"end\":4941,\"start\":4563},{\"end\":5304,\"start\":4943},{\"end\":5642,\"start\":5306},{\"end\":5844,\"start\":5644},{\"end\":6010,\"start\":5846},{\"end\":6337,\"start\":6027},{\"end\":6780,\"start\":6339},{\"end\":7263,\"start\":6782},{\"end\":7949,\"start\":7265},{\"end\":8844,\"start\":7951},{\"end\":9557,\"start\":8846},{\"end\":9810,\"start\":9559},{\"end\":10408,\"start\":9812},{\"end\":10723,\"start\":10410},{\"end\":11429,\"start\":10725},{\"end\":11727,\"start\":11431},{\"end\":12473,\"start\":11751},{\"end\":12963,\"start\":12475},{\"end\":13615,\"start\":12986},{\"end\":14567,\"start\":13617},{\"end\":16120,\"start\":14569},{\"end\":16882,\"start\":16138},{\"end\":17376,\"start\":16884},{\"end\":18768,\"start\":17378},{\"end\":20302,\"start\":18770},{\"end\":20582,\"start\":20304},{\"end\":21457,\"start\":20782},{\"end\":21968,\"start\":21459},{\"end\":22845,\"start\":21970},{\"end\":23225,\"start\":22869},{\"end\":24437,\"start\":23227},{\"end\":24671,\"start\":24439},{\"end\":25377,\"start\":24697},{\"end\":25965,\"start\":25379},{\"end\":26757,\"start\":25989},{\"end\":27048,\"start\":26800},{\"end\":27684,\"start\":27154},{\"end\":27811,\"start\":27725},{\"end\":28920,\"start\":27834},{\"end\":29334,\"start\":28922},{\"end\":30118,\"start\":29359},{\"end\":30687,\"start\":30120},{\"end\":31345,\"start\":30689},{\"end\":31708,\"start\":31347},{\"end\":32006,\"start\":31734},{\"end\":32379,\"start\":32018},{\"end\":34572,\"start\":32395},{\"end\":35134,\"start\":34574},{\"end\":35333,\"start\":35136},{\"end\":35552,\"start\":35335},{\"end\":35844,\"start\":35554},{\"end\":36325,\"start\":35846},{\"end\":37319,\"start\":36341},{\"end\":37486,\"start\":37321},{\"end\":38411,\"start\":37488},{\"end\":38603,\"start\":38413},{\"end\":39781,\"start\":38605},{\"end\":40013,\"start\":39783},{\"end\":40496,\"start\":40015},{\"end\":40973,\"start\":40512},{\"end\":41216,\"start\":40975},{\"end\":41487,\"start\":41218}]", "formula": "[{\"attributes\":{\"id\":\"formula_0\"},\"end\":20781,\"start\":20583},{\"attributes\":{\"id\":\"formula_1\"},\"end\":24696,\"start\":24672},{\"attributes\":{\"id\":\"formula_2\"},\"end\":25988,\"start\":25966},{\"attributes\":{\"id\":\"formula_3\"},\"end\":26799,\"start\":26758},{\"attributes\":{\"id\":\"formula_4\"},\"end\":27153,\"start\":27049},{\"attributes\":{\"id\":\"formula_5\"},\"end\":27724,\"start\":27685}]", "table_ref": "[{\"attributes\":{\"ref_id\":\"tab_4\"},\"end\":28871,\"start\":28864},{\"end\":30530,\"start\":30523},{\"end\":32981,\"start\":32974},{\"attributes\":{\"ref_id\":\"tab_6\"},\"end\":37110,\"start\":37096},{\"attributes\":{\"ref_id\":\"tab_10\"},\"end\":37511,\"start\":37504},{\"end\":38375,\"start\":38368},{\"end\":38490,\"start\":38483},{\"end\":40336,\"start\":40329}]", "section_header": "[{\"attributes\":{\"n\":\"1.\"},\"end\":1441,\"start\":1429},{\"attributes\":{\"n\":\"2.\"},\"end\":6025,\"start\":6013},{\"attributes\":{\"n\":\"3.\"},\"end\":11749,\"start\":11730},{\"attributes\":{\"n\":\"3.1\"},\"end\":12984,\"start\":12966},{\"attributes\":{\"n\":\"3.2\"},\"end\":16136,\"start\":16123},{\"attributes\":{\"n\":\"3.3\"},\"end\":22867,\"start\":22848},{\"attributes\":{\"n\":\"4.\"},\"end\":27832,\"start\":27814},{\"end\":29357,\"start\":29337},{\"end\":31732,\"start\":31711},{\"attributes\":{\"n\":\"5.\"},\"end\":32016,\"start\":32009},{\"end\":32393,\"start\":32382},{\"end\":36339,\"start\":36328},{\"attributes\":{\"n\":\"6.\"},\"end\":40510,\"start\":40499},{\"end\":41499,\"start\":41489},{\"end\":41656,\"start\":41646},{\"end\":41840,\"start\":41830},{\"end\":41940,\"start\":41930},{\"end\":42074,\"start\":42064},{\"end\":42290,\"start\":42279},{\"end\":42392,\"start\":42383},{\"end\":43066,\"start\":43057},{\"end\":43212,\"start\":43203},{\"end\":43368,\"start\":43359},{\"end\":43632,\"start\":43623}]", "table": "[{\"end\":43055,\"start\":42475},{\"end\":43621,\"start\":43439},{\"end\":46241,\"start\":44458}]", "figure_caption": "[{\"end\":41644,\"start\":41501},{\"end\":41828,\"start\":41658},{\"end\":41928,\"start\":41842},{\"end\":42062,\"start\":41942},{\"end\":42277,\"start\":42076},{\"end\":42381,\"start\":42293},{\"end\":42475,\"start\":42394},{\"end\":43201,\"start\":43068},{\"end\":43357,\"start\":43214},{\"end\":43439,\"start\":43376},{\"end\":44458,\"start\":43634}]", "figure_ref": "[{\"end\":4275,\"start\":4267},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":4511,\"start\":4503},{\"end\":5515,\"start\":5507},{\"end\":7740,\"start\":7732},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":14514,\"start\":14506},{\"end\":14810,\"start\":14802},{\"end\":14876,\"start\":14868},{\"end\":15004,\"start\":14996},{\"end\":15270,\"start\":15262},{\"attributes\":{\"ref_id\":\"fig_1\"},\"end\":18032,\"start\":18023},{\"attributes\":{\"ref_id\":\"fig_1\"},\"end\":18563,\"start\":18555},{\"end\":21803,\"start\":21795},{\"end\":26544,\"start\":26536},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":26867,\"start\":26858},{\"attributes\":{\"ref_id\":\"fig_2\"},\"end\":29272,\"start\":29264},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":29984,\"start\":29976},{\"end\":35007,\"start\":34999},{\"end\":35272,\"start\":35264},{\"end\":35456,\"start\":35448},{\"end\":35740,\"start\":35732},{\"attributes\":{\"ref_id\":\"fig_5\"},\"end\":38410,\"start\":38402},{\"end\":39542,\"start\":39534},{\"attributes\":{\"ref_id\":\"fig_4\"},\"end\":40262,\"start\":40246},{\"attributes\":{\"ref_id\":\"fig_5\"},\"end\":40325,\"start\":40317}]", "bib_author_first_name": "[{\"end\":46856,\"start\":46855},{\"end\":46858,\"start\":46857},{\"end\":46867,\"start\":46866},{\"end\":46877,\"start\":46876},{\"end\":46888,\"start\":46887},{\"end\":47291,\"start\":47290},{\"end\":47304,\"start\":47303},{\"end\":47604,\"start\":47603},{\"end\":47606,\"start\":47605},{\"end\":47614,\"start\":47613},{\"end\":47616,\"start\":47615},{\"end\":47622,\"start\":47621},{\"end\":47624,\"start\":47623},{\"end\":47832,\"start\":47831},{\"end\":47834,\"start\":47833},{\"end\":47842,\"start\":47841},{\"end\":48137,\"start\":48136},{\"end\":48149,\"start\":48148},{\"end\":48152,\"start\":48150},{\"end\":48161,\"start\":48160},{\"end\":48172,\"start\":48171},{\"end\":48186,\"start\":48185},{\"end\":48470,\"start\":48469},{\"end\":48472,\"start\":48471},{\"end\":48486,\"start\":48485},{\"end\":48488,\"start\":48487},{\"end\":48498,\"start\":48497},{\"end\":48500,\"start\":48499},{\"end\":48512,\"start\":48511},{\"end\":48514,\"start\":48513},{\"end\":48524,\"start\":48523},{\"end\":48526,\"start\":48525},{\"end\":48753,\"start\":48752},{\"end\":48760,\"start\":48759},{\"end\":48771,\"start\":48770},{\"end\":48782,\"start\":48781},{\"end\":49040,\"start\":49037},{\"end\":49225,\"start\":49224},{\"end\":49227,\"start\":49226},{\"end\":49235,\"start\":49234},{\"end\":49237,\"start\":49236},{\"end\":49249,\"start\":49248},{\"end\":49251,\"start\":49250},{\"end\":49260,\"start\":49259},{\"end\":49262,\"start\":49261},{\"end\":49608,\"start\":49607},{\"end\":49620,\"start\":49619},{\"end\":49632,\"start\":49631},{\"end\":49982,\"start\":49981},{\"end\":49993,\"start\":49992},{\"end\":50003,\"start\":50002},{\"end\":50006,\"start\":50004},{\"end\":50015,\"start\":50014},{\"end\":50026,\"start\":50025},{\"end\":50040,\"start\":50039},{\"end\":50360,\"start\":50359},{\"end\":50368,\"start\":50367},{\"end\":50376,\"start\":50375},{\"end\":50378,\"start\":50377},{\"end\":50386,\"start\":50385},{\"end\":50643,\"start\":50642},{\"end\":50655,\"start\":50654},{\"end\":50957,\"start\":50956},{\"end\":50967,\"start\":50966},{\"end\":50977,\"start\":50976},{\"end\":51332,\"start\":51331},{\"end\":51342,\"start\":51341},{\"end\":51352,\"start\":51351},{\"end\":51362,\"start\":51361},{\"end\":51695,\"start\":51694},{\"end\":51697,\"start\":51696},{\"end\":51708,\"start\":51707},{\"end\":51710,\"start\":51709},{\"end\":51719,\"start\":51718},{\"end\":51721,\"start\":51720},{\"end\":51725,\"start\":51724},{\"end\":51727,\"start\":51726},{\"end\":51739,\"start\":51738},{\"end\":51741,\"start\":51740},{\"end\":52016,\"start\":52015},{\"end\":52026,\"start\":52025},{\"end\":52028,\"start\":52027},{\"end\":52036,\"start\":52035},{\"end\":52042,\"start\":52041},{\"end\":52051,\"start\":52050},{\"end\":52346,\"start\":52345},{\"end\":52355,\"start\":52354},{\"end\":52697,\"start\":52696},{\"end\":52704,\"start\":52703},{\"end\":52714,\"start\":52710},{\"end\":52723,\"start\":52722},{\"end\":53060,\"start\":53059},{\"end\":53062,\"start\":53061},{\"end\":53068,\"start\":53067},{\"end\":53070,\"start\":53069},{\"end\":53079,\"start\":53078},{\"end\":53081,\"start\":53080},{\"end\":53092,\"start\":53091},{\"end\":53094,\"start\":53093},{\"end\":53470,\"start\":53469},{\"end\":53482,\"start\":53481},{\"end\":53796,\"start\":53795},{\"end\":53798,\"start\":53797},{\"end\":53808,\"start\":53807},{\"end\":53819,\"start\":53818},{\"end\":54120,\"start\":54119},{\"end\":54130,\"start\":54129},{\"end\":54141,\"start\":54140},{\"end\":54150,\"start\":54149},{\"end\":54460,\"start\":54455},{\"end\":54754,\"start\":54753},{\"end\":54762,\"start\":54761},{\"end\":54775,\"start\":54774},{\"end\":54777,\"start\":54776},{\"end\":54786,\"start\":54785},{\"end\":55110,\"start\":55109},{\"end\":55120,\"start\":55119},{\"end\":55122,\"start\":55121},{\"end\":55512,\"start\":55511},{\"end\":55522,\"start\":55521},{\"end\":55534,\"start\":55533},{\"end\":55545,\"start\":55544},{\"end\":55547,\"start\":55546},{\"end\":55876,\"start\":55875},{\"end\":55885,\"start\":55884},{\"end\":55891,\"start\":55890},{\"end\":56203,\"start\":56202},{\"end\":56213,\"start\":56212},{\"end\":56223,\"start\":56222},{\"end\":56235,\"start\":56234},{\"end\":56245,\"start\":56244},{\"end\":56256,\"start\":56255},{\"end\":56632,\"start\":56631},{\"end\":56653,\"start\":56652},{\"end\":56655,\"start\":56654},{\"end\":56935,\"start\":56934},{\"end\":56937,\"start\":56936},{\"end\":56947,\"start\":56946},{\"end\":56949,\"start\":56948},{\"end\":56959,\"start\":56958},{\"end\":56961,\"start\":56960},{\"end\":57274,\"start\":57273},{\"end\":57276,\"start\":57275},{\"end\":57286,\"start\":57285},{\"end\":57288,\"start\":57287},{\"end\":57298,\"start\":57297},{\"end\":57300,\"start\":57299},{\"end\":57310,\"start\":57309},{\"end\":57312,\"start\":57311},{\"end\":57663,\"start\":57662},{\"end\":57821,\"start\":57820},{\"end\":57832,\"start\":57831},{\"end\":57834,\"start\":57833},{\"end\":57844,\"start\":57843},{\"end\":58135,\"start\":58134},{\"end\":58146,\"start\":58145},{\"end\":58158,\"start\":58157},{\"end\":58167,\"start\":58166},{\"end\":58470,\"start\":58469},{\"end\":58480,\"start\":58479},{\"end\":58487,\"start\":58486},{\"end\":58498,\"start\":58497},{\"end\":58866,\"start\":58865},{\"end\":58875,\"start\":58869},{\"end\":59077,\"start\":59076},{\"end\":59089,\"start\":59088},{\"end\":59097,\"start\":59096},{\"end\":59110,\"start\":59109},{\"end\":59121,\"start\":59120},{\"end\":59513,\"start\":59512},{\"end\":59525,\"start\":59524},{\"end\":59536,\"start\":59535},{\"end\":59859,\"start\":59858},{\"end\":59869,\"start\":59868},{\"end\":59877,\"start\":59876},{\"end\":60185,\"start\":60184},{\"end\":60197,\"start\":60196},{\"end\":60415,\"start\":60411},{\"end\":60715,\"start\":60714},{\"end\":60717,\"start\":60716},{\"end\":60977,\"start\":60976},{\"end\":60979,\"start\":60978},{\"end\":61143,\"start\":61142},{\"end\":61151,\"start\":61150},{\"end\":61159,\"start\":61158},{\"end\":61168,\"start\":61167},{\"end\":61176,\"start\":61175},{\"end\":61183,\"start\":61182},{\"end\":61548,\"start\":61547},{\"end\":61555,\"start\":61554},{\"end\":61820,\"start\":61819},{\"end\":61824,\"start\":61821},{\"end\":61832,\"start\":61831},{\"end\":61834,\"start\":61833}]", "bib_author_last_name": "[{\"end\":46864,\"start\":46859},{\"end\":46874,\"start\":46868},{\"end\":46885,\"start\":46878},{\"end\":46895,\"start\":46889},{\"end\":47301,\"start\":47292},{\"end\":47311,\"start\":47305},{\"end\":47611,\"start\":47607},{\"end\":47619,\"start\":47617},{\"end\":47631,\"start\":47625},{\"end\":47839,\"start\":47835},{\"end\":47849,\"start\":47843},{\"end\":48146,\"start\":48138},{\"end\":48158,\"start\":48153},{\"end\":48169,\"start\":48162},{\"end\":48183,\"start\":48173},{\"end\":48197,\"start\":48187},{\"end\":48483,\"start\":48473},{\"end\":48495,\"start\":48489},{\"end\":48509,\"start\":48501},{\"end\":48521,\"start\":48515},{\"end\":48535,\"start\":48527},{\"end\":48757,\"start\":48754},{\"end\":48768,\"start\":48761},{\"end\":48779,\"start\":48772},{\"end\":48793,\"start\":48783},{\"end\":49035,\"start\":49015},{\"end\":49048,\"start\":49041},{\"end\":49232,\"start\":49228},{\"end\":49246,\"start\":49238},{\"end\":49257,\"start\":49252},{\"end\":49269,\"start\":49263},{\"end\":49617,\"start\":49609},{\"end\":49629,\"start\":49621},{\"end\":49641,\"start\":49633},{\"end\":49990,\"start\":49983},{\"end\":50000,\"start\":49994},{\"end\":50012,\"start\":50007},{\"end\":50023,\"start\":50016},{\"end\":50037,\"start\":50027},{\"end\":50049,\"start\":50041},{\"end\":50365,\"start\":50361},{\"end\":50373,\"start\":50369},{\"end\":50383,\"start\":50379},{\"end\":50395,\"start\":50387},{\"end\":50652,\"start\":50644},{\"end\":50667,\"start\":50656},{\"end\":50964,\"start\":50958},{\"end\":50974,\"start\":50968},{\"end\":50984,\"start\":50978},{\"end\":51339,\"start\":51333},{\"end\":51349,\"start\":51343},{\"end\":51359,\"start\":51353},{\"end\":51369,\"start\":51363},{\"end\":51705,\"start\":51698},{\"end\":51716,\"start\":51711},{\"end\":51736,\"start\":51728},{\"end\":51749,\"start\":51742},{\"end\":52023,\"start\":52017},{\"end\":52033,\"start\":52029},{\"end\":52039,\"start\":52037},{\"end\":52048,\"start\":52043},{\"end\":52059,\"start\":52052},{\"end\":52352,\"start\":52347},{\"end\":52362,\"start\":52356},{\"end\":52701,\"start\":52698},{\"end\":52708,\"start\":52705},{\"end\":52720,\"start\":52715},{\"end\":52727,\"start\":52724},{\"end\":53065,\"start\":53063},{\"end\":53076,\"start\":53071},{\"end\":53089,\"start\":53082},{\"end\":53099,\"start\":53095},{\"end\":53479,\"start\":53471},{\"end\":53491,\"start\":53483},{\"end\":53805,\"start\":53799},{\"end\":53816,\"start\":53809},{\"end\":53826,\"start\":53820},{\"end\":54127,\"start\":54121},{\"end\":54138,\"start\":54131},{\"end\":54147,\"start\":54142},{\"end\":54158,\"start\":54151},{\"end\":54464,\"start\":54461},{\"end\":54759,\"start\":54755},{\"end\":54772,\"start\":54763},{\"end\":54783,\"start\":54778},{\"end\":54792,\"start\":54787},{\"end\":55117,\"start\":55111},{\"end\":55130,\"start\":55123},{\"end\":55519,\"start\":55513},{\"end\":55531,\"start\":55523},{\"end\":55542,\"start\":55535},{\"end\":55555,\"start\":55548},{\"end\":55882,\"start\":55877},{\"end\":55888,\"start\":55886},{\"end\":55900,\"start\":55892},{\"end\":56210,\"start\":56204},{\"end\":56220,\"start\":56214},{\"end\":56232,\"start\":56224},{\"end\":56242,\"start\":56236},{\"end\":56253,\"start\":56246},{\"end\":56270,\"start\":56257},{\"end\":56650,\"start\":56633},{\"end\":56661,\"start\":56656},{\"end\":56944,\"start\":56938},{\"end\":56956,\"start\":56950},{\"end\":56968,\"start\":56962},{\"end\":57283,\"start\":57277},{\"end\":57295,\"start\":57289},{\"end\":57307,\"start\":57301},{\"end\":57319,\"start\":57313},{\"end\":57668,\"start\":57664},{\"end\":57829,\"start\":57822},{\"end\":57841,\"start\":57835},{\"end\":57851,\"start\":57845},{\"end\":58143,\"start\":58136},{\"end\":58155,\"start\":58147},{\"end\":58164,\"start\":58159},{\"end\":58177,\"start\":58168},{\"end\":58477,\"start\":58471},{\"end\":58484,\"start\":58481},{\"end\":58495,\"start\":58488},{\"end\":58509,\"start\":58499},{\"end\":58881,\"start\":58876},{\"end\":59086,\"start\":59078},{\"end\":59094,\"start\":59090},{\"end\":59107,\"start\":59098},{\"end\":59118,\"start\":59111},{\"end\":59135,\"start\":59122},{\"end\":59522,\"start\":59514},{\"end\":59533,\"start\":59526},{\"end\":59550,\"start\":59537},{\"end\":59866,\"start\":59860},{\"end\":59874,\"start\":59870},{\"end\":59885,\"start\":59878},{\"end\":60194,\"start\":60186},{\"end\":60207,\"start\":60198},{\"end\":60422,\"start\":60416},{\"end\":60724,\"start\":60718},{\"end\":60987,\"start\":60980},{\"end\":61148,\"start\":61144},{\"end\":61156,\"start\":61152},{\"end\":61165,\"start\":61160},{\"end\":61173,\"start\":61169},{\"end\":61180,\"start\":61177},{\"end\":61189,\"start\":61184},{\"end\":61552,\"start\":61549},{\"end\":61559,\"start\":61556},{\"end\":61829,\"start\":61825},{\"end\":61844,\"start\":61835}]", "bib_entry": "[{\"attributes\":{\"id\":\"b0\",\"matched_paper_id\":25078069},\"end\":47214,\"start\":46786},{\"attributes\":{\"id\":\"b1\",\"matched_paper_id\":1857729},\"end\":47572,\"start\":47216},{\"attributes\":{\"id\":\"b2\",\"matched_paper_id\":3177797},\"end\":47796,\"start\":47574},{\"attributes\":{\"id\":\"b3\",\"matched_paper_id\":7077943},\"end\":48057,\"start\":47798},{\"attributes\":{\"id\":\"b4\",\"matched_paper_id\":15971714},\"end\":48429,\"start\":48059},{\"attributes\":{\"id\":\"b5\",\"matched_paper_id\":3252915},\"end\":48694,\"start\":48431},{\"attributes\":{\"id\":\"b6\",\"matched_paper_id\":7630279},\"end\":49011,\"start\":48696},{\"attributes\":{\"id\":\"b7\"},\"end\":49146,\"start\":49013},{\"attributes\":{\"id\":\"b8\",\"matched_paper_id\":12442030},\"end\":49553,\"start\":49148},{\"attributes\":{\"id\":\"b9\",\"matched_paper_id\":15439655},\"end\":49938,\"start\":49555},{\"attributes\":{\"id\":\"b10\",\"matched_paper_id\":6015957},\"end\":50319,\"start\":49940},{\"attributes\":{\"id\":\"b11\"},\"end\":50581,\"start\":50321},{\"attributes\":{\"id\":\"b12\",\"matched_paper_id\":678258},\"end\":50889,\"start\":50583},{\"attributes\":{\"id\":\"b13\",\"matched_paper_id\":10747140},\"end\":51246,\"start\":50891},{\"attributes\":{\"id\":\"b14\",\"matched_paper_id\":7843537},\"end\":51623,\"start\":51248},{\"attributes\":{\"id\":\"b15\",\"matched_paper_id\":527500},\"end\":51981,\"start\":51625},{\"attributes\":{\"id\":\"b16\",\"matched_paper_id\":2846066},\"end\":52296,\"start\":51983},{\"attributes\":{\"id\":\"b17\",\"matched_paper_id\":16912627},\"end\":52633,\"start\":52298},{\"attributes\":{\"id\":\"b18\",\"matched_paper_id\":8585584},\"end\":52936,\"start\":52635},{\"attributes\":{\"id\":\"b19\",\"matched_paper_id\":31296},\"end\":53387,\"start\":52938},{\"attributes\":{\"id\":\"b20\",\"matched_paper_id\":432993},\"end\":53732,\"start\":53389},{\"attributes\":{\"id\":\"b21\",\"matched_paper_id\":8485237},\"end\":54075,\"start\":53734},{\"attributes\":{\"id\":\"b22\"},\"end\":54397,\"start\":54077},{\"attributes\":{\"id\":\"b23\",\"matched_paper_id\":964287},\"end\":54692,\"start\":54399},{\"attributes\":{\"id\":\"b24\",\"matched_paper_id\":18627014},\"end\":55016,\"start\":54694},{\"attributes\":{\"id\":\"b25\",\"matched_paper_id\":7730498},\"end\":55439,\"start\":55018},{\"attributes\":{\"id\":\"b26\",\"matched_paper_id\":10984733},\"end\":55815,\"start\":55441},{\"attributes\":{\"id\":\"b27\",\"matched_paper_id\":6045658},\"end\":56131,\"start\":55817},{\"attributes\":{\"id\":\"b28\",\"matched_paper_id\":1129667},\"end\":56568,\"start\":56133},{\"attributes\":{\"id\":\"b29\",\"matched_paper_id\":6706547},\"end\":56868,\"start\":56570},{\"attributes\":{\"id\":\"b30\",\"matched_paper_id\":15149849},\"end\":57216,\"start\":56870},{\"attributes\":{\"id\":\"b31\",\"matched_paper_id\":17169661},\"end\":57587,\"start\":57218},{\"attributes\":{\"id\":\"b32\"},\"end\":57757,\"start\":57589},{\"attributes\":{\"id\":\"b33\",\"matched_paper_id\":11703129},\"end\":58100,\"start\":57759},{\"attributes\":{\"doi\":\"GT-CS-08-09\",\"id\":\"b34\"},\"end\":58390,\"start\":58102},{\"attributes\":{\"id\":\"b35\"},\"end\":58781,\"start\":58392},{\"attributes\":{\"id\":\"b36\"},\"end\":59006,\"start\":58783},{\"attributes\":{\"id\":\"b37\",\"matched_paper_id\":9790585},\"end\":59436,\"start\":59008},{\"attributes\":{\"id\":\"b38\",\"matched_paper_id\":11106352},\"end\":59810,\"start\":59438},{\"attributes\":{\"id\":\"b39\",\"matched_paper_id\":15559434},\"end\":60116,\"start\":59812},{\"attributes\":{\"id\":\"b40\"},\"end\":60329,\"start\":60118},{\"attributes\":{\"id\":\"b41\",\"matched_paper_id\":17007528},\"end\":60663,\"start\":60331},{\"attributes\":{\"id\":\"b42\",\"matched_paper_id\":9441150},\"end\":60936,\"start\":60665},{\"attributes\":{\"id\":\"b43\"},\"end\":61069,\"start\":60938},{\"attributes\":{\"id\":\"b44\",\"matched_paper_id\":13124732},\"end\":61490,\"start\":61071},{\"attributes\":{\"id\":\"b45\",\"matched_paper_id\":8548919},\"end\":61788,\"start\":61492},{\"attributes\":{\"id\":\"b46\",\"matched_paper_id\":15836170},\"end\":62061,\"start\":61790}]", "bib_title": "[{\"end\":46853,\"start\":46786},{\"end\":47288,\"start\":47216},{\"end\":47601,\"start\":47574},{\"end\":47829,\"start\":47798},{\"end\":48134,\"start\":48059},{\"end\":48467,\"start\":48431},{\"end\":48750,\"start\":48696},{\"end\":49222,\"start\":49148},{\"end\":49605,\"start\":49555},{\"end\":49979,\"start\":49940},{\"end\":50357,\"start\":50321},{\"end\":50640,\"start\":50583},{\"end\":50954,\"start\":50891},{\"end\":51329,\"start\":51248},{\"end\":51692,\"start\":51625},{\"end\":52013,\"start\":51983},{\"end\":52343,\"start\":52298},{\"end\":52694,\"start\":52635},{\"end\":53057,\"start\":52938},{\"end\":53467,\"start\":53389},{\"end\":53793,\"start\":53734},{\"end\":54117,\"start\":54077},{\"end\":54453,\"start\":54399},{\"end\":54751,\"start\":54694},{\"end\":55107,\"start\":55018},{\"end\":55509,\"start\":55441},{\"end\":55873,\"start\":55817},{\"end\":56200,\"start\":56133},{\"end\":56629,\"start\":56570},{\"end\":56932,\"start\":56870},{\"end\":57271,\"start\":57218},{\"end\":57818,\"start\":57759},{\"end\":58467,\"start\":58392},{\"end\":59074,\"start\":59008},{\"end\":59510,\"start\":59438},{\"end\":59856,\"start\":59812},{\"end\":60409,\"start\":60331},{\"end\":60712,\"start\":60665},{\"end\":61140,\"start\":61071},{\"end\":61545,\"start\":61492},{\"end\":61817,\"start\":61790}]", "bib_author": "[{\"end\":46866,\"start\":46855},{\"end\":46876,\"start\":46866},{\"end\":46887,\"start\":46876},{\"end\":46897,\"start\":46887},{\"end\":47303,\"start\":47290},{\"end\":47313,\"start\":47303},{\"end\":47613,\"start\":47603},{\"end\":47621,\"start\":47613},{\"end\":47633,\"start\":47621},{\"end\":47841,\"start\":47831},{\"end\":47851,\"start\":47841},{\"end\":48148,\"start\":48136},{\"end\":48160,\"start\":48148},{\"end\":48171,\"start\":48160},{\"end\":48185,\"start\":48171},{\"end\":48199,\"start\":48185},{\"end\":48485,\"start\":48469},{\"end\":48497,\"start\":48485},{\"end\":48511,\"start\":48497},{\"end\":48523,\"start\":48511},{\"end\":48537,\"start\":48523},{\"end\":48759,\"start\":48752},{\"end\":48770,\"start\":48759},{\"end\":48781,\"start\":48770},{\"end\":48795,\"start\":48781},{\"end\":49037,\"start\":49015},{\"end\":49050,\"start\":49037},{\"end\":49234,\"start\":49224},{\"end\":49248,\"start\":49234},{\"end\":49259,\"start\":49248},{\"end\":49271,\"start\":49259},{\"end\":49619,\"start\":49607},{\"end\":49631,\"start\":49619},{\"end\":49643,\"start\":49631},{\"end\":49992,\"start\":49981},{\"end\":50002,\"start\":49992},{\"end\":50014,\"start\":50002},{\"end\":50025,\"start\":50014},{\"end\":50039,\"start\":50025},{\"end\":50051,\"start\":50039},{\"end\":50367,\"start\":50359},{\"end\":50375,\"start\":50367},{\"end\":50385,\"start\":50375},{\"end\":50397,\"start\":50385},{\"end\":50654,\"start\":50642},{\"end\":50669,\"start\":50654},{\"end\":50966,\"start\":50956},{\"end\":50976,\"start\":50966},{\"end\":50986,\"start\":50976},{\"end\":51341,\"start\":51331},{\"end\":51351,\"start\":51341},{\"end\":51361,\"start\":51351},{\"end\":51371,\"start\":51361},{\"end\":51707,\"start\":51694},{\"end\":51718,\"start\":51707},{\"end\":51724,\"start\":51718},{\"end\":51738,\"start\":51724},{\"end\":51751,\"start\":51738},{\"end\":52025,\"start\":52015},{\"end\":52035,\"start\":52025},{\"end\":52041,\"start\":52035},{\"end\":52050,\"start\":52041},{\"end\":52061,\"start\":52050},{\"end\":52354,\"start\":52345},{\"end\":52364,\"start\":52354},{\"end\":52703,\"start\":52696},{\"end\":52710,\"start\":52703},{\"end\":52722,\"start\":52710},{\"end\":52729,\"start\":52722},{\"end\":53067,\"start\":53059},{\"end\":53078,\"start\":53067},{\"end\":53091,\"start\":53078},{\"end\":53101,\"start\":53091},{\"end\":53481,\"start\":53469},{\"end\":53493,\"start\":53481},{\"end\":53807,\"start\":53795},{\"end\":53818,\"start\":53807},{\"end\":53828,\"start\":53818},{\"end\":54129,\"start\":54119},{\"end\":54140,\"start\":54129},{\"end\":54149,\"start\":54140},{\"end\":54160,\"start\":54149},{\"end\":54466,\"start\":54455},{\"end\":54761,\"start\":54753},{\"end\":54774,\"start\":54761},{\"end\":54785,\"start\":54774},{\"end\":54794,\"start\":54785},{\"end\":55119,\"start\":55109},{\"end\":55132,\"start\":55119},{\"end\":55521,\"start\":55511},{\"end\":55533,\"start\":55521},{\"end\":55544,\"start\":55533},{\"end\":55557,\"start\":55544},{\"end\":55884,\"start\":55875},{\"end\":55890,\"start\":55884},{\"end\":55902,\"start\":55890},{\"end\":56212,\"start\":56202},{\"end\":56222,\"start\":56212},{\"end\":56234,\"start\":56222},{\"end\":56244,\"start\":56234},{\"end\":56255,\"start\":56244},{\"end\":56272,\"start\":56255},{\"end\":56652,\"start\":56631},{\"end\":56663,\"start\":56652},{\"end\":56946,\"start\":56934},{\"end\":56958,\"start\":56946},{\"end\":56970,\"start\":56958},{\"end\":57285,\"start\":57273},{\"end\":57297,\"start\":57285},{\"end\":57309,\"start\":57297},{\"end\":57321,\"start\":57309},{\"end\":57670,\"start\":57662},{\"end\":57831,\"start\":57820},{\"end\":57843,\"start\":57831},{\"end\":57853,\"start\":57843},{\"end\":58145,\"start\":58134},{\"end\":58157,\"start\":58145},{\"end\":58166,\"start\":58157},{\"end\":58179,\"start\":58166},{\"end\":58479,\"start\":58469},{\"end\":58486,\"start\":58479},{\"end\":58497,\"start\":58486},{\"end\":58511,\"start\":58497},{\"end\":58869,\"start\":58865},{\"end\":58883,\"start\":58869},{\"end\":59088,\"start\":59076},{\"end\":59096,\"start\":59088},{\"end\":59109,\"start\":59096},{\"end\":59120,\"start\":59109},{\"end\":59137,\"start\":59120},{\"end\":59524,\"start\":59512},{\"end\":59535,\"start\":59524},{\"end\":59552,\"start\":59535},{\"end\":59868,\"start\":59858},{\"end\":59876,\"start\":59868},{\"end\":59887,\"start\":59876},{\"end\":60196,\"start\":60184},{\"end\":60209,\"start\":60196},{\"end\":60424,\"start\":60411},{\"end\":60726,\"start\":60714},{\"end\":60989,\"start\":60976},{\"end\":61150,\"start\":61142},{\"end\":61158,\"start\":61150},{\"end\":61167,\"start\":61158},{\"end\":61175,\"start\":61167},{\"end\":61182,\"start\":61175},{\"end\":61191,\"start\":61182},{\"end\":61554,\"start\":61547},{\"end\":61561,\"start\":61554},{\"end\":61831,\"start\":61819},{\"end\":61846,\"start\":61831}]", "bib_venue": "[{\"end\":46977,\"start\":46897},{\"end\":47373,\"start\":47313},{\"end\":47669,\"start\":47633},{\"end\":47906,\"start\":47851},{\"end\":48229,\"start\":48199},{\"end\":48542,\"start\":48537},{\"end\":48837,\"start\":48795},{\"end\":49327,\"start\":49271},{\"end\":49722,\"start\":49643},{\"end\":50106,\"start\":50051},{\"end\":50436,\"start\":50397},{\"end\":50716,\"start\":50669},{\"end\":51041,\"start\":50986},{\"end\":51419,\"start\":51371},{\"end\":51776,\"start\":51751},{\"end\":52116,\"start\":52061},{\"end\":52424,\"start\":52364},{\"end\":52771,\"start\":52729},{\"end\":53142,\"start\":53101},{\"end\":53541,\"start\":53493},{\"end\":53883,\"start\":53828},{\"end\":54216,\"start\":54160},{\"end\":54533,\"start\":54466},{\"end\":54835,\"start\":54794},{\"end\":55187,\"start\":55132},{\"end\":55605,\"start\":55557},{\"end\":55953,\"start\":55902},{\"end\":56328,\"start\":56272},{\"end\":56710,\"start\":56663},{\"end\":57028,\"start\":56970},{\"end\":57379,\"start\":57321},{\"end\":57660,\"start\":57589},{\"end\":57908,\"start\":57853},{\"end\":58132,\"start\":58102},{\"end\":58566,\"start\":58511},{\"end\":58863,\"start\":58783},{\"end\":59201,\"start\":59137},{\"end\":59607,\"start\":59552},{\"end\":59942,\"start\":59887},{\"end\":60182,\"start\":60118},{\"end\":60478,\"start\":60424},{\"end\":60781,\"start\":60726},{\"end\":60974,\"start\":60938},{\"end\":61251,\"start\":61191},{\"end\":61621,\"start\":61561},{\"end\":61904,\"start\":61846},{\"end\":52471,\"start\":52426},{\"end\":55208,\"start\":55189}]"}}}, "year": 2023, "month": 12, "day": 17}