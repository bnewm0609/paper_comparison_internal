{"id": 231878073, "updated": "2022-08-10 13:35:24.756", "metadata": {"title": "A Formal Analysis of the FIDO UAF Protocol", "authors": "[{\"first\":\"Haonan\",\"last\":\"Feng\",\"middle\":[]},{\"first\":\"Hui\",\"last\":\"Li\",\"middle\":[]},{\"first\":\"Xuesong\",\"last\":\"Pan\",\"middle\":[]},{\"first\":\"Ziming\",\"last\":\"Zhao\",\"middle\":[]}]", "venue": "Proceedings 2021 Network and Distributed System Security Symposium", "journal": "Proceedings 2021 Network and Distributed System Security Symposium", "publication_date": {"year": 2021, "month": null, "day": null}, "abstract": "The FIDO protocol suite aims at allowing users to log in to remote services with a local and trusted authenticator. With FIDO, relying services do not need to store user-chosen secrets or their hashes, which eliminates a major attack surface for e-business. Given its increasing popularity, it is imperative to formally analyze whether the security promises of FIDO hold. In this paper, we present a comprehensive and formal verification of the FIDO UAF protocol by formalizing its security assumptions and goals and modeling the protocol under different scenarios in ProVerif. Our analysis identifies the minimal security assumptions required for each of the security goals of FIDO UAF to hold. We confirm previously manually discovered vulnerabilities in an automated way and disclose several new attacks. Guided by the formal verification results we also discovered 2 practical attacks on 2 popular Android FIDO apps, which we responsibly disclosed to the vendors. In addition, we offer several concrete recommendations to fix the identified problems and weaknesses in the protocol.", "fields_of_study": "[\"Computer Science\"]", "external_ids": {"arxiv": null, "mag": "3137615531", "acl": null, "pubmed": null, "pubmedcentral": null, "dblp": "conf/ndss/FengLP021", "doi": "10.14722/ndss.2021.24363"}}, "content": {"source": {"pdf_hash": "f45c9cc4a5b6255d124e39bf35f09a2efa8cf7de", "pdf_src": "MergedPDFExtraction", "pdf_uri": null, "oa_url_match": false, "oa_info": {"license": null, "open_access_url": "https://doi.org/10.14722/ndss.2021.24363", "status": "BRONZE"}}, "grobid": {"id": "c750d1b5266b25029df2cbf13d415033e9772be7", "type": "plain-text", "url": "s3://ai2-s2-pdf-extraction-prod/parse-results/s2orc_worker/f45c9cc4a5b6255d124e39bf35f09a2efa8cf7de.txt", "contents": "\nA Formal Analysis of the FIDO UAF Protocol\n\n\nHaonan Feng \nBeijing University of Posts and Telecommunications CactiLab\nUniversity at Buffalo\n\n\nHui Li \nBeijing University of Posts and Telecommunications CactiLab\nUniversity at Buffalo\n\n\nXuesong Pan panxuesong@bupt.edu.cnzimingzh@buffalo.edu \nBeijing University of Posts and Telecommunications CactiLab\nUniversity at Buffalo\n\n\nZiming Zhao \nBeijing University of Posts and Telecommunications CactiLab\nUniversity at Buffalo\n\n\nA Formal Analysis of the FIDO UAF Protocol\n10.14722/ndss.2021.24363\nThe FIDO protocol suite aims at allowing users to log in to remote services with a local and trusted authenticator. With FIDO, relying services do not need to store user-chosen secrets or their hashes, which eliminates a major attack surface for e-business. Given its increasing popularity, it is imperative to formally analyze whether the security promises of FIDO hold. In this paper, we present a comprehensive and formal verification of the FIDO UAF protocol by formalizing its security assumptions and goals and modeling the protocol under different scenarios in ProVerif. Our analysis identifies the minimal security assumptions required for each of the security goals of FIDO UAF to hold. We confirm previously manually discovered vulnerabilities in an automated way and disclose several new attacks. Guided by the formal verification results we also discovered 2 practical attacks on 2 popular Android FIDO apps, which we responsibly disclosed to the vendors. In addition, we offer several concrete recommendations to fix the identified problems and weaknesses in the protocol.\n\nI. INTRODUCTION\n\nFast IDentity Online (FIDO) has gained significant popularity in recent years as a public-key cryptography based authentication framework that enables users to login remote online services and websites by authenticating themselves to local trusted authenticators, such as a fingerprint scanner on a smartphone. With FIDO, relying web services do not need to store user-chosen secrets or their hashes, which eliminates a major attack surface for e-business [26], [27], [55]. At the time of writing, more than 250 companies have become members of the FIDO alliance [5], and more than 703 certified FIDO products are in the market [15]. Android 7.0+ is now also FIDO2 certified out of the box, and Microsoft Windows has been supporting the FIDO2 standard since October 2018, which gives billions of users the ability to leverage builtin authenticators for passwordless access to websites and applications [2].\n\nThe original FIDO protocol suite consists of two sets of specifications: Universal Authentication Framework (UAF) and Universal Second Factor (U2F). UAF allows users to register their accounts with the relying party through a trusted authenticator and replaces the traditional password login scheme. U2F allows users to add a second-factor local authenticator to enhance the security of their accounts. FIDO2 was officially launched in 2018 with the addition of Web Authentica- \u2021 Corresponding author tion specification (WebAuthn) [52] and Client-to-Authenticator Protocol (CTAP) [3]. WebAuthn supports online services to use FIDO through a standardized web API, whereas CTAP supports external devices to work with browsers supporting WebAuthn.\n\nGiven the increasing popularity of FIDO, it is imperative to analyze if its security promises hold. Some flaws of FIDO have already been identified using manual analysis [29], [36], [42], [43], [47]. Even though these ad hoc methods can help discover some vulnerabilities, they lack a formal foundation and are not capable of systematically verifying the properties of FIDO.\n\nAlso, there have been several attempts to formally verify FIDO [38], [48]. However, they have many limitations: i) none of them presented a formalization of the security assumptions and goals from the FIDO specifications, which led to an inaccurate, if not incorrect, modeling of the protocol and security properties; ii) they focused on the U2F protocol, which has a simpler attack model than the UAF protocol does. This is because multiple vulnerable entities in the UAF are consolidated into one trusted physical device in the U2F; iii) their oversimplified modeling of the protocol failed in discovering more vulnerabilities.\n\nIn fact, formally verifying the security properties of the UAF protocol is challenging: i) many security assumptions and security goals are implicit and buried in over 500 pages of English specifications across 19 documents. The formal extraction of them requires considerable analysis and interpretation of the specifications; ii) the attack model is complicated because many entities in the protocol can be compromised in realworld settings. A comprehensive verification should consider all possible scenarios; iii) the UAF protocol is complex with many steps and optional steps, which should also be considered in verification.\n\nTo systematically evaluate the security of UAF, we tackle aforementioned challenges and resort to formal methods, which have been used in verifying the security of real-world protocols, such as Needham-Schroeder [44], TLS [20]- [22], 5G authentication [18], IKE [30], Diffie-Hellman [1], [49], ISO/IEC 9798-2 [57], LMAP [37], vTPM migration [28], 3PAKE [54], e-voting [32], E-Health [33], USB Type-C [50], etc. The contributions of this paper are summarized as follows: 1) We provide a formalization of UAF's security assumptions and goals by extracting and formally interpreting them from the specifications. We consider all sorts of properties, including authentication, non-repudiation, confidentiality, and privacy;\n\n2) We provide a faithful and formal model of the UAF protocol, which is a pragmatic balance of a detailed representation that can lead to the discovery of many vulnerabilities and an abstraction that is amenable to formal verification tools;\n\n3) We carry out an automatic verification in the symbolic model using ProVerif [23], [24]. We open-source our verification tool and code UAFVerif 1 ; 4) We present the verification results by confirming previously found vulnerabilities and disclosing new attacks. Also, we present the minimal assumptions for UAF to meet each security property; 5) Guided by the analysis results, we perform 2 attacks on 2 popular Android UAF apps, which represent two types of vulnerabilities. We responsibly disclosed them to the vendors, resulting in 1 vulnerability ID (CNNVD-202005-1219); 6) We offer several concrete and explicit suggestions to fix the identified problems in the protocol and specifications.\n\nThe rest of the paper is organized as follows. Section II introduces the UAF architecture and protocol. Section III presents our interpretation and formal model of UAF's security assumptions and goals. In Section IV, we explain the basic principle of ProVerif and our modeling choices. We present the security analysis results of the UAF protocol using ProVerif in Section V and summarize the defects of the UAF protocol. Besides, we discuss some possible attacks for the UAF protocol and give some recommendations. We introduce the related works in Section VI. Section VII concludes the paper.\n\n\nII. OVERVIEW OF THE UAF PROTOCOL\n\nThe UAF protocol has two major operations, namely authenticator registration and authentication. At a high level, the UAF protocol works as follows: a user wishes to log in to remote services using a device that has a certified UAF authenticator, e.g., fingerprint sensor. The authenticator has a trusted attestation key (either RSA or ECDSA). The user logs in to a relying party, such as a banking website, using her original credentials, e.g., text-based password. The authenticator records her fingerprint, generates an authentication key for this website, signs the public part of the new key with the attestation key, and sends it to the website. The website links the user's online profile with the authentication key if it is valid. As a result, the trust between the relying party and the authenticator is established and the procedure of authenticator registration is completed. In subsequent login attempts (the authentication procedure), the user only needs to prove her identity to the local authenticator, upon the success of which the website and the authenticator will run a challenge-response protocol with the authentication key. Table I describes the acronyms used in this paper. Section II-A presents the overall architecture and entities of UAF. Some of the steps and exchanged messages of the protocol differ based on the type of authenticator in use. In Section II-B and II-C, we illustrate the protocol using 1st-factor bound authenticators [7]. Section II-D explains the protocol operations under different types of authenticators and use cases.\n\n\nA. Architecture\n\nAs shown in Figure 1, we abstract 5 major entities and 4 communication channels in the Universal Authentication 1) an authenticator, which has an internal matcher for user verifications, stores a model identifier, an attestation key, and a symmetric key AAID, sk AT , k W . The authenticator generates asymmetric authentication keys (sk AU , pk AU ) [8]. There are 4 types of authenticators, 1st-factor bound authenticator (1B), 2nd-factor bound authenticator (2B), 1st-factor roaming authenticator (1R), and 2nd-factor roaming authenticator (2R). They differ in generating and using h, KeyID and ak, which we explain in Section II-D;\n\n2) the Authenticator Specific Module (ASM) is an authenticator abstraction layer that provides a uniform API for the upper layer. When ASM is launched for the first time, it generates a secret (tok) [9];\n\n3) a UAF Client (UC) is a system service or application that implements the client-side logic of the UAF protocol. A UAF Client is identified by a CallerID, which ASM can retrieve from the operating system. For example, on Android, CallerID is the hash of the UAF Client's APK signing certificate; 4) a User Agent (UA) is a user application identified by a URI named FacetID. When the user agent is a browser, FacetID is the web origin of the web page triggering the UAF operation, e.g., https://login.example.com/. When the user agent is an app on Android, FacetID is the hash of the user agent's APK signing certificate; 5) a Relying Party (RP) consists of a web server and a UAF server. The UAF server ensures that only trusted authenticators can be registered, manages the association of authenticators to user accounts, and evaluates user authentications.\n\nThe UAF specifications require TLS communication between a UA and an RP. Other software entities communicate via inter-process communication (IPC) methods or hardware and software communication. Figure 2 depicts the message flows of the UAF authenticator registration operation using a 1B authenticator.\n\n\nB. Authenticator Registration\n\nUpon the success of the original authentication method, e.g., text-based password, RP generates a registration request message UName, AppID, SData, Chlg and sends it to UC. UName identifies the user, while AppID is a URL that points to a list of trusted user agents. Chlg is a random challenge value, and SData is a session identifier created by the Relying Party.\n\nAfter receiving the request message from RP, UC retrieves the trusted user agent list from AppID and verifies if FacetID is on the list [4]. UC stores the session ID SData as xSData and computes TSLData using the TLS channel information to Acronym Full name Description RP\n\nRelying Party The server-side, which contains a web server and a UAF server.\n\n\nUA\n\nUser Agent A user application that supports the UAF protocol. UC UAF Client A system service or application that implements the client-side logic of the UAF protocol.\n\n\nASM\n\nAuthenticator Specific Module An authenticator abstraction layer that provides a uniform API for the upper layer.\n\n\nUName\n\nUsername A human-readable string identifying a user's account at a Relying Party.\n\n\nAppID\n\nApplication Identifier A URL pointing to the trusted facets.\n\n\nFacetID\n\nApplication Facet Identifier A platform-specific identifier (URI) for an application facet to indicate how an application is implemented on various platforms (such as Web applications, Android applications or IOS applications).\n\n\nSData\n\nServer Data A session identifier created by the Relying Party.\n\n\nChlg\n\nServer Challenge A random value that is provided by the FIDO UAF Server in the UAF protocol requests.\n\n\nTr\n\nTransaction Text Text to be confirmed in the case of transaction confirmation.\n\n\nTLSData\n\nChannel Binding A channel binding allows applications to establish that the two end-points of a secure channel at one network layer are the same as at a higher layer by binding authentication to the higher layer to the channel at the lower layer.\n\n\nAAID\n\nAuthenticator Attestation Identifier A unique identifier assigned to a model, class or batch of FIDO UAF Authenticators that all share the same characteristics CNTR\n\nSignature counter A monotonically increasing counter maintained by the Authenticator. It is increased on every use of the Authentication private key. FIDO UAF Server uses this value to detect cloned authenticators. tok ASMToken A randomly generated secret when the ASM is launched the first time and the ASM will maintain this secret until the ASM is uninstalled. prevent the TLS MIMT attack [39]. Then, UC sends UName and the final challenge parameters f cp = AppID, FacetID, Chlg, TLSData to ASM.\n\nASM computes the final challenge f c = hash(f cp) and a token ak = hash(AppID || tok || CallerID), where || denotes concatenation. ak is a token under the KHAccessToken mechanism, which is an access control mechanism for protecting an authenticator's FIDO UAF credentials from unauthorized use [9]. The authenticator uses ak in the procedure of authentication to verify ASM. Then, ASM sends UName, AppID, ak, f c to the authenticator.\n\nThe authenticator updates the token ak = hash(ak || AppID). Then, the authenticator triggers its built-in matcher, e.g., fingerprint sensor, to locally verifies the user's identity. Then, an authentication key pair sk AU , pk AU for this user account is generated. The authenticator generates a random KeyID as the key identifier. The authenticator computes a key handle h = E k W (sk AU , ak, UName, KeyID), where E k W is the symmetric encryption. After that, the authenticator generates a random signature counter CN T R A , which should be synchronized with RP. CNTR can be used by RP to detect cloned authenticators. Finally, the authenticator computes the signature S = sign sk AT (AAID, f c, KeyID, CN T R A , pk AU ), where sign is a sign function, and sends AAID, f c, KeyID, CN T R A , pk AU , S to ASM, ASM stores CallerID, AppID, h, KeyID and sends the messages to UC. UC forwards the message, xSData and fcp to RP.\n\nTo verify RP is in the same session with UA and UC, RP compares xf c = hash(AppID || Chlg || TLSData) with the received f c and compares SData with xSData. Next, it verifies fcp.AppID, fcp.Chlg and fcp.TLSData correspond to those stored in RP, and checks if fcp.FacetID is in the trusted FacetIDs list. Then, RP verifies the signature S with the attestation public key (pk AT ) of this authenticator. If the signature matches, RP stores CN T R A , pk AU , KeyID, AAID and completes this registration. Figure 3 depicts the message flows of the authentication operation using a 1B authenticator to step-up authentication, which can also be extended to the transaction confirmation operation. The transaction confirmation offers support for prompting a user to confirm a specific transaction with a secure display device. In Figure 3, the transaction confirmation related operations are marked with a '[]'.\n\n\nC. Authentication\n\nIn authentication and transaction confirmation, RP sends an authentication request message AppID, KeyID, SData, Chlg, [Tr] to UC. Then UC computes fcp = AppID, Facet, Chlg, TLSData , and sends fcp, KeyID, [Tr] to ASM.\n\nOnce ASM receives the message, it computes the final challenge f c = hash(fcp) and the token ak = hash(AppID || tok || CallerID), after which it locates h by KeyID and sends ak, f c, AppID, h, [Tr] to the authenticator.\n\nUpon receiving the message, the authenticator updates the token ak = hash(ak || AppID) and triggers its built-in matcher to verifies the user's identity. Then, the authenticator computes sk AU , xak, xUName, KeyID = D k W (h), where D k W is the decryption function. Next, the authenticator checks if xak matches ak to make sure it is the trusted ASM. If the check passes, the authenticator displays the transaction text Tr on the secure display for the user to confirm. Then, it computes hTr = hash(Tr) and increases CN T R A to xCN T R A . A random value n is generated to protect the authenticator from the replay attack. Finally, the authenticator computes the signature S = sign sk AU (AAID, n, f c, [hTr], AAID, skAT , kW  RP locates pk AU of this user by UName, AAID', KeyID . It compares SData and xSData to make sure it is the same session. Next, it it verifies fcp.AppID, fcp.Chlg and fcp.TLSData correspond to those stored in RP, and checks if fcp.FacetID is in the trusted FacetIDs list. Then, it compares AAID' with AAID to ensure that the message comes from the same authenticator registered with RP. Then RP computes xf c = hash (AppID || Chlg || TLSData) and compares it with f c to make sure the response is right. Then it compares hTr with hash(Tr) and verifies the signature S. Finally, RP checks whether xCN T R A increases compared to CN T R S , if not, the sync failed. If all the checks pass, RP updates CN T R S with xCN T R A and finishes the authentication process.\n\n\nD. Protocol Operations Under Different Authenticators and Use Cases\n\nIn FIDO, bound authenticators (1B and 2B) are embedded into a user's device, e.g., a built-in fingerprint sensor. Roaming authenticators (1R and 2R) are not bound to any device, e.g., a USB dongle with a built-in capacitive touch device. Users can use roaming authenticators with any number of devices. The 1st-factor authenticators (1B and 1R) normally operate as the first factor to authenticate users, while the 2nd-factor authenticator can operate in multi-factor authentication.\n\nAlso, there are two use cases when it comes to an authenticator executing the sign command. One case is that there is no user session (no cookies, a clear machine). In this case, RP communicates with UA for the first time and does not know who the user is and cannot provide KeyID associated with the user. In this paper, we call this case login authentication. The other case is called step-up authentication, where there is already a user session in which the user is unauthenticated or nominally authenticated. RP knows who the user is and provides KeyID associated with the user. For example, transaction confirmation can only happen when there is a user session.\n\nThe UAF protocol under different types of authenticators and use cases differ in some steps and messages [8]. Table  II summarizes    for bound authenticators, ASM generates ak with AppID, tok and CallerID. For roaming authenticators, ak only contains AppID; vii) in the authentication process, RP provides KeyID only for step-up authentication cases.\n1B random KeyID h = E k W (sk AU , ak, UName, KeyID) \u2192 ASM ak = hash(AppID || tok || CallerID) login: RP does not provide KeyID step-up: RP provides KeyID 2B random KeyID h = E k W (sk AU , ak, KeyID) \u2192 ASM ak = hash(AppID || tok || CallerID) step-up: RP provides KeyID 1R random KeyID h = E k W (sk AU , ak, UName, KeyID) \u2192 Authenticator ak = hash(AppID) login: RP does not provide KeyID step-up: RP provides KeyID 2R KeyID = h h = E k W (sk AU , ak) \u2192 RP ak = hash(AppID) step-up: RP provides KeyID\n\nIII. THREAT MODEL AND SECURITY GOALS\n\nThe UAF specifications list their security assumptions in Section 6 of the security reference [6], and provide the allowed cryptography list [11], the allowed operating environment list [12], the authenticator metadata requirements [13], the authenticator security requirements [14] in respective documents. However, the security assumptions are very strong and impractical, and many real-world deployments do not strictly follow them. To provide a more comprehensive analysis, we strive to analyze under the security assumptions that cover more realistic scenarios.\n\nBecause automation in the extraction and formalization of security assumptions and goals from lengthy and ambiguous natural language documents is still very challenging, we manually extract the security goals of the UAF from several documents and translate the informal descriptions of the security goals into precise and formal expressions, which would be the precondition for the formal analysis. We use our experience to make choices in what to model and how to model to achieve a balance between analysis feasibility and model accuracy [6]- [9].\n\nA. Assumptions and Threat Model 1) Assumptions on Cryptographic Algorithms: We assume the cryptographic algorithms are secure, which means without knowing the correct keys, the adversary can never forge signatures or decrypt messages.\n\n2) Assumptions on Channels and Entities: UAF uses four channels, as shown in Figure 1. The communications among Authenticator, ASM, UC, and UA use interprocess communication (IPC) channels or hardware and software communication channels. The communications between UA and RP use a network channel, which is protected by the TLS. We assume that i) the attacker cannot eavesdrop, intercept, or manipulate the communications on an established channel between legitimate entities; but ii) an attacker can install malicious entities to initiate and accept communication requests. For example, a user may be tricked into installing a malicious UC downloaded from the internet, which could communicate with legitimate UA or ASM. We verify if the security properties of UAF hold when there are different malicious entities.\n\nIn addition, applications are subject to known software attacks and may be controlled by attackers (e.g., hook, root), so we verify if the security properties of UAF hold when each of the entities is compromised. We also consider malicious or compromised authenticators because i) in some real-world deployments, the authenticator is implemented as software; ii) hardware-based authenticators are subject to side-channel attacks [40], [41].\n\n\n3) Assumptions on Data Protections:\n\nWe assume the following data fields are public, and the attacker has access to all of them: FacetID, CallerID, AAID, AppID, UName, pk AT , pk AU . We verify if the security properties of UAF hold when the following data is compromised or leaked: k W , tok, CNTR, h, sk AT , sk AU .\n\n\n4) Assumptions on Authenticators:\n\nWe assume the authenticator always authenticates users correctly, RP authenticating the authenticator is equivalent to RP authenticating the user.\n\nBecause a large number of authenticators may share the same AAID and sk AT for privacy preserving [10], we assume the attacker has an authenticator with the same sk AT and AAID as the user's, with which the attacker can calculate the signature and pass the authentication of RP.\n\n\nB. Formalization of UAF's Security Goals\n\nThe formal expressions are indicated in purple text.\n\n\n1) Authentication Properties:\n\nTo precisely formalize the authentication properties, we resort to Lowe's taxonomy of authentication properties [45], which can be directly modeled in formal methods and widely used in previous research [18]. Lowe's taxonomy specifies multiple levels of authentication, from A's point of view, between an initiator A and a responder B: i) aliveness: whenever A completes a run of the protocol, the aliveness property ensures that B has previously been running the protocol, but not necessarily with A; ii) weak agreement: whenever A completes a run of the protocol, the weak agreement property ensures that B has previously been running the protocol with A, but not necessarily with the same data; iii) non-injective agreement on data items ds: whenever A completes a run of the protocol, the non-injective agreement property ensures that B has previously been running the protocol with A. Besides, A and B agreed on the data values in ds. However, the property cannot guarantee that there is a one-to-one relationship between the runs of A and the runs of B; iv) injective agreement on data items ds: whenever A completes a run of the protocol, the injective agreement property ensures that B has previously been running the protocol with A. Besides, A and B agreed on the data values in ds, and each such run of A corresponds to a unique run of B. This prevents replay attacks.\n\nThe authentication goals are extracted from Section 4 of the security reference [6]. The overall goal of the UAF is SG-1.\n\nSG-1 Strong User Authentication: Authenticate (i.e. recognize) a user and/or a device to a Relying Party with high (cryptographic) strength.\n\nAfter a successful authentication process, RP (identified by AppID) shall authenticate a user account (identified by UName) with a unique registered authentication key pair (identified by KeyID) generated by a registered authenticator (identified by AAID). Formally, RP must obtain non-injective agreement on UName, AAID, KeyID, AppID with the authenticator after the authentication process.\n\nThe authentication goals are also complemented by SG-10, SG-11, SG-12, and SG-13.\n\nSG-10 DoS Resistance: Be resilient to Denial of Service Attacks. I.e. prevent attackers from inserting invalid registration information for a legitimate user for the next login phase. Afterward, the legitimate user will not be able to login successfully anymore.\n\nSG-11 Forgery Resistance: Be resilient to Forgery Attacks (Impersonation Attacks). I.e. prevent attackers from attempting to modify intercepted communications to masquerade as the legitimate user and log into the system.\n\n\nSG-12 Parallel Session Resistance:\n\nBe resilient to parallel Session Attacks. Without knowing a user's authentication credential, an attacker can masquerade as the legitimate user by creating a valid authentication message out of some eavesdropped communication between the user and the server.\n\nSG-13 Forwarding Resistance: Be resilient to Forwarding and Replay Attacks. Having intercepted previous communications, an attacker can impersonate the legal user to authenticate to the system. The attacker can replay or forward the intercepted messages.\n\nTo prevent DoS attacks, the protocol must ensure that invalid information will not affect the user's authentication, which means the attacker cannot pass the authentication of RP by any means, thus making CNTR of RP and CNTR of the authenticator out of sync. Therefore, the protocol must ensure that every successful authentication of RP is associated with the legitimate user's verification. The Forgery Resistance, Parallel Session Resistance and Forwarding Resistance require the protocol to prevent impersonation attacks by replaying, constructing, or manipulating previous messages. Formally, RP must obtain injective agreement on UName, AAID, KeyID, AppID with the authenticator after the authentication process.\n\nSG-5 Verifier Leak Resilience: Be resilient to leaks from other relying parties. I.e., nothing that a verifier could possibly leak can help an attacker impersonate the user to another relying party.\n\nSG-6 Authenticator Leak Resilience: Be resilient to leaks from other FIDO Authenticators. I.e., nothing that a particular FIDO Authenticator could possibly leak can help an attacker to impersonate any other user to any relying party\n\nWe formalize them to: after the authentication process, RP must obtain injective agreement on UName, AAID, KeyID, AppID with the authenticator when another RP leaks the same user's pk AU , UName, AAID, KeyID, CNTR or when another authenticator leaks the same user's sk AU , UName, AAID, CNTR, KeyID.\n\nNote that after a successful authentication for the user, it is the UA but not the user who has been authorized, if the correct user is verified but the malicious UA is authorized, the protocol is still not secure, so after the authentication process, RP must obtain injective agreement on UName, AAID with UA when another RP leaks the same user's pk AU , UName, AAID, KeyID, CNTR and when another authenticator leaks the same user's sk AU , UName, AAID, CNTR, KeyID.\n\nIn the registration process, the security reference only presents the following goal. SG-7 User Consent: Notify the user before a relationship to a new relying party is being established (requiring explicit consent). This goal indicates that the registration request must have been initiated by the legitimate user. We assume that the legitimate UA that initiated the registration request can represent the consent of the user, so RP must obtain injective agreement on UName, AppID with UA after the registration process.\n\nHowever, even the registration process has been consented by the user, we cannot guarantee that it is the user's authenticator who has been registered. So the registration should additionally imply that RP must obtain injective agreement on UName, AAID, KeyID, AppID, pk AU with the authenticator after the registration process.\n\nIn a transaction confirmation process, any tampering of the transaction message during its route to the end device display and back should be detected and the user cannot deny the transaction message, which FIDO presents in SG-14.\n\nSG-14 Transaction Non-Repudiation: Provide strong cryptographic non-repudiation for secure transactions.\n\nFormally, RP must obtain injective agreement on Tr with the authenticator after the transaction confirmation process.\n\n2) Confidentiality Properties: The confidentiality of sk AT , sk AU and k W is required in Section 4.1 of the security reference [6]. Formally, the cryptographic key sk AT , sk AU and k W should remain secret in the presence of the active attacker during the registration and the authentication process.\n\nKHAccessToken (ak) is an access control mechanism for protecting an authenticator's UAF credentials from unauthorized use. Once ak is leaked, the attacker will have the ability to impersonate ASM and call the authenticator. ASM is required to maintain the secrecy of ak in Section 6.1 [9]. Formally, ak should remain secret in the presence of the active attacker during the registration and the authentication process.\n\n3) Privacy Properties: The UAF protocol should ensure that the private data related to the user cannot be compromised. Otherwise, the attacker can identify a user or trace a user's behavior.\n\nFirst, Tr is sensitive data, so it must remain secret in the transaction confirmation process. Otherwise, the attacker can count transactions and track user behaviors. So, Tr should remain secret in the presence of the active attacker during the transaction confirmation process.\n\nSimilarly, CNTR must remain secret. Or, the number of successful authentications is known to the attacker, and the attacker can track user behaviors. So CNTR should remain secret in the presence of the active attacker during the registration and the authentication process.\n\nThe higher requirement for privacy is unlinkability, which is stated by: SG-4 unlinkability: Protect the protocol conversation such that any two Relying Parties cannot link the conversation to one user.\n\nThe main purpose of this goal is to mitigate the potential for collusion amongst RPs. Generally, we disregard the linkability due to the irresistible external factors (same UName, same IP address, etc.). So the UAF should provide unlinkability between different RPs.\n\n\nIV. MODELING UAF PROTOCOL IN PROVERIF\n\nIn this section, we briefly introduce the formal verification tool ProVerif and explain how security properties can be modeled in ProVerif in general. Then, we present the modeling of security goals and protocol operations. For some of the attack models that are not integrated with ProVerif, we present the tricks we used to implement them. We believe other formal verification tools, such as Tamarin [46], AVISPA [16], can also be used to model and verify UAF. We choose ProVerif due to its popularity and ease of use.\n\n\nA. Overview of ProVerif\n\nProVerif is an automatic symbolic protocol verifier, which can verify various security properties of protocols, including confidentiality, authentication, and observational equivalence [23]. Comparing with other verification tools, such as AVISPA [16], CL-AtSe [51], OFMC [19], Tamarin [46], FDR [44], Scyther [31], SATMC [17], Cryptyc [35], TA4SP [25], Maude-NPA [34], ProVerif not only solves the problem of state explosion but also supports unbounded sessions. Although ProVerif does not support algebraic operations, such as power operation and XOR operation, it can still be used to verify the UAF protocol since the protocol does not use such operations.\n\nProVerif verifies in an extension of the applied \u03c0-calculus with cryptography. Based on first-order logic resolution rules on Horn clauses [53], it determines whether the desired security properties are met. If a property is violated, it can construct an attack at both the Horn clause level and the \u03c0-calculus level.\n\nIn \u03c0-calculus, messages are described as terms, and a term is constructed by constructors. For example, we can define senc(M,K) as a symmetric encryption of the message M under the key K, where senc(bitstring, key) is a constructor. The corresponding destructor sdec(bitstring, key) is defined as follows to formally represent the decryption of the ciphertext with the same key K:  \n\n\nB. Formalizing Security Goals in ProVerif\n\nProVerif can prove reachability properties, correspondence assertions, and equivalence properties.\n\nConfidentiality is a reachability property. ProVerif checks all possible protocol executions and all possible attacker behaviors to infer which terms are available to the attacker. Using the following query statements, ProVerif tests the confidentiality of the term M and the confidentiality of the bound name or variable x. Authentication properties can be verified via the Correspondence assertions. Correspondence assertions are used to capture the relationships between events. If the specified events can be executed in the correct order and they have the same arguments, the related properties can be guaranteed. For example, if entity A executes an event e1 (A terminates the protocol with B) with the argument x (B's identity) and there is an entity B that has executed an event e2 (B started a session of the protocol with A) with the same argument x, from A's point of view, B has finished a non-injective agreement with A on data x. We can use the following query to check the non-injective agreement on data x: 1 query x:ID; 2 event(e1(x)) ==> event(e2(x)).\n\nUnlinkability is an equivalence property, which could be verified using observational equivalence [23]. If the attacker cannot distinguish a process P from a process Q, P and Q are observational equivalent P \u2248 Q where the processes P and Q have the same structure and differ only in the choice of terms. In ProVerif, the equivalence is written by a single \"biprocess\", which encodes both P and Q. Such a biprocess uses the construct diff[M,M'] to represent the terms that differ between P and Q (keyword choice is a synonym for diff), where P uses the first component of the choice M, while Q uses the second one M'. For example, if P and Q are protocols that have the same structure but only differ in the parameter a (P for a 1 and Q for a 2 ), then the equivalence of P and Q can be expressed by: P (a 1 ) \u2248 P (a 2 ). The processes can be expressed as follows, and ProVerif verifies whether they are equivalent. 1 free a:bitstring.  Challenge. Modeling the unlinkability goal in the UAF is difficult because ProVerif could only verify the observational equivalence from the perspective of the attacker. But the unlinkability requirement in UAF is from the perspective of RP. To model this situation, we need to make sure the attacker knows what RP knows. However, in our model, the attacker can participate in the protocol as malicious entities, and can actively manipulate the session data to break the security goals, where RP never does. So we model the unlinkability in the following way: i) when analyzing the unlinkability, we assume there are no malicious entities in the protocol run; ii) we assume the channel between RP and UA is public, which allows the attacker to have the same knowledge as RP; iii) we assume the attacker is a passive attacker who could only listen to the communication channel between RP and UA.\n\n\nC. ProVerif Models of the UAF\n\nWe modeled different types of authenticators and application scenarios in ProVerif, which takes 900 lines of ProVerif code. Then we analyzed whether the UAF protocol meets the security goals in different scenarios using different security assumptions and process combinations. We discuss the challenges we overcame: 1) Modeling Malicious Entity Scenarios: ProVerif models two types of channels, the Public channel and the Private channel. The public channel is assumed to be completely controlled by the attacker who has the \"Dolev-Yao\" capabilities, while the data on the private channel is excluded from the attacker's knowledge. Unfortunately, none of these channels can be directly used to model the malicious entities scenarios where the communication between honest entities is assumed secure but the attacker can act as a malicious entity to communicate with some of the entities.\n\nTo this end, we used a modeling trick and verified its correctness with the developers of ProVerif. We define two entity processes A and A' (both of them communicate with process B) running in parallel, where A communicates via a private channel while A' communicates via a public channel. The attacker can control the public channel, so he/she can act as a malicious B and communicate with A'. When removing the process A', there is no malicious B in the environment.\n\nThis model becomes more complex in UAF because it contains more than two entities. Take ASM as an example, it communicates with two entities, UC and the authenticator. We define a process macro ASM, which contains two arguments of type channel MC and MA, where MC for communicating with UC and MA for communicating with the authenticator, as defined below: By controlling the type of MA and MC, different scenarios can be modeled. The following statements represent that from ASM's point of view, the system has no malicious authenticator and UC since there is only an ASM that uses private channel MC and MA to communicate. Note that channels defined in the process by \"new\" are private. The following statements represent a system that has malicious authenticators since there is an ASM that uses public channel c to communicate with the authenticator.  This trick requires two processes (only differ in channels) to run in parallel. However, ProVerif 2.00 does not allow the same event to execute several times in the same branch in verifying event correspondence, which raises the difficulty for ProVerif to verify such scenarios.\n\nTo solve this challenge, we used an 'if' statement to force the process macro that contains the test events to only present once in a branch. As the following code shows, we run two ASM processes in parallel with different channel parameters to make sure only one of them is on a certain branch. The main process receives branch information on the public channel c and lets the attacker choose between the two branches. We confirmed the correctness of this trick with the developers of ProVerif, who also fixed the problem in ProVerif 2.01. 1 free c:channel[public]. 2) Modeling Unlinkability Scenarios: Modeling the UAF operations for unlinkability analysis is challenging. We explicitly model the scenario in which two RPs might authenticate the same user or different users.\n\nFirst, we consider two RPs run in parallel with different AppID. Then, we define a System macro, which represents protocol runs that an RP authenticates or registers a user. By controlling the arguments of the System, we specify which RP is running. For example, System(AppID1,...) means RP with AppID1 is running, while System(AppID2,...) means a different RP with AppID2 is running. Last, we specify two Systems to run. One of them represents an RP that authenticates a user, whereas the other represents another RP that authenticates the same user or authenticates another user. Different users use different devices, so their authenticators have different k W , and their ASMs have different tok. Whether the two RPs authenticate the same user, sk AU and KeyID in the system is different because the authenticator always generates a new sk AU and KeyID for each account during the registration process. Since different users may use authenticators with the same AAID, we do not consider the differences of AAID. Similarly, in different user devices, CallerID and FacetID could be the same, so we do not consider either. We do not consider the impact of UName of the unlinkability.  \n\n\nV. SECURITY ANALYSIS\n\nIn this section, we present the formal verification results of the UAF protocol. We identify the minimal security assumptions required for each of the security goals in Section III-B to hold. The formal verification identifies the design flaws in the UAF, but not specific implementation vulnerabilities in different apps. The root causes of these flaws include that FIDO UAF supports different deployment settings but gives impractical and ambiguous security assumptions for such settings.\n\nThe results are analyzed from 417,792 automatically generated cases considering different authenticator types, scenarios, and assumptions. It took 80 hours to analyze all cases on a computer with Intel(R) Core(TM) i7-3770 CPU and 16GB RAM. Section V-A describes the method for automatically identifying minimal security assumptions. Section V-B presents the result overview. Section V-C presents some attacks. Section V-D describes our recommendations.\n\n\nA. Automatically Identifying Minimal Security Assumptions\n\nTo automatically identify minimal security assumptions, we developed a tool UAFVerif to generate cases corresponding to different scenarios for ProVerif to perform analysis on. UAFVerif is implemented in 680 lines of Python code. The high-level idea is to define a variable security assumption set A, where A = \u2205 represents no security assumption. UAFVerif adds security assumptions {a 1 , ..., a n } into A and triggers ProVerif to analyze if the protocol satisfies the security properties under these security assumptions. It starts with verifying a single security assumption, then all combinations of 2 assumptions, and so on. When the state of a security property changes from unmet to met, the minimal security requirement is recorded.   Table III and IV present the minimal assumptions required for UAF to achieve the confidentiality properties and authentication properties. 'Reg.' means the registration process, 'Auth.' means the authentication process. 'C.' means the confidentiality properties. 'A.' means the authentication properties. 'Basic' represents the authentication goals we explain in Section III-B, 'Non-R' represents the transaction non-repudiation goal. We present security assumptions in symbols: '\u2227' denotes AND, whereas '\u2228' denotes OR. A, M, C, U represent Authenticator, ASM, UC, UA, respectively. '\u00ac' before a data field represents the field is not compromised. '\u00ac' before 'X[Y ]' represents that the system does not exist malicious X that can communicate with Y . For example, '\u00acM [A]' means that there is no malicious ASM that can communicate with the authenticator, while '\u00acM [C]' means that there is no malicious ASM in the system that can communicate with UC. ' \u221a ' means the protocol meets the security goal under all conditions. '\u00d7' means the protocol cannot meet the security goal nonetheless. '\u2212' means we do not consider this property. Table III shows, the protocol does not disclose k W or sk AT in the registration process because they do not leave the authenticator. However, h, which is encrypted by k W and contains sk AU , will leave the authenticator (except for 1R authenticator, which stores h inside its internal storage). Therefore, if k W is compromised, the attacker can decrypt h and get sk AU . For 1B and 2B authenticators, h is only sent from the authenticator to ASM. So as long as there is no malicious ASM, the attacker cannot obtain sk AU . Confidentiality of sk AU holds when using 1R authenticators since it never leaves the authenticator. 2R authenticators take h as KeyID and send it to RPs, therefore, the protocol should guarantee that k W will not be compromised. As Table IV shows in the authentication process, for 1B and 2B authenticators, if k W is secure, the attacker cannot decrypt h to get sk AU . If k W is compromised, the attacker cannot obtain h from ASM assuming no malicious authenticators. For 1R authenticators, since h does not leave the authenticator, as long as the authenticator is not compromised, sk AU is secure. For 2R authenticators, since h will be sent from RP, the minimal assumption is to keep the confidentiality of k W .\n\n\nB. Result Overview\n\n\n1) Confidentiality Properties: As\n\nTo maintain the confidentiality of ak in 1B and 2B authenticators, tok cannot be compromised and there should not be a malicious authenticator. If the attacker gets tok, he/she can compute ak = hash(AppID || tok || CallerID). Whether it is the registration process or authentication process, ak needs to be sent to the authenticator by ASM. If there is a malicious authenticator, the attacker can get the message, which contains ak, from ASM. When using 1R and 2R authenticators, ak's confidentiality cannot be satisfied nonetheless, because ak only contains AppID, which is public and known by the attacker. Therefore, the KHAccessToken mechanism is futile. We will discuss attacks on this issue in Section V-C and provide a fix in Section V-D2.\n\nTo maintain the confidentiality of CNTR in the registration process, the deployment of the protocol must satisfy \u00acC[M ] and \u00acM [A]. Otherwise, the malicious entity can initiate a registration process to get CNTR generated by the authenticator. In the authentication process, for 1B and 2B authenticators, to maintain the confidentiality of CNTR, the protocol must satisfy \u00ack W and \u00acA[M ], or satisfy \u00acM [A]. Since ASM has access control over UC's CallerID, UC checks FacetID of the UA, so malicious UCs and UAs cannot start the legitimate authenticator. So when there is no malicious ASM, the confidentiality of CNTR holds. Besides, ASM needs to send h to start the authenticator in 1B and 2B authenticators. If there is no malicious authenticator and k W is not compromised, the attacker cannot get h, even there is a malicious ASM, the attacker cannot provide h and start the legitimate authenticator, the confidentiality of CNTR holds. For 1R and 2R authenticators, ASM does not verify UC's CallerID. A malicious UC can call ASM and get CNTR from the authenticator. So the deployment of the protocol should ensure there is no malicious UC and there is no malicious ASM.\n\nAny malicious UC, ASM, or authenticator can get Tr from the caller. This is because Tr is sent from RP to the authenticator, UA does not verify UC, UC does not verify ASM, and ASM does not verify authenticator in the authentication process.  2) Authentication Properties: As shown in Table III, to achieve the authentication goals in registration, the minimal assumption is \u00acC[U ] and \u00acM [C] and \u00acA[M ]. The results show that whether sk AT is compromised has little influence on the authentication goals because the attacker has an authenticator with the same sk AT to register. Therefore, sk AT can only guarantee that the authenticator registered in RP must be legitimate, but cannot guarantee the authentication goals of the registration process. To achieve the authentication goals in the registration process, the protocol should guarantee that it is the user's authenticator that is bound to his/her account but not the attacker's authenticator, which requires \u00acC[U ] and \u00acM [C] and \u00acA[M ]. ProVerif generated an attack when one of them is not satisfied, which we will discuss in Section V-C. The root cause of this issue is because there is no access control mechanism from UA to UC, from UC to ASM, or from ASM to the authenticator in the registration process. For example, a UA may send the UAF request to any UC installed on the user's devices, including a malicious one.\n\nThe confidentiality of sk AU , k W , tok, and CN T R is crucial for authentication properties in the authentication process. k W protects sk AU . When the attacker get k W , he/she can decrypt h and get sk AU . When tok is compromised, the attacker can construct ak and use a malicious ASM to start the authenticator. The confidentiality of sk AU and CNTR ensures the authentication and non-repudiation goals. As long as one of them does not leak, the attacker cannot undermine authentication properties. For simplicity, these results are not shown in Table IV. During the authentication process, the minimal assumptions vary under different types of authenticators and use cases. The protocol satisfies the authentication goals in stepup authentication phases since it is based on a successful login authentication. In the login case, for 1B authenticators, the protocol must satisfy \u00acA[M ] or \u00acM [A]. Otherwise, the attacker can get ak by a malicious authenticator and pass the KHAccessToken mechanism to start the authenticator. For 1R authenticators, ASM does not verify CallerID of UC, so the minimal assumptions additionally require \u00acC[M ]. Besides, for 1R authenticators, the attacker knows ak, which means he/she can pass the KHAccessToken mechanism anytime. Therefore, to guarantee the authentication goals, the protocol must satisfy In addition, the results show the protocol holds nonrepudiation on Tr as long as k W , sk AU , tok are not compromised.\n\nThe results show that the protocol can prevent attacks from malicious RP and UA because UC verifies FacetID. For example, when UA is a browser and the user visits a phishing site, the FacetID, which is the malicious web origin, will not pass the verification of UC. If UA is an application, only when UA is compromised or the user uses a malicious UA, it would visit a malicious RP. In this situation, FacetID, which is the identifier of the malicious UA, is not in the trusted user agent list retrieved from AppID.\n\n3) Unlinkability Property: The verification results show that the protocol can satisfy unlinkability in both the registration process and the authentication process. In the registration process, it is because different users can register using the authenticators with the same AAID and sk AT . RPs cannot confirm that the two registrations are conducted by the same user through AAID or pk AT , nor can they confirm that the two registrations are conducted by different people according to AAID or pk AT .\n\nRegardless of whether two accounts registered on two RPs are from the same user, the authenticator has generated different sk AU and KeyID during the registration process, so the two RPs cannot distinguish whether the verified accounts are from the same user based on pk AU or KeyID. In fact, the information that RP can obtain during an authentication process includes UName, AAID, CallerID, FacetID, KeyID, CNTR. AAID cannot be used to distinguish two users since a large number of authenticators share the same AAID. CallerID and FacetID are identifiers related to the applications and the platforms, which cannot be used to identify the user either. RPs cannot collude and use CNTRs to find out the accounts of the same user since CNTRs are independent. So none of the fields helps RPs to distinguish whether the accounts come from the same user, the protocol holds the unlinkability in the authentication process.\n\n\nC. Attacks\n\nGuided by the analysis results presented in V-B, we discover 4 types of attacks: i) authenticator rebinding attack, in which the attacker binds his/her authenticator to the victim's account; ii) parallel session attack, in which the attacker impersonates the victim by using the victim's authenticator to sign requests; iii) privacy disclosure attack, in which the victim's Tr and CNTR will be leaked; iv) denial of service attack, in which the attacker can invalidate the victim's legitimate authenticator. , the injective agreement on UName, AAID, KeyID, AppID between RP and the authenticator in the registration process cannot be satisfied, rebinding attacks can be performed. To do so, the attacker needs to convince the user to install a malicious UC, ASM, or authenticator into his/her device.\n\nThe attack has the following steps: i) the victim uses UA to log in to RP in the traditional way and initiate the UAF registration; ii) UA sends the registration request to the malicious UC. Or, UC sends the request to the malicious ASM. Or, ASM sends the request to the malicious authenticator; iii) the malicious UC redirects the request to the attacker's device; iv) the attacker uses his/her authenticator to continue the UAF operations with the redirected request; v) the attacker sends the response message to the malicious UC on the victim's device and forwards it to RP via UA; vi) the attacker completes the UAF registration on behalf of the victim and successfully rebinds the victim's identity to the attacker's authenticator. As a result, the attacker can bypass the authentication of RP and impersonate the victim.\n\nTo verify the feasibility of this attack on real-world apps, we compiled a dataset of 1,856 payment-related Android applications and identified 42 that use the UAF protocol. These apps can be divided into two categories depending on the authenticator type. 8 out of the 42 apps have a hardware-based authenticator, e.g., China Mobile Pay, whereas the other 34 use a software-based authenticator, e.g., Jingdong Finance.\n\nWe successfully carried out authenticator rebinding attacks on China Mobile Pay and Jingdong Finance. The other 40 apps may also be vulnerable to these attacks. We chose China Mobile Pay and Jingdong Finance because of their popularity. As of October 2020, China Mobile Pay has 214,424,508 downloads in total, and Jingdong Finance has 1,043,164,317 downloads in total. In March 2020, China Mobile Pay has monthly active users of 3,838,000 and Jingdong Finance has monthly active users of 23,116,000.\n\nWe reported the vulnerability of China Mobile Pay to the China National Vulnerability Database of Information Security (CNNVD) on May 25, 2020, resulting in a medium-risk vulnerability ID (CNNVD-202005-1219) on July 31, 2020. We disclosed the vulnerability on Jingdong Finance to JD Security Response Center on December 12, 2018, who replied on December 19, 2018, stating they would ignore the vulnerability.\n\nChina Mobile Pay (package name: com.cmcc.hebao, version: 7.6.70, MD5: 384c99ecd3ac0ea0f805959da2b76608) in Android deploys the UAF protocol by calling a thirdparty UC and uses the hardware authenticator. However, the application (UA) does not authenticate the entity it calls, which means it may call any UC, including a malicious one (lacking the assumption of \u00acC[U ]). Therefore, once the user selects the malicious UC to call, the attacker can carry out the authenticator rebinding attack. Similar attacks can be performed when the attacker compromises UA, UC, ASM, or authenticator, but this requires higher capabilities of the attacker. The mis-binding attack [36] is similar to the authenticator rebinding attack, except that the former requires the attacker to corrupt UC and ASM. Cloned authenticator attack [47] needs the attacker to evade the security mechanism of the environment of the authenticator, get information of the user's authenticator, and deploy a malicious cloned authenticator. We performed the attack on Jingdong Finance (package name: com.jd.jrapp, version: 5.0.1, MD5: d56a8c05ab61194251b00b873fa3d4c4) by hooking the ASM and redirected messages to the attacker's device.  [36], which requires the compromise of the legitimate UC and ASM, which is harder to pull off.\n\n\n2) Parallel Session\n\nFor 1B authenticators, the attack can be carried out in 2 steps. In step 1, i) the victim tries to log in to RP; ii) the legitimate ASM forwards the request, which contains ak and h, to the malicious authenticator. Since the malicious authenticator does not have sk AU and CN T R, it cannot generate a valid authentication response. In step 2: i) the victim tries to log in to RP again; ii) the attacker sends a login request to RP with the victim's account at the same time and gets Chlg; iii) the malicious ASM sends the request message with the valid ak, h and the attacker's Chlg to the legitimate authenticator; iv) unbeknownst to the victim, the victim verifies the fingerprint, and the authenticator signs the message and generates the authentication response.\n\nSimilarly, for 1R authenticators, the attack can be carried out in 2 steps. In step 1, the attacker computes ak = hash(AppID). In step 2: i) the victim tries to log in to RP; ii) the attacker sends a login request to RP with the victim's account at the same time and gets Chlg; iii) the malicious ASM sends the request message with the valid ak and the attacker's Chlg to the legitimate authenticator, or the malicious UC sends the request message with the attacker's Chlg to the legitimate ASM; v) unbeknownst to the victim, the victim verifies the fingerprint, and the authenticator signs the message and generates the authentication response.\n\n3) Privacy Disclosure Attack: When the deployment of the protocol does not satisfy the assumptions \u00acC[U ] or \u00acC[M ], some of the user's personal data will be leaked. Assuming there is a malicious UC and using the 1B authenticator: i) the victim tries to log in to RP or make a transaction with RP; ii) the malicious UC receives authentication request; iii) the attacker can confirm whether the victim is logging in or making a transaction depending on whether Tr is included in the request.\n\nFor 1R and 2R authenticators, ASM does not verify UC's CallerID: i) the victim tries to log in to RP or make a transaction with RP; ii) the malicious UC receives the authentication request, which may contain Tr; iii) the malicious UC sends the authentication request to the legitimate ASM, and the legitimate authenticator signs and performs other operations; iv) the malicious UC gets the authenticator response, which contains CNTR, signature, etc.; v) malicious UC forwards authentication response, the authentication succeeds. The attacker can use CNTR to compute how many times the victim tries to log in or make transactions. The attacker can also use the signature for chosen-ciphertext attacks. For 1R and 2R authenticators, if there is a malicious UC or ASM, the attacker can use the following steps to permanently disable the authenticator by making CNTR of the legitimate authenticator out of sync with RP: i) the victim tries to log in to RP or make a transaction with RP; ii) the malicious UC receives the authentication request from legitimate UA, forwards the request to the authenticator via ASM, and the authenticator signs. The authenticator's CNTR increments accordingly; iii) when the authentication response is returned to the malicious UC, it intercepts the request and sends a fail message to UA; iv) RP gets a failure, so CNTR does not increment; v) the attacker can repeat this attack multiple times to cause CNTR out of sync. Note that the UAF protocol does not have a CNTR synchronization mechanism.\n\n\n4) Denial of Service\n\n\nD. Recommendations\n\nWe present several concrete recommendations to enhance the security of the UAF protocol.\n\n\n1) Explicit Requirements:\n\nThe security goals given by the security reference are informal and fragmentary: i) SG-1 is ambiguous in which no clear definition of 'strong authentication' is provided; ii) except SG-1, all other authentication properties were presented in the format of resilience to some known attacks or vulnerabilities, which do not evolve as new attacks are discovered; iii) only the user consent goal is explicitly presented for the registration process, which has several implicit goals as we discussed in Section III-B.\n\nWe recommend presenting security requirements and goals in a more explicit and active way in the specifications. For example, the specifications can use formal expressions to describe the security properties as shown in Section III-B. The analysis results show that the registration process is more vulnerable to attack, so the specifications should improve the description of authentication properties for the registration process.\n\n2) Modify the KHAccessToken Mechanism: The analysis results show that the KHAccessToken mechanism is futile to prevent the malicious ASMs: i) the confidentiality of ak cannot be held when using 1R and 2R authenticators; ii) the confidentiality of ak cannot be held when there is a malicious authenticator. The authenticator's trust on ASM is based on the Trust On First Use (TOFU) concept [10], which means it assumes there is no malicious ASM in the registration process but there can be malicious ASMs in the authentication process. However, it is equally difficult for the attacker to trick the victim into installing a malicious ASM in the registration process or the authentication process. So this mechanism is futile to prevent malicious ASMs. Furthermore, even if ASM is trusted in the registration process, the attacker can still get ak from ASM by receiving authentication requests with malicious authenticators.\n\nWe give the following recommendations: i) there should be requirements for mechanisms to guarantee the security of the running environment of ASM and the authenticator. And, vendors must ensure the deployment of the protocol satisfies \u00acA[M ] and \u00acM [A], e.g., running ASM and the authenticator in a trusted execution environment; ii) the KHAccessToken mechanism for 1R and 2R authenticators should be improved to prevent malicious ASM from communicating with the authenticator. For example, same as bound authenticators, ak should include tok. To this end, the authenticator can maintain a trusted list of ASMs; iii) there should be a mechanism for the authenticator to authenticate ASM. For example, in 1B and 2B authenticators, vendors can provide a shared key in both ASM and the authenticator, so the communication between ASM and the authenticator can be encrypted.\n\n3) Authenticating UC at ASM: If the deployment of the protocol does not satisfy \u00acC[M ], some security properties will not hold. Although Section 6.2 of ASM specification states that ASM must implement the access control of CallerID [9], it does not specify how to verify CallerID and leave the implementation of the security mechanisms to the vendors. We emphasize the importance of this issue and suggest to have a standard ASM access control mechanism for CallerID in the specification. For example, ASM can maintain a trusted Cal-lerID list. Only UCs with a valid CallerID can communicate with ASM.\n\n\n4)\n\nAuthenticating UC at UA: The protocol does not require UA to authenticate UC. As a result, UA or the user may invoke a malicious UC installed on the device. We recommend the specifications to require UA to authenticate UC. For example, UA can use the same mechanism as ASM does to authenticate UC.\n\n\nVI. RELATED WORK\n\nHu et al. manually abstracted the UAF protocol and presented 3 attacks, including mis-binding attack, parallel session attack, and multi-user attack [36]. Leoutsarakos manually found 15 defects of the UAF protocol, which were not formally verified [42]. Panos et al. presented a manual and informal analysis of the UAF protocol with several discovered vulnerabilities and attacks [47]. Loutfi et al. gave a set of trust requirements of the FIDO UAF protocol which included the trust requirements in FIDO consortium, in service providers, in a hardware manufacturer, in a local device computing platform, and in the end-user [43]. Zhang et al. presented an attack on FIDO transaction confirmation and proposed a secure display mechanism for mobile devices [56]. Jacomme et al. found that the U2F protocol can guarantee authentication in many threat scenarios, such as with phishing sites, but cannot achieve authentication goals in the presence of malware in the user environment [38]. Although the paper analyzed different scenarios, no formal model was given. Meanwhile, the model description of the U2F protocol was simple, and it did not consider different security assumptions and optional protocol operations. Chang et al. found that the U2F protocol could leak two fixed keys (attestation key and device secret key) through a side-channel attack. They recommended a modification of the U2F protocol to minimize the effect of this attack and presented a new variant of the U2F protocol to provide a stronger security guarantee. Similarly, they introduced how to perform side-channel attacks on the UAF protocol [29]. Pereira et al. formally analyzed the authentication properties of the U2F protocol [48]. They analyzed two types of U2F clients with and without AppID verification and found that the U2F protocol could not satisfy authentication without AppID verification. However, the protocol model was oversimplified.\n\nDifferent from previous work, we provide a faithful formalization of the UAF protocol and use the formal method to analyze the UAF protocol.\n\n\nVII. CONCLUSION\n\nIn this paper, we formally analyzed the UAF protocol. We formalized the security assumptions and goals of the protocol, provided a formal model of the protocol, and used ProVerif to analyze the protocol under different scenarios. Our analysis identified the minimal security assumptions required for each of the security goals of the UAF protocol. By summarizing and analyzing the results given by ProVerif, we presented the defects of the protocol and illustrated some attacks. We also confirmed previously discovered vulnerabilities in an automated way and disclosed several new attacks. Also, we offered several concrete recommendations to fix the identified problems and weaknesses in the protocol.\n\nFig. 2 .\n2if right then: store pkAU , KeyID, AAID, CN T RS CN T RS \u2190 CN T RA get TLSData from TLS channel CheckSign pkAT (S, AAID, f c, KeyID, CN T RA, pkAU ) xSData, AAID, fc, KeyID xSData, AAID, fc, KeyID CN T RA, pkAU , S, CertAT AAID, fc, KeyID check if FacetID in the facet list login by the original authentication method CN T RA, pkAU , S, CertAT CN T RA, pkAU , S, fcp, CertAT CN T RA, pkAU , S, fcp, CertAT fcp.AppID == AppID if fcp.FacetID is in the trusted FacetIDs list fcp.TLSData == TLSData fcp.Chlg == Chlg generate random KeyID store CallerID, AppID, Registration of the Authenticator KeyID, xCN T R A ) and sends AAID, n, f c, [hTr], KeyID, xCN T R A , S to UC, which sends the message, xSData and fcp to RP.\n\n\nthe differences: i) only 1st-factor authenticators (1B and 1R) can be used in login authentication cases; ii) 2R AAID, kW , RA \u2190 CN T RA + 1 S \u2190 sign skAU (AAID, n, f c, [hT r], KeyID, xCN T RA) Check: fcp.AppID == AppID xfc == fc CheckSign pkAU (S, AAID, f c, [hTr], KeyID, xCN T RA ) If right then: AppID, KeyID, SData, Chlg, [Tr ] ak, fc, AppID, h, [Tr ] AAID, n, fc, [hTr ] new random n new random SData xak == ak xSData, AAID, n, fc, [hTr ] [get Tr ] skAU , xak, xUName, KeyID \u2190 Dk W (h) [hTr \u2190 hash(Tr)] CN T RS \u2190 xCN T RA locate pkAU by UName, AAID', KeyID\n\nFig. 3 .\n3[hTr == hash(Tr )] get TLSData from TLS channel get TLSData from TLS channel ak \u2190 hash(ak || AppID ) verify the user [display and let the user verify the Tr ] AAID == AAID' xCN T RA == CN T RS + 1 hash(fcp) ak \u2190 hash(AppID || Tok || CallerID ) check if FacetID in the list initiate authentication if fcp.FacetID is in the trusted FacetIDs list xSData == SData fcp.TLSData == TLSData fcp.Chlg == Chlg locate h by KeyID ASM UAF Client User Agent Relying Party xfc \u2190 hash(AppID || Chlg || TLSData) Authentication operation: the operations framed by '[]' are needed only in the transaction confirmation operations.\n\n\nfun senc(bitstring,key):bitstring.\n\n1 let\n1ASM(MC:channel, MA:channel) = (...)\n\n\nMC, MA) | UC(MC) | Authenticator(MA)\n\n\nAppID2, AAID, choice[skAU,skAU2], choice[ KeyID,KeyID2], choice[kW,kW2], choice[tok, tok2], UName, FacetID, CallerID)\n\n\n\u00acM [A], and the minimal assumption comes into \u00acC[M ] and \u00acM [A].\n\n1 )\n1Authenticator Rebinding Attack: When the deployment of the protocol does not meet the assumptions \u00acC[U ], \u00acM [C] or \u00acA[M ]\n\n\n1 https://github.com/CactiLab/UAFVerifAuthenticator \nASM \nUAF Client \nWeb & UAF Server \nUser Agent \n\nUser Device \nRelying Party \n\nTLS \n\nFig. 1. UAF architecture \n\nFramework: \n\n\n\nTABLE I .\nIACRONYMS AND DESCRIPTIONS.\n\nTABLE II .\nIIPROTOCOL DIFFERENCES UNDER DIFFERENT TYPES OF AUTHENTICATORS AND USE CASES.authenticators use h as KeyID, whereas other authenticators \ngenerate a random KeyID; iii) since bound authenticators do \nnot have internal storage, they store h in ASM. 1R authen-\nticators have internal storage and store h inside themselves. \nThe protocol requires 2R authenticators to store h at RP; iv) \nif KeyID is generated randomly, it is stored in h; v) if it is a \n1st-factor authenticator (1B and 1R), h contains UName; vi) \n\n\n\nTABLE III .\nIIIMINIMAL ASSUMPTIONS REQUIRED FOR THE UAF REGISTRATION PROCESS TO ACHIEVE CONFIDENTIALITY PROPERTIES AND AUTHENTICATION PROPERTIES.\n\nTABLE IV .\nIVMINIMAL ASSUMPTIONS REQUIRED FOR THE UAF AUTHENTICATION PROCESS TO ACHIEVE CONFIDENTIALITY PROPERTIES AND AUTHENTICATION PROPERTIES.\n\n\nAttack: Parallel session attacks can be performed during the authentication process when the deployment of the protocol does not satisfy the assumptions \u00acA[M ] or \u00acM [A] for the 1B login case, or does not satisfy the assumptions \u00acC[M ] and \u00acM [A] for the 1R login case. In other words, to carry out the attack in the 1B login case, there should be a malicious authenticator and a malicious ASM on the victim's device, whereas to perform the attack in the 1R login case there should be a malicious UC or a malicious ASM on the victim's device. A similar attack was proposed\n\n\nAttack: The attacker can carry out a DoS attack when the deployment of the protocol does not satisfy the assumptions \u00acC[U ] or \u00acM [C] or \u00acA[M ]. For all 4 types of authenticators, if there is a malicious UC, ASM, or authenticator, the attacker can discard the authentication request and the user cannot finish the authentication.\nACKNOWLEDGMENTWe thank Malihek Shirvanian and the anonymous reviewers for their comments. The research of Beijing University and Posts and Telecommunications is partially funded by the Technology Major Project of China (2018ZX03001010-005).\nImperfect forward secrecy: How diffie-hellman fails in practice. D Adrian, K Bhargavan, Z Durumeric, P Gaudry, M Green, J A Halderman, N Heninger, D Springall, E Thom\u00e9, L Valenta, ACM SIGSAC Conference on Computer and Communications Security. ACMD. Adrian, K. Bhargavan, Z. Durumeric, P. Gaudry, M. Green, J. A. Halderman, N. Heninger, D. Springall, E. Thom\u00e9, L. Valenta et al., \"Imperfect forward secrecy: How diffie-hellman fails in practice,\" in ACM SIGSAC Conference on Computer and Communications Security. ACM, 2015, pp. 5-17.\n\nAndroid Now FIDO2 Certified, Accelerating Global Migration Beyond Passwords. F Alliance, F. Alliance, \"Android Now FIDO2 Certified, Accelerating Global Mi- gration Beyond Passwords,\" https://fidoalliance.org/android-now-fido2- certified-accelerating-global-migration-beyond-passwords/, 2017.\n\nClient to authenticator protocol (ctap). --, \"Client to authenticator protocol (ctap),\" https://fidoalliance.org/ specs/fido-v2.0-ps-20190130/fido-client-to-authenticator-protocol- v2.0-ps-20190130.html, 2017.\n\nFido appid and facet specification. --, \"Fido appid and facet specification,\" https://fidoalliance.org/ specs/fido-uaf-v1.1-ps-20170202/fido-appid-and-facets-v1.1-ps- 20170202.html, 2017.\n\nFido members. --, \"Fido members,\" https://fidoalliance.org/members/, 2017.\n\nFido security reference. --, \"Fido security reference,\" https://fidoalliance.org/specs/fido-uaf- v1.1-ps-20170202/fido-security-ref-v1.1-ps-20170202.html, 2017.\n\nFido uaf architectural overview. --, \"Fido uaf architectural overview,\" https://fidoalliance.org/specs/ fido-uaf-v1.1-ps-20170202/fido-uaf-overview-v1.1-ps-20170202.html, 2017.\n\nFido uaf authenticator commands. --, \"Fido uaf authenticator commands,\" https://fidoalliance.org/ specs/fido-uaf-v1.1-ps-20170202/fido-uaf-authnr-cmds-v1.1-ps- 20170202.html, 2017.\n\nFido uaf authenticator-specific module api. --, \"Fido uaf authenticator-specific module api,\" https: //fidoalliance.org/specs/fido-uaf-v1.1-ps-20170202/fido-uaf-asm- api-v1.1-ps-20170202.html, 2017.\n\nFido uaf protocol specification. Fido authenticator allowed cryptography list. 11--, \"Fido uaf protocol specification,\" https://fidoalliance.org/specs/ fido-uaf-v1.1-ps-20170202/fido-uaf-protocol-v1.1-ps-20170202.html, 2017. [11] --, \"Fido authenticator allowed cryptography list,\" https://fidoalliance.org/specs/fido-security-requirements-v1.2-2018/ fido-authenticator-allowed-cryptography-list-v1.0-wd-20180629.html, 2018.\n\nFido authenticator allowed restricted operating environments list. 13Fido authenticator metadata requirements,\" https--, \"Fido authenticator allowed restricted operating environments list,\" https://fidoalliance.org/specs/fido-security-requirements-v1.2- 2018/fido-authenticator-allowed-restricted-operating-environments- list-v1.0-wd-20180629.html, 2018. [13] --, \"Fido authenticator metadata requirements,\" https:\n\nFido authenticator security requirements. 14//fidoalliance.org/specs/fido-security-requirements-v1.2-2018/fido- authenticator-metadata-requirements-v1.0-wd-20180629.html, 2018. [14] --, \"Fido authenticator security requirements,\" https:\n\n. FIDO Certified Products. --, \"FIDO Certified Products,\" https://fidoalliance.org/certification/ fido-certified-products/, 2019.\n\nThe avispa tool for the automated validation of internet security protocols and applications. A Armando, D Basin, Y Boichut, Y Chevalier, L Compagna, J Cu\u00e9llar, P H Drielsma, P.-C H\u00e9am, O Kouchnarenko, J Mantovani, SpringerA. Armando, D. Basin, Y. Boichut, Y. Chevalier, L. Compagna, J. Cu\u00e9llar, P. H. Drielsma, P.-C. H\u00e9am, O. Kouchnarenko, J. Mantovani et al., \"The avispa tool for the automated validation of internet security protocols and applications,\" in International conference on computer aided verification. Springer, 2005, pp. 281-285.\n\nSatmc: a sat-based model checker for security-critical systems. A Armando, R Carbone, L Compagna, International Conference on Tools and Algorithms for the Construction and Analysis of Systems. SpringerA. Armando, R. Carbone, and L. Compagna, \"Satmc: a sat-based model checker for security-critical systems,\" in International Conference on Tools and Algorithms for the Construction and Analysis of Systems. Springer, 2014, pp. 31-45.\n\nA formal analysis of 5g authentication. D Basin, J Dreier, L Hirschi, S Radomirovic, R Sasse, V Stettler, ACM SIGSAC Conference on Computer and Communications Security. D. Basin, J. Dreier, L. Hirschi, S. Radomirovic, R. Sasse, and V. Stettler, \"A formal analysis of 5g authentication,\" in ACM SIGSAC Conference on Computer and Communications Security, 2018, pp. 1383-1396.\n\nOfmc: A symbolic model checker for security protocols. D Basin, S M\u00f6dersheim, L Vigano, International Journal of Information Security. 43D. Basin, S. M\u00f6dersheim, and L. Vigano, \"Ofmc: A symbolic model checker for security protocols,\" International Journal of Information Security, vol. 4, no. 3, pp. 181-208, 2005.\n\nA messy state of the union: Taming the composite state machines of tls. B Beurdouche, K Bhargavan, A Delignat-Lavaud, C Fournet, M Kohlweiss, A Pironti, P.-Y Strub, J K Zinzindohoue, IEEE Symposium on Security and Privacy. IEEEB. Beurdouche, K. Bhargavan, A. Delignat-Lavaud, C. Fournet, M. Kohlweiss, A. Pironti, P.-Y. Strub, and J. K. Zinzindohoue, \"A messy state of the union: Taming the composite state machines of tls,\" in IEEE Symposium on Security and Privacy. IEEE, 2015, pp. 535-552.\n\nVerified models and reference implementations for the tls 1.3 standard candidate. K Bhargavan, B Blanchet, N Kobeissi, IEEE Symposium on Security and Privacy (SP). IEEEK. Bhargavan, B. Blanchet, and N. Kobeissi, \"Verified models and reference implementations for the tls 1.3 standard candidate,\" in IEEE Symposium on Security and Privacy (SP). IEEE, 2017, pp. 483-502.\n\nCryptographically verified implementations for tls. K Bhargavan, C Fournet, R Corin, E Zalinescu, ACM conference on Computer and communications security. ACMK. Bhargavan, C. Fournet, R. Corin, and E. Zalinescu, \"Cryptographi- cally verified implementations for tls,\" in ACM conference on Computer and communications security. ACM, 2008, pp. 459-468.\n\nModeling and verifying security protocols with the applied pi calculus and proverif. B Blanchet, 1B. Blanchet, \"Modeling and verifying security protocols with the applied pi calculus and proverif,\" vol. 1, no. 1-2, pp. 1-135, 2016.\n\nProVerif 2.00: Automatic Cryptographic Protocol Verifier, User Manual and Tutorial. B Blanchet, B Smyth, V Cheval, M Sylvestre, B. Blanchet, B. Smyth, V. Cheval, and M. Sylvestre, ProVerif 2.00: Automatic Cryptographic Protocol Verifier, User Manual and Tutorial, May 2018, http://prosecco.gforge.inria.fr/personal/bblanche/ proverif/manual.pdf.\n\nValidation of prouv\u00e9 protocols using the automatic tool ta4sp. Y Boichut, N Kosmatov, L Vigneron, Taiwanese-French Conference on Information Technology. Y. Boichut, N. Kosmatov, and L. Vigneron, \"Validation of prouv\u00e9 pro- tocols using the automatic tool ta4sp,\" in Taiwanese-French Conference on Information Technology (TFIT 2006), 2006, pp. 467-480.\n\nThe science of guessing: analyzing an anonymized corpus of 70 million passwords. J Bonneau, IEEE Symposium on Security and Privacy. IEEEJ. Bonneau, \"The science of guessing: analyzing an anonymized corpus of 70 million passwords,\" in IEEE Symposium on Security and Privacy. IEEE, 2012, pp. 538-552.\n\nThe quest to replace passwords: A framework for comparative evaluation of web authentication schemes. J Bonneau, C Herley, P C Van Oorschot, F Stajano, IEEE Symposium on Security and Privacy. IEEEJ. Bonneau, C. Herley, P. C. Van Oorschot, and F. Stajano, \"The quest to replace passwords: A framework for comparative evaluation of web authentication schemes,\" in IEEE Symposium on Security and Privacy. IEEE, 2012, pp. 553-567.\n\nAnalysis of the security-enhanced vtpm migration protocol based on proverif. D Chang, X Chu, G Wei, International Conference on Computational and Information Sciences. IEEED. Chang, X. Chu, and G. Wei, \"Analysis of the security-enhanced vtpm migration protocol based on proverif,\" in International Conference on Computational and Information Sciences. IEEE, 2013, pp. 1437-1440.\n\nOn making u2f protocol leakage-resilient via re-keying. D Chang, S Mishra, S K Sanadhya, A P Singh, IACR Cryptology ePrint Archive. 2017721D. Chang, S. Mishra, S. K. Sanadhya, and A. P. Singh, \"On making u2f protocol leakage-resilient via re-keying.\" IACR Cryptology ePrint Archive, vol. 2017, p. 721, 2017.\n\nKey exchange in ipsec revisited: Formal analysis of ikev1 and ikev2. C Cremers, European Symposium on Research in Computer Security. SpringerC. Cremers, \"Key exchange in ipsec revisited: Formal analysis of ikev1 and ikev2,\" in European Symposium on Research in Computer Security. Springer, 2011, pp. 315-334.\n\nUnbounded verification, falsification, and characterization of security protocols by pattern refinement. C J Cremers, ACM conference on Computer and communications security. ACMC. J. Cremers, \"Unbounded verification, falsification, and characteriza- tion of security protocols by pattern refinement,\" in ACM conference on Computer and communications security. ACM, 2008, pp. 119-128.\n\nVerifying privacy-type properties of electronic voting protocols. S Delaune, S Kremer, M Ryan, Journal of Computer Security. 174S. Delaune, S. Kremer, and M. Ryan, \"Verifying privacy-type properties of electronic voting protocols,\" Journal of Computer Security, vol. 17, no. 4, pp. 435-487, 2009.\n\nFormal analysis of an e-health protocol. N Dong, H Jonker, J Pang, arXiv:1808.08403arXiv preprintN. Dong, H. Jonker, and J. Pang, \"Formal analysis of an e-health protocol,\" arXiv preprint arXiv:1808.08403, 2018.\n\nA rewriting-based inference system for the nrl protocol analyzer and its meta-logical properties. S Escobar, C Meadows, J Meseguer, Theoretical Computer Science. 3671-2S. Escobar, C. Meadows, and J. Meseguer, \"A rewriting-based inference system for the nrl protocol analyzer and its meta-logical properties,\" Theoretical Computer Science, vol. 367, no. 1-2, pp. 162-202, 2006.\n\nTypes and effects for asymmetric cryptographic protocols. A D Gordon, A Jeffrey, Journal of Computer Security. 123-4A. D. Gordon and A. Jeffrey, \"Types and effects for asymmetric cryptographic protocols,\" Journal of Computer Security, vol. 12, no. 3-4, pp. 435-483, 2004.\n\nSecurity analysis of an attractive online authentication standard: Fido uaf protocol. K Hu, Z Zhang, China Communications. 1312K. Hu and Z. Zhang, \"Security analysis of an attractive online authen- tication standard: Fido uaf protocol,\" China Communications, vol. 13, no. 12, pp. 189-198, 2016.\n\nSecurity analysis of lmap using avispa. S Islam, International journal of security and networks. 91S. Islam, \"Security analysis of lmap using avispa,\" International journal of security and networks, vol. 9, no. 1, pp. 30-39, 2014.\n\nAn extensive formal analysis of multifactor authentication protocols. C Jacomme, S Kremer, IEEE Computer Security Foundations Symposium (CSF). IEEEC. Jacomme and S. Kremer, \"An extensive formal analysis of multi- factor authentication protocols,\" in IEEE Computer Security Founda- tions Symposium (CSF). IEEE, 2018, pp. 1-15.\n\nOn the effective prevention of tls man-inthe-middle attacks in web applications. N Karapanos, S Capkun, Usenix Security Symposium. N. Karapanos and S. Capkun, \"On the effective prevention of tls man-in- the-middle attacks in web applications,\" in Usenix Security Symposium, 2014, pp. 671-686.\n\nDifferential power analysis. P Kocher, J Jaffe, B Jun, Annual international cryptology conference. SpringerP. Kocher, J. Jaffe, and B. Jun, \"Differential power analysis,\" in Annual international cryptology conference. Springer, 1999, pp. 388-397.\n\nTiming attacks on implementations of diffie-hellman, rsa, dss, and other systems. P C Kocher, Annual International Cryptology Conference. SpringerP. C. Kocher, \"Timing attacks on implementations of diffie-hellman, rsa, dss, and other systems,\" in Annual International Cryptology Conference. Springer, 1996, pp. 104-113.\n\nWhat's wrong with fido. N Leoutsarakos, N. Leoutsarakos, \"What's wrong with fido?\" http://zeropasswords.com/ pdfs/WHATisWRONG\\ FIDO.pdf, 2011.\n\nFido trust requirements. I Loutfi, A J\u00f8sang, Nordic Conference on Secure IT Systems. SpringerI. Loutfi and A. J\u00f8sang, \"Fido trust requirements,\" in Nordic Conference on Secure IT Systems. Springer, 2015, pp. 139-155.\n\nBreaking and fixing the needham-schroeder public-key protocol using fdr. G Lowe, International Workshop on Tools and Algorithms for the Construction and Analysis of Systems. SpringerG. Lowe, \"Breaking and fixing the needham-schroeder public-key protocol using fdr,\" in International Workshop on Tools and Algorithms for the Construction and Analysis of Systems. Springer, 1996, pp. 147-166.\n\nA hierarchy of authentication specifications. Computer Security Foundations Workshop. IEEE--, \"A hierarchy of authentication specifications,\" in Computer Se- curity Foundations Workshop. IEEE, 1997, pp. 31-43.\n\nThe tamarin prover for the symbolic analysis of security protocols. S Meier, B Schmidt, C Cremers, D Basin, International Conference on Computer Aided Verification. SpringerS. Meier, B. Schmidt, C. Cremers, and D. Basin, \"The tamarin prover for the symbolic analysis of security protocols,\" in International Conference on Computer Aided Verification. Springer, 2013, pp. 696-701.\n\nA security evaluation of fido's uaf protocol in mobile and embedded devices. C Panos, S Malliaros, C Ntantogian, A Panou, C Xenakis, International Tyrrhenian Workshop on Digital Communication. SpringerC. Panos, S. Malliaros, C. Ntantogian, A. Panou, and C. Xenakis, \"A security evaluation of fido's uaf protocol in mobile and embedded devices,\" in International Tyrrhenian Workshop on Digital Communi- cation. Springer, 2017, pp. 127-142.\n\nFormal analysis of the fido 1.x protocol. O Pereira, F Rochet, C Wiedling, International Symposium on Foundations & Practice of Security. O. Pereira, F. Rochet, and C. Wiedling, \"Formal analysis of the fido 1.x protocol,\" in International Symposium on Foundations & Practice of Security, 2017.\n\nAutomated analysis of diffie-hellman protocols and advanced security properties. B Schmidt, S Meier, C Cremers, D Basin, IEEE Computer Security Foundations Symposium. IEEEB. Schmidt, S. Meier, C. Cremers, and D. Basin, \"Automated analysis of diffie-hellman protocols and advanced security properties,\" in IEEE Computer Security Foundations Symposium. IEEE, 2012, pp. 78-94.\n\nSok: \"plug & pray\" today -understanding usb insecurity in versions 1 through c. J Tian, N Scaife, D Kumar, M Bailey, A Bates, K Butler, IEEE Symposium on Security & Privacy. J. Tian, N. Scaife, D. Kumar, M. Bailey, A. Bates, and K. Butler, \"Sok: \"plug & pray\" today -understanding usb insecurity in versions 1 through c,\" in IEEE Symposium on Security & Privacy, 2018.\n\nThe cl-atse protocol analyser. M Turuani, International Conference on Rewriting Techniques and Applications. SpringerM. Turuani, \"The cl-atse protocol analyser,\" in International Conference on Rewriting Techniques and Applications. Springer, 2006, pp. 277- 286.\n\nWeb authentication: An api for accessing public key credentials level 1. W3C. W3C, \"Web authentication: An api for accessing public key credentials level 1,\" https://www.w3.org/TR/webauthn/, 2017.\n\nTowards an automatic analysis of security protocols in first-order logic. C Weidenbach, International Conference on Automated Deduction. SpringerC. Weidenbach, \"Towards an automatic analysis of security protocols in first-order logic,\" in International Conference on Automated Deduction. Springer, 1999, pp. 314-328.\n\nImprovement of a three-party password-based key exchange protocol with formal verification. Q Xie, N Dong, X Tan, D S Wong, G Wang, Information Technology and Control. 423Q. Xie, N. Dong, X. Tan, D. S. Wong, and G. Wang, \"Improvement of a three-party password-based key exchange protocol with formal verification,\" Information Technology and Control, vol. 42, no. 3, pp. 231-237, 2013.\n\nThe security of modern password expiration: An algorithmic framework and empirical analysis. Y Zhang, F Monrose, M Reiter, ACM conference on Computer and communications security. ACMY. Zhang, F. Monrose, and M. Reiter, \"The security of modern password expiration: An algorithmic framework and empirical analysis,\" in ACM conference on Computer and communications security. ACM, 2010, pp. 176-186.\n\nSecure display for fido transaction confirmation. Y Zhang, X Wang, Z Zhao, H Li, ACM Conference on Data and Application Security and Privacy. Y. Zhang, X. Wang, Z. Zhao, and H. Li, \"Secure display for fido transaction confirmation,\" in ACM Conference on Data and Application Security and Privacy, 2018, pp. 155-157.\n\nFormal analysis of iso/iec 9798-2 authentication standard using avispa. S Ziauddin, B Martin, Asia joint conference on information security. IEEES. Ziauddin and B. Martin, \"Formal analysis of iso/iec 9798-2 authen- tication standard using avispa,\" in Asia joint conference on information security. IEEE, 2013, pp. 108-114.\n", "annotations": {"author": "[{\"end\":142,\"start\":46},{\"end\":234,\"start\":143},{\"end\":374,\"start\":235},{\"end\":471,\"start\":375}]", "publisher": null, "author_last_name": "[{\"end\":57,\"start\":53},{\"end\":149,\"start\":147},{\"end\":246,\"start\":243},{\"end\":386,\"start\":382}]", "author_first_name": "[{\"end\":52,\"start\":46},{\"end\":146,\"start\":143},{\"end\":242,\"start\":235},{\"end\":381,\"start\":375}]", "author_affiliation": "[{\"end\":141,\"start\":59},{\"end\":233,\"start\":151},{\"end\":373,\"start\":291},{\"end\":470,\"start\":388}]", "title": "[{\"end\":43,\"start\":1},{\"end\":514,\"start\":472}]", "venue": null, "abstract": "[{\"end\":1625,\"start\":540}]", "bib_ref": "[{\"attributes\":{\"ref_id\":\"b23\"},\"end\":2104,\"start\":2100},{\"attributes\":{\"ref_id\":\"b24\"},\"end\":2110,\"start\":2106},{\"attributes\":{\"ref_id\":\"b52\"},\"end\":2116,\"start\":2112},{\"attributes\":{\"ref_id\":\"b4\"},\"end\":2210,\"start\":2207},{\"attributes\":{\"ref_id\":\"b12\"},\"end\":2276,\"start\":2272},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":2549,\"start\":2546},{\"attributes\":{\"ref_id\":\"b49\"},\"end\":3087,\"start\":3083},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":3135,\"start\":3132},{\"attributes\":{\"ref_id\":\"b26\"},\"end\":3472,\"start\":3468},{\"attributes\":{\"ref_id\":\"b33\"},\"end\":3478,\"start\":3474},{\"attributes\":{\"ref_id\":\"b39\"},\"end\":3484,\"start\":3480},{\"attributes\":{\"ref_id\":\"b40\"},\"end\":3490,\"start\":3486},{\"attributes\":{\"ref_id\":\"b44\"},\"end\":3496,\"start\":3492},{\"attributes\":{\"ref_id\":\"b35\"},\"end\":3741,\"start\":3737},{\"attributes\":{\"ref_id\":\"b45\"},\"end\":3747,\"start\":3743},{\"attributes\":{\"ref_id\":\"b41\"},\"end\":5153,\"start\":5149},{\"attributes\":{\"ref_id\":\"b17\"},\"end\":5163,\"start\":5159},{\"attributes\":{\"ref_id\":\"b19\"},\"end\":5169,\"start\":5165},{\"attributes\":{\"ref_id\":\"b15\"},\"end\":5193,\"start\":5189},{\"attributes\":{\"ref_id\":\"b27\"},\"end\":5203,\"start\":5199},{\"attributes\":{\"ref_id\":\"b0\"},\"end\":5223,\"start\":5220},{\"attributes\":{\"ref_id\":\"b46\"},\"end\":5229,\"start\":5225},{\"attributes\":{\"ref_id\":\"b54\"},\"end\":5250,\"start\":5246},{\"attributes\":{\"ref_id\":\"b34\"},\"end\":5261,\"start\":5257},{\"attributes\":{\"ref_id\":\"b25\"},\"end\":5282,\"start\":5278},{\"attributes\":{\"ref_id\":\"b51\"},\"end\":5294,\"start\":5290},{\"attributes\":{\"ref_id\":\"b29\"},\"end\":5309,\"start\":5305},{\"attributes\":{\"ref_id\":\"b30\"},\"end\":5324,\"start\":5320},{\"attributes\":{\"ref_id\":\"b47\"},\"end\":5341,\"start\":5337},{\"attributes\":{\"ref_id\":\"b20\"},\"end\":5984,\"start\":5980},{\"attributes\":{\"ref_id\":\"b21\"},\"end\":5990,\"start\":5986},{\"attributes\":{\"ref_id\":\"b6\"},\"end\":8698,\"start\":8695},{\"attributes\":{\"ref_id\":\"b7\"},\"end\":9173,\"start\":9170},{\"attributes\":{\"ref_id\":\"b8\"},\"end\":9658,\"start\":9655},{\"attributes\":{\"ref_id\":\"b3\"},\"end\":11365,\"start\":11362},{\"attributes\":{\"ref_id\":\"b36\"},\"end\":13366,\"start\":13362},{\"attributes\":{\"ref_id\":\"b8\"},\"end\":13767,\"start\":13764},{\"attributes\":{\"ref_id\":\"b7\"},\"end\":19025,\"start\":19022},{\"attributes\":{\"ref_id\":\"b5\"},\"end\":19906,\"start\":19903},{\"attributes\":{\"ref_id\":\"b10\"},\"end\":19999,\"start\":19995},{\"end\":20091,\"start\":20087},{\"attributes\":{\"ref_id\":\"b5\"},\"end\":20920,\"start\":20917},{\"attributes\":{\"ref_id\":\"b8\"},\"end\":20925,\"start\":20922},{\"attributes\":{\"ref_id\":\"b37\"},\"end\":22414,\"start\":22410},{\"attributes\":{\"ref_id\":\"b38\"},\"end\":22420,\"start\":22416},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":23030,\"start\":23026},{\"attributes\":{\"ref_id\":\"b42\"},\"end\":23453,\"start\":23449},{\"attributes\":{\"ref_id\":\"b15\"},\"end\":23544,\"start\":23540},{\"attributes\":{\"ref_id\":\"b5\"},\"end\":24801,\"start\":24798},{\"attributes\":{\"ref_id\":\"b5\"},\"end\":29864,\"start\":29861},{\"attributes\":{\"ref_id\":\"b8\"},\"end\":30325,\"start\":30322},{\"attributes\":{\"ref_id\":\"b43\"},\"end\":32123,\"start\":32119},{\"attributes\":{\"ref_id\":\"b13\"},\"end\":32136,\"start\":32132},{\"attributes\":{\"ref_id\":\"b20\"},\"end\":32454,\"start\":32450},{\"attributes\":{\"ref_id\":\"b13\"},\"end\":32516,\"start\":32512},{\"attributes\":{\"ref_id\":\"b48\"},\"end\":32530,\"start\":32526},{\"attributes\":{\"ref_id\":\"b16\"},\"end\":32541,\"start\":32537},{\"attributes\":{\"ref_id\":\"b43\"},\"end\":32555,\"start\":32551},{\"attributes\":{\"ref_id\":\"b41\"},\"end\":32565,\"start\":32561},{\"attributes\":{\"ref_id\":\"b28\"},\"end\":32579,\"start\":32575},{\"attributes\":{\"ref_id\":\"b14\"},\"end\":32591,\"start\":32587},{\"attributes\":{\"ref_id\":\"b32\"},\"end\":32605,\"start\":32601},{\"attributes\":{\"ref_id\":\"b22\"},\"end\":32617,\"start\":32613},{\"attributes\":{\"ref_id\":\"b31\"},\"end\":32633,\"start\":32629},{\"attributes\":{\"ref_id\":\"b50\"},\"end\":33070,\"start\":33066},{\"attributes\":{\"ref_id\":\"b20\"},\"end\":34947,\"start\":34943},{\"attributes\":{\"ref_id\":\"b0\"},\"end\":35761,\"start\":35760},{\"attributes\":{\"ref_id\":\"b0\"},\"end\":39746,\"start\":39745},{\"attributes\":{\"ref_id\":\"b33\"},\"end\":55736,\"start\":55732},{\"attributes\":{\"ref_id\":\"b44\"},\"end\":55887,\"start\":55883},{\"attributes\":{\"ref_id\":\"b33\"},\"end\":56272,\"start\":56268},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":61325,\"start\":61321},{\"attributes\":{\"ref_id\":\"b8\"},\"end\":62963,\"start\":62960},{\"attributes\":{\"ref_id\":\"b33\"},\"end\":63807,\"start\":63803},{\"attributes\":{\"ref_id\":\"b39\"},\"end\":63906,\"start\":63902},{\"attributes\":{\"ref_id\":\"b44\"},\"end\":64038,\"start\":64034},{\"attributes\":{\"ref_id\":\"b40\"},\"end\":64282,\"start\":64278},{\"attributes\":{\"ref_id\":\"b53\"},\"end\":64413,\"start\":64409},{\"attributes\":{\"ref_id\":\"b35\"},\"end\":64637,\"start\":64633},{\"attributes\":{\"ref_id\":\"b26\"},\"end\":65274,\"start\":65270},{\"attributes\":{\"ref_id\":\"b45\"},\"end\":65363,\"start\":65359}]", "figure": "[{\"attributes\":{\"id\":\"fig_0\"},\"end\":67171,\"start\":66445},{\"attributes\":{\"id\":\"fig_1\"},\"end\":67737,\"start\":67172},{\"attributes\":{\"id\":\"fig_2\"},\"end\":68359,\"start\":67738},{\"attributes\":{\"id\":\"fig_3\"},\"end\":68396,\"start\":68360},{\"attributes\":{\"id\":\"fig_8\"},\"end\":68440,\"start\":68397},{\"attributes\":{\"id\":\"fig_9\"},\"end\":68479,\"start\":68441},{\"attributes\":{\"id\":\"fig_14\"},\"end\":68599,\"start\":68480},{\"attributes\":{\"id\":\"fig_15\"},\"end\":68666,\"start\":68600},{\"attributes\":{\"id\":\"fig_16\"},\"end\":68795,\"start\":68667},{\"attributes\":{\"id\":\"tab_0\",\"type\":\"table\"},\"end\":68974,\"start\":68796},{\"attributes\":{\"id\":\"tab_1\",\"type\":\"table\"},\"end\":69013,\"start\":68975},{\"attributes\":{\"id\":\"tab_3\",\"type\":\"table\"},\"end\":69538,\"start\":69014},{\"attributes\":{\"id\":\"tab_5\",\"type\":\"table\"},\"end\":69685,\"start\":69539},{\"attributes\":{\"id\":\"tab_7\",\"type\":\"table\"},\"end\":69832,\"start\":69686},{\"attributes\":{\"id\":\"tab_8\",\"type\":\"table\"},\"end\":70407,\"start\":69833},{\"attributes\":{\"id\":\"tab_9\",\"type\":\"table\"},\"end\":70739,\"start\":70408}]", "paragraph": "[{\"end\":2550,\"start\":1644},{\"end\":3296,\"start\":2552},{\"end\":3672,\"start\":3298},{\"end\":4303,\"start\":3674},{\"end\":4935,\"start\":4305},{\"end\":5656,\"start\":4937},{\"end\":5899,\"start\":5658},{\"end\":6598,\"start\":5901},{\"end\":7194,\"start\":6600},{\"end\":8800,\"start\":7231},{\"end\":9454,\"start\":8820},{\"end\":9659,\"start\":9456},{\"end\":10521,\"start\":9661},{\"end\":10826,\"start\":10523},{\"end\":11224,\"start\":10860},{\"end\":11498,\"start\":11226},{\"end\":11576,\"start\":11500},{\"end\":11749,\"start\":11583},{\"end\":11870,\"start\":11757},{\"end\":11961,\"start\":11880},{\"end\":12031,\"start\":11971},{\"end\":12270,\"start\":12043},{\"end\":12342,\"start\":12280},{\"end\":12452,\"start\":12351},{\"end\":12537,\"start\":12459},{\"end\":12795,\"start\":12549},{\"end\":12968,\"start\":12804},{\"end\":13468,\"start\":12970},{\"end\":13904,\"start\":13470},{\"end\":14833,\"start\":13906},{\"end\":15738,\"start\":14835},{\"end\":15977,\"start\":15760},{\"end\":16198,\"start\":15979},{\"end\":17691,\"start\":16200},{\"end\":18246,\"start\":17763},{\"end\":18915,\"start\":18248},{\"end\":19268,\"start\":18917},{\"end\":20375,\"start\":19809},{\"end\":20926,\"start\":20377},{\"end\":21162,\"start\":20928},{\"end\":21979,\"start\":21164},{\"end\":22421,\"start\":21981},{\"end\":22742,\"start\":22461},{\"end\":22926,\"start\":22780},{\"end\":23206,\"start\":22928},{\"end\":23303,\"start\":23251},{\"end\":24716,\"start\":23337},{\"end\":24839,\"start\":24718},{\"end\":24981,\"start\":24841},{\"end\":25374,\"start\":24983},{\"end\":25457,\"start\":25376},{\"end\":25721,\"start\":25459},{\"end\":25943,\"start\":25723},{\"end\":26240,\"start\":25982},{\"end\":26496,\"start\":26242},{\"end\":27216,\"start\":26498},{\"end\":27416,\"start\":27218},{\"end\":27650,\"start\":27418},{\"end\":27951,\"start\":27652},{\"end\":28420,\"start\":27953},{\"end\":28943,\"start\":28422},{\"end\":29273,\"start\":28945},{\"end\":29505,\"start\":29275},{\"end\":29611,\"start\":29507},{\"end\":29730,\"start\":29613},{\"end\":30035,\"start\":29732},{\"end\":30455,\"start\":30037},{\"end\":30647,\"start\":30457},{\"end\":30928,\"start\":30649},{\"end\":31203,\"start\":30930},{\"end\":31407,\"start\":31205},{\"end\":31675,\"start\":31409},{\"end\":32237,\"start\":31717},{\"end\":32925,\"start\":32265},{\"end\":33244,\"start\":32927},{\"end\":33628,\"start\":33246},{\"end\":33772,\"start\":33674},{\"end\":34843,\"start\":33774},{\"end\":36675,\"start\":34845},{\"end\":37596,\"start\":36709},{\"end\":38066,\"start\":37598},{\"end\":39202,\"start\":38068},{\"end\":39981,\"start\":39204},{\"end\":41169,\"start\":39983},{\"end\":41684,\"start\":41194},{\"end\":42138,\"start\":41686},{\"end\":45319,\"start\":42200},{\"end\":46124,\"start\":45378},{\"end\":47298,\"start\":46126},{\"end\":48681,\"start\":47300},{\"end\":50145,\"start\":48683},{\"end\":50662,\"start\":50147},{\"end\":51169,\"start\":50664},{\"end\":52089,\"start\":51171},{\"end\":52904,\"start\":52104},{\"end\":53733,\"start\":52906},{\"end\":54154,\"start\":53735},{\"end\":54655,\"start\":54156},{\"end\":55065,\"start\":54657},{\"end\":56362,\"start\":55067},{\"end\":57153,\"start\":56386},{\"end\":57800,\"start\":57155},{\"end\":58292,\"start\":57802},{\"end\":59820,\"start\":58294},{\"end\":59954,\"start\":59866},{\"end\":60496,\"start\":59984},{\"end\":60930,\"start\":60498},{\"end\":61854,\"start\":60932},{\"end\":62726,\"start\":61856},{\"end\":63329,\"start\":62728},{\"end\":63633,\"start\":63336},{\"end\":65580,\"start\":63654},{\"end\":65722,\"start\":65582},{\"end\":66444,\"start\":65742}]", "formula": "[{\"attributes\":{\"id\":\"formula_0\"},\"end\":19769,\"start\":19269}]", "table_ref": "[{\"attributes\":{\"ref_id\":\"tab_1\"},\"end\":8385,\"start\":8378},{\"attributes\":{\"ref_id\":\"tab_1\"},\"end\":19047,\"start\":19027},{\"attributes\":{\"ref_id\":\"tab_1\"},\"end\":42953,\"start\":42944},{\"attributes\":{\"ref_id\":\"tab_1\"},\"end\":44085,\"start\":44076},{\"attributes\":{\"ref_id\":\"tab_1\"},\"end\":44843,\"start\":44835},{\"attributes\":{\"ref_id\":\"tab_1\"},\"end\":47593,\"start\":47584},{\"attributes\":{\"ref_id\":\"tab_1\"},\"end\":49244,\"start\":49235}]", "section_header": "[{\"end\":1642,\"start\":1627},{\"end\":7229,\"start\":7197},{\"end\":8818,\"start\":8803},{\"end\":10858,\"start\":10829},{\"end\":11581,\"start\":11579},{\"end\":11755,\"start\":11752},{\"end\":11878,\"start\":11873},{\"end\":11969,\"start\":11964},{\"end\":12041,\"start\":12034},{\"end\":12278,\"start\":12273},{\"end\":12349,\"start\":12345},{\"end\":12457,\"start\":12455},{\"end\":12547,\"start\":12540},{\"end\":12802,\"start\":12798},{\"end\":15758,\"start\":15741},{\"end\":17761,\"start\":17694},{\"end\":19807,\"start\":19771},{\"end\":22459,\"start\":22424},{\"end\":22778,\"start\":22745},{\"end\":23249,\"start\":23209},{\"end\":23335,\"start\":23306},{\"end\":25980,\"start\":25946},{\"end\":31715,\"start\":31678},{\"end\":32263,\"start\":32240},{\"end\":33672,\"start\":33631},{\"end\":36707,\"start\":36678},{\"end\":41192,\"start\":41172},{\"end\":42198,\"start\":42141},{\"end\":45340,\"start\":45322},{\"end\":45376,\"start\":45343},{\"end\":52102,\"start\":52092},{\"end\":56384,\"start\":56365},{\"end\":59843,\"start\":59823},{\"end\":59864,\"start\":59846},{\"end\":59982,\"start\":59957},{\"end\":63334,\"start\":63332},{\"end\":63652,\"start\":63636},{\"end\":65740,\"start\":65725},{\"end\":66454,\"start\":66446},{\"end\":67747,\"start\":67739},{\"end\":68403,\"start\":68398},{\"end\":68671,\"start\":68668},{\"end\":68985,\"start\":68976},{\"end\":69025,\"start\":69015},{\"end\":69551,\"start\":69540},{\"end\":69697,\"start\":69687}]", "table": "[{\"end\":68974,\"start\":68836},{\"end\":69538,\"start\":69103}]", "figure_caption": "[{\"end\":67171,\"start\":66456},{\"end\":67737,\"start\":67174},{\"end\":68359,\"start\":67749},{\"end\":68396,\"start\":68362},{\"end\":68440,\"start\":68405},{\"end\":68479,\"start\":68443},{\"end\":68599,\"start\":68482},{\"end\":68666,\"start\":68602},{\"end\":68795,\"start\":68673},{\"end\":68836,\"start\":68798},{\"end\":69013,\"start\":68987},{\"end\":69103,\"start\":69028},{\"end\":69685,\"start\":69555},{\"end\":69832,\"start\":69700},{\"end\":70407,\"start\":69835},{\"end\":70739,\"start\":70410}]", "figure_ref": "[{\"attributes\":{\"ref_id\":\"fig_8\"},\"end\":8840,\"start\":8832},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":10726,\"start\":10718},{\"attributes\":{\"ref_id\":\"fig_2\"},\"end\":15344,\"start\":15336},{\"attributes\":{\"ref_id\":\"fig_2\"},\"end\":15665,\"start\":15657},{\"attributes\":{\"ref_id\":\"fig_8\"},\"end\":21249,\"start\":21241}]", "bib_author_first_name": "[{\"end\":71047,\"start\":71046},{\"end\":71057,\"start\":71056},{\"end\":71070,\"start\":71069},{\"end\":71083,\"start\":71082},{\"end\":71093,\"start\":71092},{\"end\":71102,\"start\":71101},{\"end\":71104,\"start\":71103},{\"end\":71117,\"start\":71116},{\"end\":71129,\"start\":71128},{\"end\":71142,\"start\":71141},{\"end\":71151,\"start\":71150},{\"end\":71593,\"start\":71592},{\"end\":74312,\"start\":74311},{\"end\":74323,\"start\":74322},{\"end\":74332,\"start\":74331},{\"end\":74343,\"start\":74342},{\"end\":74356,\"start\":74355},{\"end\":74368,\"start\":74367},{\"end\":74379,\"start\":74378},{\"end\":74381,\"start\":74380},{\"end\":74396,\"start\":74392},{\"end\":74404,\"start\":74403},{\"end\":74420,\"start\":74419},{\"end\":74830,\"start\":74829},{\"end\":74841,\"start\":74840},{\"end\":74852,\"start\":74851},{\"end\":75240,\"start\":75239},{\"end\":75249,\"start\":75248},{\"end\":75259,\"start\":75258},{\"end\":75270,\"start\":75269},{\"end\":75285,\"start\":75284},{\"end\":75294,\"start\":75293},{\"end\":75630,\"start\":75629},{\"end\":75639,\"start\":75638},{\"end\":75653,\"start\":75652},{\"end\":75963,\"start\":75962},{\"end\":75977,\"start\":75976},{\"end\":75990,\"start\":75989},{\"end\":76009,\"start\":76008},{\"end\":76020,\"start\":76019},{\"end\":76033,\"start\":76032},{\"end\":76047,\"start\":76043},{\"end\":76056,\"start\":76055},{\"end\":76058,\"start\":76057},{\"end\":76467,\"start\":76466},{\"end\":76480,\"start\":76479},{\"end\":76492,\"start\":76491},{\"end\":76807,\"start\":76806},{\"end\":76820,\"start\":76819},{\"end\":76831,\"start\":76830},{\"end\":76840,\"start\":76839},{\"end\":77191,\"start\":77190},{\"end\":77423,\"start\":77422},{\"end\":77435,\"start\":77434},{\"end\":77444,\"start\":77443},{\"end\":77454,\"start\":77453},{\"end\":77749,\"start\":77748},{\"end\":77760,\"start\":77759},{\"end\":77772,\"start\":77771},{\"end\":78119,\"start\":78118},{\"end\":78440,\"start\":78439},{\"end\":78451,\"start\":78450},{\"end\":78461,\"start\":78460},{\"end\":78463,\"start\":78462},{\"end\":78479,\"start\":78478},{\"end\":78843,\"start\":78842},{\"end\":78852,\"start\":78851},{\"end\":78859,\"start\":78858},{\"end\":79202,\"start\":79201},{\"end\":79211,\"start\":79210},{\"end\":79221,\"start\":79220},{\"end\":79223,\"start\":79222},{\"end\":79235,\"start\":79234},{\"end\":79237,\"start\":79236},{\"end\":79524,\"start\":79523},{\"end\":79870,\"start\":79869},{\"end\":79872,\"start\":79871},{\"end\":80216,\"start\":80215},{\"end\":80227,\"start\":80226},{\"end\":80237,\"start\":80236},{\"end\":80489,\"start\":80488},{\"end\":80497,\"start\":80496},{\"end\":80507,\"start\":80506},{\"end\":80759,\"start\":80758},{\"end\":80770,\"start\":80769},{\"end\":80781,\"start\":80780},{\"end\":81097,\"start\":81096},{\"end\":81099,\"start\":81098},{\"end\":81109,\"start\":81108},{\"end\":81398,\"start\":81397},{\"end\":81404,\"start\":81403},{\"end\":81648,\"start\":81647},{\"end\":81910,\"start\":81909},{\"end\":81921,\"start\":81920},{\"end\":82248,\"start\":82247},{\"end\":82261,\"start\":82260},{\"end\":82490,\"start\":82489},{\"end\":82500,\"start\":82499},{\"end\":82509,\"start\":82508},{\"end\":82791,\"start\":82790},{\"end\":82793,\"start\":82792},{\"end\":83054,\"start\":83053},{\"end\":83199,\"start\":83198},{\"end\":83209,\"start\":83208},{\"end\":83465,\"start\":83464},{\"end\":84063,\"start\":84062},{\"end\":84072,\"start\":84071},{\"end\":84083,\"start\":84082},{\"end\":84094,\"start\":84093},{\"end\":84453,\"start\":84452},{\"end\":84462,\"start\":84461},{\"end\":84475,\"start\":84474},{\"end\":84489,\"start\":84488},{\"end\":84498,\"start\":84497},{\"end\":84858,\"start\":84857},{\"end\":84869,\"start\":84868},{\"end\":84879,\"start\":84878},{\"end\":85192,\"start\":85191},{\"end\":85203,\"start\":85202},{\"end\":85212,\"start\":85211},{\"end\":85223,\"start\":85222},{\"end\":85566,\"start\":85565},{\"end\":85574,\"start\":85573},{\"end\":85584,\"start\":85583},{\"end\":85593,\"start\":85592},{\"end\":85603,\"start\":85602},{\"end\":85612,\"start\":85611},{\"end\":85887,\"start\":85886},{\"end\":86391,\"start\":86390},{\"end\":86727,\"start\":86726},{\"end\":86734,\"start\":86733},{\"end\":86742,\"start\":86741},{\"end\":86749,\"start\":86748},{\"end\":86751,\"start\":86750},{\"end\":86759,\"start\":86758},{\"end\":87115,\"start\":87114},{\"end\":87124,\"start\":87123},{\"end\":87135,\"start\":87134},{\"end\":87470,\"start\":87469},{\"end\":87479,\"start\":87478},{\"end\":87487,\"start\":87486},{\"end\":87495,\"start\":87494},{\"end\":87809,\"start\":87808},{\"end\":87821,\"start\":87820}]", "bib_author_last_name": "[{\"end\":71054,\"start\":71048},{\"end\":71067,\"start\":71058},{\"end\":71080,\"start\":71071},{\"end\":71090,\"start\":71084},{\"end\":71099,\"start\":71094},{\"end\":71114,\"start\":71105},{\"end\":71126,\"start\":71118},{\"end\":71139,\"start\":71130},{\"end\":71148,\"start\":71143},{\"end\":71159,\"start\":71152},{\"end\":71602,\"start\":71594},{\"end\":74320,\"start\":74313},{\"end\":74329,\"start\":74324},{\"end\":74340,\"start\":74333},{\"end\":74353,\"start\":74344},{\"end\":74365,\"start\":74357},{\"end\":74376,\"start\":74369},{\"end\":74390,\"start\":74382},{\"end\":74401,\"start\":74397},{\"end\":74417,\"start\":74405},{\"end\":74430,\"start\":74421},{\"end\":74838,\"start\":74831},{\"end\":74849,\"start\":74842},{\"end\":74861,\"start\":74853},{\"end\":75246,\"start\":75241},{\"end\":75256,\"start\":75250},{\"end\":75267,\"start\":75260},{\"end\":75282,\"start\":75271},{\"end\":75291,\"start\":75286},{\"end\":75303,\"start\":75295},{\"end\":75636,\"start\":75631},{\"end\":75650,\"start\":75640},{\"end\":75660,\"start\":75654},{\"end\":75974,\"start\":75964},{\"end\":75987,\"start\":75978},{\"end\":76006,\"start\":75991},{\"end\":76017,\"start\":76010},{\"end\":76030,\"start\":76021},{\"end\":76041,\"start\":76034},{\"end\":76053,\"start\":76048},{\"end\":76071,\"start\":76059},{\"end\":76477,\"start\":76468},{\"end\":76489,\"start\":76481},{\"end\":76501,\"start\":76493},{\"end\":76817,\"start\":76808},{\"end\":76828,\"start\":76821},{\"end\":76837,\"start\":76832},{\"end\":76850,\"start\":76841},{\"end\":77200,\"start\":77192},{\"end\":77432,\"start\":77424},{\"end\":77441,\"start\":77436},{\"end\":77451,\"start\":77445},{\"end\":77464,\"start\":77455},{\"end\":77757,\"start\":77750},{\"end\":77769,\"start\":77761},{\"end\":77781,\"start\":77773},{\"end\":78127,\"start\":78120},{\"end\":78448,\"start\":78441},{\"end\":78458,\"start\":78452},{\"end\":78476,\"start\":78464},{\"end\":78487,\"start\":78480},{\"end\":78849,\"start\":78844},{\"end\":78856,\"start\":78853},{\"end\":78863,\"start\":78860},{\"end\":79208,\"start\":79203},{\"end\":79218,\"start\":79212},{\"end\":79232,\"start\":79224},{\"end\":79243,\"start\":79238},{\"end\":79532,\"start\":79525},{\"end\":79880,\"start\":79873},{\"end\":80224,\"start\":80217},{\"end\":80234,\"start\":80228},{\"end\":80242,\"start\":80238},{\"end\":80494,\"start\":80490},{\"end\":80504,\"start\":80498},{\"end\":80512,\"start\":80508},{\"end\":80767,\"start\":80760},{\"end\":80778,\"start\":80771},{\"end\":80790,\"start\":80782},{\"end\":81106,\"start\":81100},{\"end\":81117,\"start\":81110},{\"end\":81401,\"start\":81399},{\"end\":81410,\"start\":81405},{\"end\":81654,\"start\":81649},{\"end\":81918,\"start\":81911},{\"end\":81928,\"start\":81922},{\"end\":82258,\"start\":82249},{\"end\":82268,\"start\":82262},{\"end\":82497,\"start\":82491},{\"end\":82506,\"start\":82501},{\"end\":82513,\"start\":82510},{\"end\":82800,\"start\":82794},{\"end\":83067,\"start\":83055},{\"end\":83206,\"start\":83200},{\"end\":83216,\"start\":83210},{\"end\":83470,\"start\":83466},{\"end\":84069,\"start\":84064},{\"end\":84080,\"start\":84073},{\"end\":84091,\"start\":84084},{\"end\":84100,\"start\":84095},{\"end\":84459,\"start\":84454},{\"end\":84472,\"start\":84463},{\"end\":84486,\"start\":84476},{\"end\":84495,\"start\":84490},{\"end\":84506,\"start\":84499},{\"end\":84866,\"start\":84859},{\"end\":84876,\"start\":84870},{\"end\":84888,\"start\":84880},{\"end\":85200,\"start\":85193},{\"end\":85209,\"start\":85204},{\"end\":85220,\"start\":85213},{\"end\":85229,\"start\":85224},{\"end\":85571,\"start\":85567},{\"end\":85581,\"start\":85575},{\"end\":85590,\"start\":85585},{\"end\":85600,\"start\":85594},{\"end\":85609,\"start\":85604},{\"end\":85619,\"start\":85613},{\"end\":85895,\"start\":85888},{\"end\":86402,\"start\":86392},{\"end\":86731,\"start\":86728},{\"end\":86739,\"start\":86735},{\"end\":86746,\"start\":86743},{\"end\":86756,\"start\":86752},{\"end\":86764,\"start\":86760},{\"end\":87121,\"start\":87116},{\"end\":87132,\"start\":87125},{\"end\":87142,\"start\":87136},{\"end\":87476,\"start\":87471},{\"end\":87484,\"start\":87480},{\"end\":87492,\"start\":87488},{\"end\":87498,\"start\":87496},{\"end\":87818,\"start\":87810},{\"end\":87828,\"start\":87822}]", "bib_entry": "[{\"attributes\":{\"id\":\"b0\",\"matched_paper_id\":347988},\"end\":71513,\"start\":70981},{\"attributes\":{\"id\":\"b1\"},\"end\":71806,\"start\":71515},{\"attributes\":{\"id\":\"b2\"},\"end\":72017,\"start\":71808},{\"attributes\":{\"id\":\"b3\"},\"end\":72206,\"start\":72019},{\"attributes\":{\"id\":\"b4\"},\"end\":72282,\"start\":72208},{\"attributes\":{\"id\":\"b5\"},\"end\":72444,\"start\":72284},{\"attributes\":{\"id\":\"b6\"},\"end\":72622,\"start\":72446},{\"attributes\":{\"id\":\"b7\"},\"end\":72804,\"start\":72624},{\"attributes\":{\"id\":\"b8\"},\"end\":73004,\"start\":72806},{\"attributes\":{\"id\":\"b9\"},\"end\":73430,\"start\":73006},{\"attributes\":{\"id\":\"b10\"},\"end\":73846,\"start\":73432},{\"attributes\":{\"id\":\"b11\"},\"end\":74084,\"start\":73848},{\"attributes\":{\"id\":\"b12\"},\"end\":74215,\"start\":74086},{\"attributes\":{\"id\":\"b13\"},\"end\":74763,\"start\":74217},{\"attributes\":{\"id\":\"b14\",\"matched_paper_id\":7667334},\"end\":75197,\"start\":74765},{\"attributes\":{\"id\":\"b15\",\"matched_paper_id\":49480110},\"end\":75572,\"start\":75199},{\"attributes\":{\"id\":\"b16\",\"matched_paper_id\":14570155},\"end\":75888,\"start\":75574},{\"attributes\":{\"id\":\"b17\",\"matched_paper_id\":2208832},\"end\":76382,\"start\":75890},{\"attributes\":{\"id\":\"b18\",\"matched_paper_id\":21220505},\"end\":76752,\"start\":76384},{\"attributes\":{\"id\":\"b19\",\"matched_paper_id\":7589666},\"end\":77103,\"start\":76754},{\"attributes\":{\"id\":\"b20\"},\"end\":77336,\"start\":77105},{\"attributes\":{\"id\":\"b21\"},\"end\":77683,\"start\":77338},{\"attributes\":{\"id\":\"b22\",\"matched_paper_id\":759145},\"end\":78035,\"start\":77685},{\"attributes\":{\"id\":\"b23\",\"matched_paper_id\":9886259},\"end\":78335,\"start\":78037},{\"attributes\":{\"id\":\"b24\",\"matched_paper_id\":7847705},\"end\":78763,\"start\":78337},{\"attributes\":{\"id\":\"b25\",\"matched_paper_id\":3216414},\"end\":79143,\"start\":78765},{\"attributes\":{\"id\":\"b26\",\"matched_paper_id\":10062982},\"end\":79452,\"start\":79145},{\"attributes\":{\"id\":\"b27\",\"matched_paper_id\":18222662},\"end\":79762,\"start\":79454},{\"attributes\":{\"id\":\"b28\",\"matched_paper_id\":8148849},\"end\":80147,\"start\":79764},{\"attributes\":{\"id\":\"b29\",\"matched_paper_id\":9723809},\"end\":80445,\"start\":80149},{\"attributes\":{\"doi\":\"arXiv:1808.08403\",\"id\":\"b30\"},\"end\":80658,\"start\":80447},{\"attributes\":{\"id\":\"b31\",\"matched_paper_id\":18034015},\"end\":81036,\"start\":80660},{\"attributes\":{\"id\":\"b32\",\"matched_paper_id\":14786207},\"end\":81309,\"start\":81038},{\"attributes\":{\"id\":\"b33\",\"matched_paper_id\":6925884},\"end\":81605,\"start\":81311},{\"attributes\":{\"id\":\"b34\",\"matched_paper_id\":5082932},\"end\":81837,\"start\":81607},{\"attributes\":{\"id\":\"b35\",\"matched_paper_id\":51970375},\"end\":82164,\"start\":81839},{\"attributes\":{\"id\":\"b36\",\"matched_paper_id\":9491834},\"end\":82458,\"start\":82166},{\"attributes\":{\"id\":\"b37\",\"matched_paper_id\":14656014},\"end\":82706,\"start\":82460},{\"attributes\":{\"id\":\"b38\",\"matched_paper_id\":15475583},\"end\":83027,\"start\":82708},{\"attributes\":{\"id\":\"b39\"},\"end\":83171,\"start\":83029},{\"attributes\":{\"id\":\"b40\",\"matched_paper_id\":32758288},\"end\":83389,\"start\":83173},{\"attributes\":{\"id\":\"b41\",\"matched_paper_id\":9626081},\"end\":83781,\"start\":83391},{\"attributes\":{\"id\":\"b42\",\"matched_paper_id\":16952640},\"end\":83992,\"start\":83783},{\"attributes\":{\"id\":\"b43\",\"matched_paper_id\":17458545},\"end\":84373,\"start\":83994},{\"attributes\":{\"id\":\"b44\",\"matched_paper_id\":21373578},\"end\":84813,\"start\":84375},{\"attributes\":{\"id\":\"b45\",\"matched_paper_id\":905571},\"end\":85108,\"start\":84815},{\"attributes\":{\"id\":\"b46\",\"matched_paper_id\":4648814},\"end\":85483,\"start\":85110},{\"attributes\":{\"id\":\"b47\",\"matched_paper_id\":50786713},\"end\":85853,\"start\":85485},{\"attributes\":{\"id\":\"b48\",\"matched_paper_id\":15379409},\"end\":86116,\"start\":85855},{\"attributes\":{\"id\":\"b49\"},\"end\":86314,\"start\":86118},{\"attributes\":{\"id\":\"b50\",\"matched_paper_id\":2526261},\"end\":86632,\"start\":86316},{\"attributes\":{\"id\":\"b51\",\"matched_paper_id\":8666108},\"end\":87019,\"start\":86634},{\"attributes\":{\"id\":\"b52\",\"matched_paper_id\":555580},\"end\":87417,\"start\":87021},{\"attributes\":{\"id\":\"b53\",\"matched_paper_id\":3925541},\"end\":87734,\"start\":87419},{\"attributes\":{\"id\":\"b54\",\"matched_paper_id\":13218142},\"end\":88058,\"start\":87736}]", "bib_title": "[{\"end\":71044,\"start\":70981},{\"end\":73037,\"start\":73006},{\"end\":74827,\"start\":74765},{\"end\":75237,\"start\":75199},{\"end\":75627,\"start\":75574},{\"end\":75960,\"start\":75890},{\"end\":76464,\"start\":76384},{\"end\":76804,\"start\":76754},{\"end\":77746,\"start\":77685},{\"end\":78116,\"start\":78037},{\"end\":78437,\"start\":78337},{\"end\":78840,\"start\":78765},{\"end\":79199,\"start\":79145},{\"end\":79521,\"start\":79454},{\"end\":79867,\"start\":79764},{\"end\":80213,\"start\":80149},{\"end\":80756,\"start\":80660},{\"end\":81094,\"start\":81038},{\"end\":81395,\"start\":81311},{\"end\":81645,\"start\":81607},{\"end\":81907,\"start\":81839},{\"end\":82245,\"start\":82166},{\"end\":82487,\"start\":82460},{\"end\":82788,\"start\":82708},{\"end\":83196,\"start\":83173},{\"end\":83462,\"start\":83391},{\"end\":83827,\"start\":83783},{\"end\":84060,\"start\":83994},{\"end\":84450,\"start\":84375},{\"end\":84855,\"start\":84815},{\"end\":85189,\"start\":85110},{\"end\":85563,\"start\":85485},{\"end\":85884,\"start\":85855},{\"end\":86189,\"start\":86118},{\"end\":86388,\"start\":86316},{\"end\":86724,\"start\":86634},{\"end\":87112,\"start\":87021},{\"end\":87467,\"start\":87419},{\"end\":87806,\"start\":87736}]", "bib_author": "[{\"end\":71056,\"start\":71046},{\"end\":71069,\"start\":71056},{\"end\":71082,\"start\":71069},{\"end\":71092,\"start\":71082},{\"end\":71101,\"start\":71092},{\"end\":71116,\"start\":71101},{\"end\":71128,\"start\":71116},{\"end\":71141,\"start\":71128},{\"end\":71150,\"start\":71141},{\"end\":71161,\"start\":71150},{\"end\":71604,\"start\":71592},{\"end\":74322,\"start\":74311},{\"end\":74331,\"start\":74322},{\"end\":74342,\"start\":74331},{\"end\":74355,\"start\":74342},{\"end\":74367,\"start\":74355},{\"end\":74378,\"start\":74367},{\"end\":74392,\"start\":74378},{\"end\":74403,\"start\":74392},{\"end\":74419,\"start\":74403},{\"end\":74432,\"start\":74419},{\"end\":74840,\"start\":74829},{\"end\":74851,\"start\":74840},{\"end\":74863,\"start\":74851},{\"end\":75248,\"start\":75239},{\"end\":75258,\"start\":75248},{\"end\":75269,\"start\":75258},{\"end\":75284,\"start\":75269},{\"end\":75293,\"start\":75284},{\"end\":75305,\"start\":75293},{\"end\":75638,\"start\":75629},{\"end\":75652,\"start\":75638},{\"end\":75662,\"start\":75652},{\"end\":75976,\"start\":75962},{\"end\":75989,\"start\":75976},{\"end\":76008,\"start\":75989},{\"end\":76019,\"start\":76008},{\"end\":76032,\"start\":76019},{\"end\":76043,\"start\":76032},{\"end\":76055,\"start\":76043},{\"end\":76073,\"start\":76055},{\"end\":76479,\"start\":76466},{\"end\":76491,\"start\":76479},{\"end\":76503,\"start\":76491},{\"end\":76819,\"start\":76806},{\"end\":76830,\"start\":76819},{\"end\":76839,\"start\":76830},{\"end\":76852,\"start\":76839},{\"end\":77202,\"start\":77190},{\"end\":77434,\"start\":77422},{\"end\":77443,\"start\":77434},{\"end\":77453,\"start\":77443},{\"end\":77466,\"start\":77453},{\"end\":77759,\"start\":77748},{\"end\":77771,\"start\":77759},{\"end\":77783,\"start\":77771},{\"end\":78129,\"start\":78118},{\"end\":78450,\"start\":78439},{\"end\":78460,\"start\":78450},{\"end\":78478,\"start\":78460},{\"end\":78489,\"start\":78478},{\"end\":78851,\"start\":78842},{\"end\":78858,\"start\":78851},{\"end\":78865,\"start\":78858},{\"end\":79210,\"start\":79201},{\"end\":79220,\"start\":79210},{\"end\":79234,\"start\":79220},{\"end\":79245,\"start\":79234},{\"end\":79534,\"start\":79523},{\"end\":79882,\"start\":79869},{\"end\":80226,\"start\":80215},{\"end\":80236,\"start\":80226},{\"end\":80244,\"start\":80236},{\"end\":80496,\"start\":80488},{\"end\":80506,\"start\":80496},{\"end\":80514,\"start\":80506},{\"end\":80769,\"start\":80758},{\"end\":80780,\"start\":80769},{\"end\":80792,\"start\":80780},{\"end\":81108,\"start\":81096},{\"end\":81119,\"start\":81108},{\"end\":81403,\"start\":81397},{\"end\":81412,\"start\":81403},{\"end\":81656,\"start\":81647},{\"end\":81920,\"start\":81909},{\"end\":81930,\"start\":81920},{\"end\":82260,\"start\":82247},{\"end\":82270,\"start\":82260},{\"end\":82499,\"start\":82489},{\"end\":82508,\"start\":82499},{\"end\":82515,\"start\":82508},{\"end\":82802,\"start\":82790},{\"end\":83069,\"start\":83053},{\"end\":83208,\"start\":83198},{\"end\":83218,\"start\":83208},{\"end\":83472,\"start\":83464},{\"end\":84071,\"start\":84062},{\"end\":84082,\"start\":84071},{\"end\":84093,\"start\":84082},{\"end\":84102,\"start\":84093},{\"end\":84461,\"start\":84452},{\"end\":84474,\"start\":84461},{\"end\":84488,\"start\":84474},{\"end\":84497,\"start\":84488},{\"end\":84508,\"start\":84497},{\"end\":84868,\"start\":84857},{\"end\":84878,\"start\":84868},{\"end\":84890,\"start\":84878},{\"end\":85202,\"start\":85191},{\"end\":85211,\"start\":85202},{\"end\":85222,\"start\":85211},{\"end\":85231,\"start\":85222},{\"end\":85573,\"start\":85565},{\"end\":85583,\"start\":85573},{\"end\":85592,\"start\":85583},{\"end\":85602,\"start\":85592},{\"end\":85611,\"start\":85602},{\"end\":85621,\"start\":85611},{\"end\":85897,\"start\":85886},{\"end\":86404,\"start\":86390},{\"end\":86733,\"start\":86726},{\"end\":86741,\"start\":86733},{\"end\":86748,\"start\":86741},{\"end\":86758,\"start\":86748},{\"end\":86766,\"start\":86758},{\"end\":87123,\"start\":87114},{\"end\":87134,\"start\":87123},{\"end\":87144,\"start\":87134},{\"end\":87478,\"start\":87469},{\"end\":87486,\"start\":87478},{\"end\":87494,\"start\":87486},{\"end\":87500,\"start\":87494},{\"end\":87820,\"start\":87808},{\"end\":87830,\"start\":87820}]", "bib_venue": "[{\"end\":71222,\"start\":71161},{\"end\":71590,\"start\":71515},{\"end\":71847,\"start\":71808},{\"end\":72053,\"start\":72019},{\"end\":72220,\"start\":72208},{\"end\":72307,\"start\":72284},{\"end\":72477,\"start\":72446},{\"end\":72655,\"start\":72624},{\"end\":72848,\"start\":72806},{\"end\":73083,\"start\":73039},{\"end\":73497,\"start\":73432},{\"end\":73888,\"start\":73848},{\"end\":74111,\"start\":74088},{\"end\":74309,\"start\":74217},{\"end\":74956,\"start\":74863},{\"end\":75366,\"start\":75305},{\"end\":75707,\"start\":75662},{\"end\":76111,\"start\":76073},{\"end\":76546,\"start\":76503},{\"end\":76906,\"start\":76852},{\"end\":77188,\"start\":77105},{\"end\":77420,\"start\":77338},{\"end\":77836,\"start\":77783},{\"end\":78167,\"start\":78129},{\"end\":78527,\"start\":78489},{\"end\":78931,\"start\":78865},{\"end\":79275,\"start\":79245},{\"end\":79585,\"start\":79534},{\"end\":79936,\"start\":79882},{\"end\":80272,\"start\":80244},{\"end\":80486,\"start\":80447},{\"end\":80820,\"start\":80792},{\"end\":81147,\"start\":81119},{\"end\":81432,\"start\":81412},{\"end\":81702,\"start\":81656},{\"end\":81980,\"start\":81930},{\"end\":82295,\"start\":82270},{\"end\":82557,\"start\":82515},{\"end\":82844,\"start\":82802},{\"end\":83051,\"start\":83029},{\"end\":83256,\"start\":83218},{\"end\":83563,\"start\":83472},{\"end\":83867,\"start\":83829},{\"end\":84157,\"start\":84102},{\"end\":84566,\"start\":84508},{\"end\":84951,\"start\":84890},{\"end\":85275,\"start\":85231},{\"end\":85657,\"start\":85621},{\"end\":85962,\"start\":85897},{\"end\":86194,\"start\":86191},{\"end\":86451,\"start\":86404},{\"end\":86800,\"start\":86766},{\"end\":87198,\"start\":87144},{\"end\":87559,\"start\":87500},{\"end\":87875,\"start\":87830}]"}}}, "year": 2023, "month": 12, "day": 17}