{"id": 246531628, "updated": "2022-10-17 23:17:04.972", "metadata": {"title": "GrapHD: Graph-Based Hyperdimensional Memorization for Brain-Like Cognitive Learning", "authors": "[{\"first\":\"Prathyush\",\"last\":\"Poduval\",\"middle\":[]},{\"first\":\"Haleh\",\"last\":\"Alimohamadi\",\"middle\":[]},{\"first\":\"Ali\",\"last\":\"Zakeri\",\"middle\":[]},{\"first\":\"Farhad\",\"last\":\"Imani\",\"middle\":[]},{\"first\":\"M.\",\"last\":\"Najafi\",\"middle\":[\"Hassan\"]},{\"first\":\"Tony\",\"last\":\"Givargis\",\"middle\":[]},{\"first\":\"Mohsen\",\"last\":\"Imani\",\"middle\":[]}]", "venue": "Frontiers in Neuroscience", "journal": "Frontiers in Neuroscience", "publication_date": {"year": 2022, "month": null, "day": null}, "abstract": "Memorization is an essential functionality that enables today's machine learning algorithms to provide a high quality of learning and reasoning for each prediction. Memorization gives algorithms prior knowledge to keep the context and define confidence for their decision. Unfortunately, the existing deep learning algorithms have a weak and nontransparent notion of memorization. Brain-inspired HyperDimensional Computing (HDC) is introduced as a model of human memory. Therefore, it mimics several important functionalities of the brain memory by operating with a vector that is computationally tractable and mathematically rigorous in describing human cognition. In this manuscript, we introduce a brain-inspired system that represents HDC memorization capability over a graph of relations. We propose GrapHD, hyperdimensional memorization that represents graph-based information in high-dimensional space. GrapHD defines an encoding method representing complex graph structure while supporting both weighted and unweighted graphs. Our encoder spreads the information of all nodes and edges across into a full holistic representation so that no component is more responsible for storing any piece of information than another. Then, GrapHD defines several important cognitive functionalities over the encoded memory graph. These operations include memory reconstruction, information retrieval, graph matching, and shortest path. Our extensive evaluation shows that GrapHD: (1) significantly enhances learning capability by giving the notion of short/long term memorization to learning algorithms, (2) enables cognitive computing and reasoning over memorization graph, and (3) enables holographic brain-like computation with substantial robustness to noise and failure.", "fields_of_study": "[\"Medicine\"]", "external_ids": {"arxiv": null, "mag": null, "acl": null, "pubmed": "35185456", "pubmedcentral": "8855686", "dblp": null, "doi": "10.3389/fnins.2022.757125"}}, "content": {"source": {"pdf_hash": "db46a0b25b7828addd70e4844be61a621584a991", "pdf_src": "Frontier", "pdf_uri": null, "oa_url_match": false, "oa_info": {"license": "CCBY", "open_access_url": "https://www.frontiersin.org/articles/10.3389/fnins.2022.757125/pdf", "status": "GOLD"}}, "grobid": {"id": "9eed5f4aec80ab6cc725ea57913d31b87e8a15b8", "type": "plain-text", "url": "s3://ai2-s2-pdf-extraction-prod/parse-results/s2orc_worker/db46a0b25b7828addd70e4844be61a621584a991.txt", "contents": "\nGrapHD: Graph-Based Hyperdimensional Memorization for Brain-Like Cognitive Learning\nFebruary 2022\n\nMostafa Rahimi Azghadi \nHaitong Li \nKeshab K Parhi \nPrathyush Poduval \nIndian Institute of Science\nBangaloreIndia\n\nHaleh Alimohamadi \nDepartment of Bioengineering\nUniversity of California\nLos Angeles, Los AngelesCAUnited States\n\nAli Zakeri \nDepartment of Computer Science\nUniversity of California\nIrvine, IrvineCAUnited States\n\nFarhad Imani \nDepartment of Mechanical Engineering\nUniversity of Connecticut\nStorrsCTUnited States\n\nM Hassan Najafi \nSchool of Computing and Informatics\nUniversity of Louisiana\nLafayetteLAUnited States\n\nTony Givargis \nDepartment of Computer Science\nUniversity of California\nIrvine, IrvineCAUnited States\n\nMohsen Imani m.imani@uci.edu \nDepartment of Computer Science\nUniversity of California\nIrvine, IrvineCAUnited States\n\n\nJames Cook University\nAustralia\n\n\nStanford University\nUnited States\n\n\nMohsen Imani\nUniversity of Minnesota Twin Cities\nUnited States\n\nGrapHD: Graph-Based Hyperdimensional Memorization for Brain-Like Cognitive Learning\n\nFrontiers in Neuroscience | www.frontiersin.org\n1757125February 202210.3389/fnins.2022.757125Received: 11 August 2021 Accepted: 03 January 2022ORIGINAL RESEARCH Edited by: Reviewed by: *Correspondence: Specialty section: This article was submitted to Neuromorphic Engineering, a section of the journal Frontiers in Neuroscience Citation: Poduval P, Alimohamadi H, Zakeri A, Imani F, Najafi MH, Givargis T and Imani M (2022) GrapHD: Graph-Based Hyperdimensional Memorization for Brain-Like Cognitive Learning. Front. Neurosci. 16:757125.brain-inspired computinghyperdimensional computing (HDC)neuromorphic computingmachine leaningmemorization\nMemorization is an essential functionality that enables today's machine learning algorithms to provide a high quality of learning and reasoning for each prediction. Memorization gives algorithms prior knowledge to keep the context and define confidence for their decision. Unfortunately, the existing deep learning algorithms have a weak and nontransparent notion of memorization. Brain-inspired HyperDimensional Computing (HDC) is introduced as a model of human memory. Therefore, it mimics several important functionalities of the brain memory by operating with a vector that is computationally tractable and mathematically rigorous in describing human cognition. In this manuscript, we introduce a brain-inspired system that represents HDC memorization capability over a graph of relations. We propose GrapHD, hyperdimensional memorization that represents graph-based information in high-dimensional space. GrapHD defines an encoding method representing complex graph structure while supporting both weighted and unweighted graphs. Our encoder spreads the information of all nodes and edges across into a full holistic representation so that no component is more responsible for storing any piece of information than another. Then, GrapHD defines several important cognitive functionalities over the encoded memory graph. These operations include memory reconstruction, information retrieval, graph matching, and shortest path. Our extensive evaluation shows that GrapHD:(1) significantly enhances learning capability by giving the notion of short/long term memorization to learning algorithms, (2) enables cognitive computing and reasoning over memorization graph, and (3) enables holographic brain-like computation with substantial robustness to noise and failure.\n\nINTRODUCTION\n\nWe face increasing needs for efficient processing for diverse cognitive tasks using a vast volume of generated data (Bonomi et al., 2012;Chen and Lin, 2014). Therefore, there is a crucial need for scalable algorithms to learn and reason about each prediction on today's embedded devices. Particularly, memorization is an essential functionality that enables today's algorithms to provide a higher quality of learning and reason for each prediction or decision. Memorization gives learning and information processing algorithms prior knowledge to keep the context and define confidence. Unfortunately, existing deep learning algorithms have a weak and nontransparent notion of memorization. Although Recurrent Neural Network (RNNs) and Long Short-Term Memory networks (LSTMs) incorporate memorization, they are very difficult to train and still not fully transparent to explore on prior knowledge (Pascanu et al., 2013;Sodhani et al., 2020).\n\nThere are also other crucial challenges with existing memorization techniques. Running algorithms that incorporate memorization (e.g., RNNs and LSTMs) often results in extremely slow processing speed and high energy consumption or needs a large cluster of application-specific integrated chips (ASIC), e.g., deep learning on Google TPU (Jouppi et al., 2017). This computation complexity is beyond the capability of resourceconstraint embedded devices. In addition, edge devices often rely on unreliable battery-based sources, fault-tolerant memory and logics, and noisy wireless communication (Van Kranenburg and Bassi, 2012;Lee and Lee, 2015). Unfortunately, today's algorithms require high precision training and have almost no robustness to such noise and failure. For example, the existing RNNs and LSTMs require high-precision floating-point representation to train (Courbariaux et al., 2014;Micikevicius et al., 2017). This makes these algorithms highly sensitive to possible noise or failure.\n\nRecently, HyperDimensional Computing (HDC) has been introduced as an alternative computational model that mimics important brain functionalities toward high-efficiency and noisetolerant computation (Kanerva, 2009). Unlike deep learning, HDC is a model of the Cerebellum cortex that biologically represents human memory. HDC is motivated by the observation that the cerebellum cortex operates on high-dimensional data representations . In HDC, objects are thereby encoded with high-dimensional vectors, called hypervectors, which have thousands of elements (Rahimi et al., 2016b;Imani et al., 2017aImani et al., , 2019b. HDC incorporates learning capability along with typical memory functions of storing/loading information. It mimics several important functionalities of the human memory model with vector operations which are computationally tractable and mathematically rigorous in describing human cognition. The natural memorization capability enables HDC to provide several advantages as compared to the conventional deep learning solutions: (1) HDC is suitable for on-device learning based on hardware acceleration due to its highly parallel nature (Li et al., 2016;Imani et al., 2017b;Hern\u00e1ndez-Cano et al., 2021b), (2) hidden features of information can be well-exposed, thereby empowering both training and inference with the lightweight computation and a small number of iterations (Rahimi et al., 2016a;Mitrokhin et al., 2019), and (3) the hypervector representation inherently exhibits strong robustness against the noise and corrupted data (Imani et al., 2017b;Frady and Sommer, 2019;Frady et al., 2020).\n\nHDC has been employed as a part of many applications, including genomics Poduval et al., 2021a), signal processing (Karunaratne et al., 2021), robotics (Mitrokhin et al., 2019;Neubert et al., 2019), and sensor fusion (R\u00e4s\u00e4nen and Saarinen, 2015), manufacturing (Chen et al., 2021), and detection/recognition tasks (Genssler and Amrouch, 2021). Although HDC is a memory model, existing algorithms do not well exploit HDC memorization capability. For example, in all existing HDC algorithms, memorization has a weak definition of information accumulation. However, as has been shown by neuroscientists, the brain has a more complex definition (O'reilly and Munakata, 2000;Hassabis et al., 2017;Chai et al., 2018). Our brain naturally clusters data and represents information as a graph structure, where objects and edges show the correlation between objects (Wiecki et al., 2015;Bassett and Sporns, 2017). Over time, these memory graphs get larger and more complex while the brain automatically forgets or approximates old information (Chien and Honey, 2020). In addition, the brain has a highly approximate but ultra-fast mechanism to retrieve information (Schacter and Slotnick, 2004). Although we can implement and represent a graph using existing database and graph processing systems (Lumsdaine et al., 2007;Sahu et al., 2017), such a system will be highly complex, costly, non-scalable, and far from biological systems.\n\nPrior research works have already attempted to use vector symbolic architecture and hyperdimensional computing to represent and process graph knowledge. Work in Gayler (1998) exploited hyperdimensional computing for graph representation. This method is designed specifically for graph isomorphism and cannot support complex information extraction from graph representation. Work in Ma et al. (2018) used holographic reduced representation (HRR) to map graphs into highdimensional space. However, this approach relies on external learning algorithms, i.e., neural networks, to extract knowledge from the graph. As a result, the HRR encoding mainly acts as a latent space encoding rather than a memory to store graph information. Another existing direction focused on finding a graph embedding in real vector space (Nickel et al., 2016). By characterizing the similarity of the nodes using some loss function, the dot product between vectors is proportional to the similarity, which can be used for knowledge learning. However, this approach is quite costly as it requires gradient descent. In addition, it is not suitable for graph memorization.\n\nThis paper defines a brain-inspired system that better represents HDC memorization capability. We introduce, GrapHD, a graph-based hyperdimensional system that encodes graphs into high-dimensional space and enables reasoning on that graph. We use high-dimensional vectors to holographically represent the nodes and memorize the graph. GrapHD enables several cognitive functionalities to operate over compressed encoded graph directly. The main contributions of the paper are listed as follow:\n\n\u2022 GrapHD defines an encoding method that represents complex graph-based data structure into high-dimensional space.\n\nGrapHD supports a wide range of memory graphs, including weighted and unweighted graphs. Our encoder spreads the information of all nodes and edges across into a full holistic representation so that no component is more responsible for storing any piece of information than another. This brainlike holographic representation enables us to define highly efficient and robust cognitive operations over the encoded graph without accessing original data. \u2022 Using this memorization model, we introduce an inference process that can be used to recover the graph information from graph hypervector. Our reconstruction process is iterative in nature and relies on noise prediction and cancellation. GrapHD defines several important cognitive functionalities over the encoded memory graph. These operations include memory reconstruction, information retrieval, graph matching, and shortest path. \u2022 We propose the idea of graph refinement that increases the capacity of memorization. Inspired by human memorization, refinement iteratively checks and strengthens the already known knowledge. This ensures that the known information, e.g., graph nodes and their connections, is well memorized.\n\nWe design a statistical model that mathematically defines the capacity of a hypervector to perform the tasks mentioned earlier.\n\n\u2022 We also develop an in-memory architecture that operates as a tensor processor to accelerate GrapHD computation. Our architecture supports row-parallel NOR-based operation over binary vectors stored in non-volatile memory. Then, we extend it to enable complex operations and accelerate various GrapHD applications.\n\nWe evaluate GrapHD on a wide range of applications. Our evaluation shows that GrapHD memorization capability not only enhances the reasoning capability of existing machine learning systems but also improves the learning accuracy. For example, we offer GrapHD application to enhance the existing CNN model for the object detection task. Our results show that GrapHD achieves 3.8\u00d7 faster training and 1.7\u00d7 faster inference than RNN, while ensuring the same classification accuracy. Our evaluation also shows that our in-memory accelerator achieves 30.4\u00d7 faster and 61.5\u00d7 higher energy efficiency as compared to NVIDIA 1080 GPU. We also run GrapHD operations with the Nengo SPA module (Bekolay et al., 2014) to simulate how GrapHD can be adapted for Neuromorphic hardware, and use it to run our novel error correcting decoding process. This provides feasibility for GrapHD model to be used as the encoding for Neuromorphic models of the brain. An example where this can be used is SPAUN (Stewart et al., 2012), which is a spiking neural network which can perform multiple tasks without requiring re-wiring. SPAUN encodes the query information using Semantic Pointer Architecture which is then fed into the neural network, and GrapHD can be used as the encoder to better memorize relationships and correlations thus expanding the cognitive abilities of SPAUN.\n\nA few examples where a graph representation is natural is analyzing relationships in social media and knowledge graph representations (Pitas, 2016;Bi et al., 2019;Chian et al., 2021). Our model can also be used in graph constructions, where the Spiking Neural Network is supposed to construct graph representations of data, or to construct certain sub-graphs and clusters of an input graph based on certain rules and correlations.\n\n\nPRELIMINARY\n\nHyperdimensional Computing: The brain's circuits are massive in terms of numbers of neurons and synapses, suggesting that large circuits are fundamental to the brain's computing. Hyperdimensional computing (HDC) (Kanerva, 2009) explores this idea by looking at computing with ultra-wide words-that is, with very high-dimensional vectors or hypervectors. The fundamental units of computation in HDC are high dimensional representations of data known as \"hypervectors, \" which are constructed from raw signals using an encoding procedure. There exist a huge number of different, nearly orthogonal hypervectors with the dimensionality in the thousands (Kanerva, 1998;Ge and Parhi, 2020). This lets us combine such hypervectors into a new hypervector using well-defined vector space operations while keeping the information of the two with high probability. Hypervectors are holographic and (pseudo) random with i.i.d. components. A hypervector contains all the information combined and spread across all its components in a full holistic representation so that no element is more responsible for storing any piece of information than another. In recent years, HDC or in general vector symbolic architecture has been employed in a range of applications, such as classification (Kanerva et al., 2000;Ge and Parhi, 2020;Zou et al., 2021b), activity recognition (Kim et al., 2018), biomedical signal processing (Moin et al., 2021), multimodal sensor fusion (R\u00e4s\u00e4nen and Saarinen, 2015), distributed sensors (Kleyko and Osipov, 2014;Kleyko et al., 2018), voice recognition (Imani et al., 2017a), genomics Poduval et al., 2021a), regression (Hern\u00e1ndez-Cano et al., 2021a), and privacy (H\u00e9rnandez-Cano et al., 2021). For example, work in Simpkin et al. (2017) used vector symbolic architecture for representing and orchestrating complex decentralized workflows. Work in Rallapalli et al. (2019) developed a novel embedding mechanism for single graph nodes that co-learns graph structure and textual descriptions. A key HDC advantage is its training capability in one or few shots, where object categories are learned from one or few examples and in a single pass over the training data instead of many iterations. HDC has achieved comparable to higher accuracy compared to support vector machines (SVMs) Imani et al., 2019b), gradient boosting (Imani et al., 2019c), and convolutional neural networks (CNNs) (Mitrokhin et al., 2019), as well as lower execution energy on embedded processors, compared to SVMs (Montagna et al., 2018), CNNs and long short-term memory (Imani et al., 2019b).\n\nHolographic Graph Representation: There are existing research works focused on high-dimensional and holographic graph representation. Work in Gayler and Levy (2009) represented graphs in an HDC model by binding together vertices to represent edges and adding the vectors together. However, they specified only a single graph isomorphism problem that can be solved using their model, without specifying how their model can be generalized to solve additional problems. On the other hand, our model provides an end-to-end framework to perform various operations and problems that can be solved purely using HDC operations. Moreover, we also provide a novel method to recover the bundled information that is stored in the graph memory. This method uses the iterative noise canceling method, where the results at one iteration are used to guess the noise in the next iteration. Additionally, we also discuss a memory refinement process that can be used to expand the capacity of our hypervectors.\n\nWork in Ma et al. (2018) used holographic reduced representation to map nodes into high-dimensional space. This mapping, which is based on HRR, aims to learn graph as latent space; thus, it does not explicitly memorize the graph. The inference process is done using a 2-layered neural network. As a result, this representation relies on a neural network and is primarily suited for learning. In contrast, in our method, the learning, inference, and memorization tasks can be performed using native HDC operations. This makes our architecture robust, efficient, and scalable and enables us to retrieve desired information more transparently.\n\nWork in Nickel et al. (2016) introduced a method to find an embedding of a graph in a vector space. A graph embedding is usually a learning process to find vector representations of graphs such that the vectors representing two nodes are correlated based on the nodes' similarity within the graph. This representation is obtained using the gradient descent method, which is computationally costly. In addition, the vector generated as graph representation has very low dimensionality, e.g., D = 150. In contrast, we define it entirely differently as we do not find a graph embedding. Our solution chooses random hypervectors to represent each node and uses them to build up graph memory. Our model is able to represent information and perform cognitive and inference operations using orthogonality of random hypervectors. We only perform the tasks and decoding using native HDC operations like bundling, binding, and similarity search.\n\n\nHyperdimensional Primitives\n\nLet us assume H 1 , H 2 are two randomly generated hypervectors ( H \u2208 {\u22121, +1} D ) and \u03b4( H 1 , H 2 ) \u2248 0 (\u03b4 is similarity metric defined below).\n\nBinding ( * ) of two hypervectors H 1 and H 2 is done by component-wise multiplication (XOR in binary) and denoted as H 1 * H 2 . The result of the operation is new hypervector that is dissimilar to its constituent vectors i.e., \u03b4( H 1 * H 2 , H 1 ) \u2248 0; thus binding is well suited for associating two hypervectors. Binding is used for variable-value association and, more generally, for mapping.\n\nBundling (+) operation is done via component-wise addition of hypervectors, denoted as H 1 + H 2 . The bundling is a memorization function that keeps the information of input data into a bundled vector. The bundled hypervectors preserves similarity to its component hypervectors, i.e., \u03b4( H 1 + H 2 , H 1 ) >> 0. Hence, the majority function is well suited for representing sets. Note that the vector that we get after bundling will have integer components, and will be an element of Z D in general. We do not clip the values of the components back to \u00b11.\n\nPermutation (\u03c1) operation, \u03c1( H), shuffles components of H with a random permutation of the D components of the hypervector, with \u03c1 p defined as \u03c1 applied p times. The intriguing property of the permutation is that it creates a near-orthogonal and reversible hypervector to H, i.e., \u03b4(\u03c1 p ( H), H) \u2243 0 when p = 0 and \u03c1 \u2212p (\u03c1 p ( H)) = H. Thus, we can use it to represent sequences and orders.\n\nReasoning is done by measuring the similarity of hypervectors. We denote the similarity with \u03b4( H 1 , H 2 ) = H 1 \u00b7 H 2 /D, where H 1 and H 2 are two hypervectors, and \u00b7 denotes the dot product.\n\n\nMotivation and Overview\n\nAs neuroscientists have already shown, the human brain memorizes events as a sparse memory graph (Reijneveld et al., 2007;George, 2008;Tijms et al., 2013), where nodes are the objects/events, and the edges represent the correlation between them. The brain does reasoning and analogy by referring to this memory as prior knowledge. For example, as humans, when we see a set of events or objects repeatedly occurring together, these objects get a higher correlation in our graph memory. By referring to this memory, we can identify the correlated objects, make better decisions, and reason about them.\n\nAlthough building up this graph is often easy, the main challenges are: (1) how to effectively represent this graph to enable highly efficient and robust brain-like memorization, and (2) how to perform information retrieval and reasoning on such representation. Unlike the existing graph processing algorithms that perform costly exact computations, brain memorization and cognitive computation are highly approximate and efficient.\n\nIn this paper, we propose GrapHD, a hyperdimensional graph memory that enables robust, efficient, and holographic cognitive learning. Figure 1 shows an overview of GrapHD. GrapHD encodes various graph data into high-dimensional space ( Figure 1A). The encoding is based on a well-defined set of mathematics introduced in Section 2.1. Our encoding represents a graph using a single hypervector, where each dimension represents a neuron. GrapHD enables a wide range of cognitive operations directly over the graph hypervector ( Figure 1B). These cognitive operations extract information from the graph without explicit access to original nodes. We exploit these functionalities to enable several applications, including graph matching, shortest path, and object detection ( Figure 1C).\n\n\nHYPERDIMENSIONAL GRAPH REPRESENTATION\n\nIn this section, we explain how to represent graph structure in high-dimensional space. We exploit hyperdimensional mathematics, introduced in Section 2.1, to spread the graph information across the fully holistic high-dimensional representation. In this representation, no hypervector element is more responsible for storing any piece of information than another. Here, we explain how GrapHD encodes both weighted and unweighted graphs. Figure 2 shows the functionality of GrapHD encoding representing unweighted graphs. We first assign a random hypervector H i to each node in the graph (Figure 2A). Assuming a graph with V nodes and E edges, we generate\n\n\nUnweighted Undirected Graphs\n{ H 1 , H 2 , \u00b7 \u00b7 \u00b7 , H V } as high-dimensional signature of nodes,\nwhere H i is a D\u2212dimensional hypervector whose components are randomly chosen from the set {\u22121, +1}. Due to random generation, the node hypervectors are nearly orthogonal:\n\u03b4( H k , H l ) \u2243 0 (k = l),\nwhere \u03b4 denotes the similarity defined in Section 2.1. This non-zero similarity is the noise in our model which can result in misprediction. The role of noise in our model is further elaborated in Section 4.1.\n\nWe exploit the node hypervectors to create a memory for each node. The node memory needs to remember all connections that a particular node has to its neighbors ( Figure 2B). For example, we construct the node i memory by accumulating all node hypervectors connected to it: M i = j H j , where j represents all the neighbors of node i. Thanks to HDC mathematics, the bundling keeps the information of all connections. For example, we can check if memory node i has connection to node k using: \u03b4( M i , H k ), where \u03b4 \u226b 0 and \u03b4 \u2243 0 show existence and non-existence, respectively. This is explained in Section 4.1 in detail.\n\nAfter generating a memory for each node, we construct a single hypervector representing a graph. The graph memory should memorize the information of nodes and their connections. To this end, for each node, we associate the node and memory hypervectors, e.g., H i * M i for node i. The bundling of all associated hypervectors generates a graph memory ( Figure 2C):\nG = 1 2 H 1 * M 1 + H 2 * M 2 + \u00b7 \u00b7 \u00b7 + H V * M V = 1 2 V i=1 H i * M i\nwhere the graph memory is a compressed, invertible, and transparent model. Note that we have introduced a factor of 1 2 because if we expand the node memory, then H i * H j and H j * H i will be counted twice. Given the graph memory G, we can reconstruct a local node memory using:\nH i * G = M i + noise \u2248 M i\nwhere this approximate equality holds true because the HD vectors are randomly constructed; thus, they are nearly orthogonal. Once we have the node memory, we can check if nodes j and i are connected by calculating the similarity R = \u03b4( H j , M i ), where R is termed as the decision score. If there exists an edge between i and j, then R \u223c 1. Otherwise, R \u223c 0.\n\n\nUnweighted, Directed Graphs\n\nWe use a similar encoding method as an undirected graph to build up each memory node. Since the graph is directed, each memory only bundles the connections out of the node. These memory nodes need to be combined to represent a graph. Unlike a undirected graph, the memory needs to preserve the sequence that nodes are connected together. Therefore, we construct the graph memory as:\nG = n i H i * \u03c1 M i ,\nwhere \u03c1 is a permutation that permutes the node memory once, which is used to preserve the order of association. The edge between i and j is not treated the same as the edge between j and i because the permutation makes the binding a non-commutative operation. Therefore, compared to undirected graphs, there is no factor 1 2 to construct the graph memory for directed graphs.\n\n\nWeighted Graphs\n\nIn weighted graphs, the connection between nodes is represented using real values. To ensure holographic representation, our encoding needs to first represent those weights into hypervectors. Figure 3 shows GrapHD encoding for a node memory. Let us assume all weights in graph are normalized values [0, 1). we exploit stochastic representation to construct the vectors V a for a real number a \u2208 [0, 1). We generate V 1 as a random hypervector representing a value 1 and exploit that to generate weight hypervectors. For example, we generate V a by randomly choosing (1 \u2212 a) \u00d7 D dimensions of V 1 , and multiplying them by  \u22121. We define this evaluation of V a as:\nf ( V a ) = \u03b4( V a , V 1 )+1 2 = a,\nwhere the final equality follows from the definition of V a . Although the randomness of weight hypervectors affects the robustness, the randomness makes this method undesirable when we look at the iterative method of decoding the node memory.\n\nThe key problem is that slightly different values a will result in completely orthogonal vectors, which will eventually take up a lot of capacity. To avoid the above drawbacks, we generate V a by flipping the components from (a \u00d7 D) th to the D th component of V 1 . We note that we round a \u00d7 D to the closest integer ( Figure 3B). The evaluation function remains the same and provides the same result as before. This encoding is purely deterministic with respect to the weight value. Moreover, nearby values will generate correlated orthogonal vectors. As a result, we do not lose the capacity here and can represent a large set of weights.\n\nUsing stochastic weight representation, we can construct the node memory using M i = j V w ij * H j ( Figure 3C). In this manner, we can store the weights in a holographic way such that the values of the weights do not bias the encoding. This is purely done using an end-to-end compatible HD framework.\n\n\nGraph Memory Refinement\n\nThe brain is weak in one-pass memorization, as we often need multiple reviews of the same document to memorize the details. HDC also may not memorize every detail of a graph by singletime encoding and memorization (Gallistel and King, 2011;Ji et al., 2020). To ensure the information is well-memorized, HDC should look at a graph iteratively and strengthen nodes' information and connection. We name this process as memory refinement. In HDC, the model memorizes connections between nodes by bundling together hypervectors that represent different edges. However, these hypervectors are not perfectly orthogonal with each other. As a result, during the decision process, when the model calculates the similarity of a connection with the memory, the noise from the different connections can accumulate. This can lead to two possibilities: (1) the similarity of an existing node goes below a decision threshold, and (2) the similarity of a nonexisting node goes above the threshold. These possibilities can result in misprediction of the connection.\n\nThe problem is that given a node vector i, we need to recognize which other nodes have vertices to node i. In other words, we need to check which memory nodes include the node i hypervector. This can be done by calculating the similarity of all memory nodes with node i hypervector:\nR ij = \u03b4 M j , H i\nwhere, R ij is called the decision score. As described in Section 4.1, if R ij is greater than T (called a decision threshold), then we conclude that H i exists in M j . Our expectation is that all local memories which include node i should get a higher similarity than a threshold (R > T). The refinement procedure is done in multiple iterations. In each iteration, we chose a node i with node hypervector H i . Then, we go through the local memories of all the nodes j and perform the following update procedure\nM j \u2192 M j + H i If R ij < T but j and i share an edge M j \u2192 M j \u2212 H i If R ij > T but j and i do not share an edge\nBy this operation, we aim to strengthen the memory of the connections that are weakly memorized. However, refinement may result in some other connections being mispredicted. To prevent this, we perform memory refinement in an iterative manner until we converge into a final memory model. Note that the refined memory is an integer component hypervector.\n\nRefinement is a process that is used in almost all other HD problems too, and is more commonly called Retraining. Almost all HD models require retraining to make them stronger in memory. Usually, retraining is implemented in models that use association search, where we match a query with multiple classes (For example, in classification tasks). Then, we subtract the query from the class with which it does not belong (with a factor proportional to similarity) and we add the query to the class with which it belongs if the similarity is not high enough. This results in a large separation between the similarity of the matching classes and mismatching classes with a query, which is the aim.\n\nHowever, GraphHD uses a thresholding-based method to check if an node or edge exists (Based on Section 4.1 and 4.3, respectively) in the graph memory. For this, we need an alternative way of refinement which is different from the retraining used in the traditional context. This is why in our model we subtract or add the edge vector pairs to the graph memory based on whether the similarity is above or below the threshold, as described in the previous paragraph. Our aim here is not to differentiate between the classes, but to separate the signal distribution from the noise.\n\nIn Section 6.2, we show the impact of the memory refinement on increasing the hypervector capacity to memorize larger graphs.\n\n\nALGORITHMS WITH GraphHD REPRESENTATION\n\nWe perform several important cognitive functionalities over the memory graph to extract information or reason based on that.\n\nWe discuss a few key capabilities which have a wide range of applications in robotic, genomics, signal processing, and machine learning. All tasks can be directly implemented over a single graph memory hypervector without storing original nodes or their connection. In other words, we will show how a single graph hypervector can answer several cognitive questions in a fast and efficient way. In the following, we demonstrate the algorithms only for an undirected unweighted graphs. However, the algorithms described can be extended to directed and weighted graphs without much difficulty. For directed graphs, we would have an additional step of applying an inverse permutation when reconstructing the node memory from graph memory, and using the permutation while checking existence of edge inside the graph memory. For the weighted graphs, we need to recover the weight of the edge using the similarity search, and then define a reasonable threshold for the similarity above which we can confidently conclude the edge actually exists inside the graph (and that the measure similarity is not the noise). We generate graphs randomly by first considering a fully connected graphs, and then deleting a random but uniformly chosen set of edges.\n\n\nInformation Retrieval\n\nThe main objective of information retrieval is to extract information about the edges connected to a node and the information associated with each node. We devise a statistical framework to study the errors and data recovery. Given the graph memory G, we can use this to reconstruct the node memory. Using the node memory, we run inference to find the two main quantities-the nodes that share an edge with the current node and the information that has been associated with the current node via binding.\n\nFirst, we consider the task of identifying whether a node A is connected to node B given the node memory M A . The node memory can be written as\nM A = d A i=1 H i ,\nwhere H i is the hypervectors of all the nodes connected to A and d A is the degree of the node A. If the hypervector of node B is given by H B , then we calculate the decision score R given by:\nR = \u03b4( M A , H B ) = d A i=1,i =B \u03b4( H i , H B ) Noise + \u03b4( H B , H B ) signal (1)\nThis is for the case that the node B is connected to node A. If not, then the signal term would become part of the noise term. The similarity between two random hypervectors can be written as\n\u03b4( V 1 , V 2 ) = 1 D ( D i=1 a i )\nwhere a i are random variables with values uniformly sampled from {\u22121, +1}. As a result by the central limit theorem, 1 D ( D i=1 a i ) is a Gaussian distribution with mean 0 and standard deviation 1 \u221a D . Thus, by the central limit theorem again we get that\nN i=1 \u03b4( V i , V) \u223c N(0, N D )\nWhere V and V i are randomly chosen vectors, and N is an integer. Thus, in the case that A and B have an edge connecting them, then the decision score R follows a Gaussian N(1, (d A \u2212 1)/D) distribution. When there is no edge between A and B, then R follows a Gaussian N(0, d A D ) distribution. Using this, we can construct a theoretical Receiver operating characteristic (ROC) curve and then define a threshold value T. If R > T, then we can conclude that nodes A and B have an edge between them, and if R < T then we can conclude that there is no edge between A and B. Figure 4A shows the similarity distribution of existing patterns (blue color, called signal) and non-existing patterns (orange color, called noise) in the reference or memorized hypervector. Both signal and noise follow Gaussian distribution, where the spread is an effect of interference noise as shown in Equation 1. To identify the existence of a pattern, our goal is to put a threshold that can separate signal and noise distribution. Figure 4B shows the ROC curve indicating the impact of threshold value on true and false-positive rates. Ideally, we want the ROC curve to pass through the left-top corner, where true and false positive rates are 100 and 0%, respectively. The sharp turning point would represent the optimal scenario. However, the ROC would be less sharp if we decreased the dimensionality. For example, in D = 1k, signal and noise will have wider distribution; thus, the perfect true positive rate can only be obtained with a very high false-positive rate.\n\n\nNode Memory Reconstruction\n\nIn this section, we discuss an iterative method to recover the node memory from the graph hypervector in an error-correcting way. The main idea is to first formulate a reasonable estimation of all node memories using the unbinding procedure. Then, we find a revised estimate for all the nodes by recursively canceling out the interference noise. Figure 5 shows GrapHD functionality for node memory reconstruction. Suppose we are given the graph memory hypervector G. The first estimation of node memory i can be computed as, M (1) i ( \u2022 a ):\nH i * G = M i + j =i H i * H j \u22430 * M j(2)\nHere, we use the fact that H i * H i * M i = M i because H i is a bipolar vector. This equation gives us the first estimation of all node memories ( \u2022 b ), which is often noisy. The noise comes from the nearly orthogonal distribution of node hypervectors. Through an iterative process, we can start reducing the crossinterference noise ( \u2022 c ). In each iteration, we find an estimation of memory nodes, M j (j = i), and deduct that noise from the next estimation. For example, we can recursively construct the following vectors ( \u2022 d ):\nM (k+1) i = H i * \uf8eb \uf8ed G \u2212 j =i H j * M (k) j \uf8f6 \uf8f8 (3) = H i * G \u2212 j =i H i * H j * M (k) j(4)\nThe guess for the (k + 1) th step is constructed by first subtracting the guess from the k th step, which minimizes the error. For example, M 2 i is the revised estimate that we get from M 1 i (the first estimation) to cancel the noise. This process is repeated until we reach convergence. Section 6.4 explores the impact of different parameters on the quality of node memory reconstruction.\n\nMathematical Capacity: The accuracy of error reconstruction models depends primarily on two parameters: the number of edges of the graph, n, and the dimension of hypervectors, D.\n\nIf there are more edges in the graph, then the cross-terms can contribute a higher value of noise in the iterative reconstruction step. A way to measure the noise can be done using the Signal Noise Ratio. Suppose that each node has on average d = E/V edges connecting to it. Then the node memory of a specific node is the sum of d different neighbor vertices of that node. Consider node A, with node memory\nM A = d i=1 H v i ,\nwhere v i are all the nodes containing an edge to A. To check whether the node B has an edge with A, we calculate the similarity given by\nR = \u03b4( H B , M A ) = \u03b4( H B , H B ) Signal + v i =B \u03b4( H B , H v i ) Noise\nThe signal term is of magnitude 1, because every node vector is bipolar. Next, as we have demonstrated in Section 4.1, the noise term follows a gaussian distribution N(0, d\u22121 D ). Thus, we can define the signal to noise ratio to be SNR = 10 log 1\n(d \u2212 1)/D \u2248 5 log D d\nAs we can see, the increase of D decreases the noise, and we can decrease the noise by decreasing the average number of edges per vertices. Note that we assume the dimension D and the number of edges E are large to validate our approximation.\n\n\nGraph Reconstruction\n\nHere, we will discuss methods to reconstruct the whole graph given its memory hypervector G. There are two main paths one can take for this: (1) follow the methods in Section 4.2 and first reconstruct the local node memory, and (2) use the methods of Section 4.1 to retrieve all the edges that are connected to the node via the node memory. We observe that the first technique can come with a large error rate. This is because the reconstruction of the node memory is not a binary classification process. Since we rely on convergence, the converged value of the node memory might have various errors that can make the node memory reconstruction vulnerable to error.\n\nIn this paper, we present an iterative process to reconstruct the graph directly from the graph memory. We first define a function f (A, B) that checks the existence of an edge between nodes A and B. f (A, B) = 0 shows that there is no edge from node A to B, while f (A, B) = 1 indicates an edge. Figure 6 shows GrapHD functionality for graph memory reconstruction. In the first step, we generate a hypervector for all possible edges in the graph and initiate f (1) = 0 for all edges. Then, we consider the existence of each edge (e.g., H A * H B ) in the graph memory, G ( \u2022 a ). As we explained in Section 4.1, this existence can be Frontiers in Neuroscience | www.frontiersin.org   computed by checking the similarity of the edge hypervector with graph memory ( \u2022 b ). If the returned similarity value is larger than the threshold, we set f (1) = 1. This is the inference process as described in 4.1. We repeat this process for all the nodes of the graph, and we construct the first estimation of the graph, G (1) .\n\nOur goal is to enhance our estimation through an iterative noise cancellation method. Suppose there is an edge between A and B in f (1) (A, B), thus the noise vector is given by N (1)\nAB = G (1) \u2212 H A * H B .\nif there is no edge, the noise vector is simply N (1) AB = G (1) . In short, we can write this as ( \u2022 c ):\nN (1) AB = G (1) \u2212 f (1) (A, B)( H A * H B ) Frontiers in Neuroscience | www.frontiersin.org\nWe construct the second estimation of the graph by initializing the function f (2) (A, B) = 0, and then checking whether the edge between A and B exists in the noise-corrected memory M\u2212 N (1)\n\nAB . If the result is positive, then we modify f (2) (A, B) = 1 and repeat the process for all pairs of nodes. This process is repeated iteratively as follows. Suppose we're given the k th estimate of the graph f (k) . We initialize the graph representation f (k+1) to 0. Then we use this to generate the graph memory G (k) which corresponds to the graph f (k) (A, B). We calculate the noise for A and B as follows:\nN (k) AB = G (k) \u2212 f (k) (A, B)( H A * H B )\nWe then check whether the edge from A to B exists inside the vector G (k) \u2212 N (k)\n\nAB . If the answer is yes, we set f (k+1) (A, B) = 1 otherwise we set f (k+1) (A, B) = 0. We repeat the process until the convergence of the function f . Figure 7 shows a visual example of graph memory reconstruction during iterative noise cancellation. The results are shown for a graph with 30 nodes and 150 edges. The blue lines show the correct edges on the graph, while the red lines are edges in the actual graph but are not predicted by our graph reconstruction. Note that our method does not predict extra edges that are not a part of the graph. Our result shows that the initial graph reconstruction is approximate and cannot predict several existing edges. However, going further through iterative noise cancellation, we can get a higher accuracy by predicting more edges correctly. With 15 iterations, our technique can recover the entire graph accurately. Section 6.3 explores the impact of different parameters on GrapHD graph reconstruction.\n\n\nGraph Matching\n\nIn this section, we formulate an algorithm to match two graphs directly using the HD framework. The aim here is to estimate the number of edges that occur in both graphs between the corresponding edges. One specific assumption we make about our model is that each node serves a specific function or specific memory. For example, in a cognitive model, we might have nodes that could represent items like cat, dog, animal, and pencil. The cat, dog, and animals would have edges among each other that represent the amount of correlation between them, while the pencil vertex would not be attached to any of them due to a lack of correlation with the other three items. This assumption is required to define the problem of graph matching appropriately. In cases where the node ordering does not matter, then matching two graphs has an additional component of finding a mapping between the vertices of two graphs which maximizes a similarity metric. However, by assuming the mapping of vertices to be fixed, our problem simplifies to finding how much the edges match.\n\nSuppose we are given the graph memory M, M \u2032 of two directed unweighted graphs G and G \u2032 . Then, using the method of Section 4.2, we can find the node memory M a , M \u2032 a of node a of both the graphs G, G \u2032 , respectively. Our aim is to now compare these two graphs. To proceed, we find the difference of the node memory D a = M a \u2212 M \u2032 a of node a. Now, we note that all the nodes that are connected to node a in both the graphs cancel out.\n\nOnly the nodes that are connected to node a in exactly one of the graphs are present in the difference vector D. We can write\nD = N i=1 (\u22121) n i H i where n i = 0 if H i is connected to node a in G but not in G \u2032 , n i = 1 if H i is connected to the node in G \u2032 but not in G.\nHere, N is the number of differences in the neighborhood of the node in both the graphs. That is, the number of nodes connected to the current node in exactly one of the graphs. Now, we use a statistical method to estimate the value of N. Each component of D is a sum of N random variables which take up values 1 or \u22121. Thus, each component of D goes as 2B \u2212 N, where B is a binomial distribution with p = 0.5 and N terms. The standard deviation of a binomial distribution is given by\n\u03c3 B = Npq = \u221a N \u00d7 0.5 \u00d7 0.5 = \u221a N/2.\nWe can then use the method of moments to estimate N.\nSuppose Y = 2B \u2212 N. Then, we have Y = 2 B \u2212 N = N \u2212 N = 0. As a result, Y 2 = \u03c3 Y is the standard deviation of Y. From the properties of standard deviation, \u03c3 Y = 2\u03c3 B = \u221a N.\nThus, we can estimate N as Y 2 . In Section 6.5, we show the capability of our proposed technique to enable efficient and parallel brain-like graph matching.\n\n\nNEUROMORPHIC HARDWARE ACCELERATION\n\nGrapHD operations are highly parallel; thus, they can be accelerated on existing platforms. However, operating over long binary vectors could still be costly or non-optimized for CPU and GPU platforms. CPUs do not have enough resources for parallelism, and GPUs are more suitable for highprecision computations such as floating-point values (Halawani et al., 2021;Imani et al., 2021;Poduval et al., 2021b). To accelerate GrapHD, we develop a novel platform that naturally operates over long binary vectors. The capability of Non-Volatile Memories (NVMs) to act as both storage and a processing unit has encouraged us to use Processing In-Memory (PIM) platform for GrapHD acceleration. Since 2016, there have been several hardware accelerators for hyperdimensional computing based on processing in-memory technology. For example, work in Li et al. (2016), Imani et al. (2017b), and Imani et al. (2020) developed a novel PIM architecture accelerating associative search using content addressable memory. Work in Imani et al. (2019d) designed scalable PIM architecture to support encoding and scalable associative search. However, unlike existing hyperdimensional learning models, GrapHD is not based on association search. GrapHD performs computation using highly parallel (low-precision) arithmetic operation. This makes all existing hyperdimensional accelerators unable to accelerate GrapHD. GrapHD operations are mainly bitwise or low-precision vector-vector operations over long hypervectors. For example, binding is primarily based on XNOR operation between two vectors stored in different memory columns. \n\n\nNOR-Based In-memory Computing\n\nIn this paper, we develop DPIM that exploits the switching characteristic of memristor devices to internally perform the bitwise computation on the selected memory element without reading them out of array or using any sense amplifier. Figure 8A shows the structure of DPIM. DPIM exploits crossbar memory with single-bit NVM device and implements NOR operation in a row-parallel way among the selected memory columns (Imani et al., 2019a). In crossbar, each memristor device switches between two resistive states, R ON (low resistive state, \"1\") and R OFF (high resistive state, \"0\"), whenever the voltage across the device exceeds a threshold (Biolek et al., 2021). This property can be exploited to implement NOR gate between the memory elements (Kvatinsky et al., 2014). Figure 8A also shows the NOR functionality on a single row of a crossbar memory. To execute NOR in a row, an execution voltage, V 0 , is applied at the p terminals of the inputs devices while the p terminal of the output memristor is grounded. If one or more input memristors are in a low resistance state (storing \"1\" value), the voltage across the output device will be V 0 , resulting in switching the output device to the high resistance stage (\"0\" value). However, if all input devices are in the high resistance stage, the voltage across the output device cannot switch the output device; thus, the output device keeps \"1\" value.\n\nSince NOR is a universal logic gate, it can be used to implement other logic operations like addition and multiplication (Haj-Ali et al., 2018;Imani et al., 2019a). DPIM arithmetic operations are, in general, slower than the corresponding CMOS-based implementations. This is because memristor devices are slow in switching. However, this PIM architecture can provide significant speedup with massive parallelism. PIM can support addition and multiplications in parallel, irrespective of the number of rows. For example, to add values stored in different columns of memory, PIM takes the same amount of time to process the addition in a single row or all memory rows. Depending on the size of the operation, the computation takes a different time to execute. Let us assume the computation of k vertical vectors of N-bits with a length of l. When k \u2264 R/N \u2212 M op , the execution time of addition and multiplication can be modeled as:\nT op = (k \u2212 1) \u00d7 \u2308l/R\u2309 Crossbar Reuse \u00d7T op + w \u00d7 T D write\nwhere T op is the time of either fixed-point or floating-point arithmetic operations, R is the number of array rows, and 0 \u2264 w \u2264 N \u00d7 k is the number of write operations.\n\n\nDPIM Operations\n\nIn DPIM, at each time step, the main computation is a bitwise NOR operation between two columns of memory, storing two vectors. DPIM supports row-parallel computation, meaning that regardless of the number of rows, it takes the same amount of time to perform addition/multiplication. Figure 8B shows the functionality of DPIM performing row-parallel arithmetic operations. For any selected columns, DPIM computes a series of the NOR-based operations to implement bundling and binding. To perform computation among more than two vectors, the arithmetic operations are performing serially. For an example shown in Figure 8B, to perform arithmetic over three vectors, DPIM computes arithmetic between (A \u00b1 B), then the result is aggregated with the third vector (A \u00b1 B \u00b1 C).\n\nDPIM only supports column-wise computation; thus, it cannot perform vector-matrix multiplication entirely in a single memory block. To address this, work in Imani et al. (2019a) proposed the idea of transposed vector-matrix multiplication that enables both multiplication and accumulation to happen using column-wise operations. This approach stores multiple copies of a transposed input vector (horizontal vector) in different memory rows. However, this method is slow and requires a large amount of reserved memory; thus, eliminating high-precision computation in a DPIM block.\n\nTo enable DPIM to perform accumulation in a rowparallel way, we propose a novel technique that enables multiplication and accumulation to be performed in two different blocks (Figure 8C). DPIM performs column-wise multiplication between the input vector and the matrix stored in memory. This multiplication is performed on the original data without transposing the input vector or matrix. To enable column-wise accumulation, our method writes the transposed multiplication results on the second block. To minimize the cost of data movement, we exploit the sense amplifier to perform row-parallel/bit-serial read operation of multiplication results and write them in the pipeline on the next memory block (accumulation block). This enables fast and efficient data transfer. Finally, we compute the vector-matrix multiplication by column-wise addition of the vectors in (A \u00d7 B) T matrix. In Section 6.8, we evaluate DPIM capability in accelerating different GrapHD applications.\n\n\nAPPLICATIONS EVALUATION\n\n\nExperimental Setup\n\nGrapHD has been implemented in both software and hardware co-module. In software, we verified GrapHD functionality by implementing it using Python on CPU. To ease the deployment on parallel platforms, we integrate GrapHD with PyTorch library. We optimized the PyTorch library to more effectively work with hypervectors as a common GrapHD data structure. We evaluated the framework on NVIDIA Jetson TX2, which has a CUDA-enabled GPGPU running with low-power profiles. We measure the latency of the learning procedure and the power consumption using the NVIDIA tegrastats utility.\n\nWe evaluate GrapHD functionality on multiple cognitive and learning tasks: (1) Graph memory and node memory reconstruction, (2) graph matching that checks the similarity of graph memories, (3) shortest path between nodes to reason about the relation and closeness of two memorized objects in the graph memory. (4) context-aware learning in object detection, where GrapHD is used as external memory to keep the relation between the objects occurring in different video frames.\n\nFor circuit-level simulation, we use HSPICE to measure the energy consumption and performance of DPIM in 28nm technology. The robustness of all proposed circuits, i.e., interconnect, has been verified by considering 10% process variations on the size and threshold voltage of transistors using 5,000 Monte Carlo simulations. DPIM works with any bipolar resistive technology, which is the most commonly used in existing NVMs. Here, we adopt a memristor device with a VTEAM model (Kvatinsky et al., 2015;Biolek et al., 2021). The memristor's model parameters are chosen to produce a switching delay of 1.1ns, a voltage pulse of 1V and 2V for RESET and SET operations to fit practical devices (Kvatinsky et al., 2014). Figure 9 shows the similarity distribution of existing and non-existing patterns into graph hypervectors. The results are obtained for the initial (left) and the adjusted graph memory. As explained in Section 3.4, for perfect prediction and information retrieval, we would like to have no overlap between noise and signal distribution such that a threshold value can separate distributions. GrapHD memory refinement aims to iteratively increase the hypervector capacity and reduce the overlap between the signal and noise distribution. This would enable us to store large graphs in smaller dimensions. Graph refinement increases the similarity (decision score) of the existing patterns by recursively checking if the graph memory correctly memorizes them. For each misprediction (decision score lower than threshold T for existing patterns), we adjust the graph hypervector. As Figure 9 shows, the iterative graph refinement reduces the overlap between the noise and signal distribution until having zero overlaps in 20 iterations. This technique increases the capacity of a hypervector with fixed dimensionality to store a larger graph. In other words, this technique makes the ROC curve ( Figure 4B) sharper, resulting in 100% true positive with 0% false-positive rates. Figure 10A shows the impact of hypervector dimensionality and the number of edges on the quality of information retrieval. Our results indicate a larger graph requires higher hypervector dimensionality to ensure full graph memorization. For example, a graph with 100 and 200 edges can be accurately stored in a graph hypervector with D = 4k and D = 6k dimensionality, respectively. Figure 10B shows the number of required iterations for data recovery. Our technique requires fewer iterations of noise cancellation when the dimensionality of a hypervector is larger than the number of edges that it can accurately store. On the other hand, when the dimensionality is much lower than the required value, our algorithm may still require a few iterations, but it would converge to a random solution. In summary, maximum iterations are required when the dimensionality is the FIGURE 9 | Distribution of existing and non-existing nodes in graph memory without and with an iterative graph memory refinement, shown for 100, 000 edges. lowest possible value that provides enough capacity to accurately recover the stored information. Figure 10C also shows the number of mismatched edges during different noise cancellation iterations. Initially, our graph reconstruction comes with a large number of mismatched edges. This mismatch is larger for larger graph sizes. The error rate starts decreasing during our recursive error correction mechanism. When the size of the graph is within a capacity of a hypervector (V \u2264 150 for D = 4k, as shown in Figure 10A), our reconstruction will accurately recover the model. However, when the hypervector stores more patterns, our data recovery often diverges to a random graph (red line shown in Figure 10C). By increasing the number of vertices (and fixing the number of edges to 100), we find that the capacity is unchanged by the number of vertices for high dimensions. This could be because when we have a large enough number of vertices, then most of them will not be connected to any other vertices (due to a fixed number of edges). As a result, they will have 0 node memory and will contribute nothing to the graph memory, thus preserving capacity. The primary bottleneck is in generating orthogonal hypervectors that represent the nodes, so that in the decoding steps we do not make any false decisions. This is why at low dimensions we get a higher error, because the generated hypervectors for the nodes are not completely orthogonal to each other.\n\n\nGraph Memory Refinement\n\n\nGraph Reconstruction\n\nOne of the main advantages of hyperdimensional representation is its high robustness to noise and failure. In GrapHD, hypervectors are random and holographic with i.i.d. components. Each hypervector stores the information across all its components so that no component is more responsible for storing any piece of information than another. This makes a hypervector robust against errors in its components. Figure 10D shows the impact of noise in dimensions on graph memory reconstruction. The results are reported when different percentages of hypervector dimensions are randomly dropped. Our representation provides inherent robustness to such noise, as the data can still be reconstructed when the dimensionality is large enough. For example, our method tolerates 10% random noise using D = 6k dimensions to represent a graph with 30 nodes and 150 edges. Figure 11A shows the impact of graph size and hypervector dimension on node memory reconstruction error. Similar to graph reconstruction, the node reconstruction error depends on the graph size and dimensionality. A larger graph with more edges requires a higher dimensionality to ensure accurate node memory reconstruction. For example, for graphs with 100 and 200 nodes, our technique requires D = 2k and D = 4k to ensure 100% accurate node reconstruction. Note that using a hypervector with lower dimensionality to store a large graph could result in a quality loss during the information extraction. For example, using D = 2k to store a graph with 200 nodes reduces the chance of node memory reconstruction. Note that HDC is an approximate computational model. Therefore, it cannot theoretically ensure 100% data reconstruction. However, as our results show, in practice it is highly possible to get completely accurate reconstruction rate when your node memory is not loaded with more than its theoretical capacity. Figure 11B also shows how the number of required iterations changes depending on the graph size and hypervector dimensionality. As expected, node reconstruction is faster when hypervector dimensionality is larger (in fixed graph size). The lower number of iterations comes from a low error rate and interference noises. Figure 11C shows the node memory reconstruction error for a hypervector with D = 4k dimensions that stores different graph sizes. The larger graph, the more iterations we need to cancel the noise. In addition, the noise is less likely to cancel out to decrease the error rate (as also shown in Figure 11A heatmap).\n\n\nNode Memory Reconstruction\n\nSimilar to graph reconstruction, node reconstruction is inherently robust to noise and failure on random hypervector elements. Our evaluation in Figure 11D shows higher robustness in hypervectors with higher dimensionality. For example, hypervectors with D = 6k can tolerate a 5% error rate with no error. Even dropping more dimensions still has a small impact on the reconstruction error. Figure 12 evaluates the quality of GrapHD for graph matching using hypervectors with different dimensions. For all evaluations, the graph size is assumed to be fixed (30 nodes and 150 edges). The x-axis in the graph shows the actual edge difference between the two graphs, while the y-axis shows our estimated node difference. Ideally, we expect to see a graph with a straight line (y = x), indicating that our estimation accurately matches the actual edge difference. However, graph matching comes with an error when the hypervector dimensionality is low. As our evaluation indicates, the estimated edge difference gets a higher error (becomes far from the diagonal line) when the dimensionality gets lower.\n\n\nGraph Matching\n\n\nShortest Path Between Nodes\n\nIn a graphical model of memory, identifying the context of information and making inferences often require identifying correlated nodes separated by certain distances in graphs. These are nodes that are not directly related; rather, they are related by a series of nodes that connect only to the next node. This is similar to how a reasoning process occurs; we start off with an observation connected to another memory. This memory would, in turn, lead to a connection with another memory through reasoning. This is equivalent to finding the path between two nodes and studying its connections in the graph.\n\nWe can use GrapHD algorithms to find a path between two nodes and find the shortest distance between them. Suppose we want to find the shortest path between two nodes A and B in a graph G. First, we reconstruct all the local node memory for all nodes in the graph. Next, we maintain a distance value associated with all nodes, and this value is initialized to 0. This value will later be substituted with the step at which the node is encountered in the graph algorithm, which is also the distance of the node from A.\n\nHere we explain our algorithm. In the first step, we consider the node A with node memory H A . Next, using the thresholding method from section 4.1, we find all the nodes that have an edge with A. These nodes are distance 1 away from A, and we assign a distance value of 1 to these nodes. Next, we consider the node memory of all the distance d = 1 nodes and add them together. Then we repeat the same process to find all nodes not encountered before that share an edge with the distance of d = 1 nodes. These nodes are a distance of d = 2 away. Suppose we have the set of all distance d = n nodes; we add up all their local memories. Then, we find the set of all nodes not encountered before, which share an edge of one of the distance d = n nodes. These nodes will be labeled with distance d = n + 1. The process is repeated until either the node B is encountered, until all the nodes are encountered, or no new nodes are encountered.\n\nIf the node B is never encountered when the process terminates, we conclude no path between the nodes A and B. If B is encountered, we begin finding out the exact path joining A and B. Suppose node B is at a distance d away from A. We consider the node memory of B and then find which one of the d \u2212 1 distance nodes shares an edge with the node B. If there are multiple, we choose one of them randomly. Next, we consider the node memory of this d \u2212 1 distance node. We find which of the d \u2212 2 distance nodes share an edge with the d \u2212 1 distance node. If there are multiple, then we again chose one of the nodes arbitrarily. We continue this process recursively. After reaching the d \u2212 k distance node, we consider its node memory and find a d \u2212 k \u2212 1 distance node that shares an edge with the distance d \u2212 k node. The process is continued until we reach the node A. Following the nodes back will allow us to find the shortest path that joins the nodes A and B.\n\nIn the evaluations, we simulate d disjoint random graphs, each with V av = 21 vertices and E av = 270 edges. In all these graphs, we chose one random node and labeled it as 1, 2, 3, 4, \u00b7 \u00b7 \u00b7 , d. Next, we form an edge between all nodes. In this way, we construct a random graph that contains pairs of nodes with distances 1 to d in a controlled manner. In our evaluations, we chose d = 50 and the results are shown in Figure 12B. We see that as we increase the distance between the destination node and the starting node, the accuracy decreases drastically. This is because the number of edges that GrapHD searches through in each iteration increases exponentially with each step. As a result, the capacity eventually saturates if the graph is too big and if the distance is too large. On the other hand, increasing the dimension also increases the accuracy. This is expected since larger dimensions would increase the capacity of GrapHD, which allows storing a larger number of neighbors efficiently.\n\nThe shortest path detection has a natural interpretation in the case of weighted graph. In the weighted graph representation, the weights on edges become proportional to the similarity of the edge with memory. This results in a stochastic path finding algorithm, where the probability an edge is identified as being connected to the current node is proportional to the weight on edge. This has interpretation in the cognitive framework that the edge weight can be thought of as how strongly two nodes are correlated in the memory or how strongly the connection is memorized. The Human brain would form reasoning-based connections between two such objects depending on whether the two items in memory are strongly correlated. We can mimic a probabilistic path finding algorithm by using the current algorithm for the weighted graphs, which can mimic the reasoning process of the human brain. However, if we want to find a path independent of the weights, then we would need to store the graph using the unweighted encoding, and then the same algorithm would work as expected.\n\n\nObject Detection\n\nBased on the mathematical discussion in the paper (Section 4.1), we already showed the advantages that GrapHD for information retrieval, which is a key operation involved in traditional knowledge graph and relational learning benchmarks. Instead, in this work, we focus on a more advanced task that exploits knowledge graphs as a memorization model to enhance existing machine learning models. Our task also involves operations and computations that are not in high-dimension. Particularly, we evaluate GrapHD capability to help existing object detection algorithms. Deep learning models have already been used for highly accurate object detection (Ren et al., 2015). Particularly, convolutions neural networks (CNNs) showed promising results in extracting information from image and video data. However, CNN has a weak notion of time; thus, their predictions might be non-sense or out of context, e.g., predicting a moon as a light in videos taken from the sky.\n\nGrapHD is a memorization model that can be used beside any learning algorithm. To eliminate these miss-predictions, CNNs need to keep the context by associating the objects during the training and inference phase. We exploit GrapHD to memorize the relation of objects as a memory graph. GrapHD assigns strong weights between objects that are more likely to happen together in a video frame. For every prediction, CNN predicts all objects that have been seen in a frame. Next, GrapHD encodes the objects into high-dimensional space and checks the graph memory to see a possible correlation of these items (i.e., the distance or existence of edges in a graph memory). This enables CNNs to provide more accurate decisions and also the capability to reason about the prediction based on prior knowledge. To get the maximum benefit from GrapHD, the learning and memorization models need to be integrated. In other words, both CNN and GrapHD models need to be updated using the same procedure and rules. In our study, the GrapHD is placed as a dynamic memory beside the CNN. For each given train data, the data is processed using both CNN and GrapHD. At first, CNN operates over the data to make a prediction. Next, GrapHD look at the CNN prediction and accordingly gives a new loss term to the CNN in order to get updated. This loss represents how far the CNN prediction was compared to a GrapHD memorization prediction. Figure 13A shows the accuracy and efficiency of CNN enhanced with GrapHD and recurrent neural networks (RNNs) for object detection task (Karpathy and Fei-Fei, 2015). The results are reported over the Microsoft COCO object detection dataset . Work in Karpathy and Fei-Fei (2015), Kousik et al. (2021) integrated CNN and RNN in series, thus providing memorization capability for CNN in making a prediction. The results are reported for networks running on NVIDIA Jetson TX2, an embedded processor. Our evaluation shows that CNN enhanced with GrapHD can provide the same accuracy as the RNN network. However, our method can provide significantly higher computation efficiency. Our solution enables parallel construction of CNN and GrapHD model, thus enabling parallel training. Our evaluation shows that GrapHD achieves 3.8\u00d7 faster training and 1.7\u00d7 faster inference than RNN while ensuring the same classification accuracy. Note that GrapHD provides a higher capability for reasoning, as it has direct access to the transparent memorized values.\n\n\nHardware Acceleration\n\nAs we explained in Section 5, GrapHD applications can be accelerated on parallel platforms. Here, we study the capability of the proposed DPIM architecture in accelerating GrapHD applications. Figure 13B shows the performance and energy efficiency of DPIM running different GrapHD applications. The results are reported for a large graph with 1,000 nodes that have been mapped to a hypervector with different dimensions. All results are reported respective to NVIDIA GTX 1080 GPU when GPU runs multiple queries to ensure maximum resource utilization. Our results indicate that DPIM provides higher speedup and energy efficiency as compared to GPU regardless of the dimensionality and GrapHD operation. For example, DPIM achieves 10.6\u00d7 faster and 42.0\u00d7 higher energy efficiency than GPU with D = 1K dimensions. DPIM efficiency depends on two factors: (1) Application: operations required by GrapHD applications. DPIM provides higher benefits for applications that require lower precision arithmetic. This is due to a linear and quadratic increase in DPIM bundling and binding time in respect to bit-precision. For example, GrapHD during graph and node reconstruction operates over low precision hypervectors, thus providing higher computation efficiency over GPU. (2) Dimensionality: DPIM efficiency increases with the hypervector dimensionality. This efficiency comes from DPIM capability to support fast and row-parallel operations and also address data movement issues by eliminating costly data access to off-chip memory. Our results indicate that DPIM provides significantly higher performance speedup for graphs with higher dimensionality. For example, GrapHD using D = 16K and D = 32K dimensions provide on average 23.1\u00d7 and 30.4\u00d7 faster computation compared to GPU. In terms of energy efficiency, DPIM efficiency has a lower relation to dimensionality as both DPIM and GPU will require the same number of operations. The slight improvement in DPIM energy efficiency comes from its capability in data movement reduction.\n\n\nGraph Decoding With Nengo\n\nIn this section, we demonstrate GrapHD memory decoding using the Nengo SPA module to simulate how our model can work with Neuromorphic hardware and support existing models that try to make more brain-like models of cognition and reasoning. A key example where our model can be applied is SPAUN (Stewart et al., 2012), which is a large-scale cognitive model of the brain. SPAUN consists of about 2.3 million spiking neurons which are used to run various tasks like addition, digit recognition, and question answering without requiring any rewiring of the neurons. SPAUN represents information using Holographic Reduced Representation (HRR) (DuBois and Phillips, 2017), where the hypervectors are unit real vectors, and the binding is done using circular convolution. Our model for storing graph memory can be used to better represent associated information and correlated memory events in graph-based format and also decoded using the algorithms in this paper.\n\nThe implementation of GrapHD uses the HRR encoding that comes with the Nengo SPA module. The module implements HRR operations like binding, bundling and similarity using a Spiking Neural Network architecture. Our implementation contains an encoding module and decoding module. First, we generate random D = 64 dimensional vectors for each of the nodes. The encoding module then constructs the Graph memory of the graph based on the algorithm in Section 3. This is done using the binding and bundling operations implemented in Nengo SPA. The decoding module requires additional steps of first unbinding the memory vector with all possible node vectors, and then checking the similarity of the result with all other nodes. Based on the thresholding process, it is then decided whether an edge between two nodes exist. Calculating the similarity with all the nodes is done automatically by Nengo where it checks the similarity between all the semantic pointers in the vocabulary of the model. The main step is in unbinding the memory vector with all the nodes, which is done by calculating the unbinding of a query vector and memory vector. The query vector is chosen to cycle through all the node vector over a period of 0.5s, and then Nengo calculated the similarity of the result with all the node vectors as a function of time.\n\nAs Figure 14A shows, we use a graph with six vertices and ten edges and demonstrate at each step how the neuromorphic model of GrapHD decodes the graph. We decode the memory at each iteration by sending a query signal for a total of 0.5 s which sequentially changes value from the SPA representing V 0 to V 5 . From the output similarity at each of these time frames with the rest of the vertices, we can understand whether a connection between two nodes exists. For example, consider Figure 14C, which is the first iteration of the decoding process. To find whether an edge between node 2 and node 3, we look at the time of 0.21 s, when the query has the vector representing node 2 and then find the similarity of the line representing node 3 (Red). This similarity is about 0.3, which is greater than the threshold value (chosen to be 0.1).\n\nIn Figure 14, we show the results of the Graph decoding process. The figures show the similarity of the semantic pointer with each of the vectors representing all the nodes. In Figure 14B, we show the similarity of the query vector with each of the nodes as a function of time. It keeps cycling between all the nodes once within one cycle of 0.5 s. In Figure 14C, we show the Graph memory of the model and its similarity with each of the node vectors when we feed in the query vector to calculate the similarity. In Figures 14D,E, we show the output of the graph decoding process in the first and second iterations. We find that the output graph in the first iteration has an edge missing, but then it finds this edge and accurately decodes the graph in the second iteration.\n\nBesides SPAUN, as vector symbolic architecture, GrapHD has full compatibility with the new Intel neuromorphic framework, i.e., LAVA. This further shows the capability of GrapHD to be used as neuromorphic computing framework.\n\n\nCONCLUSION\n\nThis paper defines a brain-inspired system, called GrapHD, that better represents HDC memorization capability in terms of a graph of relations. We introduce, GrapHD, graph-based hyperdimensional memorization that represents information into high-dimensional space and enables reasoning. GrapHD defines an encoding method that represents complex graphbased data structure into high-dimensional space. Our encoder spreads the information of all nodes and edges across into a full holistic representation so that no component is more responsible for storing any piece of information than another. Then, GrapHD defines several important cognitive functionalities over the encoded memory graph. These operations include memory reconstruction, information retrieval, graph matching, and shortest path.\n\n\nDATA AVAILABILITY STATEMENT\n\nThe original contributions presented in the study are publicly available. This data can be found here through Microsoft COCO dataset: https://cocodataset.org/#home.\n\nFIGURE 1 |\n1GrapHD overview: (A) hyperdimensional graph encoding into a hypervector, (B) GrapHD cognitive operations, and (C) GrapHD applications.\n\nFIGURE 2 |\n2Graph memory encoding in GrapHD: (A) node hypervector generation, (B) creating a node memory, and (C) graph memory generation.\n\nFIGURE 3 |\n3Node memory encoding in GrapHD for weighted graph: (A) node hypervector generation, (B) creating weight hypervectors, and (C) node memory generation.\n\nFIGURE 4 |\n4Information retrieval (A) Distribution of signal and noise during information retrieval, and (B) ROC curves for different dimensionalities.\n\nFIGURE 5 |\n5Node memory reconstruction. (A) node hypervectors, (B) estimated node memory based on node hypervectors, (C) cross-interference noise estimation, and (D) recursive noise cancellation in graph memory.\n\nFIGURE 6 |\n6Graph memory reconstruction: (A) create all possible edge hypervectors, (B) checking the existence of each edge on the graph, (C) iterative noise cancellation.\n\nFIGURE 7 |\n7Visual graph reconstruction: red are mismatched edges and blue are existing edges. # Edges = 150, # Nodes = 30, and D = 3, 500.\n\nFIGURE 8 |\n8(A) NOR-based in-memory computing using switching characteristic of NVM devices. (B) row-parallel arithmetic operations, including addition and multiplication, and (C) row-parallel dot product operation.\n\nFIGURE 10 |\n10Graph reconstruction: (A) reconstruction accuracy, (B) required iterations vs. graph size and dimensions, (C) error rate v. iterations, and (D) robustness to noise (Shown over 1,000 trials).\n\nFIGURE 11 |\n11Node memory reconstruction: (A) error rate, (B) required iterations vs. graph size and dimensions, (C) error rate vs. iterations, and (D) robustness to noise.\n\nFIGURE 12 |\n12(A) Graph matching vs. dimensions: actual vs. estimated edge difference (For a single model) and (B) GrapHD success rate performing shortest path on an encoded graph (shown over 1,000 trials).\n\nFIGURE 13 |\n13(A) GrapHD vs. RNN for object detection: Accuracy and efficiency. (B) DPIM speedup and energy efficiency running different GrapHD operations over GPU.\n\nFIGURE 14 |\n14Results of the graph decoding process on neuromorphic hardware. (A) graph structure and the initial reconstructed graph, (B) similarity of the query vector with each of the nodes, (C) similarity with each of the node vector with graph memory of the model, (D,E) output of the graph decoding process in the first (D) and second iterations (E).\nFrontiers in Neuroscience | www.frontiersin.org\nFebruary 2022 | Volume 16 | Article 757125\nAUTHOR CONTRIBUTIONSPP and MI conceived the research. PP, HA, AZ, FI, MHN, TG, and MI conducted the research and analyzed the data. PP, HA, FI, TG, and MI wrote the manuscript. All authors reviewed the manuscript and agreed on the contents of the paper.Conflict of Interest:The authors declare that the research was conducted in the absence of any commercial or financial relationships that could be construed as a potential conflict of interest.\nNetwork neuroscience. D S Bassett, O Sporns, 10.1038/nn.4502Nat. Neurosci. 20Bassett, D. S., and Sporns, O. (2017). Network neuroscience. Nat. Neurosci. 20, 353-364. doi: 10.1038/nn.4502\n\nNengo: a python tool for building large-scale functional brain models. T Bekolay, J Bergstra, E Hunsberger, T Dewolf, T C Stewart, D Rasmussen, 10.3389/fninf.2013.00048Front. Neuroinform. 748Bekolay, T., Bergstra, J., Hunsberger, E., DeWolf, T., Stewart, T. C., Rasmussen, D., et al. (2014). Nengo: a python tool for building large-scale functional brain models. Front. Neuroinform. 7:48. doi: 10.3389/fninf.2013. 00048\n\nGraph-based object classification for neuromorphic vision sensing. Y Bi, A Chadha, A Abbas, E Bourtsoulatze, Andreopoulos , Y , Proceedings of the IEEE/CVF International Conference on Computer Vision (Seoul). the IEEE/CVF International Conference on Computer Vision (Seoul)Bi, Y., Chadha, A., Abbas, A., Bourtsoulatze, E., and Andreopoulos, Y. (2019). \"Graph-based object classification for neuromorphic vision sensing, \" in Proceedings of the IEEE/CVF International Conference on Computer Vision (Seoul), 491-501.\n\nv) team for spice simulation of memristive devices with improved numerical performance. D Biolek, Z Kolka, V Biolkov\u00e1, Z Biolek, S Kvatinsky, 10.1109/ACCESS.2021.3059241IEEE Access. 9Biolek, D., Kolka, Z., Biolkov\u00e1, V., Biolek, Z., and Kvatinsky, S. (2021). (v) team for spice simulation of memristive devices with improved numerical performance. IEEE Access 9, 30242-30255. doi: 10.1109/ACCESS.2021.30 59241\n\nFog computing and its role in the internet of things. F Bonomi, R Milito, J Zhu, Addepalli , S , Proceedings of the First Edition of the MCC Workshop on Mobile Cloud Computing. the First Edition of the MCC Workshop on Mobile Cloud ComputingNew York, NYBonomi, F., Milito, R., Zhu, J., and Addepalli, S. (2012). \"Fog computing and its role in the internet of things, \" in Proceedings of the First Edition of the MCC Workshop on Mobile Cloud Computing (New York, NY), 13-16.\n\nWorking memory from the psychological and neurosciences perspectives: a review. W J Chai, A I Hamid, Abdullah , J M , 10.3389/fpsyg.2018.00401Front. Psychol. 9401Chai, W. J., Abd Hamid, A. I., and Abdullah, J. M. (2018). Working memory from the psychological and neurosciences perspectives: a review. Front. Psychol. 9:401. doi: 10.3389/fpsyg.2018.00401\n\nJoint active search and neuromorphic computing for efficient data exploitation and monitoring in additive manufacturing. R Chen, M Imani, F Imani, 10.1016/j.jmapro.2021.09.048J. Manuf. Process. 71Chen, R., Imani, M., and Imani, F. (2021). Joint active search and neuromorphic computing for efficient data exploitation and monitoring in additive manufacturing. J. Manuf. Process. 71, 743-752. doi: 10.1016/j.jmapro.2021.09.048\n\nBig data deep learning: challenges and perspectives. X.-W Chen, Lin , X , 10.1109/ACCESS.2014.2325029IEEE Access. 2Chen, X.-W., and Lin, X. (2014). Big data deep learning: challenges and perspectives. IEEE Access 2, 514-525. doi: 10.1109/ACCESS.2014.23 25029\n\nLearning through structure: towards deep neuromorphic knowledge graph embeddings. V C Chian, M Hildebrandt, T Runkler, D Dold, 2021 International Conference on Neuromorphic Computing (ICNC). WuhanIEEEChian, V. C., Hildebrandt, M., Runkler, T., and Dold, D. (2021). \"Learning through structure: towards deep neuromorphic knowledge graph embeddings, \" in 2021 International Conference on Neuromorphic Computing (ICNC) (Wuhan: IEEE), 61-70.\n\nConstructing and forgetting temporal context in the human cerebral cortex. H.-Y S Chien, C J Honey, 10.1016/j.neuron.2020.02.013Neuron. 106Chien, H.-Y. S., and Honey, C. J. (2020). Constructing and forgetting temporal context in the human cerebral cortex. Neuron 106, 675-686. doi: 10.1016/j.neuron.2020.02.013\n\nM Courbariaux, Y Bengio, J.-P David, arXiv:1412.7024Training deep neural networks with low precision multiplications. arXiv. PreprintCourbariaux, M., Bengio, Y., and David, J.-P. (2014). Training deep neural networks with low precision multiplications. arXiv [Preprint] arXiv:1412.7024.\n\nWorking memory concept encoding using holographic reduced representations. G M Dubois, J L Phillips, MAICS. Fort WayneDuBois, G. M., and Phillips, J. L. (2017). \"Working memory concept encoding using holographic reduced representations, \" in MAICS (Fort Wayne, IN), 137-144.\n\nE P Frady, D Kleyko, F T Sommer, 10.1109/TNNLS.2021.3105949arXiv:2009.06734Variable binding for sparse distributed representations: theory and applications. arXiv [Preprint. Frady, E. P., Kleyko, D., and Sommer, F. T. (2020). Variable binding for sparse distributed representations: theory and applications. arXiv [Preprint] arXiv:2009.06734. doi: 10.1109/TNNLS.2021.31\n\nRobust computation with rhythmic spike patterns. E P Frady, F T Sommer, 10.1073/pnas.1902653116Proc. Natl. Acad. Sci. U.S.A. 116Frady, E. P., and Sommer, F. T. (2019). Robust computation with rhythmic spike patterns. Proc. Natl. Acad. Sci. U.S.A. 116, 18050-18059. doi: 10.1073/pnas.1902653116\n\nMemory and the Computational Brain: Why Cognitive Science Will Transform Neuroscience. C R Gallistel, A P King, John Wiley & Sons6Hoboken, NJGallistel, C. R., and King, A. P. (2011). Memory and the Computational Brain: Why Cognitive Science Will Transform Neuroscience, vol. 6. Hoboken, NJ: John Wiley & Sons.\n\nMultiplicative binding, representation operators analogy (workshop poster). R W Gayler, PreprintGayler, R. W. (1998). Multiplicative binding, representation operators analogy (workshop poster). Preprint.\n\nA distributed basis for analogical mapping. R W Gayler, S D Levy, New Frontiers in Analogy Research: Proceedings of the Second International Conference on Analogy. 9Gayler, R. W., and Levy, S. D. (2009). \"A distributed basis for analogical mapping, \" in New Frontiers in Analogy Research: Proceedings of the Second International Conference on Analogy, Vol. 9 (Sofia).\n\nClassification using hyperdimensional computing: a review. L Ge, K K Parhi, 10.1109/MCAS.2020.2988388IEEE Circ. Syst. Mag. 20Ge, L., and Parhi, K. K. (2020). Classification using hyperdimensional computing: a review. IEEE Circ. Syst. Mag. 20, 30-47. doi: 10.1109/MCAS.2020.29 88388\n\nBrain-inspired computing for wafer map defect pattern classification. P R Genssler, Amrouch , H , 2021 IEEE International Test Conference (ITC). Anaheim, CAIEEEGenssler, P. R., and Amrouch, H. (2021). \"Brain-inspired computing for wafer map defect pattern classification, \" in 2021 IEEE International Test Conference (ITC) (Anaheim, CA: IEEE), 123-132.\n\nHow the brain might work: a hierarchical and temporal model for learning and recognition (Ph.D. thesis). D George, . Stanford UniversityGeorge, D. (2008). How the brain might work: a hierarchical and temporal model for learning and recognition (Ph.D. thesis). Stanford University. Available online at: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1. 163.7566&rep=rep1&type=pdf\n\nEfficient algorithms for in-memory fixed point multiplication using magic. A Haj-Ali, R Ben-Hur, N Wald, S Kvatinsky, 2018 IEEE International Symposium on Circuits and Systems (ISCAS). FlorenceIEEEHaj-Ali, A., Ben-Hur, R., Wald, N., and Kvatinsky, S. (2018). \"Efficient algorithms for in-memory fixed point multiplication using magic, \" in 2018 IEEE International Symposium on Circuits and Systems (ISCAS) (Florence: IEEE), 1-5.\n\nRram-based cam combined with timedomain circuits for hyperdimensional computing. Y Halawani, D Kilani, E Hassan, H Tesfai, H Saleh, Mohammad , B , 10.21203/rs.3.rs-608660/v1Sci. Rep. 11Halawani, Y., Kilani, D., Hassan, E., Tesfai, H., Saleh, H., and Mohammad, B. (2021). Rram-based cam combined with time- domain circuits for hyperdimensional computing. Sci. Rep. 11, 19848. doi: 10.21203/rs.3.rs-608660/v1\n\nNeuroscience-inspired artificial intelligence. D Hassabis, D Kumaran, C Summerfield, M Botvinick, 10.1016/j.neuron.2017.06.011Neuron. 95Hassabis, D., Kumaran, D., Summerfield, C., and Botvinick, M. (2017). Neuroscience-inspired artificial intelligence. Neuron 95, 245-258. doi: 10.1016/j.neuron.2017.06.011\n\nPrid: model inversion privacy attacks in hyperdimensional learning systems. A H\u00e9rnandez-Cano, R Cammarota, M Imani, 2021 58th ACM/IEEE Design Automation Conference (DAC). San Francisco, CAIEEEH\u00e9rnandez-Cano, A., Cammarota, R., and Imani, M. (2021). \"Prid: model inversion privacy attacks in hyperdimensional learning systems, \" in 2021 58th ACM/IEEE Design Automation Conference (DAC) (San Francisco, CA: IEEE), 553-558.\n\nReghd: robust and efficient regression in hyper-dimensional learning system. A Hern\u00e1ndez-Cano, C Zhuo, X Yin, M Imani, 58Hern\u00e1ndez-Cano, A., Zhuo, C., Yin, X., and Imani, M. (2021a). \"Reghd: robust and efficient regression in hyper-dimensional learning system, \" in 2021 58th\n\nACM/IEEE Design Automation Conference (DAC). San Francisco, CAIEEEACM/IEEE Design Automation Conference (DAC) (San Francisco, CA: IEEE), 7-12.\n\nReal-time and robust hyperdimensional classification. A Hern\u00e1ndez-Cano, C Zhuo, X Yin, M Imani, Proceedings of the 2021 on Great Lakes Symposium on VLSI. the 2021 on Great Lakes Symposium on VLSIHern\u00e1ndez-Cano, A., Zhuo, C., Yin, X., and Imani, M. (2021b). \"Real-time and robust hyperdimensional classification, \" in Proceedings of the 2021 on Great Lakes Symposium on VLSI, 397-402.\n\nFloatpim: In-memory acceleration of deep neural network training with high precision. M Imani, S Gupta, Y Kim, T Rosing, 2019Imani, M., Gupta, S., Kim, Y., and Rosing, T. (2019a). \"Floatpim: In-memory acceleration of deep neural network training with high precision, \" in 2019\n\nACM/IEEE 46th Annual International Symposium on Computer Architecture (ISCA). Phoenix, AZIEEEACM/IEEE 46th Annual International Symposium on Computer Architecture (ISCA) (Phoenix, AZ: IEEE), 802-815.\n\nA framework for collaborative learning in secure high-dimensional space. M Imani, Y Kim, S Riazi, J Messerly, P Liu, F Koushanfar, 2019 IEEE 12th International Conference on Cloud Computing (CLOUD). MilanIEEEImani, M., Kim, Y., Riazi, S., Messerly, J., Liu, P., Koushanfar, F., et al. (2019b). \"A framework for collaborative learning in secure high-dimensional space, \" in 2019 IEEE 12th International Conference on Cloud Computing (CLOUD) (Milan: IEEE), 435-446.\n\nVoicehd: Hyperdimensional computing for efficient speech recognition. M Imani, D Kong, A Rahimi, T Rosing, 2017 IEEE International Conference on Rebooting Computing (ICRC). Washington, DCIEEEImani, M., Kong, D., Rahimi, A., and Rosing, T. (2017a). \"Voicehd: Hyperdimensional computing for efficient speech recognition, \" in 2017 IEEE International Conference on Rebooting Computing (ICRC) (Washington, DC: IEEE), 1-8.\n\nBric: locality-based encoding for energy-efficient brain-inspired hyperdimensional computing. M Imani, J Morris, J Messerly, H Shu, Y Deng, T Rosing, Proceedings of the 56th Annual Design Automation Conference. the 56th Annual Design Automation ConferenceLas Vegas, NVImani, M., Morris, J., Messerly, J., Shu, H., Deng, Y., and Rosing, T. (2019c). \"Bric: locality-based encoding for energy-efficient brain-inspired hyperdimensional computing, \" in Proceedings of the 56th Annual Design Automation Conference 2019 (Las Vegas, NV), 1-6.\n\nDual: acceleration of clustering algorithms using digital-based processing in-memory. M Imani, S Pampana, S Gupta, M Zhou, Y Kim, T Rosing, 2020 53rd Annual IEEE/ACM International Symposium on Microarchitecture (MICRO). AthensIEEEImani, M., Pampana, S., Gupta, S., Zhou, M., Kim, Y., and Rosing, T. (2020). \"Dual: acceleration of clustering algorithms using digital-based processing in-memory, \" in 2020 53rd Annual IEEE/ACM International Symposium on Microarchitecture (MICRO) (Athens: IEEE), 356-371.\n\nExploring hyperdimensional associative memory. M Imani, A Rahimi, D Kong, T Rosing, J M Rabaey, 2017 IEEE International Symposium on High Performance Computer Architecture (HPCA). Austin, TXIEEEImani, M., Rahimi, A., Kong, D., Rosing, T., and Rabaey, J. M. (2017b). \"Exploring hyperdimensional associative memory, \" in 2017 IEEE International Symposium on High Performance Computer Architecture (HPCA) (Austin, TX,: IEEE), 445-456.\n\nSearchd: a memory-centric hyperdimensional computing with stochastic training. M Imani, X Yin, J Messerly, S Gupta, M Niemier, X S Hu, 10.1109/TCAD.2019.2952544IEEE Trans. Comput. Aided Design Integrat. Circ. Syst. 39Imani, M., Yin, X., Messerly, J., Gupta, S., Niemier, M., Hu, X. S., et al. (2019d). Searchd: a memory-centric hyperdimensional computing with stochastic training. IEEE Trans. Comput. Aided Design Integrat. Circ. Syst. 39, 2422-2433. doi: 10.1109/TCAD.2019.2952544\n\nRevisiting hyperdimensional learning for fpga and low-power architectures. M Imani, Z Zou, S Bosch, S Anantha Rao, S Salamat, V Kuma, 2021 IEEE International Symposium on High-Performance Computer Architecture (HPCA). SeoulIEEEImani, M., Zou, Z., Bosch, S., Anantha Rao, S., Salamat, S., and Kuma, V. (2021). \"Revisiting hyperdimensional learning for fpga and low-power architectures, \" in 2021 IEEE International Symposium on High-Performance Computer Architecture (HPCA) (Seoul: IEEE), 221-234.\n\nAutomatic recall machines: Internal replay, continual learning and the brain. X Ji, J Henriques, T Tuytelaars, A Vedaldi, arXiv:2006.12323arXiv [PreprintJi, X., Henriques, J., Tuytelaars, T., and Vedaldi, A. (2020). Automatic recall machines: Internal replay, continual learning and the brain. arXiv [Preprint] arXiv:2006.12323.\n\nIn-datacenter performance analysis of a tensor processing unit. N P Jouppi, C Young, N Patil, D Patterson, G Agrawal, R Bajwa, 2017 ACM/IEEE 44th Annual International Symposium on Computer Architecture (ISCA). Toronto, ONIEEEJouppi, N. P., Young, C., Patil, N., Patterson, D., Agrawal, G., Bajwa, R., et al. (2017). \"In-datacenter performance analysis of a tensor processing unit, \" in 2017 ACM/IEEE 44th Annual International Symposium on Computer Architecture (ISCA) (Toronto, ON: IEEE), 1-12.\n\nEncoding structure in boolean space. P Kanerva, in ICANN. 98SpringerKanerva, P. (1998). \"Encoding structure in boolean space, \" in ICANN, Vol. 98 (Los Angeles, CA: Springer), 387-392.\n\nHyperdimensional computing: An introduction to computing in distributed representation with high-dimensional random vectors. P Kanerva, 10.1007/s12559-009-9009-8Cogn. Comput. 1Kanerva, P. (2009). Hyperdimensional computing: An introduction to computing in distributed representation with high-dimensional random vectors. Cogn. Comput. 1, 139-159. doi: 10.1007/s12559-009- 9009-8\n\nRandom indexing of text samples for latent semantic analysis. P Kanerva, J Kristofersson, A Holst, Proceedings of the 22nd Annual Conference of the Cognitive Science Society. the 22nd Annual Conference of the Cognitive Science SocietyPhiladelphia, PA1036Kanerva, P., Kristofersson, J., and Holst, A. (2000). \"Random indexing of text samples for latent semantic analysis, \" in Proceedings of the 22nd Annual Conference of the Cognitive Science Society, Vol. 1036 (Philadelphia, PA).\n\nDeep visual-semantic alignments for generating image descriptions. A Karpathy, L Fei-Fei, Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. the IEEE Conference on Computer Vision and Pattern RecognitionBoston, MAIEEEKarpathy, A., and Fei-Fei, L. (2015). \"Deep visual-semantic alignments for generating image descriptions, \" in Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (Boston, MA: IEEE), 3128-3137.\n\nEnergy efficient in-memory hyperdimensional encoding for spatio-temporal signal processing. G Karunaratne, M Le Gallo, M Hersche, G Cherubini, L Benini, A Sebastian, 10.1109/TCSII.2021.3068126IEEE Trans. Circ. Syst. II. 68Karunaratne, G., Le Gallo, M., Hersche, M., Cherubini, G., Benini, L., Sebastian, A., et al. (2021). Energy efficient in-memory hyperdimensional encoding for spatio-temporal signal processing. IEEE Trans. Circ. Syst. II 68, 1725-1729. doi: 10.1109/TCSII.2021.3068126\n\nGeniehd: efficient dna pattern matching accelerator using hyperdimensional computing. Y Kim, M Imani, N Moshiri, T Rosing, 2020Kim, Y., Imani, M., Moshiri, N., and Rosing, T. (2020). \"Geniehd: efficient dna pattern matching accelerator using hyperdimensional computing, \" in 2020\n\nDesign, Automation Test in Europe Conference Exhibition (DATE). GrenobleIEEEDesign, Automation Test in Europe Conference Exhibition (DATE) (Grenoble: IEEE), 115-120.\n\nEfficient human activity recognition using hyperdimensional computing. Y Kim, M Imani, T S Rosing, Proceedings of the 8th International Conference on the Internet of Things. the 8th International Conference on the Internet of ThingsNew York, NYACM38Kim, Y., Imani, M., and Rosing, T. S. (2018). \"Efficient human activity recognition using hyperdimensional computing, \" in Proceedings of the 8th International Conference on the Internet of Things (New York, NY: ACM), 38.\n\nBrain-like classifier of temporal patterns. D Kleyko, E Osipov, 2014 International Conference on Computer and Information Sciences (ICCOINS). Kuala LumpurIEEEKleyko, D., and Osipov, E. (2014). \"Brain-like classifier of temporal patterns, \" in 2014 International Conference on Computer and Information Sciences (ICCOINS) (Kuala Lumpur: IEEE), 1-6.\n\nHyperdimensional computing in industrial systems: the use-case of distributed fault isolation in a power plant. D Kleyko, E Osipov, N Papakonstantinou, V Vyatkin, 10.1109/ACCESS.2018.2840128IEEE Access. 6Kleyko, D., Osipov, E., Papakonstantinou, N., and Vyatkin, V. (2018). Hyperdimensional computing in industrial systems: the use-case of distributed fault isolation in a power plant. IEEE Access 6, 30766-30777. doi: 10.1109/ACCESS.2018.2840128\n\nImproved salient object detection using hybrid convolution recurrent neural network. N Kousik, Y Natarajan, R A Raja, S Kallam, R Patan, A H Gandomi, 10.1016/j.eswa.2020.114064Expert. Syst. Appl. 166114064Kousik, N., Natarajan, Y., Raja, R. A., Kallam, S., Patan, R., and Gandomi, A. H. (2021). Improved salient object detection using hybrid convolution recurrent neural network. Expert. Syst. Appl. 166:114064. doi: 10.1016/j.eswa.2020. 114064\n\nMagic memristor-aided logic. S Kvatinsky, D Belousov, S Liman, G Satat, N Wald, E G Friedman, 10.1109/TCSII.2014.2357292IEEE Trans. Circ. Syst. II. 61Kvatinsky, S., Belousov, D., Liman, S., Satat, G., Wald, N., Friedman, E. G., et al. (2014). Magic memristor-aided logic. IEEE Trans. Circ. Syst. II 61, 895-899. doi: 10.1109/TCSII.2014.2357292\n\nVteam: a general model for voltage-controlled memristors. S Kvatinsky, M Ramadan, E G Friedman, A Kolodny, 10.1109/TCSII.2015.2433536IEEE Trans. Circ. Syst. II. 62Kvatinsky, S., Ramadan, M., Friedman, E. G., and Kolodny, A. (2015). Vteam: a general model for voltage-controlled memristors. IEEE Trans. Circ. Syst. II 62, 786-790. doi: 10.1109/TCSII.2015.2433536\n\nThe internet of things (iot): Applications, investments, and challenges for enterprises. I Lee, K Lee, 10.1016/j.bushor.2015.03.008Bus. Horiz. 58Lee, I., and Lee, K. (2015). The internet of things (iot): Applications, investments, and challenges for enterprises. Bus. Horiz. 58, 431-440. doi: 10.1016/j.bushor.2015.03.008\n\nHyperdimensional computing with 3d vrram in-memory kernels: device-architecture co-design for energy-efficient, error-resilient language recognition. H Li, T F Wu, A Rahimi, K.-S Li, M Rusch, C.-H Lin, Electron Devices Meeting (IEDM). San Francisco, CAIEEELi, H., Wu, T. F., Rahimi, A., Li, K.-S., Rusch, M., Lin, C.-H., et al. (2016). \"Hyperdimensional computing with 3d vrram in-memory kernels: device-architecture co-design for energy-efficient, error-resilient language recognition, \" in Electron Devices Meeting (IEDM), 2016 IEEE International (San Francisco, CA: IEEE).\n\nMicrosoft coco: common objects in context. T.-Y Lin, M Maire, S Belongie, J Hays, P Perona, D Ramanan, European Conference on Computer Vision. ZurichSpringerLin, T.-Y., Maire, M., Belongie, S., Hays, J., Perona, P., Ramanan, D., et al. (2014). \"Microsoft coco: common objects in context, \" in European Conference on Computer Vision (Zurich: Springer), 740-755.\n\nChallenges in parallel graph processing. A Lumsdaine, D Gregor, B Hendrickson, J Berry, 10.1142/S0129626407002843Parallel Proces. Lett. 17Lumsdaine, A., Gregor, D., Hendrickson, B., and Berry, J. (2007). Challenges in parallel graph processing. Parallel Proces. Lett. 17, 5-20. doi: 10.1142/S0129626407002843\n\nHolistic representations for memorization and inference. Y Ma, M Hildebrandt, V Tresp, S Baier, UAI. Monterey, CAMa, Y., Hildebrandt, M., Tresp, V., and Baier, S. (2018). \"Holistic representations for memorization and inference, \" in UAI (Monterey, CA), 403-413.\n\n. P Micikevicius, S Narang, J Alben, G Diamos, E Elsen, D Garcia, arXiv:1710.03740Mixed precision training. arXiv [PreprintMicikevicius, P., Narang, S., Alben, J., Diamos, G., Elsen, E., Garcia, D., et al. (2017). Mixed precision training. arXiv [Preprint] arXiv:1710. 03740.\n\nLearning sensorimotor control with neuromorphic sensors: toward hyperdimensional active perception. A Mitrokhin, C Fermller, Aloimonos Y , 10.1126/scirobotics.aaw6736Sci. Rob. 430Mitrokhin, A., Fermller, C., and Aloimonos. Y. (2019). Learning sensorimotor control with neuromorphic sensors: toward hyperdimensional active perception. Sci. Rob. 4:30. doi: 10.1126/scirobotics.aaw6736\n\nA wearable biosensing system with in-sensor adaptive machine learning for hand gesture recognition. A Moin, A Zhou, A Rahimi, A Menon, S Benatti, G Alexandrov, 10.1038/s41928-020-00510-8Nat. Electron. 4Moin, A., Zhou, A., Rahimi, A., Menon, A., Benatti, S., Alexandrov, G., et al. (2021). A wearable biosensing system with in-sensor adaptive machine learning for hand gesture recognition. Nat. Electron. 4, 54-63. doi: 10.1038/s41928-020-00510-8\n\nPulp-hd: accelerating brain-inspired high-dimensional computing on a parallel ultra-low power platform. F Montagna, A Rahimi, S Benatti, D Rossi, L Benini, 2018 55th ACM/ESDA/IEEE Design Automation Conference (DAC). San Francisco, CAIEEEMontagna, F., Rahimi, A., Benatti, S., Rossi, D., and Benini, L. (2018). \"Pulp-hd: accelerating brain-inspired high-dimensional computing on a parallel ultra-low power platform, \" in 2018 55th ACM/ESDA/IEEE Design Automation Conference (DAC) (San Francisco, CA: IEEE), 1-6.\n\nAn introduction to hyperdimensional computing for robotics. P Neubert, S Schubert, P Protzel, 10.1007/s13218-019-00623-z33KI-K\u00fcnstliche IntellNeubert, P., Schubert, S., and Protzel, P. (2019). An introduction to hyperdimensional computing for robotics. KI-K\u00fcnstliche Intell. 33, 319-330. doi: 10.1007/s13218-019-00623-z\n\nHolographic embeddings of knowledge graphs. M Nickel, L Rosasco, T Poggio, Proceedings of the AAAI Conference on Artificial Intelligence. the AAAI Conference on Artificial Intelligence30Nickel, M., Rosasco, L., and Poggio, T. (2016). Holographic embeddings of knowledge graphs. In Proceedings of the AAAI Conference on Artificial Intelligence, volume 30.\n\nComputational Explorations in Cognitive Neuroscience: Understanding the Mind by Simulating the Brain. R C O&apos;reilly, Y Munakata, MIT PressCambridge, MAO'reilly, R. C., and Munakata, Y. (2000). Computational Explorations in Cognitive Neuroscience: Understanding the Mind by Simulating the Brain. Cambridge, MA: MIT Press.\n\nOn the difficulty of training recurrent neural networks. R Pascanu, T Mikolov, Y Bengio, PMLRInternational Conference on Machine Learning. AtlantaPascanu, R., Mikolov, T., and Bengio, Y. (2013). \"On the difficulty of training recurrent neural networks, \" in International Conference on Machine Learning (Atlanta: PMLR), 1310-1318.\n\nI Pitas, Graph-Based Social Media Analysis. Boca Raton, FLCRC Press39Pitas, I. (2016). Graph-Based Social Media Analysis, Vol. 39. Boca Raton, FL: CRC Press.\n\nStochd: stochastic hyperdimensional system for efficient and robust learning from raw data. P Poduval, Z Zou, H Najafi, H Homayoun, M Imani, IEEE/ACM Design Automation Conference (DAC). San Francisco, CAIEEEPoduval, P., Zou, Z., Najafi, H., Homayoun, H., and Imani, M. (2021b). \"Stochd: stochastic hyperdimensional system for efficient and robust learning from raw data, \" in IEEE/ACM Design Automation Conference (DAC) (San Francisco, CA: IEEE).\n\nCognitive correlative encoding for genome sequence matching in hyperdimensional system. P Poduval, Z Zou, X Yin, E Sadredini, M Imani, IEEE/ACM Design Automation Conference (DAC). San Francisco, CAIEEEPoduval, P., Zou, Z., Yin, X., Sadredini, E., and Imani, M. (2021a). \"Cognitive correlative encoding for genome sequence matching in hyperdimensional system, \" in IEEE/ACM Design Automation Conference (DAC) (San Francisco, CA: IEEE).\n\nHyperdimensional biosignal processing: a case study for emg-based hand gesture recognition. A Rahimi, S Benatti, P Kanerva, L Benini, J M Rabaey, 2016 IEEE International Conference on Rebooting Computing (ICRC). San Diego, CAIEEERahimi, A., Benatti, S., Kanerva, P., Benini, L., and Rabaey, J. M. (2016a). \"Hyperdimensional biosignal processing: a case study for emg-based hand gesture recognition, \" in 2016 IEEE International Conference on Rebooting Computing (ICRC) (San Diego, CA: IEEE), 1-8.\n\nEfficient biosignal processing using hyperdimensional computing: network templates for combined learning and classification of exg signals. A Rahimi, P Kanerva, L Benini, J M Rabaey, 10.1109/JPROC.2018.2871163Proc. IEEE. 107Rahimi, A., Kanerva, P., Benini, L., and Rabaey, J. M. (2018). Efficient biosignal processing using hyperdimensional computing: network templates for combined learning and classification of exg signals. Proc. IEEE 107, 123-143. doi: 10.1109/JPROC.2018.2871163\n\nA robust and energy-efficient classifier using brain-inspired hyperdimensional computing. A Rahimi, P Kanerva, J M Rabaey, ISLPED. San Francisco, CAACMRahimi, A., Kanerva, P., and Rabaey, J. M. (2016b). \"A robust and energy-efficient classifier using brain-inspired hyperdimensional computing, \" in ISLPED (San Francisco, CA: ACM), 64-69.\n\nSense: semantically enhanced node sequence embedding. S Rallapalli, L Ma, M Srivatsa, A Swami, H Kwon, G Bent, 2019 IEEE International Conference on Big Data (Big Data). Los Angeles, CAIEEERallapalli, S., Ma, L., Srivatsa, M., Swami, A., Kwon, H., Bent, G., et al. (2019). \"Sense: semantically enhanced node sequence embedding, \" in 2019 IEEE International Conference on Big Data (Big Data) (Los Angeles, CA: IEEE), 665-670.\n\nSequence prediction with sparse distributed hyperdimensional coding applied to the analysis of mobile phone use patterns. O J R\u00e4s\u00e4nen, J P Saarinen, 10.1109/TNNLS.2015.2462721IEEE Trans. Neural Netw. Learn. Syst. 27R\u00e4s\u00e4nen, O. J., and Saarinen, J. P. (2015). Sequence prediction with sparse distributed hyperdimensional coding applied to the analysis of mobile phone use patterns. IEEE Trans. Neural Netw. Learn. Syst. 27, 1878-1889. doi: 10.1109/TNNLS.2015.2462721\n\nThe application of graph theoretical analysis to complex networks in the brain. J C Reijneveld, S C Ponten, H W Berendse, C J Stam, 10.1016/j.clinph.2007.08.010Clin. Neurophysiol. 118Reijneveld, J. C., Ponten, S. C., Berendse, H. W., and Stam, C. J. (2007). The application of graph theoretical analysis to complex networks in the brain. Clin. Neurophysiol. 118, 2317-2331. doi: 10.1016/j.clinph.2007. 08.010\n\nFaster r-cnn: towards real-time object detection with region proposal networks. S Ren, K He, R Girshick, J Sun, arXiv:1506.01497arXiv [PreprintRen, S., He, K., Girshick, R., and Sun, J. (2015). Faster r-cnn: towards real-time object detection with region proposal networks. arXiv [Preprint] arXiv:1506.01497.\n\nThe ubiquity of large graphs and surprising challenges of graph processing. S Sahu, A Mhedhbi, S Salihoglu, J Lin, M T \u00d6zsu, 10.1145/3186728.3164139Proc. VLDB Endowment. VLDB Endowment11Sahu, S., Mhedhbi, A., Salihoglu, S., Lin, J., and \u00d6zsu, M. T. (2017). The ubiquity of large graphs and surprising challenges of graph processing. Proc. VLDB Endowment 11, 420-431. doi: 10.1145/3186728.3164139\n\nThe cognitive neuroscience of memory distortion. D L Schacter, S D Slotnick, 10.1016/j.neuron.2004.08.017Neuron. 44Schacter, D. L., and Slotnick, S. D. (2004). The cognitive neuroscience of memory distortion. Neuron 44, 149-160. doi: 10.1016/j.neuron.2004. 08.017\n\nToward training recurrent neural networks for lifelong learning. C Simpkin, I Taylor, G A Bent, G De Mel, S ; S Rallapalli, S Chandar, Y Bengio, 10.1162/neco_a_01246Neural Comput. 32Semantic workflow encoding using vector symbolic architecturesSimpkin, C., Taylor, I., Bent, G. A., de Mel, G., and Rallapalli, S. (2017). Semantic workflow encoding using vector symbolic architectures. Available online at: https://orca.cardiff.ac.uk/112242/1/camera-ready-semanticworkflow- encoding.pdf Sodhani, S., Chandar, S., and Bengio, Y. (2020). Toward training recurrent neural networks for lifelong learning. Neural Comput. 32, 1-35. doi: 10.1162/neco_a_01246\n\nSpaun: a perception-cognitionaction model using spiking neurons. T Stewart, F.-X Choo, C Eliasmith, Proceedings of the Annual Meeting of the Cognitive Science Society. the Annual Meeting of the Cognitive Science Society34SapporoStewart, T., Choo, F.-X., and Eliasmith, C. (2012). \"Spaun: a perception-cognition- action model using spiking neurons, \" in Proceedings of the Annual Meeting of the Cognitive Science Society, Vol. 34 (Sapporo).\n\nAlzheimer's disease: connecting findings from graph theoretical studies of brain networks. B M Tijms, A M Wink, W De Haan, W M Van Der Flier, C J Stam, P Scheltens, 10.1016/j.neurobiolaging.2013.02.020Neurobiol. Aging. 34Tijms, B. M., Wink, A. M., de Haan, W., van der Flier, W. M., Stam, C. J., Scheltens, P., et al. (2013). Alzheimer's disease: connecting findings from graph theoretical studies of brain networks. Neurobiol. Aging 34, 2023-2036. doi: 10.1016/j.neurobiolaging.2013.02.020\n\nIot challenges. R Van Kranenburg, A Bassi, 10.1186/2192-1121-1-9Commun. Mobile Comput. 1Van Kranenburg, R., and Bassi, A. (2012). Iot challenges. Commun. Mobile Comput. 1, 1-5. doi: 10.1186/2192-1121-1-9\n\nModel-based cognitive neuroscience approaches to computational psychiatry: clustering and classification. T V Wiecki, J Poland, M J Frank, 10.1177/2167702614565359Clin. Psychol. Sci. 3Wiecki, T. V., Poland, J., and Frank, M. J. (2015). Model-based cognitive neuroscience approaches to computational psychiatry: clustering and classification. Clin. Psychol. Sci. 3, 378-399. doi: 10.1177/2167702614565359\n\nSpiking hyperdimensional network: neuromorphic models integrated with memoryinspired framework. Z Zou, H Alimohamadi, F Imani, Y Kim, M Imani, arXiv:2110.00214arXivPreprintZou, Z., Alimohamadi, H., Imani, F., Kim, Y., and Imani, M. (2021a). Spiking hyperdimensional network: neuromorphic models integrated with memory- inspired framework. arXiv [Preprint] arXiv:2110.00214.\n\nScalable edge-based hyperdimensional learning system with brainlike neural adaptation. Z Zou, Y Kim, F Imani, H Alimohamadi, R Cammarota, M Imani, Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis. the International Conference for High Performance Computing, Networking, Storage and AnalysisSt. Louis, MOZou, Z., Kim, Y., Imani, F., Alimohamadi, H., Cammarota, R., and Imani, M. (2021b). \"Scalable edge-based hyperdimensional learning system with brain- like neural adaptation, \" in Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis (St. Louis, MO), 1-15.\n", "annotations": {"author": "[{\"end\":123,\"start\":100},{\"end\":135,\"start\":124},{\"end\":151,\"start\":136},{\"end\":214,\"start\":152},{\"end\":328,\"start\":215},{\"end\":427,\"start\":329},{\"end\":527,\"start\":428},{\"end\":630,\"start\":528},{\"end\":732,\"start\":631},{\"end\":849,\"start\":733},{\"end\":883,\"start\":850},{\"end\":919,\"start\":884},{\"end\":984,\"start\":920}]", "publisher": null, "author_last_name": "[{\"end\":122,\"start\":115},{\"end\":134,\"start\":132},{\"end\":150,\"start\":145},{\"end\":169,\"start\":162},{\"end\":232,\"start\":221},{\"end\":339,\"start\":333},{\"end\":440,\"start\":435},{\"end\":543,\"start\":537},{\"end\":644,\"start\":636},{\"end\":745,\"start\":740}]", "author_first_name": "[{\"end\":107,\"start\":100},{\"end\":114,\"start\":108},{\"end\":131,\"start\":124},{\"end\":142,\"start\":136},{\"end\":144,\"start\":143},{\"end\":161,\"start\":152},{\"end\":220,\"start\":215},{\"end\":332,\"start\":329},{\"end\":434,\"start\":428},{\"end\":529,\"start\":528},{\"end\":536,\"start\":530},{\"end\":635,\"start\":631},{\"end\":739,\"start\":733}]", "author_affiliation": "[{\"end\":213,\"start\":171},{\"end\":327,\"start\":234},{\"end\":426,\"start\":341},{\"end\":526,\"start\":442},{\"end\":629,\"start\":545},{\"end\":731,\"start\":646},{\"end\":848,\"start\":763},{\"end\":882,\"start\":851},{\"end\":918,\"start\":885},{\"end\":983,\"start\":921}]", "title": "[{\"end\":84,\"start\":1},{\"end\":1068,\"start\":985}]", "venue": "[{\"end\":1117,\"start\":1070}]", "abstract": "[{\"end\":3481,\"start\":1712}]", "bib_ref": "[{\"attributes\":{\"ref_id\":\"b4\"},\"end\":3634,\"start\":3613},{\"attributes\":{\"ref_id\":\"b7\"},\"end\":3653,\"start\":3634},{\"end\":4227,\"start\":4196},{\"attributes\":{\"ref_id\":\"b63\"},\"end\":4415,\"start\":4393},{\"end\":4436,\"start\":4415},{\"attributes\":{\"ref_id\":\"b37\"},\"end\":4796,\"start\":4775},{\"attributes\":{\"ref_id\":\"b79\"},\"end\":5064,\"start\":5032},{\"attributes\":{\"ref_id\":\"b51\"},\"end\":5082,\"start\":5064},{\"attributes\":{\"ref_id\":\"b10\"},\"end\":5336,\"start\":5310},{\"attributes\":{\"ref_id\":\"b56\"},\"end\":5362,\"start\":5336},{\"attributes\":{\"ref_id\":\"b39\"},\"end\":5653,\"start\":5638},{\"attributes\":{\"ref_id\":\"b69\"},\"end\":6018,\"start\":5996},{\"attributes\":{\"ref_id\":\"b30\"},\"end\":6037,\"start\":6018},{\"attributes\":{\"ref_id\":\"b29\"},\"end\":6058,\"start\":6037},{\"attributes\":{\"ref_id\":\"b52\"},\"end\":6613,\"start\":6596},{\"attributes\":{\"ref_id\":\"b33\"},\"end\":6633,\"start\":6613},{\"attributes\":{\"ref_id\":\"b26\"},\"end\":6662,\"start\":6633},{\"attributes\":{\"ref_id\":\"b67\"},\"end\":6855,\"start\":6833},{\"attributes\":{\"ref_id\":\"b57\"},\"end\":6878,\"start\":6855},{\"attributes\":{\"ref_id\":\"b33\"},\"end\":7015,\"start\":6994},{\"attributes\":{\"ref_id\":\"b13\"},\"end\":7038,\"start\":7015},{\"attributes\":{\"ref_id\":\"b12\"},\"end\":7057,\"start\":7038},{\"attributes\":{\"ref_id\":\"b66\"},\"end\":7155,\"start\":7133},{\"attributes\":{\"ref_id\":\"b42\"},\"end\":7201,\"start\":7175},{\"attributes\":{\"ref_id\":\"b57\"},\"end\":7236,\"start\":7212},{\"attributes\":{\"ref_id\":\"b60\"},\"end\":7257,\"start\":7236},{\"attributes\":{\"ref_id\":\"b71\"},\"end\":7305,\"start\":7277},{\"attributes\":{\"ref_id\":\"b6\"},\"end\":7340,\"start\":7321},{\"attributes\":{\"ref_id\":\"b18\"},\"end\":7402,\"start\":7374},{\"attributes\":{\"ref_id\":\"b62\"},\"end\":7730,\"start\":7701},{\"attributes\":{\"ref_id\":\"b22\"},\"end\":7752,\"start\":7730},{\"attributes\":{\"ref_id\":\"b5\"},\"end\":7770,\"start\":7752},{\"attributes\":{\"ref_id\":\"b80\"},\"end\":7937,\"start\":7916},{\"attributes\":{\"ref_id\":\"b0\"},\"end\":7962,\"start\":7937},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":8116,\"start\":8093},{\"attributes\":{\"ref_id\":\"b75\"},\"end\":8244,\"start\":8215},{\"attributes\":{\"ref_id\":\"b54\"},\"end\":8371,\"start\":8347},{\"attributes\":{\"ref_id\":\"b74\"},\"end\":8389,\"start\":8371},{\"attributes\":{\"ref_id\":\"b15\"},\"end\":8659,\"start\":8646},{\"attributes\":{\"ref_id\":\"b55\"},\"end\":8883,\"start\":8867},{\"attributes\":{\"ref_id\":\"b61\"},\"end\":9319,\"start\":9298},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":12575,\"start\":12553},{\"attributes\":{\"ref_id\":\"b77\"},\"end\":12877,\"start\":12855},{\"attributes\":{\"ref_id\":\"b64\"},\"end\":13375,\"start\":13362},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":13391,\"start\":13375},{\"attributes\":{\"ref_id\":\"b8\"},\"end\":13410,\"start\":13391},{\"attributes\":{\"ref_id\":\"b39\"},\"end\":13900,\"start\":13886},{\"attributes\":{\"ref_id\":\"b38\"},\"end\":14338,\"start\":14323},{\"attributes\":{\"ref_id\":\"b17\"},\"end\":14357,\"start\":14338},{\"attributes\":{\"ref_id\":\"b40\"},\"end\":14969,\"start\":14947},{\"attributes\":{\"ref_id\":\"b17\"},\"end\":14988,\"start\":14969},{\"attributes\":{\"ref_id\":\"b82\"},\"end\":15006,\"start\":14988},{\"attributes\":{\"ref_id\":\"b45\"},\"end\":15047,\"start\":15029},{\"attributes\":{\"ref_id\":\"b58\"},\"end\":15097,\"start\":15078},{\"attributes\":{\"ref_id\":\"b71\"},\"end\":15152,\"start\":15124},{\"attributes\":{\"ref_id\":\"b46\"},\"end\":15199,\"start\":15174},{\"attributes\":{\"ref_id\":\"b47\"},\"end\":15219,\"start\":15199},{\"attributes\":{\"ref_id\":\"b30\"},\"end\":15260,\"start\":15239},{\"attributes\":{\"ref_id\":\"b66\"},\"end\":15293,\"start\":15271},{\"attributes\":{\"ref_id\":\"b24\"},\"end\":15336,\"start\":15306},{\"attributes\":{\"ref_id\":\"b23\"},\"end\":15379,\"start\":15350},{\"attributes\":{\"ref_id\":\"b76\"},\"end\":15423,\"start\":15402},{\"attributes\":{\"ref_id\":\"b70\"},\"end\":15558,\"start\":15534},{\"attributes\":{\"ref_id\":\"b29\"},\"end\":15988,\"start\":15968},{\"attributes\":{\"ref_id\":\"b31\"},\"end\":16029,\"start\":16008},{\"attributes\":{\"ref_id\":\"b57\"},\"end\":16096,\"start\":16072},{\"attributes\":{\"ref_id\":\"b59\"},\"end\":16196,\"start\":16173},{\"attributes\":{\"ref_id\":\"b29\"},\"end\":16251,\"start\":16230},{\"attributes\":{\"ref_id\":\"b16\"},\"end\":16418,\"start\":16396},{\"attributes\":{\"ref_id\":\"b55\"},\"end\":17271,\"start\":17255},{\"attributes\":{\"ref_id\":\"b61\"},\"end\":17917,\"start\":17897},{\"attributes\":{\"ref_id\":\"b72\"},\"end\":20697,\"start\":20672},{\"attributes\":{\"ref_id\":\"b19\"},\"end\":20710,\"start\":20697},{\"attributes\":{\"ref_id\":\"b78\"},\"end\":20729,\"start\":20710},{\"attributes\":{\"ref_id\":\"b14\"},\"end\":28324,\"start\":28298},{\"attributes\":{\"ref_id\":\"b36\"},\"end\":28340,\"start\":28324},{\"attributes\":{\"ref_id\":\"b21\"},\"end\":46166,\"start\":46143},{\"attributes\":{\"ref_id\":\"b35\"},\"end\":46185,\"start\":46166},{\"attributes\":{\"ref_id\":\"b65\"},\"end\":46207,\"start\":46185},{\"attributes\":{\"ref_id\":\"b52\"},\"end\":46655,\"start\":46639},{\"attributes\":{\"ref_id\":\"b33\"},\"end\":46677,\"start\":46657},{\"attributes\":{\"ref_id\":\"b34\"},\"end\":46832,\"start\":46812},{\"attributes\":{\"ref_id\":\"b27\"},\"end\":47883,\"start\":47862},{\"attributes\":{\"ref_id\":\"b3\"},\"end\":48110,\"start\":48089},{\"attributes\":{\"ref_id\":\"b49\"},\"end\":48217,\"start\":48193},{\"attributes\":{\"ref_id\":\"b20\"},\"end\":48999,\"start\":48977},{\"attributes\":{\"ref_id\":\"b27\"},\"end\":49019,\"start\":48999},{\"attributes\":{\"ref_id\":\"b27\"},\"end\":50986,\"start\":50966},{\"attributes\":{\"ref_id\":\"b50\"},\"end\":53974,\"start\":53950},{\"attributes\":{\"ref_id\":\"b3\"},\"end\":53994,\"start\":53974},{\"attributes\":{\"ref_id\":\"b49\"},\"end\":54186,\"start\":54162},{\"attributes\":{\"ref_id\":\"b73\"},\"end\":67486,\"start\":67468},{\"attributes\":{\"ref_id\":\"b41\"},\"end\":69364,\"start\":69336},{\"attributes\":{\"ref_id\":\"b41\"},\"end\":69477,\"start\":69450},{\"attributes\":{\"ref_id\":\"b48\"},\"end\":69499,\"start\":69479},{\"attributes\":{\"ref_id\":\"b77\"},\"end\":72641,\"start\":72619}]", "figure": "[{\"attributes\":{\"id\":\"fig_0\"},\"end\":77615,\"start\":77468},{\"attributes\":{\"id\":\"fig_1\"},\"end\":77755,\"start\":77616},{\"attributes\":{\"id\":\"fig_2\"},\"end\":77918,\"start\":77756},{\"attributes\":{\"id\":\"fig_3\"},\"end\":78071,\"start\":77919},{\"attributes\":{\"id\":\"fig_4\"},\"end\":78284,\"start\":78072},{\"attributes\":{\"id\":\"fig_5\"},\"end\":78457,\"start\":78285},{\"attributes\":{\"id\":\"fig_6\"},\"end\":78598,\"start\":78458},{\"attributes\":{\"id\":\"fig_7\"},\"end\":78815,\"start\":78599},{\"attributes\":{\"id\":\"fig_8\"},\"end\":79021,\"start\":78816},{\"attributes\":{\"id\":\"fig_9\"},\"end\":79195,\"start\":79022},{\"attributes\":{\"id\":\"fig_10\"},\"end\":79403,\"start\":79196},{\"attributes\":{\"id\":\"fig_11\"},\"end\":79569,\"start\":79404},{\"attributes\":{\"id\":\"fig_12\"},\"end\":79927,\"start\":79570}]", "paragraph": "[{\"end\":4437,\"start\":3497},{\"end\":5438,\"start\":4439},{\"end\":7058,\"start\":5440},{\"end\":8483,\"start\":7060},{\"end\":9629,\"start\":8485},{\"end\":10123,\"start\":9631},{\"end\":10240,\"start\":10125},{\"end\":11423,\"start\":10242},{\"end\":11552,\"start\":11425},{\"end\":11869,\"start\":11554},{\"end\":13226,\"start\":11871},{\"end\":13658,\"start\":13228},{\"end\":16252,\"start\":13674},{\"end\":17245,\"start\":16254},{\"end\":17887,\"start\":17247},{\"end\":18824,\"start\":17889},{\"end\":19001,\"start\":18856},{\"end\":19400,\"start\":19003},{\"end\":19957,\"start\":19402},{\"end\":20351,\"start\":19959},{\"end\":20547,\"start\":20353},{\"end\":21174,\"start\":20575},{\"end\":21608,\"start\":21176},{\"end\":22393,\"start\":21610},{\"end\":23091,\"start\":22435},{\"end\":23362,\"start\":23191},{\"end\":23600,\"start\":23391},{\"end\":24224,\"start\":23602},{\"end\":24589,\"start\":24226},{\"end\":24943,\"start\":24662},{\"end\":25333,\"start\":24972},{\"end\":25747,\"start\":25365},{\"end\":26146,\"start\":25770},{\"end\":26829,\"start\":26166},{\"end\":27109,\"start\":26866},{\"end\":27752,\"start\":27111},{\"end\":28056,\"start\":27754},{\"end\":29131,\"start\":28084},{\"end\":29415,\"start\":29133},{\"end\":29948,\"start\":29435},{\"end\":30417,\"start\":30064},{\"end\":31112,\"start\":30419},{\"end\":31692,\"start\":31114},{\"end\":31819,\"start\":31694},{\"end\":31986,\"start\":31862},{\"end\":33231,\"start\":31988},{\"end\":33759,\"start\":33257},{\"end\":33905,\"start\":33761},{\"end\":34120,\"start\":33926},{\"end\":34395,\"start\":34204},{\"end\":34689,\"start\":34431},{\"end\":36272,\"start\":34721},{\"end\":36844,\"start\":36303},{\"end\":37424,\"start\":36888},{\"end\":37909,\"start\":37518},{\"end\":38089,\"start\":37911},{\"end\":38497,\"start\":38091},{\"end\":38655,\"start\":38518},{\"end\":38977,\"start\":38731},{\"end\":39242,\"start\":39000},{\"end\":39932,\"start\":39267},{\"end\":40952,\"start\":39934},{\"end\":41137,\"start\":40954},{\"end\":41269,\"start\":41163},{\"end\":41554,\"start\":41363},{\"end\":41971,\"start\":41556},{\"end\":42098,\"start\":42017},{\"end\":43055,\"start\":42100},{\"end\":44136,\"start\":43074},{\"end\":44578,\"start\":44138},{\"end\":44705,\"start\":44580},{\"end\":45340,\"start\":44856},{\"end\":45430,\"start\":45378},{\"end\":45763,\"start\":45606},{\"end\":47411,\"start\":45802},{\"end\":48854,\"start\":47445},{\"end\":49786,\"start\":48856},{\"end\":50016,\"start\":49847},{\"end\":50807,\"start\":50036},{\"end\":51388,\"start\":50809},{\"end\":52366,\"start\":51390},{\"end\":52993,\"start\":52415},{\"end\":53470,\"start\":52995},{\"end\":57949,\"start\":53472},{\"end\":60512,\"start\":58000},{\"end\":61641,\"start\":60543},{\"end\":62297,\"start\":61690},{\"end\":62816,\"start\":62299},{\"end\":63755,\"start\":62818},{\"end\":64720,\"start\":63757},{\"end\":65723,\"start\":64722},{\"end\":66799,\"start\":65725},{\"end\":67782,\"start\":66820},{\"end\":70243,\"start\":67784},{\"end\":72295,\"start\":70269},{\"end\":73284,\"start\":72325},{\"end\":74614,\"start\":73286},{\"end\":75458,\"start\":74616},{\"end\":76235,\"start\":75460},{\"end\":76461,\"start\":76237},{\"end\":77271,\"start\":76476},{\"end\":77467,\"start\":77303}]", "formula": "[{\"attributes\":{\"id\":\"formula_0\"},\"end\":23190,\"start\":23123},{\"attributes\":{\"id\":\"formula_1\"},\"end\":23390,\"start\":23363},{\"attributes\":{\"id\":\"formula_2\"},\"end\":24661,\"start\":24590},{\"attributes\":{\"id\":\"formula_3\"},\"end\":24971,\"start\":24944},{\"attributes\":{\"id\":\"formula_4\"},\"end\":25769,\"start\":25748},{\"attributes\":{\"id\":\"formula_5\"},\"end\":26865,\"start\":26830},{\"attributes\":{\"id\":\"formula_6\"},\"end\":29434,\"start\":29416},{\"attributes\":{\"id\":\"formula_7\"},\"end\":30063,\"start\":29949},{\"attributes\":{\"id\":\"formula_8\"},\"end\":33925,\"start\":33906},{\"attributes\":{\"id\":\"formula_9\"},\"end\":34203,\"start\":34121},{\"attributes\":{\"id\":\"formula_10\"},\"end\":34430,\"start\":34396},{\"attributes\":{\"id\":\"formula_11\"},\"end\":34720,\"start\":34690},{\"attributes\":{\"id\":\"formula_12\"},\"end\":36887,\"start\":36845},{\"attributes\":{\"id\":\"formula_13\"},\"end\":37517,\"start\":37425},{\"attributes\":{\"id\":\"formula_14\"},\"end\":38517,\"start\":38498},{\"attributes\":{\"id\":\"formula_15\"},\"end\":38730,\"start\":38656},{\"attributes\":{\"id\":\"formula_16\"},\"end\":38999,\"start\":38978},{\"attributes\":{\"id\":\"formula_17\"},\"end\":41162,\"start\":41138},{\"attributes\":{\"id\":\"formula_18\"},\"end\":41362,\"start\":41270},{\"attributes\":{\"id\":\"formula_19\"},\"end\":42016,\"start\":41972},{\"attributes\":{\"id\":\"formula_20\"},\"end\":44855,\"start\":44706},{\"attributes\":{\"id\":\"formula_21\"},\"end\":45377,\"start\":45341},{\"attributes\":{\"id\":\"formula_22\"},\"end\":45605,\"start\":45431},{\"attributes\":{\"id\":\"formula_23\"},\"end\":49846,\"start\":49787}]", "table_ref": null, "section_header": "[{\"attributes\":{\"n\":\"1.\"},\"end\":3495,\"start\":3483},{\"attributes\":{\"n\":\"2.\"},\"end\":13672,\"start\":13661},{\"attributes\":{\"n\":\"2.1.\"},\"end\":18854,\"start\":18827},{\"attributes\":{\"n\":\"2.2.\"},\"end\":20573,\"start\":20550},{\"attributes\":{\"n\":\"3.\"},\"end\":22433,\"start\":22396},{\"attributes\":{\"n\":\"3.1.\"},\"end\":23122,\"start\":23094},{\"attributes\":{\"n\":\"3.2.\"},\"end\":25363,\"start\":25336},{\"attributes\":{\"n\":\"3.3.\"},\"end\":26164,\"start\":26149},{\"attributes\":{\"n\":\"3.4.\"},\"end\":28082,\"start\":28059},{\"attributes\":{\"n\":\"4.\"},\"end\":31860,\"start\":31822},{\"attributes\":{\"n\":\"4.1.\"},\"end\":33255,\"start\":33234},{\"attributes\":{\"n\":\"4.2.\"},\"end\":36301,\"start\":36275},{\"attributes\":{\"n\":\"4.3.\"},\"end\":39265,\"start\":39245},{\"attributes\":{\"n\":\"4.4.\"},\"end\":43072,\"start\":43058},{\"attributes\":{\"n\":\"5.\"},\"end\":45800,\"start\":45766},{\"attributes\":{\"n\":\"5.1.\"},\"end\":47443,\"start\":47414},{\"attributes\":{\"n\":\"5.2.\"},\"end\":50034,\"start\":50019},{\"attributes\":{\"n\":\"6.\"},\"end\":52392,\"start\":52369},{\"attributes\":{\"n\":\"6.1.\"},\"end\":52413,\"start\":52395},{\"attributes\":{\"n\":\"6.2.\"},\"end\":57975,\"start\":57952},{\"attributes\":{\"n\":\"6.3.\"},\"end\":57998,\"start\":57978},{\"attributes\":{\"n\":\"6.4.\"},\"end\":60541,\"start\":60515},{\"attributes\":{\"n\":\"6.5.\"},\"end\":61658,\"start\":61644},{\"attributes\":{\"n\":\"6.6.\"},\"end\":61688,\"start\":61661},{\"attributes\":{\"n\":\"6.7.\"},\"end\":66818,\"start\":66802},{\"attributes\":{\"n\":\"6.8.\"},\"end\":70267,\"start\":70246},{\"attributes\":{\"n\":\"6.9.\"},\"end\":72323,\"start\":72298},{\"attributes\":{\"n\":\"7.\"},\"end\":76474,\"start\":76464},{\"end\":77301,\"start\":77274},{\"end\":77479,\"start\":77469},{\"end\":77627,\"start\":77617},{\"end\":77767,\"start\":77757},{\"end\":77930,\"start\":77920},{\"end\":78083,\"start\":78073},{\"end\":78296,\"start\":78286},{\"end\":78469,\"start\":78459},{\"end\":78610,\"start\":78600},{\"end\":78828,\"start\":78817},{\"end\":79034,\"start\":79023},{\"end\":79208,\"start\":79197},{\"end\":79416,\"start\":79405},{\"end\":79582,\"start\":79571}]", "table": null, "figure_caption": "[{\"end\":77615,\"start\":77481},{\"end\":77755,\"start\":77629},{\"end\":77918,\"start\":77769},{\"end\":78071,\"start\":77932},{\"end\":78284,\"start\":78085},{\"end\":78457,\"start\":78298},{\"end\":78598,\"start\":78471},{\"end\":78815,\"start\":78612},{\"end\":79021,\"start\":78831},{\"end\":79195,\"start\":79037},{\"end\":79403,\"start\":79211},{\"end\":79569,\"start\":79419},{\"end\":79927,\"start\":79585}]", "figure_ref": "[{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":21752,\"start\":21744},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":21856,\"start\":21846},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":22146,\"start\":22136},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":22391,\"start\":22382},{\"attributes\":{\"ref_id\":\"fig_1\"},\"end\":22881,\"start\":22873},{\"attributes\":{\"ref_id\":\"fig_1\"},\"end\":23035,\"start\":23024},{\"attributes\":{\"ref_id\":\"fig_1\"},\"end\":23774,\"start\":23765},{\"attributes\":{\"ref_id\":\"fig_1\"},\"end\":24587,\"start\":24578},{\"attributes\":{\"ref_id\":\"fig_2\"},\"end\":26366,\"start\":26358},{\"attributes\":{\"ref_id\":\"fig_2\"},\"end\":27440,\"start\":27431},{\"attributes\":{\"ref_id\":\"fig_2\"},\"end\":27865,\"start\":27856},{\"attributes\":{\"ref_id\":\"fig_3\"},\"end\":35302,\"start\":35293},{\"attributes\":{\"ref_id\":\"fig_3\"},\"end\":35741,\"start\":35732},{\"attributes\":{\"ref_id\":\"fig_4\"},\"end\":36657,\"start\":36649},{\"attributes\":{\"ref_id\":\"fig_5\"},\"end\":40239,\"start\":40231},{\"end\":41096,\"start\":41090},{\"end\":41923,\"start\":41917},{\"attributes\":{\"ref_id\":\"fig_6\"},\"end\":42262,\"start\":42254},{\"attributes\":{\"ref_id\":\"fig_7\"},\"end\":47690,\"start\":47681},{\"attributes\":{\"ref_id\":\"fig_7\"},\"end\":48228,\"start\":48219},{\"attributes\":{\"ref_id\":\"fig_7\"},\"end\":50329,\"start\":50320},{\"attributes\":{\"ref_id\":\"fig_7\"},\"end\":50657,\"start\":50648},{\"attributes\":{\"ref_id\":\"fig_7\"},\"end\":51576,\"start\":51565},{\"end\":54196,\"start\":54188},{\"end\":55074,\"start\":55063},{\"attributes\":{\"ref_id\":\"fig_3\"},\"end\":55389,\"start\":55379},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":55471,\"start\":55461},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":55853,\"start\":55843},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":56596,\"start\":56586},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":57008,\"start\":56998},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":57197,\"start\":57187},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":58416,\"start\":58406},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":58867,\"start\":58857},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":59888,\"start\":59878},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":60208,\"start\":60198},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":60502,\"start\":60492},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":60698,\"start\":60688},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":60942,\"start\":60933},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":65150,\"start\":65140},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":69210,\"start\":69200},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":70472,\"start\":70462},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":74629,\"start\":74619},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":75111,\"start\":75101},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":75472,\"start\":75463},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":75647,\"start\":75637},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":75822,\"start\":75812},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":75990,\"start\":75976}]", "bib_author_first_name": "[{\"end\":80489,\"start\":80488},{\"end\":80491,\"start\":80490},{\"end\":80502,\"start\":80501},{\"end\":80726,\"start\":80725},{\"end\":80737,\"start\":80736},{\"end\":80749,\"start\":80748},{\"end\":80763,\"start\":80762},{\"end\":80773,\"start\":80772},{\"end\":80775,\"start\":80774},{\"end\":80786,\"start\":80785},{\"end\":81143,\"start\":81142},{\"end\":81149,\"start\":81148},{\"end\":81159,\"start\":81158},{\"end\":81168,\"start\":81167},{\"end\":81196,\"start\":81184},{\"end\":81200,\"start\":81199},{\"end\":81680,\"start\":81679},{\"end\":81690,\"start\":81689},{\"end\":81699,\"start\":81698},{\"end\":81711,\"start\":81710},{\"end\":81721,\"start\":81720},{\"end\":82056,\"start\":82055},{\"end\":82066,\"start\":82065},{\"end\":82076,\"start\":82075},{\"end\":82091,\"start\":82082},{\"end\":82095,\"start\":82094},{\"end\":82556,\"start\":82555},{\"end\":82558,\"start\":82557},{\"end\":82566,\"start\":82565},{\"end\":82568,\"start\":82567},{\"end\":82584,\"start\":82576},{\"end\":82588,\"start\":82587},{\"end\":82590,\"start\":82589},{\"end\":82952,\"start\":82951},{\"end\":82960,\"start\":82959},{\"end\":82969,\"start\":82968},{\"end\":83314,\"start\":83310},{\"end\":83324,\"start\":83321},{\"end\":83328,\"start\":83327},{\"end\":83600,\"start\":83599},{\"end\":83602,\"start\":83601},{\"end\":83611,\"start\":83610},{\"end\":83626,\"start\":83625},{\"end\":83637,\"start\":83636},{\"end\":84035,\"start\":84031},{\"end\":84037,\"start\":84036},{\"end\":84046,\"start\":84045},{\"end\":84048,\"start\":84047},{\"end\":84269,\"start\":84268},{\"end\":84284,\"start\":84283},{\"end\":84297,\"start\":84293},{\"end\":84632,\"start\":84631},{\"end\":84634,\"start\":84633},{\"end\":84644,\"start\":84643},{\"end\":84646,\"start\":84645},{\"end\":84833,\"start\":84832},{\"end\":84835,\"start\":84834},{\"end\":84844,\"start\":84843},{\"end\":84854,\"start\":84853},{\"end\":84856,\"start\":84855},{\"end\":85253,\"start\":85252},{\"end\":85255,\"start\":85254},{\"end\":85264,\"start\":85263},{\"end\":85266,\"start\":85265},{\"end\":85586,\"start\":85585},{\"end\":85588,\"start\":85587},{\"end\":85601,\"start\":85600},{\"end\":85603,\"start\":85602},{\"end\":85886,\"start\":85885},{\"end\":85888,\"start\":85887},{\"end\":86059,\"start\":86058},{\"end\":86061,\"start\":86060},{\"end\":86071,\"start\":86070},{\"end\":86073,\"start\":86072},{\"end\":86443,\"start\":86442},{\"end\":86449,\"start\":86448},{\"end\":86451,\"start\":86450},{\"end\":86737,\"start\":86736},{\"end\":86739,\"start\":86738},{\"end\":86757,\"start\":86750},{\"end\":86761,\"start\":86760},{\"end\":87126,\"start\":87125},{\"end\":87484,\"start\":87483},{\"end\":87495,\"start\":87494},{\"end\":87506,\"start\":87505},{\"end\":87514,\"start\":87513},{\"end\":87920,\"start\":87919},{\"end\":87932,\"start\":87931},{\"end\":87942,\"start\":87941},{\"end\":87952,\"start\":87951},{\"end\":87962,\"start\":87961},{\"end\":87978,\"start\":87970},{\"end\":87982,\"start\":87981},{\"end\":88294,\"start\":88293},{\"end\":88306,\"start\":88305},{\"end\":88317,\"start\":88316},{\"end\":88332,\"start\":88331},{\"end\":88631,\"start\":88630},{\"end\":88649,\"start\":88648},{\"end\":88662,\"start\":88661},{\"end\":89054,\"start\":89053},{\"end\":89072,\"start\":89071},{\"end\":89080,\"start\":89079},{\"end\":89087,\"start\":89086},{\"end\":89452,\"start\":89451},{\"end\":89470,\"start\":89469},{\"end\":89478,\"start\":89477},{\"end\":89485,\"start\":89484},{\"end\":89869,\"start\":89868},{\"end\":89878,\"start\":89877},{\"end\":89887,\"start\":89886},{\"end\":89894,\"start\":89893},{\"end\":90335,\"start\":90334},{\"end\":90344,\"start\":90343},{\"end\":90351,\"start\":90350},{\"end\":90360,\"start\":90359},{\"end\":90372,\"start\":90371},{\"end\":90379,\"start\":90378},{\"end\":90797,\"start\":90796},{\"end\":90806,\"start\":90805},{\"end\":90814,\"start\":90813},{\"end\":90824,\"start\":90823},{\"end\":91240,\"start\":91239},{\"end\":91249,\"start\":91248},{\"end\":91259,\"start\":91258},{\"end\":91271,\"start\":91270},{\"end\":91278,\"start\":91277},{\"end\":91286,\"start\":91285},{\"end\":91768,\"start\":91767},{\"end\":91777,\"start\":91776},{\"end\":91788,\"start\":91787},{\"end\":91797,\"start\":91796},{\"end\":91805,\"start\":91804},{\"end\":91812,\"start\":91811},{\"end\":92233,\"start\":92232},{\"end\":92242,\"start\":92241},{\"end\":92252,\"start\":92251},{\"end\":92260,\"start\":92259},{\"end\":92270,\"start\":92269},{\"end\":92272,\"start\":92271},{\"end\":92698,\"start\":92697},{\"end\":92707,\"start\":92706},{\"end\":92714,\"start\":92713},{\"end\":92726,\"start\":92725},{\"end\":92735,\"start\":92734},{\"end\":92746,\"start\":92745},{\"end\":92748,\"start\":92747},{\"end\":93177,\"start\":93176},{\"end\":93186,\"start\":93185},{\"end\":93193,\"start\":93192},{\"end\":93202,\"start\":93201},{\"end\":93217,\"start\":93216},{\"end\":93228,\"start\":93227},{\"end\":93678,\"start\":93677},{\"end\":93684,\"start\":93683},{\"end\":93697,\"start\":93696},{\"end\":93711,\"start\":93710},{\"end\":93994,\"start\":93993},{\"end\":93996,\"start\":93995},{\"end\":94006,\"start\":94005},{\"end\":94015,\"start\":94014},{\"end\":94024,\"start\":94023},{\"end\":94037,\"start\":94036},{\"end\":94048,\"start\":94047},{\"end\":94463,\"start\":94462},{\"end\":94736,\"start\":94735},{\"end\":95053,\"start\":95052},{\"end\":95064,\"start\":95063},{\"end\":95081,\"start\":95080},{\"end\":95541,\"start\":95540},{\"end\":95553,\"start\":95552},{\"end\":96032,\"start\":96031},{\"end\":96047,\"start\":96046},{\"end\":96059,\"start\":96058},{\"end\":96070,\"start\":96069},{\"end\":96083,\"start\":96082},{\"end\":96093,\"start\":96092},{\"end\":96516,\"start\":96515},{\"end\":96523,\"start\":96522},{\"end\":96532,\"start\":96531},{\"end\":96543,\"start\":96542},{\"end\":96949,\"start\":96948},{\"end\":96956,\"start\":96955},{\"end\":96965,\"start\":96964},{\"end\":96967,\"start\":96966},{\"end\":97394,\"start\":97393},{\"end\":97404,\"start\":97403},{\"end\":97810,\"start\":97809},{\"end\":97820,\"start\":97819},{\"end\":97830,\"start\":97829},{\"end\":97850,\"start\":97849},{\"end\":98231,\"start\":98230},{\"end\":98241,\"start\":98240},{\"end\":98254,\"start\":98253},{\"end\":98256,\"start\":98255},{\"end\":98264,\"start\":98263},{\"end\":98274,\"start\":98273},{\"end\":98283,\"start\":98282},{\"end\":98285,\"start\":98284},{\"end\":98621,\"start\":98620},{\"end\":98634,\"start\":98633},{\"end\":98646,\"start\":98645},{\"end\":98655,\"start\":98654},{\"end\":98664,\"start\":98663},{\"end\":98672,\"start\":98671},{\"end\":98674,\"start\":98673},{\"end\":98995,\"start\":98994},{\"end\":99008,\"start\":99007},{\"end\":99019,\"start\":99018},{\"end\":99021,\"start\":99020},{\"end\":99033,\"start\":99032},{\"end\":99389,\"start\":99388},{\"end\":99396,\"start\":99395},{\"end\":99773,\"start\":99772},{\"end\":99779,\"start\":99778},{\"end\":99781,\"start\":99780},{\"end\":99787,\"start\":99786},{\"end\":99800,\"start\":99796},{\"end\":99806,\"start\":99805},{\"end\":99818,\"start\":99814},{\"end\":100246,\"start\":100242},{\"end\":100253,\"start\":100252},{\"end\":100262,\"start\":100261},{\"end\":100274,\"start\":100273},{\"end\":100282,\"start\":100281},{\"end\":100292,\"start\":100291},{\"end\":100603,\"start\":100602},{\"end\":100616,\"start\":100615},{\"end\":100626,\"start\":100625},{\"end\":100641,\"start\":100640},{\"end\":100929,\"start\":100928},{\"end\":100935,\"start\":100934},{\"end\":100950,\"start\":100949},{\"end\":100959,\"start\":100958},{\"end\":101138,\"start\":101137},{\"end\":101154,\"start\":101153},{\"end\":101164,\"start\":101163},{\"end\":101173,\"start\":101172},{\"end\":101183,\"start\":101182},{\"end\":101192,\"start\":101191},{\"end\":101513,\"start\":101512},{\"end\":101526,\"start\":101525},{\"end\":101546,\"start\":101537},{\"end\":101548,\"start\":101547},{\"end\":101897,\"start\":101896},{\"end\":101905,\"start\":101904},{\"end\":101913,\"start\":101912},{\"end\":101923,\"start\":101922},{\"end\":101932,\"start\":101931},{\"end\":101943,\"start\":101942},{\"end\":102348,\"start\":102347},{\"end\":102360,\"start\":102359},{\"end\":102370,\"start\":102369},{\"end\":102381,\"start\":102380},{\"end\":102390,\"start\":102389},{\"end\":102816,\"start\":102815},{\"end\":102827,\"start\":102826},{\"end\":102839,\"start\":102838},{\"end\":103121,\"start\":103120},{\"end\":103131,\"start\":103130},{\"end\":103142,\"start\":103141},{\"end\":103535,\"start\":103534},{\"end\":103537,\"start\":103536},{\"end\":103554,\"start\":103553},{\"end\":103816,\"start\":103815},{\"end\":103827,\"start\":103826},{\"end\":103838,\"start\":103837},{\"end\":104091,\"start\":104090},{\"end\":104342,\"start\":104341},{\"end\":104353,\"start\":104352},{\"end\":104360,\"start\":104359},{\"end\":104370,\"start\":104369},{\"end\":104382,\"start\":104381},{\"end\":104786,\"start\":104785},{\"end\":104797,\"start\":104796},{\"end\":104804,\"start\":104803},{\"end\":104811,\"start\":104810},{\"end\":104824,\"start\":104823},{\"end\":105226,\"start\":105225},{\"end\":105236,\"start\":105235},{\"end\":105247,\"start\":105246},{\"end\":105258,\"start\":105257},{\"end\":105268,\"start\":105267},{\"end\":105270,\"start\":105269},{\"end\":105772,\"start\":105771},{\"end\":105782,\"start\":105781},{\"end\":105793,\"start\":105792},{\"end\":105803,\"start\":105802},{\"end\":105805,\"start\":105804},{\"end\":106207,\"start\":106206},{\"end\":106217,\"start\":106216},{\"end\":106228,\"start\":106227},{\"end\":106230,\"start\":106229},{\"end\":106511,\"start\":106510},{\"end\":106525,\"start\":106524},{\"end\":106531,\"start\":106530},{\"end\":106543,\"start\":106542},{\"end\":106552,\"start\":106551},{\"end\":106560,\"start\":106559},{\"end\":107005,\"start\":107004},{\"end\":107007,\"start\":107006},{\"end\":107018,\"start\":107017},{\"end\":107020,\"start\":107019},{\"end\":107430,\"start\":107429},{\"end\":107432,\"start\":107431},{\"end\":107446,\"start\":107445},{\"end\":107448,\"start\":107447},{\"end\":107458,\"start\":107457},{\"end\":107460,\"start\":107459},{\"end\":107472,\"start\":107471},{\"end\":107474,\"start\":107473},{\"end\":107840,\"start\":107839},{\"end\":107847,\"start\":107846},{\"end\":107853,\"start\":107852},{\"end\":107865,\"start\":107864},{\"end\":108146,\"start\":108145},{\"end\":108154,\"start\":108153},{\"end\":108165,\"start\":108164},{\"end\":108178,\"start\":108177},{\"end\":108185,\"start\":108184},{\"end\":108187,\"start\":108186},{\"end\":108516,\"start\":108515},{\"end\":108518,\"start\":108517},{\"end\":108530,\"start\":108529},{\"end\":108532,\"start\":108531},{\"end\":108797,\"start\":108796},{\"end\":108808,\"start\":108807},{\"end\":108818,\"start\":108817},{\"end\":108820,\"start\":108819},{\"end\":108828,\"start\":108827},{\"end\":108838,\"start\":108837},{\"end\":108842,\"start\":108839},{\"end\":108856,\"start\":108855},{\"end\":108867,\"start\":108866},{\"end\":109449,\"start\":109448},{\"end\":109463,\"start\":109459},{\"end\":109471,\"start\":109470},{\"end\":109916,\"start\":109915},{\"end\":109918,\"start\":109917},{\"end\":109927,\"start\":109926},{\"end\":109929,\"start\":109928},{\"end\":109937,\"start\":109936},{\"end\":109948,\"start\":109947},{\"end\":109950,\"start\":109949},{\"end\":109967,\"start\":109966},{\"end\":109969,\"start\":109968},{\"end\":109977,\"start\":109976},{\"end\":110333,\"start\":110332},{\"end\":110351,\"start\":110350},{\"end\":110628,\"start\":110627},{\"end\":110630,\"start\":110629},{\"end\":110640,\"start\":110639},{\"end\":110650,\"start\":110649},{\"end\":110652,\"start\":110651},{\"end\":111023,\"start\":111022},{\"end\":111030,\"start\":111029},{\"end\":111045,\"start\":111044},{\"end\":111054,\"start\":111053},{\"end\":111061,\"start\":111060},{\"end\":111389,\"start\":111388},{\"end\":111396,\"start\":111395},{\"end\":111403,\"start\":111402},{\"end\":111412,\"start\":111411},{\"end\":111427,\"start\":111426},{\"end\":111440,\"start\":111439}]", "bib_author_last_name": "[{\"end\":80499,\"start\":80492},{\"end\":80509,\"start\":80503},{\"end\":80734,\"start\":80727},{\"end\":80746,\"start\":80738},{\"end\":80760,\"start\":80750},{\"end\":80770,\"start\":80764},{\"end\":80783,\"start\":80776},{\"end\":80796,\"start\":80787},{\"end\":81146,\"start\":81144},{\"end\":81156,\"start\":81150},{\"end\":81165,\"start\":81160},{\"end\":81182,\"start\":81169},{\"end\":81687,\"start\":81681},{\"end\":81696,\"start\":81691},{\"end\":81708,\"start\":81700},{\"end\":81718,\"start\":81712},{\"end\":81731,\"start\":81722},{\"end\":82063,\"start\":82057},{\"end\":82073,\"start\":82067},{\"end\":82080,\"start\":82077},{\"end\":82563,\"start\":82559},{\"end\":82574,\"start\":82569},{\"end\":82957,\"start\":82953},{\"end\":82966,\"start\":82961},{\"end\":82975,\"start\":82970},{\"end\":83319,\"start\":83315},{\"end\":83608,\"start\":83603},{\"end\":83623,\"start\":83612},{\"end\":83634,\"start\":83627},{\"end\":83642,\"start\":83638},{\"end\":84043,\"start\":84038},{\"end\":84054,\"start\":84049},{\"end\":84281,\"start\":84270},{\"end\":84291,\"start\":84285},{\"end\":84303,\"start\":84298},{\"end\":84641,\"start\":84635},{\"end\":84655,\"start\":84647},{\"end\":84841,\"start\":84836},{\"end\":84851,\"start\":84845},{\"end\":84863,\"start\":84857},{\"end\":85261,\"start\":85256},{\"end\":85273,\"start\":85267},{\"end\":85598,\"start\":85589},{\"end\":85608,\"start\":85604},{\"end\":85895,\"start\":85889},{\"end\":86068,\"start\":86062},{\"end\":86078,\"start\":86074},{\"end\":86446,\"start\":86444},{\"end\":86457,\"start\":86452},{\"end\":86748,\"start\":86740},{\"end\":87133,\"start\":87127},{\"end\":87492,\"start\":87485},{\"end\":87503,\"start\":87496},{\"end\":87511,\"start\":87507},{\"end\":87524,\"start\":87515},{\"end\":87929,\"start\":87921},{\"end\":87939,\"start\":87933},{\"end\":87949,\"start\":87943},{\"end\":87959,\"start\":87953},{\"end\":87968,\"start\":87963},{\"end\":88303,\"start\":88295},{\"end\":88314,\"start\":88307},{\"end\":88329,\"start\":88318},{\"end\":88342,\"start\":88333},{\"end\":88646,\"start\":88632},{\"end\":88659,\"start\":88650},{\"end\":88668,\"start\":88663},{\"end\":89069,\"start\":89055},{\"end\":89077,\"start\":89073},{\"end\":89084,\"start\":89081},{\"end\":89093,\"start\":89088},{\"end\":89467,\"start\":89453},{\"end\":89475,\"start\":89471},{\"end\":89482,\"start\":89479},{\"end\":89491,\"start\":89486},{\"end\":89875,\"start\":89870},{\"end\":89884,\"start\":89879},{\"end\":89891,\"start\":89888},{\"end\":89901,\"start\":89895},{\"end\":90341,\"start\":90336},{\"end\":90348,\"start\":90345},{\"end\":90357,\"start\":90352},{\"end\":90369,\"start\":90361},{\"end\":90376,\"start\":90373},{\"end\":90390,\"start\":90380},{\"end\":90803,\"start\":90798},{\"end\":90811,\"start\":90807},{\"end\":90821,\"start\":90815},{\"end\":90831,\"start\":90825},{\"end\":91246,\"start\":91241},{\"end\":91256,\"start\":91250},{\"end\":91268,\"start\":91260},{\"end\":91275,\"start\":91272},{\"end\":91283,\"start\":91279},{\"end\":91293,\"start\":91287},{\"end\":91774,\"start\":91769},{\"end\":91785,\"start\":91778},{\"end\":91794,\"start\":91789},{\"end\":91802,\"start\":91798},{\"end\":91809,\"start\":91806},{\"end\":91819,\"start\":91813},{\"end\":92239,\"start\":92234},{\"end\":92249,\"start\":92243},{\"end\":92257,\"start\":92253},{\"end\":92267,\"start\":92261},{\"end\":92279,\"start\":92273},{\"end\":92704,\"start\":92699},{\"end\":92711,\"start\":92708},{\"end\":92723,\"start\":92715},{\"end\":92732,\"start\":92727},{\"end\":92743,\"start\":92736},{\"end\":92751,\"start\":92749},{\"end\":93183,\"start\":93178},{\"end\":93190,\"start\":93187},{\"end\":93199,\"start\":93194},{\"end\":93214,\"start\":93203},{\"end\":93225,\"start\":93218},{\"end\":93233,\"start\":93229},{\"end\":93681,\"start\":93679},{\"end\":93694,\"start\":93685},{\"end\":93708,\"start\":93698},{\"end\":93719,\"start\":93712},{\"end\":94003,\"start\":93997},{\"end\":94012,\"start\":94007},{\"end\":94021,\"start\":94016},{\"end\":94034,\"start\":94025},{\"end\":94045,\"start\":94038},{\"end\":94054,\"start\":94049},{\"end\":94471,\"start\":94464},{\"end\":94744,\"start\":94737},{\"end\":95061,\"start\":95054},{\"end\":95078,\"start\":95065},{\"end\":95087,\"start\":95082},{\"end\":95550,\"start\":95542},{\"end\":95561,\"start\":95554},{\"end\":96044,\"start\":96033},{\"end\":96056,\"start\":96048},{\"end\":96067,\"start\":96060},{\"end\":96080,\"start\":96071},{\"end\":96090,\"start\":96084},{\"end\":96103,\"start\":96094},{\"end\":96520,\"start\":96517},{\"end\":96529,\"start\":96524},{\"end\":96540,\"start\":96533},{\"end\":96550,\"start\":96544},{\"end\":96716,\"start\":96710},{\"end\":96953,\"start\":96950},{\"end\":96962,\"start\":96957},{\"end\":96974,\"start\":96968},{\"end\":97401,\"start\":97395},{\"end\":97411,\"start\":97405},{\"end\":97817,\"start\":97811},{\"end\":97827,\"start\":97821},{\"end\":97847,\"start\":97831},{\"end\":97858,\"start\":97851},{\"end\":98238,\"start\":98232},{\"end\":98251,\"start\":98242},{\"end\":98261,\"start\":98257},{\"end\":98271,\"start\":98265},{\"end\":98280,\"start\":98275},{\"end\":98293,\"start\":98286},{\"end\":98631,\"start\":98622},{\"end\":98643,\"start\":98635},{\"end\":98652,\"start\":98647},{\"end\":98661,\"start\":98656},{\"end\":98669,\"start\":98665},{\"end\":98683,\"start\":98675},{\"end\":99005,\"start\":98996},{\"end\":99016,\"start\":99009},{\"end\":99030,\"start\":99022},{\"end\":99041,\"start\":99034},{\"end\":99393,\"start\":99390},{\"end\":99400,\"start\":99397},{\"end\":99776,\"start\":99774},{\"end\":99784,\"start\":99782},{\"end\":99794,\"start\":99788},{\"end\":99803,\"start\":99801},{\"end\":99812,\"start\":99807},{\"end\":99822,\"start\":99819},{\"end\":100250,\"start\":100247},{\"end\":100259,\"start\":100254},{\"end\":100271,\"start\":100263},{\"end\":100279,\"start\":100275},{\"end\":100289,\"start\":100283},{\"end\":100300,\"start\":100293},{\"end\":100613,\"start\":100604},{\"end\":100623,\"start\":100617},{\"end\":100638,\"start\":100627},{\"end\":100647,\"start\":100642},{\"end\":100932,\"start\":100930},{\"end\":100947,\"start\":100936},{\"end\":100956,\"start\":100951},{\"end\":100965,\"start\":100960},{\"end\":101151,\"start\":101139},{\"end\":101161,\"start\":101155},{\"end\":101170,\"start\":101165},{\"end\":101180,\"start\":101174},{\"end\":101189,\"start\":101184},{\"end\":101199,\"start\":101193},{\"end\":101523,\"start\":101514},{\"end\":101535,\"start\":101527},{\"end\":101902,\"start\":101898},{\"end\":101910,\"start\":101906},{\"end\":101920,\"start\":101914},{\"end\":101929,\"start\":101924},{\"end\":101940,\"start\":101933},{\"end\":101954,\"start\":101944},{\"end\":102357,\"start\":102349},{\"end\":102367,\"start\":102361},{\"end\":102378,\"start\":102371},{\"end\":102387,\"start\":102382},{\"end\":102397,\"start\":102391},{\"end\":102824,\"start\":102817},{\"end\":102836,\"start\":102828},{\"end\":102847,\"start\":102840},{\"end\":103128,\"start\":103122},{\"end\":103139,\"start\":103132},{\"end\":103149,\"start\":103143},{\"end\":103551,\"start\":103538},{\"end\":103563,\"start\":103555},{\"end\":103824,\"start\":103817},{\"end\":103835,\"start\":103828},{\"end\":103845,\"start\":103839},{\"end\":104097,\"start\":104092},{\"end\":104350,\"start\":104343},{\"end\":104357,\"start\":104354},{\"end\":104367,\"start\":104361},{\"end\":104379,\"start\":104371},{\"end\":104388,\"start\":104383},{\"end\":104794,\"start\":104787},{\"end\":104801,\"start\":104798},{\"end\":104808,\"start\":104805},{\"end\":104821,\"start\":104812},{\"end\":104830,\"start\":104825},{\"end\":105233,\"start\":105227},{\"end\":105244,\"start\":105237},{\"end\":105255,\"start\":105248},{\"end\":105265,\"start\":105259},{\"end\":105277,\"start\":105271},{\"end\":105779,\"start\":105773},{\"end\":105790,\"start\":105783},{\"end\":105800,\"start\":105794},{\"end\":105812,\"start\":105806},{\"end\":106214,\"start\":106208},{\"end\":106225,\"start\":106218},{\"end\":106237,\"start\":106231},{\"end\":106522,\"start\":106512},{\"end\":106528,\"start\":106526},{\"end\":106540,\"start\":106532},{\"end\":106549,\"start\":106544},{\"end\":106557,\"start\":106553},{\"end\":106565,\"start\":106561},{\"end\":107015,\"start\":107008},{\"end\":107029,\"start\":107021},{\"end\":107443,\"start\":107433},{\"end\":107455,\"start\":107449},{\"end\":107469,\"start\":107461},{\"end\":107479,\"start\":107475},{\"end\":107844,\"start\":107841},{\"end\":107850,\"start\":107848},{\"end\":107862,\"start\":107854},{\"end\":107869,\"start\":107866},{\"end\":108151,\"start\":108147},{\"end\":108162,\"start\":108155},{\"end\":108175,\"start\":108166},{\"end\":108182,\"start\":108179},{\"end\":108192,\"start\":108188},{\"end\":108527,\"start\":108519},{\"end\":108541,\"start\":108533},{\"end\":108805,\"start\":108798},{\"end\":108815,\"start\":108809},{\"end\":108825,\"start\":108821},{\"end\":108835,\"start\":108829},{\"end\":108853,\"start\":108843},{\"end\":108864,\"start\":108857},{\"end\":108874,\"start\":108868},{\"end\":109457,\"start\":109450},{\"end\":109468,\"start\":109464},{\"end\":109481,\"start\":109472},{\"end\":109924,\"start\":109919},{\"end\":109934,\"start\":109930},{\"end\":109945,\"start\":109938},{\"end\":109964,\"start\":109951},{\"end\":109974,\"start\":109970},{\"end\":109987,\"start\":109978},{\"end\":110348,\"start\":110334},{\"end\":110357,\"start\":110352},{\"end\":110637,\"start\":110631},{\"end\":110647,\"start\":110641},{\"end\":110658,\"start\":110653},{\"end\":111027,\"start\":111024},{\"end\":111042,\"start\":111031},{\"end\":111051,\"start\":111046},{\"end\":111058,\"start\":111055},{\"end\":111067,\"start\":111062},{\"end\":111393,\"start\":111390},{\"end\":111400,\"start\":111397},{\"end\":111409,\"start\":111404},{\"end\":111424,\"start\":111413},{\"end\":111437,\"start\":111428},{\"end\":111446,\"start\":111441}]", "bib_entry": "[{\"attributes\":{\"doi\":\"10.1038/nn.4502\",\"id\":\"b0\",\"matched_paper_id\":205439817},\"end\":80652,\"start\":80466},{\"attributes\":{\"doi\":\"10.3389/fninf.2013.00048\",\"id\":\"b1\",\"matched_paper_id\":5799133},\"end\":81073,\"start\":80654},{\"attributes\":{\"id\":\"b2\",\"matched_paper_id\":201070152},\"end\":81589,\"start\":81075},{\"attributes\":{\"doi\":\"10.1109/ACCESS.2021.3059241\",\"id\":\"b3\",\"matched_paper_id\":232061961},\"end\":81999,\"start\":81591},{\"attributes\":{\"id\":\"b4\",\"matched_paper_id\":86651212},\"end\":82473,\"start\":82001},{\"attributes\":{\"doi\":\"10.3389/fpsyg.2018.00401\",\"id\":\"b5\",\"matched_paper_id\":4726221},\"end\":82828,\"start\":82475},{\"attributes\":{\"doi\":\"10.1016/j.jmapro.2021.09.048\",\"id\":\"b6\",\"matched_paper_id\":244580996},\"end\":83255,\"start\":82830},{\"attributes\":{\"doi\":\"10.1109/ACCESS.2014.2325029\",\"id\":\"b7\",\"matched_paper_id\":10158224},\"end\":83515,\"start\":83257},{\"attributes\":{\"id\":\"b8\",\"matched_paper_id\":237593119},\"end\":83954,\"start\":83517},{\"attributes\":{\"doi\":\"10.1016/j.neuron.2020.02.013\",\"id\":\"b9\",\"matched_paper_id\":202864713},\"end\":84266,\"start\":83956},{\"attributes\":{\"doi\":\"arXiv:1412.7024\",\"id\":\"b10\"},\"end\":84554,\"start\":84268},{\"attributes\":{\"id\":\"b11\",\"matched_paper_id\":35277369},\"end\":84830,\"start\":84556},{\"attributes\":{\"doi\":\"10.1109/TNNLS.2021.3105949\",\"id\":\"b12\"},\"end\":85201,\"start\":84832},{\"attributes\":{\"id\":\"b13\",\"matched_paper_id\":59158853},\"end\":85496,\"start\":85203},{\"attributes\":{\"id\":\"b14\"},\"end\":85807,\"start\":85498},{\"attributes\":{\"id\":\"b15\"},\"end\":86012,\"start\":85809},{\"attributes\":{\"id\":\"b16\",\"matched_paper_id\":18842042},\"end\":86381,\"start\":86014},{\"attributes\":{\"id\":\"b17\",\"matched_paper_id\":216080530},\"end\":86664,\"start\":86383},{\"attributes\":{\"id\":\"b18\",\"matched_paper_id\":244531496},\"end\":87018,\"start\":86666},{\"attributes\":{\"id\":\"b19\"},\"end\":87406,\"start\":87020},{\"attributes\":{\"id\":\"b20\",\"matched_paper_id\":52062175},\"end\":87836,\"start\":87408},{\"attributes\":{\"id\":\"b21\",\"matched_paper_id\":236229627},\"end\":88244,\"start\":87838},{\"attributes\":{\"id\":\"b22\",\"matched_paper_id\":4511529},\"end\":88552,\"start\":88246},{\"attributes\":{\"id\":\"b23\",\"matched_paper_id\":243928303},\"end\":88974,\"start\":88554},{\"attributes\":{\"id\":\"b24\"},\"end\":89251,\"start\":88976},{\"attributes\":{\"id\":\"b25\"},\"end\":89395,\"start\":89253},{\"attributes\":{\"id\":\"b26\",\"matched_paper_id\":235474476},\"end\":89780,\"start\":89397},{\"attributes\":{\"id\":\"b27\"},\"end\":90058,\"start\":89782},{\"attributes\":{\"id\":\"b28\"},\"end\":90259,\"start\":90060},{\"attributes\":{\"id\":\"b29\",\"matched_paper_id\":197642766},\"end\":90724,\"start\":90261},{\"attributes\":{\"id\":\"b30\",\"matched_paper_id\":21351739},\"end\":91143,\"start\":90726},{\"attributes\":{\"id\":\"b31\",\"matched_paper_id\":163164623},\"end\":91679,\"start\":91145},{\"attributes\":{\"id\":\"b32\",\"matched_paper_id\":222305243},\"end\":92183,\"start\":91681},{\"attributes\":{\"id\":\"b33\",\"matched_paper_id\":1677864},\"end\":92616,\"start\":92185},{\"attributes\":{\"id\":\"b34\",\"matched_paper_id\":209093915},\"end\":93099,\"start\":92618},{\"attributes\":{\"id\":\"b35\",\"matched_paper_id\":233376633},\"end\":93597,\"start\":93101},{\"attributes\":{\"id\":\"b36\"},\"end\":93927,\"start\":93599},{\"attributes\":{\"id\":\"b37\",\"matched_paper_id\":4202768},\"end\":94423,\"start\":93929},{\"attributes\":{\"id\":\"b38\",\"matched_paper_id\":57912849},\"end\":94608,\"start\":94425},{\"attributes\":{\"id\":\"b39\",\"matched_paper_id\":733980},\"end\":94988,\"start\":94610},{\"attributes\":{\"id\":\"b40\",\"matched_paper_id\":60571601},\"end\":95471,\"start\":94990},{\"attributes\":{\"id\":\"b41\",\"matched_paper_id\":8517067},\"end\":95937,\"start\":95473},{\"attributes\":{\"id\":\"b42\",\"matched_paper_id\":233465443},\"end\":96427,\"start\":95939},{\"attributes\":{\"id\":\"b43\"},\"end\":96708,\"start\":96429},{\"attributes\":{\"id\":\"b44\"},\"end\":96875,\"start\":96710},{\"attributes\":{\"id\":\"b45\",\"matched_paper_id\":52978766},\"end\":97347,\"start\":96877},{\"attributes\":{\"id\":\"b46\",\"matched_paper_id\":18032844},\"end\":97695,\"start\":97349},{\"attributes\":{\"id\":\"b47\",\"matched_paper_id\":49416738},\"end\":98143,\"start\":97697},{\"attributes\":{\"id\":\"b48\",\"matched_paper_id\":224851076},\"end\":98589,\"start\":98145},{\"attributes\":{\"id\":\"b49\",\"matched_paper_id\":206655274},\"end\":98934,\"start\":98591},{\"attributes\":{\"id\":\"b50\",\"matched_paper_id\":206655679},\"end\":99297,\"start\":98936},{\"attributes\":{\"id\":\"b51\",\"matched_paper_id\":154569836},\"end\":99620,\"start\":99299},{\"attributes\":{\"id\":\"b52\",\"matched_paper_id\":25209638},\"end\":100197,\"start\":99622},{\"attributes\":{\"id\":\"b53\",\"matched_paper_id\":14113767},\"end\":100559,\"start\":100199},{\"attributes\":{\"id\":\"b54\",\"matched_paper_id\":9713234},\"end\":100869,\"start\":100561},{\"attributes\":{\"id\":\"b55\",\"matched_paper_id\":53964350},\"end\":101133,\"start\":100871},{\"attributes\":{\"id\":\"b56\"},\"end\":101410,\"start\":101135},{\"attributes\":{\"id\":\"b57\",\"matched_paper_id\":182118830},\"end\":101794,\"start\":101412},{\"attributes\":{\"id\":\"b58\",\"matched_paper_id\":231705788},\"end\":102241,\"start\":101796},{\"attributes\":{\"id\":\"b59\",\"matched_paper_id\":49291228},\"end\":102753,\"start\":102243},{\"attributes\":{\"id\":\"b60\"},\"end\":103074,\"start\":102755},{\"attributes\":{\"id\":\"b61\",\"matched_paper_id\":6071257},\"end\":103430,\"start\":103076},{\"attributes\":{\"id\":\"b62\"},\"end\":103756,\"start\":103432},{\"attributes\":{\"id\":\"b63\",\"matched_paper_id\":14650762},\"end\":104088,\"start\":103758},{\"attributes\":{\"id\":\"b64\"},\"end\":104247,\"start\":104090},{\"attributes\":{\"id\":\"b65\",\"matched_paper_id\":243902037},\"end\":104695,\"start\":104249},{\"attributes\":{\"id\":\"b66\",\"matched_paper_id\":243896150},\"end\":105131,\"start\":104697},{\"attributes\":{\"id\":\"b67\",\"matched_paper_id\":12008695},\"end\":105629,\"start\":105133},{\"attributes\":{\"id\":\"b68\",\"matched_paper_id\":57365377},\"end\":106114,\"start\":105631},{\"attributes\":{\"id\":\"b69\",\"matched_paper_id\":9812826},\"end\":106454,\"start\":106116},{\"attributes\":{\"id\":\"b70\",\"matched_paper_id\":53447012},\"end\":106880,\"start\":106456},{\"attributes\":{\"id\":\"b71\",\"matched_paper_id\":15258913},\"end\":107347,\"start\":106882},{\"attributes\":{\"id\":\"b72\",\"matched_paper_id\":10256858},\"end\":107757,\"start\":107349},{\"attributes\":{\"id\":\"b73\"},\"end\":108067,\"start\":107759},{\"attributes\":{\"id\":\"b74\",\"matched_paper_id\":4354498},\"end\":108464,\"start\":108069},{\"attributes\":{\"id\":\"b75\",\"matched_paper_id\":15883296},\"end\":108729,\"start\":108466},{\"attributes\":{\"id\":\"b76\",\"matched_paper_id\":202539000},\"end\":109381,\"start\":108731},{\"attributes\":{\"id\":\"b77\",\"matched_paper_id\":5740116},\"end\":109822,\"start\":109383},{\"attributes\":{\"id\":\"b78\",\"matched_paper_id\":25330230},\"end\":110314,\"start\":109824},{\"attributes\":{\"id\":\"b79\",\"matched_paper_id\":14089146},\"end\":110519,\"start\":110316},{\"attributes\":{\"id\":\"b80\",\"matched_paper_id\":14996651},\"end\":110924,\"start\":110521},{\"attributes\":{\"id\":\"b81\"},\"end\":111299,\"start\":110926},{\"attributes\":{\"id\":\"b82\",\"matched_paper_id\":239036966},\"end\":111974,\"start\":111301}]", "bib_title": "[{\"end\":80486,\"start\":80466},{\"end\":80723,\"start\":80654},{\"end\":81140,\"start\":81075},{\"end\":81677,\"start\":81591},{\"end\":82053,\"start\":82001},{\"end\":82553,\"start\":82475},{\"end\":82949,\"start\":82830},{\"end\":83308,\"start\":83257},{\"end\":83597,\"start\":83517},{\"end\":84029,\"start\":83956},{\"end\":84629,\"start\":84556},{\"end\":85250,\"start\":85203},{\"end\":86056,\"start\":86014},{\"end\":86440,\"start\":86383},{\"end\":86734,\"start\":86666},{\"end\":87481,\"start\":87408},{\"end\":87917,\"start\":87838},{\"end\":88291,\"start\":88246},{\"end\":88628,\"start\":88554},{\"end\":89449,\"start\":89397},{\"end\":90332,\"start\":90261},{\"end\":90794,\"start\":90726},{\"end\":91237,\"start\":91145},{\"end\":91765,\"start\":91681},{\"end\":92230,\"start\":92185},{\"end\":92695,\"start\":92618},{\"end\":93174,\"start\":93101},{\"end\":93991,\"start\":93929},{\"end\":94460,\"start\":94425},{\"end\":94733,\"start\":94610},{\"end\":95050,\"start\":94990},{\"end\":95538,\"start\":95473},{\"end\":96029,\"start\":95939},{\"end\":96946,\"start\":96877},{\"end\":97391,\"start\":97349},{\"end\":97807,\"start\":97697},{\"end\":98228,\"start\":98145},{\"end\":98618,\"start\":98591},{\"end\":98992,\"start\":98936},{\"end\":99386,\"start\":99299},{\"end\":99770,\"start\":99622},{\"end\":100240,\"start\":100199},{\"end\":100600,\"start\":100561},{\"end\":100926,\"start\":100871},{\"end\":101510,\"start\":101412},{\"end\":101894,\"start\":101796},{\"end\":102345,\"start\":102243},{\"end\":103118,\"start\":103076},{\"end\":103813,\"start\":103758},{\"end\":104339,\"start\":104249},{\"end\":104783,\"start\":104697},{\"end\":105223,\"start\":105133},{\"end\":105769,\"start\":105631},{\"end\":106204,\"start\":106116},{\"end\":106508,\"start\":106456},{\"end\":107002,\"start\":106882},{\"end\":107427,\"start\":107349},{\"end\":108143,\"start\":108069},{\"end\":108513,\"start\":108466},{\"end\":108794,\"start\":108731},{\"end\":109446,\"start\":109383},{\"end\":109913,\"start\":109824},{\"end\":110330,\"start\":110316},{\"end\":110625,\"start\":110521},{\"end\":111386,\"start\":111301}]", "bib_author": "[{\"end\":80501,\"start\":80488},{\"end\":80511,\"start\":80501},{\"end\":80736,\"start\":80725},{\"end\":80748,\"start\":80736},{\"end\":80762,\"start\":80748},{\"end\":80772,\"start\":80762},{\"end\":80785,\"start\":80772},{\"end\":80798,\"start\":80785},{\"end\":81148,\"start\":81142},{\"end\":81158,\"start\":81148},{\"end\":81167,\"start\":81158},{\"end\":81184,\"start\":81167},{\"end\":81199,\"start\":81184},{\"end\":81203,\"start\":81199},{\"end\":81689,\"start\":81679},{\"end\":81698,\"start\":81689},{\"end\":81710,\"start\":81698},{\"end\":81720,\"start\":81710},{\"end\":81733,\"start\":81720},{\"end\":82065,\"start\":82055},{\"end\":82075,\"start\":82065},{\"end\":82082,\"start\":82075},{\"end\":82094,\"start\":82082},{\"end\":82098,\"start\":82094},{\"end\":82565,\"start\":82555},{\"end\":82576,\"start\":82565},{\"end\":82587,\"start\":82576},{\"end\":82593,\"start\":82587},{\"end\":82959,\"start\":82951},{\"end\":82968,\"start\":82959},{\"end\":82977,\"start\":82968},{\"end\":83321,\"start\":83310},{\"end\":83327,\"start\":83321},{\"end\":83331,\"start\":83327},{\"end\":83610,\"start\":83599},{\"end\":83625,\"start\":83610},{\"end\":83636,\"start\":83625},{\"end\":83644,\"start\":83636},{\"end\":84045,\"start\":84031},{\"end\":84056,\"start\":84045},{\"end\":84283,\"start\":84268},{\"end\":84293,\"start\":84283},{\"end\":84305,\"start\":84293},{\"end\":84643,\"start\":84631},{\"end\":84657,\"start\":84643},{\"end\":84843,\"start\":84832},{\"end\":84853,\"start\":84843},{\"end\":84865,\"start\":84853},{\"end\":85263,\"start\":85252},{\"end\":85275,\"start\":85263},{\"end\":85600,\"start\":85585},{\"end\":85610,\"start\":85600},{\"end\":85897,\"start\":85885},{\"end\":86070,\"start\":86058},{\"end\":86080,\"start\":86070},{\"end\":86448,\"start\":86442},{\"end\":86459,\"start\":86448},{\"end\":86750,\"start\":86736},{\"end\":86760,\"start\":86750},{\"end\":86764,\"start\":86760},{\"end\":87135,\"start\":87125},{\"end\":87494,\"start\":87483},{\"end\":87505,\"start\":87494},{\"end\":87513,\"start\":87505},{\"end\":87526,\"start\":87513},{\"end\":87931,\"start\":87919},{\"end\":87941,\"start\":87931},{\"end\":87951,\"start\":87941},{\"end\":87961,\"start\":87951},{\"end\":87970,\"start\":87961},{\"end\":87981,\"start\":87970},{\"end\":87985,\"start\":87981},{\"end\":88305,\"start\":88293},{\"end\":88316,\"start\":88305},{\"end\":88331,\"start\":88316},{\"end\":88344,\"start\":88331},{\"end\":88648,\"start\":88630},{\"end\":88661,\"start\":88648},{\"end\":88670,\"start\":88661},{\"end\":89071,\"start\":89053},{\"end\":89079,\"start\":89071},{\"end\":89086,\"start\":89079},{\"end\":89095,\"start\":89086},{\"end\":89469,\"start\":89451},{\"end\":89477,\"start\":89469},{\"end\":89484,\"start\":89477},{\"end\":89493,\"start\":89484},{\"end\":89877,\"start\":89868},{\"end\":89886,\"start\":89877},{\"end\":89893,\"start\":89886},{\"end\":89903,\"start\":89893},{\"end\":90343,\"start\":90334},{\"end\":90350,\"start\":90343},{\"end\":90359,\"start\":90350},{\"end\":90371,\"start\":90359},{\"end\":90378,\"start\":90371},{\"end\":90392,\"start\":90378},{\"end\":90805,\"start\":90796},{\"end\":90813,\"start\":90805},{\"end\":90823,\"start\":90813},{\"end\":90833,\"start\":90823},{\"end\":91248,\"start\":91239},{\"end\":91258,\"start\":91248},{\"end\":91270,\"start\":91258},{\"end\":91277,\"start\":91270},{\"end\":91285,\"start\":91277},{\"end\":91295,\"start\":91285},{\"end\":91776,\"start\":91767},{\"end\":91787,\"start\":91776},{\"end\":91796,\"start\":91787},{\"end\":91804,\"start\":91796},{\"end\":91811,\"start\":91804},{\"end\":91821,\"start\":91811},{\"end\":92241,\"start\":92232},{\"end\":92251,\"start\":92241},{\"end\":92259,\"start\":92251},{\"end\":92269,\"start\":92259},{\"end\":92281,\"start\":92269},{\"end\":92706,\"start\":92697},{\"end\":92713,\"start\":92706},{\"end\":92725,\"start\":92713},{\"end\":92734,\"start\":92725},{\"end\":92745,\"start\":92734},{\"end\":92753,\"start\":92745},{\"end\":93185,\"start\":93176},{\"end\":93192,\"start\":93185},{\"end\":93201,\"start\":93192},{\"end\":93216,\"start\":93201},{\"end\":93227,\"start\":93216},{\"end\":93235,\"start\":93227},{\"end\":93683,\"start\":93677},{\"end\":93696,\"start\":93683},{\"end\":93710,\"start\":93696},{\"end\":93721,\"start\":93710},{\"end\":94005,\"start\":93993},{\"end\":94014,\"start\":94005},{\"end\":94023,\"start\":94014},{\"end\":94036,\"start\":94023},{\"end\":94047,\"start\":94036},{\"end\":94056,\"start\":94047},{\"end\":94473,\"start\":94462},{\"end\":94746,\"start\":94735},{\"end\":95063,\"start\":95052},{\"end\":95080,\"start\":95063},{\"end\":95089,\"start\":95080},{\"end\":95552,\"start\":95540},{\"end\":95563,\"start\":95552},{\"end\":96046,\"start\":96031},{\"end\":96058,\"start\":96046},{\"end\":96069,\"start\":96058},{\"end\":96082,\"start\":96069},{\"end\":96092,\"start\":96082},{\"end\":96105,\"start\":96092},{\"end\":96522,\"start\":96515},{\"end\":96531,\"start\":96522},{\"end\":96542,\"start\":96531},{\"end\":96552,\"start\":96542},{\"end\":96718,\"start\":96710},{\"end\":96955,\"start\":96948},{\"end\":96964,\"start\":96955},{\"end\":96976,\"start\":96964},{\"end\":97403,\"start\":97393},{\"end\":97413,\"start\":97403},{\"end\":97819,\"start\":97809},{\"end\":97829,\"start\":97819},{\"end\":97849,\"start\":97829},{\"end\":97860,\"start\":97849},{\"end\":98240,\"start\":98230},{\"end\":98253,\"start\":98240},{\"end\":98263,\"start\":98253},{\"end\":98273,\"start\":98263},{\"end\":98282,\"start\":98273},{\"end\":98295,\"start\":98282},{\"end\":98633,\"start\":98620},{\"end\":98645,\"start\":98633},{\"end\":98654,\"start\":98645},{\"end\":98663,\"start\":98654},{\"end\":98671,\"start\":98663},{\"end\":98685,\"start\":98671},{\"end\":99007,\"start\":98994},{\"end\":99018,\"start\":99007},{\"end\":99032,\"start\":99018},{\"end\":99043,\"start\":99032},{\"end\":99395,\"start\":99388},{\"end\":99402,\"start\":99395},{\"end\":99778,\"start\":99772},{\"end\":99786,\"start\":99778},{\"end\":99796,\"start\":99786},{\"end\":99805,\"start\":99796},{\"end\":99814,\"start\":99805},{\"end\":99824,\"start\":99814},{\"end\":100252,\"start\":100242},{\"end\":100261,\"start\":100252},{\"end\":100273,\"start\":100261},{\"end\":100281,\"start\":100273},{\"end\":100291,\"start\":100281},{\"end\":100302,\"start\":100291},{\"end\":100615,\"start\":100602},{\"end\":100625,\"start\":100615},{\"end\":100640,\"start\":100625},{\"end\":100649,\"start\":100640},{\"end\":100934,\"start\":100928},{\"end\":100949,\"start\":100934},{\"end\":100958,\"start\":100949},{\"end\":100967,\"start\":100958},{\"end\":101153,\"start\":101137},{\"end\":101163,\"start\":101153},{\"end\":101172,\"start\":101163},{\"end\":101182,\"start\":101172},{\"end\":101191,\"start\":101182},{\"end\":101201,\"start\":101191},{\"end\":101525,\"start\":101512},{\"end\":101537,\"start\":101525},{\"end\":101551,\"start\":101537},{\"end\":101904,\"start\":101896},{\"end\":101912,\"start\":101904},{\"end\":101922,\"start\":101912},{\"end\":101931,\"start\":101922},{\"end\":101942,\"start\":101931},{\"end\":101956,\"start\":101942},{\"end\":102359,\"start\":102347},{\"end\":102369,\"start\":102359},{\"end\":102380,\"start\":102369},{\"end\":102389,\"start\":102380},{\"end\":102399,\"start\":102389},{\"end\":102826,\"start\":102815},{\"end\":102838,\"start\":102826},{\"end\":102849,\"start\":102838},{\"end\":103130,\"start\":103120},{\"end\":103141,\"start\":103130},{\"end\":103151,\"start\":103141},{\"end\":103553,\"start\":103534},{\"end\":103565,\"start\":103553},{\"end\":103826,\"start\":103815},{\"end\":103837,\"start\":103826},{\"end\":103847,\"start\":103837},{\"end\":104099,\"start\":104090},{\"end\":104352,\"start\":104341},{\"end\":104359,\"start\":104352},{\"end\":104369,\"start\":104359},{\"end\":104381,\"start\":104369},{\"end\":104390,\"start\":104381},{\"end\":104796,\"start\":104785},{\"end\":104803,\"start\":104796},{\"end\":104810,\"start\":104803},{\"end\":104823,\"start\":104810},{\"end\":104832,\"start\":104823},{\"end\":105235,\"start\":105225},{\"end\":105246,\"start\":105235},{\"end\":105257,\"start\":105246},{\"end\":105267,\"start\":105257},{\"end\":105279,\"start\":105267},{\"end\":105781,\"start\":105771},{\"end\":105792,\"start\":105781},{\"end\":105802,\"start\":105792},{\"end\":105814,\"start\":105802},{\"end\":106216,\"start\":106206},{\"end\":106227,\"start\":106216},{\"end\":106239,\"start\":106227},{\"end\":106524,\"start\":106510},{\"end\":106530,\"start\":106524},{\"end\":106542,\"start\":106530},{\"end\":106551,\"start\":106542},{\"end\":106559,\"start\":106551},{\"end\":106567,\"start\":106559},{\"end\":107017,\"start\":107004},{\"end\":107031,\"start\":107017},{\"end\":107445,\"start\":107429},{\"end\":107457,\"start\":107445},{\"end\":107471,\"start\":107457},{\"end\":107481,\"start\":107471},{\"end\":107846,\"start\":107839},{\"end\":107852,\"start\":107846},{\"end\":107864,\"start\":107852},{\"end\":107871,\"start\":107864},{\"end\":108153,\"start\":108145},{\"end\":108164,\"start\":108153},{\"end\":108177,\"start\":108164},{\"end\":108184,\"start\":108177},{\"end\":108194,\"start\":108184},{\"end\":108529,\"start\":108515},{\"end\":108543,\"start\":108529},{\"end\":108807,\"start\":108796},{\"end\":108817,\"start\":108807},{\"end\":108827,\"start\":108817},{\"end\":108837,\"start\":108827},{\"end\":108855,\"start\":108837},{\"end\":108866,\"start\":108855},{\"end\":108876,\"start\":108866},{\"end\":109459,\"start\":109448},{\"end\":109470,\"start\":109459},{\"end\":109483,\"start\":109470},{\"end\":109926,\"start\":109915},{\"end\":109936,\"start\":109926},{\"end\":109947,\"start\":109936},{\"end\":109966,\"start\":109947},{\"end\":109976,\"start\":109966},{\"end\":109989,\"start\":109976},{\"end\":110350,\"start\":110332},{\"end\":110359,\"start\":110350},{\"end\":110639,\"start\":110627},{\"end\":110649,\"start\":110639},{\"end\":110660,\"start\":110649},{\"end\":111029,\"start\":111022},{\"end\":111044,\"start\":111029},{\"end\":111053,\"start\":111044},{\"end\":111060,\"start\":111053},{\"end\":111069,\"start\":111060},{\"end\":111395,\"start\":111388},{\"end\":111402,\"start\":111395},{\"end\":111411,\"start\":111402},{\"end\":111426,\"start\":111411},{\"end\":111439,\"start\":111426},{\"end\":111448,\"start\":111439}]", "bib_venue": "[{\"end\":80539,\"start\":80526},{\"end\":80840,\"start\":80822},{\"end\":81282,\"start\":81203},{\"end\":81771,\"start\":81760},{\"end\":82176,\"start\":82098},{\"end\":82631,\"start\":82617},{\"end\":83022,\"start\":83005},{\"end\":83369,\"start\":83358},{\"end\":83706,\"start\":83644},{\"end\":84090,\"start\":84084},{\"end\":84391,\"start\":84320},{\"end\":84662,\"start\":84657},{\"end\":85004,\"start\":84907},{\"end\":85326,\"start\":85298},{\"end\":85583,\"start\":85498},{\"end\":85883,\"start\":85809},{\"end\":86176,\"start\":86080},{\"end\":86504,\"start\":86484},{\"end\":86809,\"start\":86764},{\"end\":87123,\"start\":87020},{\"end\":87591,\"start\":87526},{\"end\":88019,\"start\":88011},{\"end\":88378,\"start\":88372},{\"end\":88723,\"start\":88670},{\"end\":89051,\"start\":88976},{\"end\":89296,\"start\":89253},{\"end\":89549,\"start\":89493},{\"end\":89866,\"start\":89782},{\"end\":90136,\"start\":90060},{\"end\":90458,\"start\":90392},{\"end\":90897,\"start\":90833},{\"end\":91354,\"start\":91295},{\"end\":91899,\"start\":91821},{\"end\":92363,\"start\":92281},{\"end\":92831,\"start\":92778},{\"end\":93317,\"start\":93235},{\"end\":93675,\"start\":93599},{\"end\":94137,\"start\":94056},{\"end\":94481,\"start\":94473},{\"end\":94783,\"start\":94771},{\"end\":95163,\"start\":95089},{\"end\":95640,\"start\":95563},{\"end\":96157,\"start\":96131},{\"end\":96513,\"start\":96429},{\"end\":96772,\"start\":96718},{\"end\":97049,\"start\":96976},{\"end\":97489,\"start\":97413},{\"end\":97898,\"start\":97887},{\"end\":98339,\"start\":98321},{\"end\":98737,\"start\":98711},{\"end\":99095,\"start\":99069},{\"end\":99440,\"start\":99430},{\"end\":99855,\"start\":99824},{\"end\":100340,\"start\":100302},{\"end\":100695,\"start\":100674},{\"end\":100970,\"start\":100967},{\"end\":101586,\"start\":101578},{\"end\":101995,\"start\":101982},{\"end\":102457,\"start\":102399},{\"end\":102813,\"start\":102755},{\"end\":103212,\"start\":103151},{\"end\":103532,\"start\":103432},{\"end\":103895,\"start\":103851},{\"end\":104132,\"start\":104099},{\"end\":104433,\"start\":104390},{\"end\":104875,\"start\":104832},{\"end\":105343,\"start\":105279},{\"end\":105850,\"start\":105840},{\"end\":106245,\"start\":106239},{\"end\":106624,\"start\":106567},{\"end\":107093,\"start\":107057},{\"end\":107527,\"start\":107509},{\"end\":107837,\"start\":107759},{\"end\":108237,\"start\":108217},{\"end\":108577,\"start\":108571},{\"end\":108909,\"start\":108896},{\"end\":109549,\"start\":109483},{\"end\":110041,\"start\":110025},{\"end\":110401,\"start\":110380},{\"end\":110702,\"start\":110684},{\"end\":111020,\"start\":110926},{\"end\":111556,\"start\":111448},{\"end\":81348,\"start\":81284},{\"end\":82253,\"start\":82178},{\"end\":83713,\"start\":83708},{\"end\":84674,\"start\":84664},{\"end\":86822,\"start\":86811},{\"end\":87601,\"start\":87593},{\"end\":88742,\"start\":88725},{\"end\":89315,\"start\":89298},{\"end\":89592,\"start\":89551},{\"end\":90149,\"start\":90138},{\"end\":90465,\"start\":90460},{\"end\":90913,\"start\":90899},{\"end\":91413,\"start\":91356},{\"end\":91907,\"start\":91901},{\"end\":92375,\"start\":92365},{\"end\":93324,\"start\":93319},{\"end\":94150,\"start\":94139},{\"end\":95240,\"start\":95165},{\"end\":95714,\"start\":95642},{\"end\":96782,\"start\":96774},{\"end\":97121,\"start\":97051},{\"end\":97503,\"start\":97491},{\"end\":99874,\"start\":99857},{\"end\":100348,\"start\":100342},{\"end\":100984,\"start\":100972},{\"end\":102476,\"start\":102459},{\"end\":103260,\"start\":103214},{\"end\":103904,\"start\":103897},{\"end\":104148,\"start\":104134},{\"end\":104452,\"start\":104435},{\"end\":104894,\"start\":104877},{\"end\":105358,\"start\":105345},{\"end\":106264,\"start\":106247},{\"end\":106641,\"start\":106626},{\"end\":108253,\"start\":108239},{\"end\":109602,\"start\":109551},{\"end\":111664,\"start\":111558}]"}}}, "year": 2023, "month": 12, "day": 17}