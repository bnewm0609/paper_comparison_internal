{"id": 20729541, "updated": "2023-09-29 09:35:02.581", "metadata": {"title": "Polynomial Codes: an Optimal Design for High-Dimensional Coded Matrix Multiplication", "authors": "[{\"first\":\"Qian\",\"last\":\"Yu\",\"middle\":[]},{\"first\":\"Mohammad\",\"last\":\"Maddah-Ali\",\"middle\":[\"Ali\"]},{\"first\":\"A.\",\"last\":\"Avestimehr\",\"middle\":[\"Salman\"]}]", "venue": "NIPS", "journal": "4403-4413", "publication_date": {"year": 2017, "month": 5, "day": 30}, "abstract": "We consider a large-scale matrix multiplication problem where the computation is carried out using a distributed system with a master node and multiple worker nodes, where each worker can store parts of the input matrices. We propose a computation strategy that leverages ideas from coding theory to design intermediate computations at the worker nodes, in order to efficiently deal with straggling workers. The proposed strategy, named as \\emph{polynomial codes}, achieves the optimum recovery threshold, defined as the minimum number of workers that the master needs to wait for in order to compute the output. Furthermore, by leveraging the algebraic structure of polynomial codes, we can map the reconstruction problem of the final output to a polynomial interpolation problem, which can be solved efficiently. Polynomial codes provide order-wise improvement over the state of the art in terms of recovery threshold, and are also optimal in terms of several other metrics. Furthermore, we extend this code to distributed convolution and show its order-wise optimality.", "fields_of_study": "[\"Computer Science\",\"Mathematics\"]", "external_ids": {"arxiv": "1705.10464", "mag": "2962850796", "acl": null, "pubmed": null, "pubmedcentral": null, "dblp": "conf/nips/YuMA17", "doi": null}}, "content": {"source": {"pdf_hash": "d3430a6b4f79b479da830826c5fa38ddf4750efd", "pdf_src": "Arxiv", "pdf_uri": "[\"https://arxiv.org/pdf/1705.10464v1.pdf\"]", "oa_url_match": false, "oa_info": null}, "grobid": {"id": "a13ff66352ab409c0521e96f330628c57f5eb3e3", "type": "plain-text", "url": "s3://ai2-s2-pdf-extraction-prod/parse-results/s2orc_worker/d3430a6b4f79b479da830826c5fa38ddf4750efd.txt", "contents": "\nPolynomial Codes: an Optimal Design for High-Dimensional Coded Matrix Multiplication\n\n\nQian Yu \nDepartment of Electrical Engineering\nUniversity of Southern California\nLos AngelesCAUSA\n\nMohammad Ali Maddah-Ali \nNokia Bell Labs\nHolmdelNJUSA\n\nA Salman Avestimehr \nDepartment of Electrical Engineering\nUniversity of Southern California\nLos AngelesCAUSA\n\nPolynomial Codes: an Optimal Design for High-Dimensional Coded Matrix Multiplication\n1\nWe consider a large-scale matrix multiplication problem where the computation is carried out using a distributed system with a master node and multiple worker nodes, where each worker can store parts of the input matrices. We propose a computation strategy that leverages ideas from coding theory to design intermediate computations at the worker nodes, in order to efficiently deal with straggling workers. The proposed strategy, named as polynomial codes, achieves the optimum recovery threshold, defined as the minimum number of workers that the master needs to wait for in order to compute the output. Furthermore, by leveraging the algebraic structure of polynomial codes, we can map the reconstruction problem of the final output to a polynomial interpolation problem, which can be solved efficiently. Polynomial codes provide order-wise improvement over the state of the art in terms of recovery threshold, and are also optimal in terms of several other metrics. Furthermore, we extend this code to distributed convolution and show its order-wise optimality.\n\nI. INTRODUCTION\n\nMatrix multiplication is one of the key building blocks underlying many data analytics and machine learning algorithms. Many such applications require massive computation and storage power to process large-scale datasets. As a result, distributed computing frameworks such as Hadoop MapReduce [1] and Spark [2] have gained significant traction, as they enable processing of data sizes at the order of tens of terabytes and more.\n\nAs we scale out computations across many distributed nodes, a major performance bottleneck is the latency in waiting for slowest nodes, or \"stragglers\" to finish their tasks [3]. The current approaches to mitigate the impact of stragglers involve creation of some form of \"computation redundancy\". For example, replicating the straggling task on another available node is a common approach to deal with stragglers (e.g., [4]). However, there have been recent results demonstrating that coding can play a transformational role for creating and exploiting computation redundancy to effectively alleviate the impact of stragglers [5], [6], [7], [8], [9]. Our main result in this paper is the development of optimal codes, named polynomial codes, to deal with stragglers in distributed high-dimensional matrix multiplication, which also provides order-wise improvement over the state of the art.\n\nMore specifically, we consider a distributed matrix multiplication problem where we aim to compute C = A B from input matrices A and B. As shown in Fig. 1, the computation is carried out using a distributed system with a master node and N worker nodes that can each store 1 m fraction of A and 1 n fraction of B, for some parameters m, n \u2208 N + . We denote the stored submtarices at each worker i \u2208 {0, . . . , N \u2212 1} by\u00c3 i andB i , which can be designed as arbitrary functions of A and B respectively. Each worker i then computes the product\u00c3 iB i and returns the result to the master.\n\nBy carefully designing the computation strategy at each worker (i.e. designing\u00c3 i andB i ), the master only needs to wait for the fastest subset of workers before recovering output C, hence mitigating the impact of stragglers. Given a computation strategy, we define its recovery threshold as the minimum number of workers that the master needs to wait for in order to compute C. In other words, if any subset of the workers with size no smaller than the recovery threshold finish their jobs, the master is able to compute C. Given this formulation, we are interested in the following main problem.\n\nWhat is the minimum possible recovery threshold for distributed matrix multiplication? Can we find an optimal computation strategy that achieves the minimum recovery threshold, while allowing efficient decoding of the final output at the master node?\n\nThere have been two computing schemes proposed earlier for this problem that leverage ideas from coding theory. The first one, introduced in [5] and extended in [10], injects redundancy in only one of the input matrices using maximum distance separable (MDS) codes [11] 1 . We illustrate this approach, referred to as one dimensional MDS code (1D MDS code), using the example shown in Fig. 2a, where we aim to compute C = A B using 3 workers that can each store half of A and the entire B. The 1D MDS code evenly divides A along the column into two submatrices denoted by A 0 and A 1 , encodes them into 3 coded matrices A 0 , A 1 , and A 0 + A 1 , and then assigns them to the 3 workers. This design allows the master to recover the . . . . . .\n\n. . . Fig. 1: Overview of the distributed matrix multiplication framework. Coded data are initially stored distributedly at N workers according to data assignment. Each worker computes the product of the two stored matrices and returns it to the master. By carefully designing the computation strategy, the master can decode given the computing results from a subset of workers, without having to wait for the stragglers (worker 1 in this example). final output given the results from any 2 of the 3 workers, hence achieving a recovery threshold of 2. More generally, one can show that the 1D MDS code achieves a recovery threshold of\nK 1D-MDS N \u2212 N n + m = \u0398(N ).(1)\nAn alternative computing scheme was recently proposed in [10] for the case of m = n, referred to as the product code, which instead injects redundancy in both input matrices. As demonstrated in Fig. 2b, product code aligns workers in an\n\u221a N \u2212by\u2212 \u221a N layout.\nA is divided along the columns into m submatrices, encoded using an ( \u221a N , m) MDS code into \u221a N coded matrices, and then assigned to the \u221a N columns of workers. Similarly \u221a N coded matrices of B are created and assigned to the \u221a N rows. Given the property of MDS codes, the master can decode an entire row after obtaining any m results in that row; likewise for the columns. Consequently, the master can recover the final output using a peeling algorithm, iteratively decoding the MDS codes on rows and columns until the output C is completely available. For example, if the 5 computing results Fig. 2b, the master can recover the needed results by computing\nA 1 B 0 , A 1 B 1 , (A 0 + A 1 ) B 1 , A 0 (B 0 + B 1 ), and A 1 (B 0 + B 1 ) are received as demonstrated inA 0 B 1 = (A 0 + A 1 ) B 1 \u2212 A 1 B 1 then A 0 B 0 = A 0 (B 0 + B 1 ) \u2212 A 0 B 1 .\nIn general, one can show that the product code achieves a recovery threshold of\nK product 2(m \u2212 1) \u221a N \u2212 (m \u2212 1) 2 + 1 = \u0398( \u221a N ),(2)\nwhich significantly improves over K 1D-MDS .\n\n(a) 1D MDS-code [5] in an example with 3 workers that can each store half of A and the entire B.\n\n(b) Product code [10] in an example with 9 workers that can each store half of A and half of B. Fig. 2: Illustration of (a) 1D MDS code, and (b) product code proposed in [5], [10].\n\nIn this paper, we show that quite interestingly, the optimum recovery threshold can be far less than what the above two schemes achieve. In fact, we show that the minimum recovery threshold does not scale with the number of workers (i.e. \u0398(1)). We prove this fact by designing a novel coded computing strategy, referred to as the polynomial code, which achieves the optimum recovery threshold of mn, and significantly improves the state of the art. Hence, our main result is as follows.\n\nFor a general matrix multiplication task C = A B using N workers, where each worker can store 1 m fraction of A and 1 n fraction of B, we propose polynomial codes that achieve the optimum recovery threshold of K poly mn = \u0398(1).\n\nFurthermore, polynomial code only requires a decoding complexity that is almost linear to the input size.\n\nThe main novelty and advantage of the proposed polynomial code is that, by carefully designing the algebraic structure of the encoded submatrices, we ensure that any mn intermediate computations at the workers are sufficient for recovering the final matrix multiplication product at the master. This in a sense creates an MDS structure on the intermediate computations, instead of only the encoded matrices as in prior works. Furthermore, by leveraging the algebraic structure of polynomial codes, we can then map the reconstruction problem of the final output at the master to a polynomial interpolation problem (or equivalently Reed-Solomon decoding [12]), which can be solved efficiently [13]. This mapping also bridges the rich theory of algebraic coding and distributed matrix multiplication.\n\nWe prove the optimality of polynomial code by showing that it achieves the information theoretic lower bound on the recovery threshold, obtained by cut-set arguments (i.e., we need at least mn matrix blocks returned from workers to recover the final output, which exactly have size mn blocks). Hence, the proposed polynomial code essentially enables a specific computing strategy such that, from any subset of workers that give the minimum amount of information needed to recover C, the master can successfully decode the final output. As a by-product, we also prove the optimality of polynomial code under several other performance metrics considered in previous literature: computation latency [5], [10], probability of failure given a deadline [9], and communication load [14], [15].\n\nFinally, we extend the polynomial code to the problem of distributed convolution [9]. We show that by simply reducing the convolution problem to matrix multiplication and applying the polynomial code, we strictly and unboundedly improve the state of the art. Furthermore, by exploiting the computing structure of convolution, we propose a variation of the polynomial code, which strictly reduces the recovery threshold even further, and achieves the optimum recovery threshold within a factor of 2.\n\n\nII. SYSTEM MODEL, PROBLEM FORMULATION, AND MAIN RESULT\n\nWe consider a problem of matrix multiplication with two input matrices A \u2208 F s\u00d7r q and B \u2208 F s\u00d7t q , for some integers r, s, t and a sufficiently large finite field F q . We are interested in computing the product C A B in a distributed computing environment with a master node and N worker nodes, where each worker can store 1 m fraction of A and 1 n fraction of B, for some parameters m, n \u2208 N + (see Fig. 1). We assume at least one of the two input matrices A and B is tall (i.e. s \u2265 r or s \u2265 t), because otherwise the output matrix C would be rank inefficient and the problem is degenerated.\n\nSpecifically, each worker i can store two\nmatrices\u00c3 i \u2208 F s\u00d7 r m q andB i \u2208 F s\u00d7 t n q\n, computed based on arbitrary functions of A and B respectively. Each worker can compute the productC i \u00c3 iB i , and return it to the master. The master waits only for the results from a subset of workers, before proceeding to recover the final output C given these products using certain decoding functions. 2\n\n\nA. Problem Formulation\n\nGiven the above system model, we formulate the distributed matrix multiplication problem based on the following terminology: We define the computation strategy as the 2N functions, denoted by\nf = (f 0 , f 1 , ..., f N \u22121 ), g = (g 0 , g 1 , ..., g N \u22121 ),(4)\nthat are used to compute each\u00c3 i andB i . Specifically,\nA i = f i (A),B i = g i (B), \u2200 i \u2208 {0, 1, ..., N \u2212 1}.(5)\nFor any integer k, we say a computation strategy is k-recoverable if the master can recover C given the computing results from any k workers. We define the recovery threshold of a computation strategy, denoted by k(f , g), as the minimum integer k such that computation strategy (f , g) is k-recoverable.\n\nUsing the above terminology, we define the following concept: Definition 1. For a distributed matrix multiplication problem of computing A B using N workers that can each store 1 m fraction of A and 1 n fraction of B, we define the optimum recovery threshold, denoted by K * , as the minimum achievable recovery threshold among all computation strategies, i.e.\nK * min f ,g k(f , g).(6)\nThe goal of this problem is to find the optimum recovery threshold K * , as well as a computation strategy that achieves such an optimum threshold.\n\n\nB. Main Result\n\nOur main result is stated in the following theorem: Theorem 1. For a distributed matrix multiplication problem of computing A B using N workers that can each store 1 m fraction of A and 1 n fraction of B, the minimum recovery threshold K * is K * = mn.\n\nFurthermore, there is a computation strategy, referred to as the polynomial code, that achieves the above K * while allowing efficient decoding at the master node, i.e., with complexity equal to that of polynomial interpolation given mn points. Remark 1. Compared to the state of the art [5], [10], the polynomial code provides order-wise improvement in terms of the recovery threshold. Specifically, the recovery threshold achieved by 1D MDS code [16] and product code [10] scale linearly with N and \u221a N respectively, while the proposed polynomial code actually achieves a recovery threshold that does not scale with N . Remark 2. The polynomial code not only improves the state of the art asymptotically, but also gives strict and significant improvement for any parameter values of N , m, and n (See Fig. 3 for example).  [5] and product code [10]), where each worker can store 1 10 fraction of each input matrix. The polynomial code attains the optimum recovery threshold K * , and significantly improves the state of the art.\n\nRemark 3. As we will discuss in Section III-B, decoding polynomial code can be mapped to a polynomial interpolation problem, which can be solved in time almost linear to the input size [13]. This is enabled by carefully designing the computing strategies at the workers, such that the computed products form a Reed-Solomon code [17] , which can be decoded efficiently using any polynomial interpolation algorithm or Reed-Solomon decoding algorithm that provides the best performance depending on the problem scenario (e.g., [18]). Remark 4. We prove the optimality of polynomial code using a matching information theoretic lower bound, which is obtained by applying a cut-set type argument around the master node. As a by-product, we can also prove that the polynomial code simultaneously achieves optimality in terms of several other performance metrics, including the computation latency [5], [10], the probability of failure given a deadline [9], and the communication load [14], [15], as discussed in Section III-D. Remark 5. Polynomial code can be extended to other distributed computation applications involving linear algebraic operations. In Section IV, we focus on the problem of distributed convolution, and show that we can obtain order-wise improvement over the state of the art (see [9]) by directly applying the polynomial code. Furthermore, by exploiting the computing structure of convolution, we propose a variation of the polynomial code that achieves the optimum recovery threshold within a factor of 2.\n\n\nIII. POLYNOMIAL CODE AND ITS OPTIMALITY\n\nIn this section, we formally describe the polynomial code and its decoding procedure. We then prove its optimality with an information theoretic converse, which completes the proof of Theorem 1. Finally, we conclude this section with the optimality of polynomial code under other settings.\n\n\nA. Motivating Example\n\nWe first demonstrate the main idea through a motivating example. Consider a distributed matrix multiplication task of computing C = A B using N = 5 workers that can each store half of the matrices (see Fig. 4). We evenly divide each input matrix along the column side into 2 submatrices: Given this notation, we essentially want to compute the following 4 uncoded components:\nA = [A 0 A 1 ], B = [B 0 B 1 ].(8)C = A B = A 0 B 0 A 0 B 1 A 1 B 0 A 1 B 1 .(9)\nNow we design a computation strategy to achieve the optimum recovery threshold of 4. Suppose elements of A, B are in F 7 , let each worker i \u2208 {0, 1, ..., 4} store the following two coded submatrices:\nA i = A 0 + iA 1 ,B i = B 0 + i 2 B 1 .(10)\nTo prove that this design gives a recovery threshold of 4, we need to design a valid decoding function for any subset of 4 workers. We demonstrate this decodability through a representative scenario, where the master receives the computation results from workers 1, 2, 3, and 4, as shown in Figure 4. The decodability for the other 4 possible scenarios can be proved similarly.\n\nAccording to the designed computation strategy, we have\n\uf8ee \uf8ef \uf8ef \uf8f0C 1 C 2 C 3 C 4 \uf8f9 \uf8fa \uf8fa \uf8fb = \uf8ee \uf8ef \uf8ef \uf8f0 1 0 1 1 1 2 1 3 2 0 2 1 2 2 2 3 3 0 3 1 3 2 3 3 4 0 4 1 4 2 4 3 \uf8f9 \uf8fa \uf8fa \uf8fb \uf8ee \uf8ef \uf8ef \uf8f0 A 0 B 0 A 1 B 0 A 0 B 1 A 1 B 1 \uf8f9 \uf8fa \uf8fa \uf8fb .(11)\nThe coefficient matrix in the above equation is a Vandermonde matrix, which is invertible because its parameters 1, 2, 3, 4 are distinct in F 7 . So one way to recover C is to directly invert equation (11), which proves the decodability. However, directly computing this inverse using the classical inversion algorithm might be expensive in more general cases. Quite interestingly, because of the algebraic structure we designed for the computation strategy (i.e., equation (10)), the decoding process can be viewed as a polynomial interpolation problem (or equivalently, decoding a Reed-Solomon code). Specifically, in this example each worker i returns\nC i =\u00c3 iB i = A 0 B 0 + iA 1 B 0 + i 2 A 0 B 1 + i 3 A 1 B 1 ,(12)\nwhich is essentially the value of the following polynomial at point x = i:\nh(x) A 0 B 0 + xA 1 B 0 + x 2 A 0 B 1 + x 3 A 1 B 1 .(13)\nHence, recovering C using computation results from 4 workers is equivalent to interpolating a 3rd-degree polynomial given its values at 4 points. Later in this section, we will show that by mapping the decoding process to polynomial interpolation, we can achieve almost-linear decoding complexity.\n\n\nB. General Polynomial Code\n\nNow we present the polynomial code in a general setting that achieves the optimum recovery threshold stated in Theorem 1 for any parameter values of N , m, and n. First of all, we evenly divide each input matrix along the column side into m and n submatrices respectively, i.e.,\nA = [A 0 A 1 ... A m\u22121 ], B = [B 0 B 1 ... B n\u22121 ],(14)\nWe then assign each worker i \u2208 {0, 1, ..., N \u2212 1} a number in F q , denoted by x i , and make sure that all x i 's are distinct. Under this setting, we define the following class of computation strategies. Definition 2. Given parameters \u03b1, \u03b2 \u2208 N, we define the (\u03b1, \u03b2)-polynomial code as\nA i = m\u22121 j=0 A j x j\u03b1 i ,B i = n\u22121 j=0 B j x j\u03b2 i , \u2200 i \u2208 {0, 1, ..., N \u2212 1}.(15)\nIn an (\u03b1, \u03b2)-polynomial code, each worker i essentially computes\nC i =\u00c3 iB i = m\u22121 j=0 n\u22121 k=0 A j B k x j\u03b1+k\u03b2 i .(16)\nIn order for the master to recover the output given any mn results (i.e. achieve the optimum recovery threshold), we carefully select the design parameters \u03b1 and \u03b2, while making sure that no two terms in the above formula has the same exponent of x.\nOne such choice is (\u03b1, \u03b2) = (1, m), i.e, let\u00c3 i = m\u22121 j=0 A j x j i ,B i = n\u22121 j=0 B j x jm i .(17)\nHence, each worker computes the value of the following degree mn \u2212 1 polynomial at point x = x i :\nh(x) m\u22121 j=0 n\u22121 k=0 A j B k x j+km ,(18)\nwhere the coefficients are exactly the mn uncoded components of C. Since all x i 's are selected to be distinct, recovering C given results from any mn workers is essentially interpolating h(x) using mn distinct points. Since h(x) has degree mn \u2212 1, the output C can always be uniquely decoded.\n\nIn terms of complexity, this decoding process can be viewed as interpolating degree mn \u2212 1 polynomials of F q for rt mn times. It is well known that polynomial interpolation of degree k has a complexity of O(k log 2 k log log k) [13]. Therefore, decoding polynomial code also only requires a complexity of O(rt log 2 (mn) log log(mn)). Furthermore, this complexity can be reduced by simply swapping in any faster polynomial interpolation algorithm or Reed-Solomon decoding algorithm. Remark 6. We can naturally extend polynomial code to the scenario where input matrix elements are real or complex numbers. In practical implementation, to avoid handling large elements in the coefficient matrix, we can first quantize input values into numbers of finite digits, embed them into a finite field that covers the range of possible values of the output matrix elements, and then directly apply polynomial code. By embedding into finite fields, we avoid large intermediate computing results, which effectively saves storage and computation time, and reduces numerical errors.\n\n\nC. Optimality of Polynomial Code for Recovery Threshold\n\nSo far we have constructed a computing scheme that achieves a recovery threshold of mn, which upper bounds K * . To complete the proof of Theorem 1, here we establish a matching lower bound through an information theoretic converse.\n\nWe need to prove that for any computation strategy, the master needs to wait for at least mn workers in order to recover the output. Recall that at least one of A and B is a tall matrix. Without loss of generality, assume A is tall (i.e. s \u2265 r). Let A be an arbitrary fixed full rank matrix and B be sampled from F s\u00d7t q uniformly at random. It is easy to show that C = A B is uniformly distributed on F r\u00d7t q . This means that the master essentially needs to recover a random variable with entropy of H(C) = rt log 2 q bits. Note that each worker returns rt mn elements of F q , providing at most rt mn log 2 q bits of information. Consequently, using a cut-set bound around the master, we can show that at least mn results from the workers need to be collected, and thus we have K * \u2265 mn. Remark 7 (Random Linear Code). We conclude this subsection by noting that, another computation design is to let each worker store two random linear combinations of the input submatrices. Although this design can achieve the optimal recovery threshold with high probability, it creates a large coding overhead and requires high decoding complexity (e.g., O(m 3 n 3 + mnrt) using the classical inversion decoding algorithm). Compared to random linear code, the proposed polynomial code achieves the optimum recovery threshold deterministically, with a significantly lower decoding complexity.\n\n\nD. Optimality of Polynomial Code for Other Performance Metrics\n\nIn the previous subsection, we proved that polynomial code is optimal in terms of the recovery threshold. As a by-product, we can prove that it is also optimal in terms of some other performance metrics. In particular, we consider the following 3 metrics considered in prior works, and formally establish the optimality of polynomial code for each of them. Proofs can be found in Appendix A.\n\nComputation latency is considered in models where the computation time T i of each worker i is a random variable with a certain probability distribution (e.g, [5], [10]). The computation latency is defined as the amount of time required for the master to collect enough information to decode C. Theorem 2. For any computation strategy, the computation latency T is always no less than the latency achieved by polynomial code, denoted by T poly . Namely,\nT \u2265 T poly .(19)\nProbability of failure given a deadline is defined as the probability that the master does not receive enough information to decode C at any time t [9]. Corollary 1. For any computation strategy, let T denote its computation latency, and let T poly denote the computation latency of polynomial code. We have\nP(T > t) \u2265 P(T poly > t) \u2200 t \u2265 0.(20)\nCorollary 1 directly follows from Theorem 2 since (19) implies (20) . Communication load is another important metric in distributed computing (e.g. [14], [15]), defined as the minimum number of bits needed to be communicated in order to complete the computation. Theorem 3. Polynomial code achieves the minimum communication load for distributed matrix multiplication, which is given by\nL * = rt log 2 q.(21)\n\nIV. EXTENSION TO DISTRIBUTED CONVOLUTION\n\nWe can extend our proposed polynomial code to distributed convolution. Specifically, we consider a convolution task with two input vectors\na = [a 0 a 1 ... a m\u22121 ], b = [b 0 b 1 ... b n\u22121 ],(22)\nwhere all a i 's and b i 's are vectors of length s over a sufficiently large field F q . We want to compute c a * b using a master and N workers. Each worker can store two vectors of length s, which are functions of a and b respectively. We refer to these functions as the computation strategy. Each worker computes the convolution of its stored vectors, and returns it to the master. The master only waits for the fastest subset of workers, before proceeding to decode c. Similar to distributed matrix multiplication, we define the recovery threshold for each computation strategy. We aim to characterize the optimum recovery threshold denoted by K * conv , and find computation strategies that closely achieve this optimum threshold, while allowing efficient decoding at the master.\n\nDistributed convolution has also been studied in [9], where the coded convolution scheme was proposed. The main idea of the coded convolution scheme is to inject redundancy in only one of the input vectors using MDS codes. The master waits for enough results such that all intermediate values a i * b j can be recovered, which allows the final output to be computed. One can show that this coded convolution scheme is in fact equivalent to the 1D MDS-coded scheme proposed in [10]. Consequently, it achieves a recovery threshold of K 1D-MDS = N \u2212 N n + m. Note that by simply adapting our proposed polynomial code designed for distributed matrix multiplication to distributed convolution, the master can recover all intermediate values a i * b j after receiving results from any mn workers, to decode the final output. Consequently, this achieves a recovery threshold of K poly = mn, which already strictly and significantly improves the state of the art.\n\nIn this paper, we take one step further and propose an improved computation strategy, strictly reducing the recovery threshold on top of the naive polynomial code. The result is summarized as follows: Theorem 4. For a distributed convolution problem of computing a * b using N workers that can each store 1 m fraction of a and 1 n fraction of b, we can find a computation strategy that achieves a recovery threshold of K conv-poly m + n \u2212 1.\n\nFurthermore, this computation strategy allows efficient decoding, i.e., with complexity equal to that of polynomial interpolation given m + n \u2212 1 points. We prove Theorem 4 by proposing a variation of the polynomial code, which exploits the computation structure of convolution. This new computing scheme is formally demonstrated in Appendix B. Remark 8. Similar to distributed matrix multiplication, our proposed computation strategy provides order-wise improvement compared to the state of the art [9] in many different settings. Furthermore, it achieves almost-linear decoding complexity using the fastest polynomial interpolation algorithm or the Reed-Solomon decoding algorithm. Moreover, we characterize K conv within a factor of 2, as stated in the following theorem and proved in Appendix C.\n\nTheorem 5. For a distributed convolution problem, the minimum recovery threshold K * conv can be characterized within a factor of 2, i.e.:\n1 2 K conv-poly < K * conv \u2264 K conv-poly .(24)\n\nAPPENDIX A OPTIMALITY OF POLYNOMIAL CODE IN LATENCY AND COMMUNICATION LOAD\n\nIn this section we prove the optimality of polynomial code for distributed matrix multiplication in terms of computation latency and communication load. Specifically, we provide the proof of Theorem 2 and Theorem 3.\n\n\nA. Proof of Theorem 2\n\nConsider an arbitrary computation strategy, we denote its computation latency by T . By definition, T is given as follows:\nT = min{ t \u2265 0 | C is decodable given results from all workers in { i | T i \u2264 t } },(25)\nwhere T i denotes the computation time of worker i. To simplify the discussion, we define\nS(t) = { i | T i \u2264 t }(26)\ngiven T 0 , T 1 , ..., T N \u22121 . As proved in Section 3.3, if C is decodable at any time t, there must be at least mn workers finishes computation. Consequently, we have T = min{ t \u2265 0 | C is decodable given results from all workers in S(t) } = min{ t \u2265 0 | C is decodable given results from all workers in S(t) and |S(t)| \u2265 mn }\n\u2265 min{ t \u2265 0 | |S(t)| \u2265 mn }.(27)\nOn the other hand, we consider the latency of polynomial code, denoted by T poly . Recall that for the polynomial code, the output C is decodable if and only if at least mn workers finishes computation, i.e., |S(t) \u2265 mn|. We have\nT poly = min{ t \u2265 0 | |S(t)| \u2265 mn }.(28)\nHence, T \u2265 T poly always holds true, which proves Theorem 2.\n\n\nB. Proof of Theorem 3\n\nRecall that in Section 3.3 we have proved that if the input matrices are sampled based on a certain distribution, then decoding the output C requires that the entropy of the entire message received by the server is at least rt log 2 q. Consequently, it takes at least rt log 2 q bits deliver such messages, which lower bounds the minimum communication load.\n\nOn the other hand, the polynomial code requires delivering rt elements in F q in total, which achieves this minimum communication load. Hence, the minimum communication load L * equals rt log 2 q.\n\n\nAPPENDIX B PROOF OF THEOREM 4\n\nIn this section, we formally describe a computation strategy, which achieves the recovery threshold stated in Theorem 4. Consider a distributed convolution problem with two input vectors\na = [a 0 a 1 ... a m\u22121 ], b = [b 0 b 1 ... b n\u22121 ],(29)\nwhere the a i 's and b i 's are vectors of length s. We aim to compute c = a * b using N workers. In previous literature [9], the computation strategies were designed so that the master can recover all intermediate values a j * b k 's. This is essentially the same computing framework used in the distributed matrix multiplication problem, so by naively applying the polynomial code (specifically the (1, m)-polynomial code using the notation in Definition 2), we can achieve the corresponding optimal recovery threshold in computing all a j * b k 's. However, the master does not need to know each individual a i * b j in order to recover the output c. To customize the coding design so as to utilize this fact, we recall the general class of computation strategies stated in Definition 2: Given design parameters \u03b1 and \u03b2, the (\u03b1, \u03b2)-polynomial code lets each worker i store two vectors\na i = m\u22121 j=0 a j x j\u03b1 i ,b i = n\u22121 j=0 b j x j\u03b2 i ,(30)\nwhere the x i 's are N distinct values assigned to the N workers.\n\nRecall that in the polynomial code designed for matrix multiplication, we picked values of \u03b1, \u03b2 such that, in the local product, all coefficients a j * b k are preserved as individual terms with distinct exponents on x i . The fact that no two terms were combined leaves enough information to the master, so that it can decode any individual coefficient value from the intermediate result. Now that decoding all individual values is no longer required in the problem of convolution, we can design a new variation of the polynomial code to further improve recovery threshold, using design parameters \u03b1 = \u03b2 = 1. In other words, each worker stores two vectors\u00e3\ni = m\u22121 j=0 a j x j i ,b i = n\u22121 j=0 b j x j i .(31)\nAfter computing the convolution product of the two locally stored vectors, each worker i returns\na i * b i = m\u22121 j=0 n\u22121 k=0 a j * b k x j+k i ,(32)\nwhich is essentially the value of the following degree m + n \u2212 2 polynomial at point x = x i .\nh(x) = m+n\u22122 j=0 min{j,n\u22121} k=max{0,j\u2212m+1} a j\u2212k * b k x j i .(33)\nUsing this design, instead of recovering all a j * b k 's, the server can only recover a subspace of their linear combinations. Interestingly, we can still recover c using these linear combinations, because it is easy to show that, if two values are combined in the same term of vector min{j,n\u22121} k=max{0,j\u2212m+1} a j\u2212k * b k , then they are also combined in the same term of c. Consequently, after receiving the computing results from any m + n \u2212 1 workers, the server can recover all the coefficients of h(x), which allows recovering c, which prove that this computation strategy achieves a recovery threshold of m + n \u2212 1.\n\nSimilar to distributed matrix multiplication, this decoding process can be viewed as interpolating degree m+n\u22122 polynomials of F q for s times. Consequently, the decoding complexity is O(s(m + n) log 2 (m + n) log log(m + n)), which is almost-linear to the input size s(m + n). Remark 9. Similar to distributed matrix multiplication, we can also extend this computation strategy to the scenario where the elements of input vectors are real or complex numbers, by quantizing all input values, embedding them into a finite field, and then directly applying our distributed convolution algorithm.\n\nAPPENDIX C ORDER-WISE CHARACTERIZATION OF K conv Now we prove Theorem 5, which characterizes the optimum recovery threshold K conv within a factor of 2. The upper bound K * conv \u2264 K conv-poly directly follows from Theorem 4, hence we focus on proving the lower bound of K * conv . We first prove the following inequality.\nK * conv \u2265 max{m, n}.(34)\nLet a be any fixed non-zero vector, and b be sampled from F sn q uniformly at random. We can be easily show that the operation of convolving with a is invertible, and thus the entropy of c a * b equals that of b, which is sn log 2 q. Note that each worker i returns\u00e3 i * b i , whose entropy is at most H(\u00e3 i ) + H(b i ) = s log 2 q. Using a cut-set bound around the master, we can show that at least n results from the workers need to be collected, and thus we have K * \u2265 n.\n\nSimilarly we have K * \u2265 m, hence K * \u2265 max{m, n}. Thus we can show that the gap between the upper and lower bounds is no larger than 2: K * \u2265 max{m, n} \u2265 m+n \n\nFig. 3 :\n3Comparison of the recovery thresholds achieved by the proposed polynomial code and the state of the arts (1D MDS code\n\nFig. 4 :\n4Example using polynomial code, with 5 workers that can each store half of each input matrix. (a) Computation strategy: each worker i stores A0 + iA1 and B0 + i 2 B1, and computes their product. (b) Decoding: master waits for results from any 4 workers, and decodes the output using fast polynomial interpolation algorithm.\nAn (n, k) MDS code is a linear code which transforms k raw inputs to n coded outputs, such that from any subset of size k of the outputs, the original k inputs can be recovered.\nNote that we consider the most general model and do not impose any constraints on the decoding functions. However, any good decoding function should have relatively low computation complexity.\n\nMapReduce: Simplified data processing on large clusters. J Dean, S Ghemawat, Sixth USENIX Symposium on Operating System Design and Implementation. J. Dean and S. Ghemawat, \"MapReduce: Simplified data processing on large clusters,\" Sixth USENIX Symposium on Operating System Design and Implementation, Dec. 2004.\n\nSpark: cluster computing with working sets. M Zaharia, M Chowdhury, M J Franklin, S Shenker, I Stoica, Proceedings of the 2nd USENIX HotCloud. the 2nd USENIX HotCloud1010M. Zaharia, M. Chowdhury, M. J. Franklin, S. Shenker, and I. Stoica, \"Spark: cluster computing with working sets,\" in Proceedings of the 2nd USENIX HotCloud, vol. 10, p. 10, June 2010.\n\nThe tail at scale. J Dean, L A Barroso, Communications of the ACM. 562J. Dean and L. A. Barroso, \"The tail at scale,\" Communications of the ACM, vol. 56, no. 2, pp. 74-80, 2013.\n\nImproving MapReduce performance in heterogeneous environments. M Zaharia, A Konwinski, A D Joseph, R H Katz, I Stoica, OSDI. 87M. Zaharia, A. Konwinski, A. D. Joseph, R. H. Katz, and I. Stoica, \"Improving MapReduce performance in heterogeneous environments,\" OSDI, vol. 8, p. 7, Dec. 2008.\n\nSpeeding up distributed machine learning using codes. K Lee, M Lam, R Pedarsani, D Papailiopoulos, K Ramchandran, arXiv:1512.02673e-printK. Lee, M. Lam, R. Pedarsani, D. Papailiopoulos, and K. Ramchandran, \"Speeding up distributed machine learning using codes,\" e-print arXiv:1512.02673, 2015.\n\nA unified coding framework for distributed computing with straggling servers. S Li, M A Maddah-Ali, A S Avestimehr, arXiv:1609.01690arXiv preprintS. Li, M. A. Maddah-Ali, and A. S. Avestimehr, \"A unified coding framework for distributed computing with straggling servers,\" arXiv preprint arXiv:1609.01690, 2016.\n\nCoded computation over heterogeneous clusters. A Reisizadehmobarakeh, S Prakash, R Pedarsani, S Avestimehr, arXiv:1701.05973arXiv preprintA. Reisizadehmobarakeh, S. Prakash, R. Pedarsani, and S. Avestimehr, \"Coded computation over heterogeneous clusters,\" arXiv preprint arXiv:1701.05973, 2017.\n\nGradient coding. R Tandon, Q Lei, A G Dimakis, N Karampatziakis, arXiv:1612.03301arXiv preprintR. Tandon, Q. Lei, A. G. Dimakis, and N. Karampatziakis, \"Gradient coding,\" arXiv preprint arXiv:1612.03301, 2016.\n\nCoded convolution for parallel and distributed computing within a deadline. S Dutta, V Cadambe, P Grover, arXiv:1705.03875arXiv preprintS. Dutta, V. Cadambe, and P. Grover, \"Coded convolution for parallel and distributed computing within a deadline,\" arXiv preprint arXiv:1705.03875, 2017.\n\nHigh-dimensional coded matrix multiplication. K Lee, C Suh, K Ramchandran, IEEE International Symposium on Information Theory. K. Lee, C. Suh, and K. Ramchandran, \"High-dimensional coded matrix multiplication,\" IEEE International Symposium on Information Theory, 2017.\n\nMaximum distance q-nary codes. R Singleton, IEEE Transactions on Information Theory. 102R. Singleton, \"Maximum distance q-nary codes,\" IEEE Transactions on Information Theory, vol. 10, no. 2, pp. 116-118, 1964.\n\nEfficient erasure decoding of reed-solomon codes. F Didier, arXiv:0901.1886arXiv preprintF. Didier, \"Efficient erasure decoding of reed-solomon codes,\" arXiv preprint arXiv:0901.1886, 2009.\n\nFast polynomial factorization and modular composition. K S Kedlaya, C Umans, SIAM Journal on Computing. 406K. S. Kedlaya and C. Umans, \"Fast polynomial factorization and modular composition,\" SIAM Journal on Computing, vol. 40, no. 6, pp. 1767-1802, 2011.\n\nA fundamental tradeoff between computation and communication in distributed computing. S Li, M A Maddah-Ali, Q Yu, A S Avestimehr, arXiv:1604.07086Submitted to IEEE Transactions on Information Theory. e-printS. Li, M. A. Maddah-Ali, Q. Yu, and A. S. Avestimehr, \"A fundamental tradeoff between computation and communication in distributed computing,\" e-print arXiv:1604.07086. Submitted to IEEE Transactions on Information Theory, 2016.\n\nHow to optimally allocate resources for coded distributed computing?. Q Yu, S Li, M A Maddah-Ali, A S Avestimehr, arXiv:1702.07297arXiv preprintQ. Yu, S. Li, M. A. Maddah-Ali, and A. S. Avestimehr, \"How to optimally allocate resources for coded distributed computing?,\" arXiv preprint arXiv:1702.07297, 2017.\n\nPowers of tensors and fast matrix multiplication. F , Le Gall, Proceedings of the 39th international symposium on symbolic and algebraic computation. the 39th international symposium on symbolic and algebraic computationACMF. Le Gall, \"Powers of tensors and fast matrix multiplication,\" in Proceedings of the 39th international symposium on symbolic and algebraic computation, pp. 296-303, ACM, 2014.\n\nIntroduction to coding theory. R Roth, Cambridge University PressR. Roth, Introduction to coding theory. Cambridge University Press, 2006.\n\nAchieving efficient polynomial multiplication in fermat fields using the fast fourier transform. S Baktir, B Sunar, Proceedings of the 44th annual Southeast regional conference. the 44th annual Southeast regional conferenceACMS. Baktir and B. Sunar, \"Achieving efficient polynomial multiplication in fermat fields using the fast fourier transform,\" in Proceedings of the 44th annual Southeast regional conference, pp. 549-554, ACM, 2006.\n", "annotations": {"author": "[{\"end\":185,\"start\":88},{\"end\":240,\"start\":186},{\"end\":350,\"start\":241}]", "publisher": null, "author_last_name": "[{\"end\":95,\"start\":93},{\"end\":209,\"start\":199},{\"end\":260,\"start\":250}]", "author_first_name": "[{\"end\":92,\"start\":88},{\"end\":194,\"start\":186},{\"end\":198,\"start\":195},{\"end\":242,\"start\":241},{\"end\":249,\"start\":243}]", "author_affiliation": "[{\"end\":184,\"start\":97},{\"end\":239,\"start\":211},{\"end\":349,\"start\":262}]", "title": "[{\"end\":85,\"start\":1},{\"end\":435,\"start\":351}]", "venue": null, "abstract": "[{\"end\":1503,\"start\":438}]", "bib_ref": "[{\"attributes\":{\"ref_id\":\"b0\"},\"end\":1818,\"start\":1815},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":1832,\"start\":1829},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":2129,\"start\":2126},{\"attributes\":{\"ref_id\":\"b3\"},\"end\":2376,\"start\":2373},{\"attributes\":{\"ref_id\":\"b4\"},\"end\":2582,\"start\":2579},{\"attributes\":{\"ref_id\":\"b5\"},\"end\":2587,\"start\":2584},{\"attributes\":{\"ref_id\":\"b6\"},\"end\":2592,\"start\":2589},{\"attributes\":{\"ref_id\":\"b7\"},\"end\":2597,\"start\":2594},{\"attributes\":{\"ref_id\":\"b8\"},\"end\":2602,\"start\":2599},{\"attributes\":{\"ref_id\":\"b4\"},\"end\":4428,\"start\":4425},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":4449,\"start\":4445},{\"attributes\":{\"ref_id\":\"b10\"},\"end\":4553,\"start\":4549},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":5760,\"start\":5756},{\"attributes\":{\"ref_id\":\"b4\"},\"end\":7006,\"start\":7003},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":7106,\"start\":7102},{\"attributes\":{\"ref_id\":\"b4\"},\"end\":7258,\"start\":7255},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":7264,\"start\":7260},{\"attributes\":{\"ref_id\":\"b11\"},\"end\":8747,\"start\":8743},{\"attributes\":{\"ref_id\":\"b12\"},\"end\":8786,\"start\":8782},{\"attributes\":{\"ref_id\":\"b4\"},\"end\":9589,\"start\":9586},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":9595,\"start\":9591},{\"attributes\":{\"ref_id\":\"b8\"},\"end\":9640,\"start\":9637},{\"attributes\":{\"ref_id\":\"b13\"},\"end\":9669,\"start\":9665},{\"attributes\":{\"ref_id\":\"b14\"},\"end\":9675,\"start\":9671},{\"attributes\":{\"ref_id\":\"b8\"},\"end\":9762,\"start\":9759},{\"attributes\":{\"ref_id\":\"b4\"},\"end\":13033,\"start\":13030},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":13039,\"start\":13035},{\"attributes\":{\"ref_id\":\"b15\"},\"end\":13194,\"start\":13190},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":13216,\"start\":13212},{\"attributes\":{\"ref_id\":\"b4\"},\"end\":13570,\"start\":13567},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":13592,\"start\":13588},{\"attributes\":{\"ref_id\":\"b0\"},\"end\":13624,\"start\":13623},{\"attributes\":{\"ref_id\":\"b12\"},\"end\":13963,\"start\":13959},{\"attributes\":{\"ref_id\":\"b16\"},\"end\":14106,\"start\":14102},{\"attributes\":{\"ref_id\":\"b17\"},\"end\":14302,\"start\":14298},{\"attributes\":{\"ref_id\":\"b4\"},\"end\":14667,\"start\":14664},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":14673,\"start\":14669},{\"attributes\":{\"ref_id\":\"b8\"},\"end\":14722,\"start\":14719},{\"attributes\":{\"ref_id\":\"b13\"},\"end\":14755,\"start\":14751},{\"attributes\":{\"ref_id\":\"b14\"},\"end\":14761,\"start\":14757},{\"attributes\":{\"ref_id\":\"b8\"},\"end\":15073,\"start\":15070},{\"attributes\":{\"ref_id\":\"b10\"},\"end\":17164,\"start\":17160},{\"attributes\":{\"ref_id\":\"b12\"},\"end\":19986,\"start\":19982},{\"attributes\":{\"ref_id\":\"b4\"},\"end\":23119,\"start\":23116},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":23125,\"start\":23121},{\"attributes\":{\"ref_id\":\"b8\"},\"end\":23579,\"start\":23576},{\"attributes\":{\"ref_id\":\"b13\"},\"end\":23926,\"start\":23922},{\"attributes\":{\"ref_id\":\"b14\"},\"end\":23932,\"start\":23928},{\"attributes\":{\"ref_id\":\"b8\"},\"end\":25260,\"start\":25257},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":25688,\"start\":25684},{\"attributes\":{\"ref_id\":\"b8\"},\"end\":27111,\"start\":27108},{\"attributes\":{\"ref_id\":\"b8\"},\"end\":29918,\"start\":29915}]", "figure": "[{\"attributes\":{\"id\":\"fig_0\"},\"end\":34159,\"start\":34031},{\"attributes\":{\"id\":\"fig_1\"},\"end\":34493,\"start\":34160}]", "paragraph": "[{\"end\":1950,\"start\":1522},{\"end\":2843,\"start\":1952},{\"end\":3430,\"start\":2845},{\"end\":4030,\"start\":3432},{\"end\":4282,\"start\":4032},{\"end\":5029,\"start\":4284},{\"end\":5665,\"start\":5031},{\"end\":5935,\"start\":5699},{\"end\":6616,\"start\":5957},{\"end\":6886,\"start\":6807},{\"end\":6985,\"start\":6941},{\"end\":7083,\"start\":6987},{\"end\":7265,\"start\":7085},{\"end\":7753,\"start\":7267},{\"end\":7982,\"start\":7755},{\"end\":8089,\"start\":7984},{\"end\":8888,\"start\":8091},{\"end\":9676,\"start\":8890},{\"end\":10176,\"start\":9678},{\"end\":10830,\"start\":10235},{\"end\":10873,\"start\":10832},{\"end\":11229,\"start\":10919},{\"end\":11447,\"start\":11256},{\"end\":11570,\"start\":11515},{\"end\":11933,\"start\":11629},{\"end\":12295,\"start\":11935},{\"end\":12469,\"start\":12322},{\"end\":12740,\"start\":12488},{\"end\":13772,\"start\":12742},{\"end\":15296,\"start\":13774},{\"end\":15629,\"start\":15340},{\"end\":16030,\"start\":15655},{\"end\":16312,\"start\":16112},{\"end\":16734,\"start\":16357},{\"end\":16791,\"start\":16736},{\"end\":17613,\"start\":16959},{\"end\":17755,\"start\":17681},{\"end\":18111,\"start\":17814},{\"end\":18420,\"start\":18142},{\"end\":18763,\"start\":18477},{\"end\":18911,\"start\":18847},{\"end\":19215,\"start\":18966},{\"end\":19414,\"start\":19316},{\"end\":19751,\"start\":19457},{\"end\":20822,\"start\":19753},{\"end\":21114,\"start\":20882},{\"end\":22497,\"start\":21116},{\"end\":22955,\"start\":22564},{\"end\":23410,\"start\":22957},{\"end\":23735,\"start\":23428},{\"end\":24160,\"start\":23774},{\"end\":24364,\"start\":24226},{\"end\":25206,\"start\":24421},{\"end\":26163,\"start\":25208},{\"end\":26606,\"start\":26165},{\"end\":27407,\"start\":26608},{\"end\":27547,\"start\":27409},{\"end\":27887,\"start\":27672},{\"end\":28035,\"start\":27913},{\"end\":28214,\"start\":28125},{\"end\":28570,\"start\":28242},{\"end\":28834,\"start\":28605},{\"end\":28936,\"start\":28876},{\"end\":29319,\"start\":28962},{\"end\":29517,\"start\":29321},{\"end\":29737,\"start\":29551},{\"end\":30681,\"start\":29794},{\"end\":30804,\"start\":30739},{\"end\":31463,\"start\":30806},{\"end\":31613,\"start\":31517},{\"end\":31760,\"start\":31666},{\"end\":32451,\"start\":31828},{\"end\":33046,\"start\":32453},{\"end\":33369,\"start\":33048},{\"end\":33870,\"start\":33396},{\"end\":34030,\"start\":33872}]", "formula": "[{\"attributes\":{\"id\":\"formula_0\"},\"end\":5698,\"start\":5666},{\"attributes\":{\"id\":\"formula_1\"},\"end\":5956,\"start\":5936},{\"attributes\":{\"id\":\"formula_2\"},\"end\":6726,\"start\":6617},{\"attributes\":{\"id\":\"formula_3\"},\"end\":6806,\"start\":6726},{\"attributes\":{\"id\":\"formula_4\"},\"end\":6940,\"start\":6887},{\"attributes\":{\"id\":\"formula_6\"},\"end\":10918,\"start\":10874},{\"attributes\":{\"id\":\"formula_7\"},\"end\":11514,\"start\":11448},{\"attributes\":{\"id\":\"formula_8\"},\"end\":11628,\"start\":11571},{\"attributes\":{\"id\":\"formula_9\"},\"end\":12321,\"start\":12296},{\"attributes\":{\"id\":\"formula_11\"},\"end\":16065,\"start\":16031},{\"attributes\":{\"id\":\"formula_12\"},\"end\":16111,\"start\":16065},{\"attributes\":{\"id\":\"formula_13\"},\"end\":16356,\"start\":16313},{\"attributes\":{\"id\":\"formula_14\"},\"end\":16958,\"start\":16792},{\"attributes\":{\"id\":\"formula_15\"},\"end\":17680,\"start\":17614},{\"attributes\":{\"id\":\"formula_16\"},\"end\":17813,\"start\":17756},{\"attributes\":{\"id\":\"formula_17\"},\"end\":18476,\"start\":18421},{\"attributes\":{\"id\":\"formula_18\"},\"end\":18846,\"start\":18764},{\"attributes\":{\"id\":\"formula_19\"},\"end\":18965,\"start\":18912},{\"attributes\":{\"id\":\"formula_20\"},\"end\":19315,\"start\":19216},{\"attributes\":{\"id\":\"formula_21\"},\"end\":19456,\"start\":19415},{\"attributes\":{\"id\":\"formula_22\"},\"end\":23427,\"start\":23411},{\"attributes\":{\"id\":\"formula_23\"},\"end\":23773,\"start\":23736},{\"attributes\":{\"id\":\"formula_24\"},\"end\":24182,\"start\":24161},{\"attributes\":{\"id\":\"formula_25\"},\"end\":24420,\"start\":24365},{\"attributes\":{\"id\":\"formula_27\"},\"end\":27594,\"start\":27548},{\"attributes\":{\"id\":\"formula_28\"},\"end\":28124,\"start\":28036},{\"attributes\":{\"id\":\"formula_29\"},\"end\":28241,\"start\":28215},{\"attributes\":{\"id\":\"formula_30\"},\"end\":28604,\"start\":28571},{\"attributes\":{\"id\":\"formula_31\"},\"end\":28875,\"start\":28835},{\"attributes\":{\"id\":\"formula_32\"},\"end\":29793,\"start\":29738},{\"attributes\":{\"id\":\"formula_33\"},\"end\":30738,\"start\":30682},{\"attributes\":{\"id\":\"formula_34\"},\"end\":31516,\"start\":31464},{\"attributes\":{\"id\":\"formula_35\"},\"end\":31665,\"start\":31614},{\"attributes\":{\"id\":\"formula_36\"},\"end\":31827,\"start\":31761},{\"attributes\":{\"id\":\"formula_37\"},\"end\":33395,\"start\":33370}]", "table_ref": null, "section_header": "[{\"end\":1520,\"start\":1505},{\"end\":10233,\"start\":10179},{\"end\":11254,\"start\":11232},{\"end\":12486,\"start\":12472},{\"end\":15338,\"start\":15299},{\"end\":15653,\"start\":15632},{\"end\":18140,\"start\":18114},{\"end\":20880,\"start\":20825},{\"end\":22562,\"start\":22500},{\"end\":24224,\"start\":24184},{\"end\":27670,\"start\":27596},{\"end\":27911,\"start\":27890},{\"end\":28960,\"start\":28939},{\"end\":29549,\"start\":29520},{\"end\":34040,\"start\":34032},{\"end\":34169,\"start\":34161}]", "table": null, "figure_caption": "[{\"end\":34159,\"start\":34042},{\"end\":34493,\"start\":34171}]", "figure_ref": "[{\"end\":2999,\"start\":2993},{\"end\":4676,\"start\":4669},{\"end\":5043,\"start\":5037},{\"end\":5900,\"start\":5893},{\"end\":6560,\"start\":6553},{\"end\":7187,\"start\":7181},{\"end\":10644,\"start\":10638},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":13551,\"start\":13545},{\"attributes\":{\"ref_id\":\"fig_1\"},\"end\":15863,\"start\":15857},{\"attributes\":{\"ref_id\":\"fig_1\"},\"end\":16656,\"start\":16648}]", "bib_author_first_name": "[{\"end\":34924,\"start\":34923},{\"end\":34932,\"start\":34931},{\"end\":35224,\"start\":35223},{\"end\":35235,\"start\":35234},{\"end\":35248,\"start\":35247},{\"end\":35250,\"start\":35249},{\"end\":35262,\"start\":35261},{\"end\":35273,\"start\":35272},{\"end\":35555,\"start\":35554},{\"end\":35563,\"start\":35562},{\"end\":35565,\"start\":35564},{\"end\":35778,\"start\":35777},{\"end\":35789,\"start\":35788},{\"end\":35802,\"start\":35801},{\"end\":35804,\"start\":35803},{\"end\":35814,\"start\":35813},{\"end\":35816,\"start\":35815},{\"end\":35824,\"start\":35823},{\"end\":36060,\"start\":36059},{\"end\":36067,\"start\":36066},{\"end\":36074,\"start\":36073},{\"end\":36087,\"start\":36086},{\"end\":36105,\"start\":36104},{\"end\":36379,\"start\":36378},{\"end\":36385,\"start\":36384},{\"end\":36387,\"start\":36386},{\"end\":36401,\"start\":36400},{\"end\":36403,\"start\":36402},{\"end\":36661,\"start\":36660},{\"end\":36684,\"start\":36683},{\"end\":36695,\"start\":36694},{\"end\":36708,\"start\":36707},{\"end\":36927,\"start\":36926},{\"end\":36937,\"start\":36936},{\"end\":36944,\"start\":36943},{\"end\":36946,\"start\":36945},{\"end\":36957,\"start\":36956},{\"end\":37197,\"start\":37196},{\"end\":37206,\"start\":37205},{\"end\":37217,\"start\":37216},{\"end\":37458,\"start\":37457},{\"end\":37465,\"start\":37464},{\"end\":37472,\"start\":37471},{\"end\":37713,\"start\":37712},{\"end\":37944,\"start\":37943},{\"end\":38140,\"start\":38139},{\"end\":38142,\"start\":38141},{\"end\":38153,\"start\":38152},{\"end\":38429,\"start\":38428},{\"end\":38435,\"start\":38434},{\"end\":38437,\"start\":38436},{\"end\":38451,\"start\":38450},{\"end\":38457,\"start\":38456},{\"end\":38459,\"start\":38458},{\"end\":38850,\"start\":38849},{\"end\":38856,\"start\":38855},{\"end\":38862,\"start\":38861},{\"end\":38864,\"start\":38863},{\"end\":38878,\"start\":38877},{\"end\":38880,\"start\":38879},{\"end\":39140,\"start\":39139},{\"end\":39145,\"start\":39143},{\"end\":39523,\"start\":39522},{\"end\":39729,\"start\":39728},{\"end\":39739,\"start\":39738}]", "bib_author_last_name": "[{\"end\":34929,\"start\":34925},{\"end\":34941,\"start\":34933},{\"end\":35232,\"start\":35225},{\"end\":35245,\"start\":35236},{\"end\":35259,\"start\":35251},{\"end\":35270,\"start\":35263},{\"end\":35280,\"start\":35274},{\"end\":35560,\"start\":35556},{\"end\":35573,\"start\":35566},{\"end\":35786,\"start\":35779},{\"end\":35799,\"start\":35790},{\"end\":35811,\"start\":35805},{\"end\":35821,\"start\":35817},{\"end\":35831,\"start\":35825},{\"end\":36064,\"start\":36061},{\"end\":36071,\"start\":36068},{\"end\":36084,\"start\":36075},{\"end\":36102,\"start\":36088},{\"end\":36117,\"start\":36106},{\"end\":36382,\"start\":36380},{\"end\":36398,\"start\":36388},{\"end\":36414,\"start\":36404},{\"end\":36681,\"start\":36662},{\"end\":36692,\"start\":36685},{\"end\":36705,\"start\":36696},{\"end\":36719,\"start\":36709},{\"end\":36934,\"start\":36928},{\"end\":36941,\"start\":36938},{\"end\":36954,\"start\":36947},{\"end\":36972,\"start\":36958},{\"end\":37203,\"start\":37198},{\"end\":37214,\"start\":37207},{\"end\":37224,\"start\":37218},{\"end\":37462,\"start\":37459},{\"end\":37469,\"start\":37466},{\"end\":37484,\"start\":37473},{\"end\":37723,\"start\":37714},{\"end\":37951,\"start\":37945},{\"end\":38150,\"start\":38143},{\"end\":38159,\"start\":38154},{\"end\":38432,\"start\":38430},{\"end\":38448,\"start\":38438},{\"end\":38454,\"start\":38452},{\"end\":38470,\"start\":38460},{\"end\":38853,\"start\":38851},{\"end\":38859,\"start\":38857},{\"end\":38875,\"start\":38865},{\"end\":38891,\"start\":38881},{\"end\":39150,\"start\":39146},{\"end\":39528,\"start\":39524},{\"end\":39736,\"start\":39730},{\"end\":39745,\"start\":39740}]", "bib_entry": "[{\"attributes\":{\"id\":\"b0\",\"matched_paper_id\":67055872},\"end\":35177,\"start\":34866},{\"attributes\":{\"id\":\"b1\",\"matched_paper_id\":11818928},\"end\":35533,\"start\":35179},{\"attributes\":{\"id\":\"b2\",\"matched_paper_id\":34900520},\"end\":35712,\"start\":35535},{\"attributes\":{\"id\":\"b3\",\"matched_paper_id\":9315803},\"end\":36003,\"start\":35714},{\"attributes\":{\"doi\":\"arXiv:1512.02673\",\"id\":\"b4\"},\"end\":36298,\"start\":36005},{\"attributes\":{\"doi\":\"arXiv:1609.01690\",\"id\":\"b5\"},\"end\":36611,\"start\":36300},{\"attributes\":{\"doi\":\"arXiv:1701.05973\",\"id\":\"b6\"},\"end\":36907,\"start\":36613},{\"attributes\":{\"doi\":\"arXiv:1612.03301\",\"id\":\"b7\"},\"end\":37118,\"start\":36909},{\"attributes\":{\"doi\":\"arXiv:1705.03875\",\"id\":\"b8\"},\"end\":37409,\"start\":37120},{\"attributes\":{\"id\":\"b9\",\"matched_paper_id\":6938356},\"end\":37679,\"start\":37411},{\"attributes\":{\"id\":\"b10\",\"matched_paper_id\":8533585},\"end\":37891,\"start\":37681},{\"attributes\":{\"doi\":\"arXiv:0901.1886\",\"id\":\"b11\"},\"end\":38082,\"start\":37893},{\"attributes\":{\"id\":\"b12\",\"matched_paper_id\":412751},\"end\":38339,\"start\":38084},{\"attributes\":{\"doi\":\"arXiv:1604.07086\",\"id\":\"b13\",\"matched_paper_id\":9671549},\"end\":38777,\"start\":38341},{\"attributes\":{\"doi\":\"arXiv:1702.07297\",\"id\":\"b14\"},\"end\":39087,\"start\":38779},{\"attributes\":{\"id\":\"b15\",\"matched_paper_id\":2597483},\"end\":39489,\"start\":39089},{\"attributes\":{\"id\":\"b16\"},\"end\":39629,\"start\":39491},{\"attributes\":{\"id\":\"b17\",\"matched_paper_id\":2993227},\"end\":40068,\"start\":39631}]", "bib_title": "[{\"end\":34921,\"start\":34866},{\"end\":35221,\"start\":35179},{\"end\":35552,\"start\":35535},{\"end\":35775,\"start\":35714},{\"end\":37455,\"start\":37411},{\"end\":37710,\"start\":37681},{\"end\":38137,\"start\":38084},{\"end\":38426,\"start\":38341},{\"end\":39137,\"start\":39089},{\"end\":39726,\"start\":39631}]", "bib_author": "[{\"end\":34931,\"start\":34923},{\"end\":34943,\"start\":34931},{\"end\":35234,\"start\":35223},{\"end\":35247,\"start\":35234},{\"end\":35261,\"start\":35247},{\"end\":35272,\"start\":35261},{\"end\":35282,\"start\":35272},{\"end\":35562,\"start\":35554},{\"end\":35575,\"start\":35562},{\"end\":35788,\"start\":35777},{\"end\":35801,\"start\":35788},{\"end\":35813,\"start\":35801},{\"end\":35823,\"start\":35813},{\"end\":35833,\"start\":35823},{\"end\":36066,\"start\":36059},{\"end\":36073,\"start\":36066},{\"end\":36086,\"start\":36073},{\"end\":36104,\"start\":36086},{\"end\":36119,\"start\":36104},{\"end\":36384,\"start\":36378},{\"end\":36400,\"start\":36384},{\"end\":36416,\"start\":36400},{\"end\":36683,\"start\":36660},{\"end\":36694,\"start\":36683},{\"end\":36707,\"start\":36694},{\"end\":36721,\"start\":36707},{\"end\":36936,\"start\":36926},{\"end\":36943,\"start\":36936},{\"end\":36956,\"start\":36943},{\"end\":36974,\"start\":36956},{\"end\":37205,\"start\":37196},{\"end\":37216,\"start\":37205},{\"end\":37226,\"start\":37216},{\"end\":37464,\"start\":37457},{\"end\":37471,\"start\":37464},{\"end\":37486,\"start\":37471},{\"end\":37725,\"start\":37712},{\"end\":37953,\"start\":37943},{\"end\":38152,\"start\":38139},{\"end\":38161,\"start\":38152},{\"end\":38434,\"start\":38428},{\"end\":38450,\"start\":38434},{\"end\":38456,\"start\":38450},{\"end\":38472,\"start\":38456},{\"end\":38855,\"start\":38849},{\"end\":38861,\"start\":38855},{\"end\":38877,\"start\":38861},{\"end\":38893,\"start\":38877},{\"end\":39143,\"start\":39139},{\"end\":39152,\"start\":39143},{\"end\":39530,\"start\":39522},{\"end\":39738,\"start\":39728},{\"end\":39747,\"start\":39738}]", "bib_venue": "[{\"end\":35345,\"start\":35322},{\"end\":39309,\"start\":39239},{\"end\":39854,\"start\":39809},{\"end\":35011,\"start\":34943},{\"end\":35320,\"start\":35282},{\"end\":35600,\"start\":35575},{\"end\":35837,\"start\":35833},{\"end\":36057,\"start\":36005},{\"end\":36376,\"start\":36300},{\"end\":36658,\"start\":36613},{\"end\":36924,\"start\":36909},{\"end\":37194,\"start\":37120},{\"end\":37536,\"start\":37486},{\"end\":37764,\"start\":37725},{\"end\":37941,\"start\":37893},{\"end\":38186,\"start\":38161},{\"end\":38540,\"start\":38488},{\"end\":38847,\"start\":38779},{\"end\":39237,\"start\":39152},{\"end\":39520,\"start\":39491},{\"end\":39807,\"start\":39747}]"}}}, "year": 2023, "month": 12, "day": 17}