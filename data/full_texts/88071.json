{"id": 88071, "updated": "2023-11-10 22:40:32.532", "metadata": {"title": "Cuckoo Filter: Practically Better Than Bloom", "authors": "[{\"first\":\"Bin\",\"last\":\"Fan\",\"middle\":[]},{\"first\":\"Dave\",\"last\":\"Andersen\",\"middle\":[\"G.\"]},{\"first\":\"Michael\",\"last\":\"Kaminsky\",\"middle\":[]},{\"first\":\"Michael\",\"last\":\"Mitzenmacher\",\"middle\":[\"D.\"]}]", "venue": null, "journal": "Proceedings of the 10th ACM International on Conference on emerging Networking Experiments and Technologies", "publication_date": {"year": 2014, "month": null, "day": null}, "abstract": "In many networking systems, Bloom filters are used for high-speed set membership tests. They permit a small fraction of false positive answers with very good space efficiency. However, they do not permit deletion of items from the set, and previous attempts to extend \"standard\" Bloom filters to support deletion all degrade either space or performance. We propose a new data structure called the cuckoo filter that can replace Bloom filters for approximate set membership tests. Cuckoo filters support adding and removing items dynamically while achieving even higher performance than Bloom filters. For applications that store many items and target moderately low false positive rates, cuckoo filters have lower space overhead than space-optimized Bloom filters. Our experimental results also show that cuckoo filters outperform previous data structures that extend Bloom filters to support deletions substantially in both time and space.", "fields_of_study": "[\"Computer Science\"]", "external_ids": {"arxiv": null, "mag": "1967373117", "acl": null, "pubmed": null, "pubmedcentral": null, "dblp": "conf/conext/FanAKM14", "doi": "10.1145/2674005.2674994"}}, "content": {"source": {"pdf_hash": "52ab6e8c70659ee995b7fa40916a3f8a63524a98", "pdf_src": "ACM", "pdf_uri": null, "oa_url_match": false, "oa_info": {"license": null, "open_access_url": "http://dl.acm.org/ft_gateway.cfm?id=2674994&type=pdf", "status": "BRONZE"}}, "grobid": {"id": "582ae59030fb8c27a88eaa382697e32a2c6950de", "type": "plain-text", "url": "s3://ai2-s2-pdf-extraction-prod/parse-results/s2orc_worker/52ab6e8c70659ee995b7fa40916a3f8a63524a98.txt", "contents": "\nCuckoo Filter: Practically Better Than Bloom\n\n\nBin Fan \nDavid G Andersen \nMichael Kaminsky michael.e.kaminsky@intel.com \nIntel Labs\n\n\nMichael D Mitzenmacher michaelm@eecs.harvard.edu \nHarvard University\n\n\n\nCarnegie Mellon University\n\n\nCuckoo Filter: Practically Better Than Bloom\n10.1145/2674005.2674994E1 [Data]: Data StructuresE4 [Data]: Data Compaction and Compression Keywords Cuckoo hashingBloom filterscompression\nIn many networking systems, Bloom filters are used for highspeed set membership tests. They permit a small fraction of false positive answers with very good space efficiency. However, they do not permit deletion of items from the set, and previous attempts to extend \"standard\" Bloom filters to support deletion all degrade either space or performance.We propose a new data structure called the cuckoo filter that can replace Bloom filters for approximate set membership tests. Cuckoo filters support adding and removing items dynamically while achieving even higher performance than Bloom filters. For applications that store many items and target moderately low false positive rates, cuckoo filters have lower space overhead than space-optimized Bloom filters. Our experimental results also show that cuckoo filters outperform previous data structures that extend Bloom filters to support deletions substantially in both time and space.\n\nA limitation of standard Bloom filters is that one cannot remove existing items without rebuilding the entire filter (or possibly introducing generally less desirable false negatives). Several approaches extend standard Bloom filters to support deletion, but with significant space or performance overhead. Counting Bloom filters [12] have been suggested for multiple applications [24,25,9], but they generally use 3-4\u00d7 space to retain the same false positive rate as a space-optimized Bloom filter. Other variants include d-left counting Bloom filters [5], which are still 1.5\u00d7 larger, and quotient filters [2], which provide significantly degraded lookup performance to yield comparable space overhead to Bloom filters. This paper shows that supporting deletion in approximate set membership tests need not impose higher overhead in space or performance compared to standard Bloom filters. We propose the cuckoo filter, a practical data structure that provides four major advantages.\n\n1. It supports adding and removing items dynamically; 2. It provides higher lookup performance than traditional Bloom filters, even when close to full (e.g., 95% space utilized); 3. It is easier to implement than alternatives such as the quotient filter; and 4. It uses less space than Bloom filters in many practical applications, if the target false positive rate is less than 3%. A cuckoo filter is a compact variant of a cuckoo hash table [21] that stores only fingerprints-a bit string derived from the item using a hash function-for each item inserted, instead of key-value pairs. The filter is densely filled with fingerprints (e.g., 95% entries occupied), which confers high space efficiency. A set membership query for item x simply searches the hash table for the fingerprint of x, and returns true if an identical fingerprint is found.\n\nWhen constructing a cuckoo filter, its fingerprint size is determined by the target false positive rate . Smaller values of require longer fingerprints to reject more false queries. Interestingly, while we show that cuckoo filters are practically better than Bloom filters for many real workloads, they are asymptotically worse: the minimum fingerprint size used in the cuckoo filter grows logarithmically with the number of entries in the table (as we explain in Section 4). As a consequence, the per-item space overhead is higher for larger tables, but this use of extra space confers a lower false positive rate. For practical problems with a few billion items or fewer, a cuckoo filter uses less space while supporting deletion than a non-deletable, space-optimized Bloom filter when < 3%. Cuckoo filters are substantially different from regular hash tables because only fingerprints are stored in the filter and the original key and value bits of each item are no longer retrievable. Because full keys are not stored, a cuckoo filter cannot even perform standard cuckoo hashing to insert new items, which involves moving existing keys based on their hash values. This difference means that the standard techniques, analyses, and optimizations that apply to cuckoo hashing do not necessarily carry over to cuckoo filters.\n\n\nTechnical contributions made by this paper include\n\n\u2022 Applying partial-key cuckoo hashing-a variant of standard cuckoo hashing-to build cuckoo filters that support dynamic addition and deletion of items (Section 3). \u2022 Exploring the reason why partial-key cuckoo hashing ensures high table occupancy for most real-world applications (Section 4). \u2022 Optimizing cuckoo filters to outperform Bloom filters in space efficiency (Section 5).\n\n\nBACKGROUND AND RELATED WORK\n\n\nBloom Filters and Variants\n\nWe compare standard Bloom filters and the variants that include support for deletion or better lookup performance, as summarized in Table 1. These data structures are evaluated empirically in Section 7. Cuckoo filters achieve higher space efficiency and performance than these data structures. [3] provide a compact representation of a set of items that supports two operations: Insert and Lookup. A Bloom filter allows a tunable false positive rate so that a query returns either \"definitely not\" (with no error), or \"probably yes\" (with probability of being wrong). The lower is, the more space the filter requires.\n\n\nStandard Bloom filters\n\nA Bloom filter consists of k hash functions and a bit array with all bits initially set to \"0\". To insert an item, it hashes this item to k positions in the bit array by k hash functions, and then sets all k bits to \"1\". Lookup is processed similarly, except it reads k corresponding bits in the array: if all the bits are set, the query returns true; otherwise it returns false.\n\nBloom filters do not support deletion.\n\nBloom filters can be very space-efficient, but are not optimal [20]. For a false positive rate , a space-optimized Bloom filter uses k = log 2 (1/ ) hash functions. Such a Bloom filter can store each item using 1.44 log 2 (1/ ) bits, which depends only on rather than the item size or the total number of items. The information-theoretic minimum requires log 2 (1/ ) bits per item, so a space-optimized Bloom filter imposes a 44% space overhead over the information-theoretic lower bound.\n\nThe information theoretic optimum is essentially achievable for a static set by using fingerprints (of length 1/ bits) and a perfect hash table [6]. To efficiently handle deletions, we replace a perfect hash function with a well-designed cuckoo hash table.\n\nCounting Bloom filters [12] extend Bloom filters to allow deletions. A counting Bloom filter uses an array of counters in place of an array of bits. An insert increments the value of k counters instead of simply setting k bits, and a lookup checks if each of the required counters is non-zero. The delete operation decrements the values of these k counters. To prevent arithmetic overflow (i.e., incrementing a counter that has the maximum possible value), each counter in the array must be sufficiently large in order to retain the Bloom filter's properties. In practice, the counter consists of four or more bits, and a counting Bloom filter therefore requires 4\u00d7 more space than a standard Bloom filter. (One can construct counting Bloom filters to use less space by introducing a secondary hash table structure to manage overflowing counters, at the expense of additional complexity.) Blocked Bloom filters [22] do not support deletion, but provide better spatial locality on lookups. A blocked Bloom filter consists of an array of small Bloom filters, each fitting in one CPU cache line. Each item is stored in only one of these small Bloom filters determined by hash partitioning. As a result, every query causes at most one cache miss to load that Bloom filter, which significantly improves performance. A drawback is that the false positive rate becomes higher because of the imbalanced load across the array of small Bloom filters.\n\nd-left Counting Bloom filters [5] are similar to the approach we use here. Hash tables using d-left hashing [19] store fingerprints for stored items. These filters delete items by removing their fingerprint. Compared to counting Bloom filters, they reduce the space cost by 50%, usually requiring 1.5 \u2212 2\u00d7 the space compared to a space-optimized non-deletable Bloom filter. Cuckoo filters achieve better space efficiency than d-left counting Bloom filters as we show, and have other advantages, including simplicity.\n\nQuotient filters [2] are also compact hash tables that store fingerprints to support deletion. Quotient filters uses a technique similar to linear probing to locate a fingerprint, and thus provide better spatial locality. However, they require additional meta-data to encode each entry, which requires 10 \u223c 25% more space than a comparable standard Bloom  filter. Moreover, all of its operations must decode a sequence of table entries before reaching the target item, and the more the hash table is filled, the longer these sequences become. As a result, its performance drops significantly when the occupancy of the hash table exceeds 75%.\n\nOther Variants: Other variants have been proposed to improve Bloom filters, either in space and/or performance. Rank-Indexed Hashing [14] builds linear chaining hash tables to store compressed fingerprints. Although similar to and somewhat more space efficient than d-left counting Bloom filters, updating the internal index that reduces the chaining cost is very expensive, making it less appealing in dynamic settings. Putze et al. proposed two variants of Bloom filters [22]. One is the previously discussed Blocked Bloom filter; the other, called a Golomb-Compressed Sequence stores all items' fingerprints in a sorted list. Its space is near-optimal, but the data structure is static and requires non-constant lookup time to decode the encoded sequence. It is therefore not evaluated with other filters in this paper. Pagh et al. proposed an asymptotically space-optimal data structure [20] based on Cleary [8]. This data structure, however, is substantially more complex than its alternatives and does not appear amenable to a high performance implementation. In contrast, cuckoo filters are easy to implement.\n\n\nCuckoo Hash Tables\n\nCuckoo Hashing Basics: A basic cuckoo hash table [21] consists of an array of buckets where each item has two candidate buckets determined by hash functions h 1 (x) and h 2 (x). The lookup procedure checks both buckets to see if either contains this item. Figure 1(a) shows the example of inserting a new item x in to a hash table of 8 buckets, where x can be placed in either buckets 2 or 6. If either of x's two buckets is empty, the algorithm inserts x to that free bucket and the insertion completes. If neither bucket has space, as is the case in this example, the item selects one of the candidate buckets (e.g., bucket 6), kicks out the existing item (in this case \"a\") and re-inserts this victim item to its own alternate location. In our example, displacing \"a\" triggers another relocation that kicks existing item \"c\" from bucket 4 to bucket 1. This procedure may repeat until a vacant bucket is found as illustrated in Figure 1(b), or until a maximum number of displacements is reached (e.g., 500 times in our implementation). If no vacant bucket is found, this hash table is considered too full to insert. Although cuckoo hashing may execute a sequence of displacements, its amortized insertion time is O(1).\n\nCuckoo hashing ensures high space occupancy because it refines earlier item-placement decisions when inserting new items. Most practical implementations of cuckoo hashing extend the basic description above by using buckets that hold multiple items, as suggested in [10]. The maximum possible load when using k hash functions and buckets of size b assuming all hash functions are perfectly random has been analyzed [13]. With proper configuration of cuckoo hash table parameters (explored in Section 5), the table space can be 95% filled with high probability.\n\nUsing Cuckoo Hashing for Set-membership: Recently, standard cuckoo hash tables have been used to provide set membership information in a few applications. To support transactional memory, Sanchez et al. proposed to store the read/write set of memory addresses of each transaction in a cuckoo hash table, and to convert this table to Bloom filters when full [23]. Their design used standard cuckoo hash tables, and thus required much more space than cuckoo filters. Our previous study in building high-speed and memoryefficient key-value stores [17,11] and software-based Ethernet switches [26] all applied cuckoo hash tables as internal data structures. That work was motivated by and also focused on improving hash table performance by an optimization called partial-key cuckoo hashing. However, as we show in this paper, this technique also enabled a new approach to build a Bloom filter replacement which has not been studied before. As a result, this paper also applies partial-key cuckoo hashing, but more importantly it offers an in-depth analysis of using this technique specifically to serve set membership tests (rather than key-value queries) and further compares the performance of cuckoo filters with alternative set membership data structures.\n\n\nChallenges in Cuckoo Filter:\n\nTo make cuckoo filters highly space efficient, we use a multi-way associative cuckoo hash table to provide high-speed lookup and high table occupancy (e.g., 95% hash table slots filled); to further reduce the hash table size, each item is first hashed into a constant-sized fingerprint before inserted into this hash table. The challenge of applying this data structure is to redesign the insert process and carefully configure the hash table to minimize space usage per item:\n\n\u2022 First, storing only fingerprints in the hash table prevents inserting items using the standard cuckoo hashing approach. Because in cuckoo hashing the insertion algorithm must be able to relocate existing fingerprints to their alternative locations. A space-inefficient but straightforward solution is to store each inserted item in its entirety (perhaps externally to the table); given the original item (\"key\"), calculating its alternate location is easy. In contrast, cuckoo filters use partial-key cuckoo hashing to find an item's alternate location based on only its fingerprint (Section 3). \u2022 Second, cuckoo filter associates each item with multiple possible locations in the hash table. This flexibility in where to store an item improves table occupancy, but retaining the same false positive rate when probing more possible locations on each lookup requires more space for longer fingerprints. In Section 5, we present our analysis to optimize the balance between the table occupancy and its size to minimize the average space cost per item.\n\n\nCUCKOO FILTER ALGORITHMS\n\nIn this paper, the basic unit of the cuckoo hash tables used for our cuckoo filters is called an entry. Each entry stores one fingerprint. The hash table consists of an array of buckets, where a bucket can have multiple entries.\n\nThis section describes how cuckoo filters perform Insert, Lookup and Delete operations. Section 3.1 presents partial-key cuckoo hashing, a variant of standard cuckoo hashing that enables cuckoo filters to insert new items dynamically. This technique was first introduced in previous work [11], but there the context was improving the lookup and insert performance of regular cuckoo hash tables where full keys were stored. In contrast, this paper focuses on optimizing and analyzing the space efficiency when using partial-key cuckoo hashing with only fingerprints, to make cuckoo filters competitive with or even more compact than Bloom filters.\n\n\nInsert\n\nAs previously stated, with standard cuckoo hashing, inserting new items to an existing hash table requires some means of accessing the original existing items in order to determine where to relocate them if needed to make room for the new ones (Section 2.2). Cuckoo filters, however, only store fingerprints and therefore there is no way to restore and rehash the original keys to find their alternate locations. To over- come this limitation, we utilize a technique called partial-key cuckoo hashing to derive an item's alternate location based on its fingerprint. For an item x, our hashing scheme calculates the indexes of the two candidate buckets as follows:\nAlgorithm 1: Insert(x) f = fingerprint(x); i 1 = hash(x); i 2 = i 1 \u2295 hash( f ); if bucket[i 1 ]h 1 (x) = hash(x), h 2 (x) = h 1 (x) \u2295 hash(x's fingerprint).(1)\nThe xor operation in Eq. (1) ensures an important property: h 1 (x) can also be calculated from h 2 (x) and the fingerprint using the same formula. In other words, to displace a key originally in bucket i (no matter if i is h 1 (x) or h 2 (x)), we directly calculate its alternate bucket j from the current bucket index i and the fingerprint stored in this bucket by\nj = i \u2295 hash(fingerprint).(2)\nHence, an insertion only uses information in the table, and never has to retrieve the original item x.\n\nIn addition, the fingerprint is hashed before it is xor-ed with the index of its current bucket to help distribute the items uniformly in the table. If the alternate location were calculated by \"i \u2295 fingerprint\" without hashing the fingerprint, the items kicked out from nearby buckets would land close to each other in the table, if the size of the fingerprint is small compared to the table size. For example, using 8-bit fingerprints the items kicked out from bucket i will be placed to buckets that are at most 256 buckets away from bucket i, because the xor operation would alter the eight low order bits of the bucket index while the higher order bits would not change. Hashing the fingerprints ensures that these items can be relocated to buckets in an entirely different part of the hash table, hence reducing hash collisions and improving the table utilization.\n\nUsing partial-key cuckoo hashing, cuckoo filters add new items dynamically by the process shown in Algorithm 1. Because these fingerprints can be significantly shorter than the size of h 1 or h 2 , there are two consequences. First, the total number of different possible choices of (h 1 , h 2 ) as calculated by Eq. (1) can be much smaller than using a perfect hash to derive h 1 and h 2 as in standard cuckoo hashing. This may cause more collisions, and in particular previous analyses for cuckoo hashing (as in [10,13]) do not hold. A full analysis of partial-key cuckoo hashing remains open (and beyond this paper); in Section 4, we provide a detailed discussion of this issue and consider how to achieve high occupancy for practical workloads.\n\nSecond, inserting two different items x and y that have the same fingerprint is fine; it is possible to have the same fingerprint appear multiple times in a bucket. However, cuckoo filters are not suitable for applications that insert the same item more than 2b times (b is the bucket size), because the two buckets for this duplicated item will become overloaded. There are several solutions for such a scenario. First, if the table need not support deletion, then this issue does not arise, because only one copy of each fingerprint must be stored. Second, one could, at some space cost, associate counters with buckets, and increment/decrement them appropriately. Finally, if the original keys are stored somewhere (perhaps in slower external storage), one could consult that record to prevent duplicate insertion entirely, at the cost of slowing down insertion if the table already contains a (false positive) matching entry for the bucket and fingerprint. Similar requirements apply to traditional and d-left counting Bloom filters. \nAlgorithm 2: Lookup(x) f = fingerprint(x); i 1 = hash(x); i 2 = i 1 \u2295 hash( f ); if\n\nLookup\n\nThe lookup process of a cuckoo filter is simple, as shown in Algorithm 2. Given an item x, the algorithm first calculates x's fingerprint and two candidate buckets according to Eq. (1). Then these two buckets are read: if any existing fingerprint in either bucket matches, the cuckoo filter returns true, otherwise the filter returns false. Notice that this ensures no false negatives as long as bucket overflow never occurs. \nAlgorithm 3: Delete(x) f = fingerprint(x); i 1 = hash(x); i 2 = i 1 \u2295 hash( f ); if\n\nDelete\n\nStandard Bloom filters cannot delete, thus removing a single item requires rebuilding the entire filter, while counting Bloom filters require significantly more space. Cuckoo filters are like counting Bloom filters that can delete inserted items by removing corresponding fingerprints from the hash tables on deletion. Other filters with similar deletion processes prove more complex than cuckoo filters. For example, d-left counting Bloom filters must use extra counters to prevent the \"false deletion\" problem on fingerprint collision 1 , and quotient filters must shift a sequence of fingerprints to fill the \"empty\" entry after deletion and maintain their \"bucket structure\". 2 The deletion process of cuckoo filters illustrated in Algorithm 3 is much simpler. It checks both candidate buckets for a given item; if any fingerprint matches in any bucket, one copy of that matched fingerprint is removed from that bucket.\n\nDeletion does not have to clean the entry after deleting an item. It also avoids the \"false deletion\" problem when two items share one candidate bucket and also have the same fingerprint. For example, if both item x and y reside in bucket i 1 and collide on fingerprint f , partial-key cuckoo hashing ensures that they both can also reside in bucket i 2 because\ni 2 = i 1 \u2295 hash( f ).\nWhen deleting x, it does not matter if the process removes the copy of f added when inserting x or y. After x is deleted, y is still perceived as a set member because there is a corresponding fingerprint left in either bucket i 1 and i 2 . An important consequence of this is that the falsepositive behavior of the filter is unchanged after deletion. (In the above example, y being in the table causes false positives for lookups of x, by definition: they share the same bucket and fingerprint.) This is the expected false-positive behavior of an approximate set membership data structure, and its probability remains bounded by .\n\nNote that, to delete an item x safely, it must have been previously inserted. Otherwise, deleting a non-inserted item might unintentionally remove a real, different item that happens to share the same fingerprint. This requirement also holds true for all other deletion-supporting filters. 1 A naive implementation of d-left counting Bloom filters has a \"false deletion\" problem. A d-left counting Bloom filter maps each item to d candidate buckets, each from a partition of the table, and stores the fingerprint in one of its d buckets. If two different items share one and only one bucket, and they have the same fingerprint (which is likely to happen when the fingerprints are small), directly deleting the fingerprint from this specific bucket may cause a wrong item to be removed. To address this issue, d-left counting Bloom filters use an additional counter in each table entry and additional indirections [5]. 2 In quotient filters, all fingerprints having the same quotient (i.e., the q most significant bits) must be stored in contiguous entries according to their numerical order. Thus, removing one fingerprint from a cluster of fingerprints must shift all the fingerprints after the hole by one slot, and also modify their meta-data bits [2].  Figure 2: Load factor \u03b1 achieved by using f -bit fingerprint using partial-key cuckoo hashing, in tables of different sizes (m = 2 15 , 2 20 , 2 25 and 2 30 buckets). Short fingerprints suffice to approach the optimal load factor achieved by using two fully independent hash functions. \u03b1 = 0 means empty and 1 means completely full. Each point is the minimal load factor seen in 10 independent runs.\n\n\nASYMPTOTIC BEHAVIOR\n\nHere we show that using partial-key cuckoo hashing to store fingerprints in a cuckoo filter to leads to a lower bound on fingerprint sizes that grows slowly with the filter size. This contrasts with other approaches (such as fingerprints and perfect hashing for a static Bloom filter, previously discussed) where the fingerprint size depended only on the desired false positive probability. While this might seem like a negative, in practice the effect seems unimportant. Empirically, a filter containing up to 4 billion items can effectively fill its hash table with loads of 95% when each bucket holds four fingerprints that are 6 bits or larger.\n\nThe notation used for our analysis in this and the next section is:\n\ntarget false positive rate f fingerprint length in bits \u03b1 load factor (0 \u2264 \u03b1 \u2264 1) b number of entries per bucket m number of buckets n number of items C average bits per item Minimum Fingerprint Size: Our proposed partial-key cuckoo hashing derives the alternate bucket of a given item based on its current location and the fingerprint (Section 3). As a result, the candidate buckets for each item are not independent. For example, assume an item can be placed in bucket i 1 or i 2 . According to Eq. Intuitively, if the fingerprints are sufficiently long, partialkey cuckoo hashing could still be a good approximation to standard cuckoo hashing; however, if the hash table is very large and stores relatively short fingerprints, the chance of insertion failures will increase due to hash collisions, which may reduce the table occupancy. This situation may arise when a cuckoo filter targets a large number of items but only a moderately low false positive rate. In the following, we determine analytically a lower bound of the probability of insertion failure.\n\nLet us first derive the probability that a given set of q items collide in the same two buckets. Assume the first item x has its first bucket i 1 and a fingerprint t x . If the other q \u2212 1 items have the same two buckets as this item x, they must 3 (1) have the same fingerprint t x , which occurs with probability 1/2 f ; and (2) have their first bucket either i 1 or i 1 \u2295 h(t x ), which occurs with probability 2/m. Therefore the probability of such q items sharing the same two buckets is 2/m \u00b7 1/2 f q\u22121 .\n\nNow consider a construction process that inserts n random items to an empty table of m = cn buckets for a constant c and constant bucket size b. Whenever there are q = 2b + 1 items mapped into the same two buckets, the insertion fails. This probability provides a lower bound for failure (and, we believe, dominates the failure probability of this construction process, although we do not prove this and do not need to in order to obtain a lower bound). Since there are in total n 2b+1 different possible sets of 2b + 1 items out of n items, the expected number of groups of 2b + 1 items colliding during the construction process is\nn 2b + 1 2 2 f \u00b7 m 2b = n 2b + 1 2 2 f \u00b7 cn 2b = \u2126 n 4 b f(3)\nWe conclude that 4 b f must be \u2126(n) to avoid a non-trivial probability of failure, as otherwise this expectation is \u2126(1). Therefore, the fingerprint size must be f = \u2126(log n/b) bits.\n\nThis result seems somewhat unfortunate, as the number of bits required for the fingerprint is \u2126(log n); recall that Bloom filters use a constant (approximately ln(1/ ) bits) per item. We might therefore have concerns about the scalability of this approach. As we show next, however, practical applications of cuckoo filters are saved by the b factor in the denominator of the lower bound: as long as we use reasonably sized buckets, the fingerprint size can remain small.\n\nEmpirical Evaluation: Figure 2 shows the load factor achieved with partial-key cuckoo hashing as we vary the fingerprint size f , bucket size b, and number of buckets in the table m. For the experiments, we varied the fingerprint size f from 1 to 20 bits. Random 64-bit keys are inserted to an empty filter until a single insertion relocates existing fingerprints more than 500 times before finding an empty entry (our \"full\" condition), then we stop and measure achieved load factor \u03b1. We run this experiment ten times for filters with m = 2 15 , 2 20 , 2 25 , and 2 30 buckets, and measured their minimum load over the ten trials. We did not use larger tables due to the memory constraint of our testbed machine.\n\nAs shown in Figure 2, across different configurations, filters with b = 4 could be filled to 95% occupancy, and with b = 8 could be filled to 98%, with sufficiently long fingerprints. After that, increasing the fingerprint size has almost no return in term of improving the load factor (but of course it reduces the false positive rate). As suggested by the theory, the minimum f required to achieve close-to-optimal occupancy increases as the filter becomes larger. Also, comparing Figure 2(a) and Figure 2(b), the minimum f for high occupancy is reduced when bucket size b becomes larger, as the theory also suggests. Overall, short fingerprints appear to suffice for realistic sized sets of items. Even when b = 4 and m = 2 30 , so the table could contain up to four billion items, once fingerprints exceed six bits, \u03b1 approaches the \"optimal load factor\" that is obtained in experiments using two fully independent hash functions.\n\n\nInsights:\n\nThe lower bound of fingerprint size derived in Eq. (3), together with the empirical results shown in Figure 2, give important insights into the cuckoo filter. While in theory the space cost of cuckoo filters is \"worse\" than Bloom filters-\u2126(log n) versus a constant-the constant terms are very important in this setting. For a Bloom filter, achieving = 1% requires roughly 10 bits per item, regardless of whether one thousand, one million, or billion items are stored. In contrast, cuckoo filters require longer fingerprints to retain the same high space efficiency of their hash tables, but lower false positive rates are achieved accordingly. The \u2126(log n) bits per fingerprint, as also predicted by the theory, grows slowly if the bucket size b is sufficiently large. We find that, for practical purposes, it can be treated as a reasonablesized constant for implementation. Figure 2 shows that for cuckoo filters targeting a few billion items, 6-bit fingerprints are sufficient to ensure very high utilization of the hash table.\n\nAs a heuristic, partial-key cuckoo hashing is very efficient, as we show further in Section 7. Several theoretical questions regarding this technique, however, remain open for future study, including proving bounds on the cost of inserting a new item and studying how much independence is required of the hash functions.\n\n\nSPACE OPTIMIZATIONS\n\nThe basic algorithms for cuckoo filter operations Insert, Lookup, and Delete presented in Section 3 are independent of the hash table configuration (e.g., how many entries each bucket has). However, choosing the right parameters for cuckoo filters can significantly affect space efficiency. This section focuses on optimizing the space efficiency of cuckoo filters, through parameter choices and additional mechanisms.\n\nSpace efficiency is measured by the average number of bits to represent each item in a full filter, derived by the table size divided by the total number of items that a filter can effectively store. Recall that, although each entry of the hash table stores one fingerprint, not all entries are occupied: there must be some slack in the table for the cuckoo filter or there will be failures when inserting items. As a result, each item effectively costs more to store than a fingerprint: if each fingerprint is f bits and the hash table has a load factor of \u03b1, then the amortized space cost C for each item is\nC = table size # of items = f \u00b7 (# of entries) \u03b1 \u00b7 (# of entries) = f \u03b1 bits.(4)\nAs we will show, both f and \u03b1 are related to the bucket size b. The following section studies how to (approximately) minimize Eq. (4) given a target false positive rate by choosing the optimal bucket size b.\n\n\nOptimal Bucket Size\n\nKeeping a cuckoo filter's total size constant but changing the bucket size leads to two consequences:\n\n(1) Larger buckets improve table occupancy (i.e., higher b \u2192 higher \u03b1). With k = 2 hash functions, the load factor \u03b1 is 50% when the bucket size b = 1 (i.e., the hash table is directly mapped), but increases to 84%, 95% or 98% respectively using bucket size b = 2, 4 or 8.\n\n(2) Larger buckets require longer fingerprints to retain the same false positive rate (i.e., higher b \u2192 higher f ). With larger buckets, each lookup checks more entries and thus has a higher chance to see fingerprint collisions. In the worst case of looking up a non-existent item, a query must probe two buckets where each bucket can have b entries. (While not all of these buckets may be filled, we analyze here    Each point is the average of 10 runs the worst case in which they are; this gives us a reasonably accurate estimate for a table that is 95% full.) In each entry, the probability that a query is matched against one stored fingerprint and returns a false-positive successful match is at most 1/2 f . After making 2b such comparisons, the upper bound of the total probability of a false fingerprint hit is\n1 \u2212 (1 \u2212 1/2 f ) 2b \u2248 2b/2 f ,(5)\nwhich is proportional to the bucket size b. To retain the target false positive rate , the filter ensures 2b/2 f \u2264 , thus the minimal fingerprint size required is approximately:\n\nf \u2265 log 2 (2b/ ) = log 2 (1/ ) + log 2 (2b) bits.\n\nUpper Bound of Space Cost As we have shown, both f and \u03b1 depend on the bucket size b. The average space cost C by Eq. (4) is bound by:\nC \u2264 log 2 (1/ ) + log 2 (2b) /\u03b1,(7)\nwhere \u03b1 increases with b. For example, when b = 4 so 1/\u03b1 \u2248 1.05, Eq. (7) shows cuckoo filters are asymptotically better (by a constant factor) than Bloom filters, which require 1.44 log 2 (1/ ) bits or more for each item.\n\nOptimal bucket size b To compare the space efficiency by using different bucket sizes b, we run experiments that first construct cuckoo hash tables by partial-key cuckoo hashing with different fingerprint sizes, and measure the amortized space cost per item and their achieved false positive rates. As shown in Figure 3, the space-optimal bucket size depends on the target false positive rate : when > 0.002, having two entries per bucket yields slightly better results than using four entries per bucket; when decreases to 0.00001 < \u2264 0.002, four entries per bucket minimizes space.\n\nIn summary, we choose (2, 4)-cuckoo filter (i.e., each item has two candidate buckets and each bucket has up to four fingerprints) as the default configuration, because it achieves the best or close-to-best space efficiency for the false positive rates that most practical applications [6] may be interested in. In the following, we present a technique that further saves space for cuckoo filters with b = 4 by encoding each bucket.\n\n\nSemi-sorting Buckets to Save Space\n\nThis subsection describes a technique for cuckoo filters with b = 4 entries per bucket that saves one bit per item. This optimization is based on the fact that the order of fingerprints within a bucket does not affect the query results. Based on this observation, we can compress each bucket by first sorting its fingerprints and then encoding the sequence of sorted fingerprints. This scheme is similar to the \"semi-sorting buckets\" optimization used in [5].\n\nThe following example illustrates how the compression saves space. Assume each bucket contains b = 4 fingerprints and each fingerprint is f = 4 bits (more general cases will be discussed later). An uncompressed bucket occupies 4\u00d74 = 16 bits. However, if we sort all four 4-bit fingerprints stored in this bucket (empty entries are treated as storing fingerprints of value \"0\"), there are only 3876 possible outcomes in total (the number of unique combinations with replacement). If we precompute and store these 3876 possible bucket-values in an extra table, and replace the original bucket with an index into this precomputed table, then each original bucket can be represented by a 12-bit index (2 12 = 4096 > 3876) rather than 16 bits, saving 1 bit per fingerprint. 4 Note that this permutation-based encoding (i.e., indexing all possible outcomes) requires extra encoding/decoding tables and indirections on each lookup. Therefore, to achieve high lookup performance it is important to make the encoding/decoding table small enough to fit in cache. As a result, our \"semi-sorting\" optimization only apply this technique for tables with buckets of four entries. Also, when fingerprints are larger than four bits, only the four most significant bits of \n\n\nCOMPARISON WITH BLOOM FILTER\n\nWe compare Bloom filters and cuckoo filters using the metrics shown in Table 2 and several additional factors.\n\nSpace Efficiency: Table 2 compares space-optimized Bloom filters and cuckoo filters with and without semi-sorting. Figure 4 further shows the bits to represent one item required by these schemes, when varies from 0.001% to 10%. The information theoretical bound requires log 2 (1/ ) bits for each item, and an optimal Bloom filter uses 1.44 log 2 (1/ ) bits per item, for a 44% overhead. Thus cuckoo filters with semi-sorting are more space efficient than Bloom filters when < 3%.\n\nNumber of Memory Accesses: For Bloom filters with k hash functions, a positive query must read k bits from the bit array. For space-optimized Bloom filters that require k = log 2 (1/ ), as gets smaller, positive queries must probe more bits and are likely to incur more cache line misses when reading each bit. For example, k = 2 when = 25%, but k is 7 when = 1%, which is more commonly seen in practice. A negative query to a space optimized Bloom filter reads two bits on average before it returns, because half of the bits are set. Any query to a cuckoo filter, positive or negative, always reads a fixed number of buckets, resulting in (at most) two cache line misses.\n\nValue Association: Cuckoo filters can be extended to also return an associated value (stored external to the filter) for each matched fingerprint. This property of cuckoo filters provides an approximate table lookup mechanism, which returns 1 + values on average for each existing item (as it can match more than one fingerprint due to false positive hits) and on average values for each non-existing item. Standard Bloom filters do not offer this functionality. Although variants like Bloomier filters can generalize Bloom filters to represent functions, these structures are more complex and require more space than cuckoo filters [7].\n\nMaximum Capacity: Cuckoo filters have a load threshold. After reaching the maximum feasible load factor, insertions are non-trivially and increasingly likely to fail, so the hash table must expand in order to store more items. In contrast, one can keep inserting new items into a Bloom filter, at the cost of an increasing false positive rate. To maintain the same target false positive rate, the Bloom filter must also expand.\n\nLimited Duplicates: If the cuckoo filter supports deletion, it must store multiple copies of the same item. Inserting the same item kb + 1 times will cause the insertion to fail. This is similar to counting Bloom filters where duplicate insertion causes counter overflow. However, there is no effect from inserting identical items multiple times into Bloom filters, or a non-deletable cuckoo filter.\n\n\nEVALUATION\n\nOur implementation 5 consists of approximately 500 lines of C++ code for standard cuckoo filters, and 500 lines for the support of the \"semi-sorting\" optimization presented in Section 5.2. In the following, we denote a basic cuckoo filter as \"CF\", and a cuckoo filter with semi-sorting as \"ss-CF\". In addition to cuckoo filters, we implemented four other filters for comparison:\n\n\u2022 Standard Bloom filter (BF) [3]: We evaluated standard Bloom filters as the baseline. In all of our experiments, the number of hash functions k are configured to achieve the lowest false positive rate, based on the filter size and the total number of items. In addition, a performance optimization is applied to speed up lookups and inserts by doing less hashing [16]. Each insert or lookup only requires two hash functions h 1 (x) and h 2 (x), and then uses these two hashes to simulate the additional k \u2212 2 hash functions in the form of\ng i (x) = h 1 (x) + i \u00b7 h 2 (x).\n\u2022 Blocked Bloom filter (blk-BF) [22]: Each filter consists of an array of blocks and each block is a small Bloom filter. The size of each block is 64 bytes to match a CPU cache line in our testbed. For each small Bloom filter, we also apply the same optimization of simulating multiple hash functions as in standard Bloom filters. \u2022 Quotient filter (QF) [2]: We evaluated our own implementation of quotient filters 6 . This filter stores three extra bits for each item as the meta-data to help locate items. Because the performance of quotient filters degrades as they become more loaded, we set the maximum load factor to be 90% as evaluated in [2]. \u2022 d-left counting Bloom filter (dl-CBF) [  have the same number of buckets; each bucket has four entries. We emphasize that the standard and blocked Bloom filters do not support deletion, and thus are compared as a baseline.\n\nExperiment Setup: All the items to insert are pre-generated 64-bit integers from random number generators. We did not eliminate duplicated items because the probability of duplicates is very small.\n\nOn each query, all filters first generate a 64-bit hash of the item using CityHash [1]. Each filter then partitions these 64 bits in this hash as it needed. For example, Bloom filters treat the high 32 bits and low 32 bits as the first two independent hashes respectively, then use these two 32-bit values to calculate the other k \u2212 2 hashes. The time to compute the 64-bit hash (about 20 ns per item in our testbed) is included in our measurement. All experiments use a machine with two Intel Xeon processors (L5640@2.27GHz, 12MB L3 cache) and 32 GB DRAM.\n\nMetrics: To fully understand how different filters realize the trade-offs in function, space and performance, we compare above filters by the following metrics:\n\n\u2022 Space efficiency: measured by the filter size in bits divided by the number of items a full filter contains. \n\n\nAchieved False Positive Rate\n\nWe first evaluate the space efficiency and false positive rates. In each run, all filters are configured to have the same size (192 MB). Bloom filters are configured to use nine hash functions, which minimizes the false positive rate with thirteen bits per item. For cuckoo filters, their hash tables have m = 2 25 buckets each consisting of four 12-bit entries. The d-left counting Bloom filter have the same number of hash table entries, but divided into d = 4 partitions. Quotient filter also has 2 27 entries where each entry stores 3-bit meta-data and a 9-bit remainder.\n\nEach filter is initially empty and items are placed until either the filter sees an insert failure (for CF, and dl-CBF), or it has reached the target capacity limit (for BF, blk-BF, and QF). The construction rate and false positive rate of different filters are shown in Table 3. Among all filters, the ss-CF achieves the lowest false positive rate. Using about the same amount of space (12.60 bits/item), enabling semi-sorting can encode one more bit into each item's fingerprint and thus halve the false positive rate from 0.19% to 0.09%, On the other hand, semi-sorting requires encoding and decoding when accessing each bucket, and thus the construction rate is reduced from 5.00 to 3.13 million items per second.\n\nThe BF and blk-BF both use 13.00 bits per item with k = 9 hash functions, but the false positive rate of the blocked filter is 2\u00d7 higher than the BF and 4\u00d7 higher than the best CF. This difference is because the blk-BF assigns each item to a single block by hashing and an imbalanced mapping will create \"hot\" blocks that serve more items than average and \"cold\" blocks that are less utilized. Unfortunately, such an imbalanced assignment happens across blocks even when strong hash functions are used [18], which increases the overall false positive rate. On the other hand, by operating in a single cache line for any query, the blk-BF achieves the highest construction rate.\n\nThe QF spends more bits per item than BFs and CFs, achieving the second best false positive rate. Due to the cost of encoding and decoding each bucket, its construction rate is the lowest.\n\nFinally, the dl-CBF sees insert failures and stops construction when the entire table is about 78% full, thus storing many fewer items. Its achieved false positive rate is much worse than the other filters because each lookup must check 16 entries, hence having a higher chance of hash collisions.\n\n\nLookup Performance\n\nDifferent Workloads We next benchmark lookup performance after the filters are filled. This section compares the lookup throughput and latency with varying workloads. The workload is characterized by the fraction of positive queries (i.e., items in the table) and negative queries (i.e., items not in the table), which can affect the lookup speed. We vary the fraction p of positive queries in the input workload from 0% (all queries are negative) to 100% (all queries are positive).\n\nThe benchmark result of lookup throughput is shown in Figure 5. Each filter occupies 192 MB, much larger than the L3 cache (20 MB) in our testbed. The blk-BF performs well when all queries are negative, because each lookup can return immediately after fetching the first \"0\" bit. However, its performance declines when more queries are positive, because it must read additional bits as part of the lookup. The throughput of BF changes similarly when p increases, but is about 4 MOPS slower. This is because the BF may incur multiple cache misses to complete one lookup whereas the blocked version can always operate in one cache line and have at most one cache miss for each lookup.\n\nIn contrast, a CF always fetches two buckets 7 , and thus achieves the same high performance when queries are 100% positive and 100% negative. The performance drops slightly when p = 50% because the CPU's branch prediction is least accurate (the probability of matching or not matching is exactly 1/2). With semi-sorting, the throughput of CF shows a similar trend when the fraction of positive queries increases, but it is lower due to the extra decoding overhead when reading each bucket. In return for the performance penalty, the semi-sorting version reduces the false positive rate by a factor of two compared to the standard cuckoo filter. However, the ss-CF still outperforms BFs when more than 25% of queries are positive.\n\nThe QF performs the worst among all filters. When a QF is 90% filled, a lookup must search a long chain of table entries and decode each of them for the target item.\n\nThe dl-CBF outperforms the ss-CF, but 30% slower than a BF. It also keeps about the same performance when serving all negative queries and all positive queries, because only a constant number of entries are searched on each lookup.\n\n\nDifferent Occupancy\n\nIn this experiment, we measure the lookup throughput when the these filters are filled at different levels of occupancy. We vary their load factor \u03b1 of each filter from 0 (empty) to its maximum occupancy. Figure 6 shows the average instantaneous lookup throughput when all queries are negative (i.e., for non-existing items) and all queries are 7 Instead of checking each item's two buckets one by one, our implementation applies a performance optimization that tries to issue two memory loads together to hide the latency of the second read.   Figure 7: Insert throughput at different occupancy. Insert random keys in a large universe until each data structure achieves its designed capacity. Each point is the average of 10 runs. positive (i.e., for existing items).\n\nThe throughput of CF and ss-CF is mostly stable across different load factor levels on both negative and positive queries. This is because the total number of entries to read and compare remains constant even as more items are inserted.\n\nIn contrast, the throughput of QF decreases substantially when more loaded. This filter searches an increasingly long chain of entries for the target item as the load factor grows.\n\nBoth BF and blk-BF behave differently when serving negative and positive queries. For positive queries, they must always check in total k bits, no matter how many items have been inserted, thus providing constant lookup throughput; while for negative queries, when the filter is less loaded, fewer bits are set and a lookup can return earlier when seeing a \"0\".\n\nThe dl-CBF behaves differently from the BF. When all lookups are negative, it ensures constant throughput like the CF, because a total of 16 entries from four buckets must be searched, no matter how many items this filter contains. For positive queries, if there are fewer items inserted, the lookup may return earlier before all four buckets are checked; however, this difference becomes negligible after the dl-CBF is about 20% filled.\n\n\nInsert Performance\n\nThe overall construction speed, measured based on the total number of items a full filter contains and the total time to insert these items, is shown in Table 3. We also study the instantaneous insert throughput across the construction process. Namely, we measure the insert throughput of different filters when they are at levels of load factors, as shown in Figure 7.\n\nIn contrast to the lookup throughput shown in Figure 6, both types of CF have decreasing insert throughput when they are more filled (though their overall construction speed is still high), while both BF and blk-BF ensure almost constant insert throughput. The CF may have to move a sequence of existing keys recursively before successfully inserting a new item, and this process becomes more expensive when the load factor grows higher. In contrast, both Bloom filters always   The QF also has decreasing insert throughput, because it must shift a sequence of items before inserting a new item, and this sequence grows longer when the table is more filled.\n\nThe dl-CBF keeps constant throughput. For each insert, it must only find an empty entry in up to four buckets; if such an entry can not be found, the insert stops without relocating existing items as in cuckoo hashing. This is also why its maximum load factor is no more than 80%. Figure 8 compares the delete performance among filters supporting deletion. The experiment deletes keys from an initially full filter until it is empty. The CF achieves the highest throughput. Both CF and ss-CF provide stable performance through the entire process. The dl-CBF performs the second best among all filters. The QF is the slowest when close to full, but becomes faster than ss-CF when close to empty.\n\n\nDelete Performance\n\nEvaluation Summary: The CF ensures high and stable lookup performance for different workloads and at different levels of occupancy. Its insert throughput declines as the filter is more filled, but the overall construction rate is still faster than other filters except the blk-BF. Enabling semisorting makes cuckoo filters more space-efficient than spaceoptimized BFs. It also makes lookups, inserts, and deletes slower, but still faster than conventional BFs.\n\n\nCONCLUSION\n\nCuckoo filters are a new data structure for approximate set membership queries that can be used for many networking problems formerly solved using Bloom filters. Cuckoo filters improve upon Bloom filters in three ways: (1) support for deleting items dynamically; (2) better lookup performance; and (3) better space efficiency for applications requiring low false positive rates ( < 3%). A cuckoo filter stores the fingerprints of a set of items based on cuckoo hashing, thus achieving high space occupancy. As a further key contribution, we have applied partial-key cuckoo hashing, which makes cuckoo filters significantly more efficient by allowing relocation based on only the stored fingerprint. Our configuration exploration suggests that the cuckoo filter, which uses buckets of size 4, will perform well for a wide range of applications, although appealingly cuckoo filter parameters can be easily varied for application-dependent tuning.\n\nWhile we expect that further extensions and optimizations to cuckoo filters are possible and will further provide impetus for their use, the data structure as described is a fast and efficient building block already well-suited to the practical demands of networking and distributed systems.\n\n\nACKNOWLEDGMENTS\n\nThis work is supported by funding from Intel via the Intel Science and Technology Center for Cloud Computing (ISTC-CC), and National Science Foundation under awards CCF-0964474, CNS-1040801, CCF-1320231, CNS-1228598, and IIS-0964473. We gratefully acknowledge the CoNEXT reviewers for their feedback and suggestions; Rasmus Pagh for discussions on analyzing space usage of cuckoo filters that led to many of the insights about the asymptotic behavior; Hyeontaek Lim for code optimizations; and Iulian Moraru, Andrew Pavlo, Peter Steenkiste for comments on writing.\n\n\nfilter, two hash per item and functions and four entries per bucket\n\nFigure 1 :\n1Illustration of cuckoo hashing\n\n\n(1), the number of possible values of i 2 is at most 2 f when using f -bit fingerprints. Using 1-byte fingerprints, given i 1 there are only up to 2 f = 256 different possible values of i 2 . For a table of m buckets, when 2 f < m (or equivalently f < log 2 m bits), the choice of i 2 is only a subset of all m buckets of the entire hash table.\n\nFigure 3 :\n3Amortized space cost per item vs. measured false positive rate, with different bucket size b = 2, 4, 8.\n\nFigure 4 :\n4False positive rate vs. space cost per element. For low false positive rates (< 3%), cuckoo filters require fewer bits per element than the space-optimized Bloom filters. The load factors to calculate space cost of cuckoo filters are obtained empirically. each fingerprint are encoded; the remainder are stored directly and separately.\n\n\u2022\nAchieved false positive rate: measured by querying a filter with non-existing items and counting the fraction of positive return values. \u2022 Construction rate: measured by the number of items that a full filter contains divided by the time to construct this full filter from empty. \u2022 Lookup, Insert and Delete throughput: measured by the average number of operations a filter can perform per second. The value can depend on the workload and the occupancy of the filter.\n\nFigure 5 :\n5Lookup performance when a filter achieves its capacity. Each point is the average of 10 runs.\n\nFigure 6 :\n6Lookup throughput (MOPS) at different occupancy. Each point is the average of 10 runs.\n\nFigure 8 :\n8Delete-until-empty throughput (MOPS) at different occupancy. Each point is the average of 10 runs. set k bits, regardless of the load factor.\n\n\nor bucket[i 2 ] has an empty entry then add f to that bucket; return Done;// must relocate existing items; \ni = randomly pick i 1 or i 2 ; \nfor n = 0; n < MaxNumKicks; n++ do \nrandomly select an entry e from bucket[i]; \nswap f and the fingerprint stored in entry e; \ni = i \u2295 hash( f ); \nif bucket[i] has an empty entry then \nadd f to bucket[i]; \nreturn Done; \n\n// Hashtable is considered full; \nreturn Failure; \n\n\n\n\nbucket[i 1 ] or bucket[i 2 ] has f then return True;return False; \n\n\n\n\nbucket[i 1 ] or bucket[i 2 ] has f then remove a copy of f from this bucket; return True;return False; \n\n\n\nTable 2 :\n2Space and lookup cost of Bloom filters and three cuckoo filters.\n\nTable 3 :\n3Space efficiency and construction speed. All filters are 192MB. Entries in bold are the best among the row.\nHere we assume hashing the fingerprints (i.e., t x \u2192 h(t x )) is collision-free, because in practice t x is a few bits and h(t x ) is much longer.\nIf the cuckoo filter does not need to support deletion, then it can ignore duplicate entries in the fingerprint list, creating the potential for saving an additional fraction of a bit per entry.\nhttps://github.com/efficient/cuckoofilter6 The source code from the original authors was not publicly available for comparison due to license issues.\n\n. Cityhash, CityHash. https://code.google.com/p/ cityhash/.\n\nDon't thrash: How to cache your hash on flash. M A Bender, M Farach-Colton, R Johnson, R Kraner, B C Kuszmaul, D Medjedovic, P Montes, P Shetty, R P Spillane, E Zadok, PVLDB5M. A. Bender, M. Farach-Colton, R. Johnson, R. Kraner, B. C. Kuszmaul, D. Medjedovic, P. Montes, P. Shetty, R. P. Spillane, and E. Zadok. Don't thrash: How to cache your hash on flash. PVLDB, 5(11):1627-1637, 2012.\n\nSpace/time trade-offs in hash coding with allowable errors. B H Bloom, Communications of the ACM. 137B. H. Bloom. Space/time trade-offs in hash coding with al- lowable errors. Communications of the ACM, 13(7):422-426, 1970.\n\nBeyond Bloom filters: From approximate membership checks to approximate state machines. F Bonomi, M Mitzenmacher, R Panigrahy, Proc. ACM SIGCOMM. ACM SIGCOMMPisa, ItalyF. Bonomi, M. Mitzenmacher, and R. Panigrahy. Beyond Bloom filters: From approximate membership checks to ap- proximate state machines. In Proc. ACM SIGCOMM, Pisa, Italy, Aug. 2006.\n\nAn improved construction for counting bloom filters. F Bonomi, M Mitzenmacher, R Panigrahy, S Singh, G Varghese, 14th Annual European Symposium on Algorithms. 4168F. Bonomi, M. Mitzenmacher, R. Panigrahy, S. Singh, and G. Varghese. An improved construction for counting bloom filters. In 14th Annual European Symposium on Algorithms, LNCS 4168, pages 684-695, 2006.\n\nNetwork Applications of Bloom Filters: A Survey. A Broder, M Mitzenmacher, A Broder, Internet Mathematics. 1A. Broder, M. Mitzenmacher, and A. Broder. Network Appli- cations of Bloom Filters: A Survey. In Internet Mathematics, volume 1, pages 636-646, 2002.\n\nThe Bloomier filter: An efficient data structure for static support lookup tables. B Chazelle, J Kilian, R Rubinfeld, A Tal, O Boy, Proceedings of SODA. SODAB. Chazelle, J. Kilian, R. Rubinfeld, A. Tal, and O. Boy. The Bloomier filter: An efficient data structure for static support lookup tables. In Proceedings of SODA, pages 30-39, 2004.\n\nCompact Hash Tables Using Bidirectional Linear Probing. J G Cleary, IEEE Transactions on Computer, C. 339J. G. Cleary. Compact Hash Tables Using Bidirectional Linear Probing. IEEE Transactions on Computer, C-33(9), Sept. 1984.\n\nLongest prefix matching using Bloom filters. S Dharmapurikar, P Krishnamurthy, D E Taylor, Proc. ACM SIGCOMM. ACM SIGCOMMKarlsruhe, GermanyS. Dharmapurikar, P. Krishnamurthy, and D. E. Taylor. Longest prefix matching using Bloom filters. In Proc. ACM SIGCOMM, Karlsruhe, Germany, Aug. 2003.\n\nBalanced allocation and dictionaries with tightly packed constant size bins. M Dietzfelbinger, C Weidling, Theoretical Computer Science. 3801M. Dietzfelbinger and C. Weidling. Balanced allocation and dictionaries with tightly packed constant size bins. Theoretical Computer Science, 380(1):47-68, 2007.\n\nMemC3: Compact and concurrent memcache with dumber caching and smarter hashing. B Fan, D G Andersen, M Kaminsky, Proc. 10th USENIX NSDI. 10th USENIX NSDILombard, ILB. Fan, D. G. Andersen, and M. Kaminsky. MemC3: Compact and concurrent memcache with dumber caching and smarter hashing. In Proc. 10th USENIX NSDI, Lombard, IL, Apr. 2013.\n\nSummary cache: A scalable wide-area Web cache sharing protocol. L Fan, P Cao, J Almeida, A Z Broder, Proc. ACM SIGCOMM. ACM SIGCOMMVancouver, BC, CanadaL. Fan, P. Cao, J. Almeida, and A. Z. Broder. Summary cache: A scalable wide-area Web cache sharing protocol. In Proc. ACM SIGCOMM, Vancouver, BC, Canada, Sept. 1998.\n\nThe multipleorientability thresholds for random hypergraphs. N Fountoulakis, M Khosla, K Panagiotou, Proceedings of the Twenty-Second Annual ACM-SIAM Symposium on Discrete Algorithms. the Twenty-Second Annual ACM-SIAM Symposium on Discrete AlgorithmsSIAMN. Fountoulakis, M. Khosla, and K. Panagiotou. The multiple- orientability thresholds for random hypergraphs. In Proceed- ings of the Twenty-Second Annual ACM-SIAM Symposium on Discrete Algorithms, pages 1222-1236. SIAM, 2011.\n\nRank-Indexed Hashing: A Compact Construction of Bloom Filters and Variants. N Hua, H C Zhao, B Lin, J J Xu, Proc. of IEEE Int'l Conf. on Network Protocols (ICNP). of IEEE Int'l Conf. on Network Protocols (ICNP)Orlando, Florida, USAN. Hua, H. C. Zhao, B. Lin, and J. J. Xu. Rank-Indexed Hash- ing: A Compact Construction of Bloom Filters and Variants. In Proc. of IEEE Int'l Conf. on Network Protocols (ICNP) 2008, Orlando, Florida, USA, Oct. 2008.\n\nLipsin: Line speed publish/subscribe internetworking. P Jokela, A Zahemszky, C Esteve Rothenberg, S Arianfar, P Nikander, Proc. ACM SIGCOMM. ACM SIGCOMMBarcelona, SpainP. Jokela, A. Zahemszky, C. Esteve Rothenberg, S. Arianfar, and P. Nikander. Lipsin: Line speed publish/subscribe inter- networking. In Proc. ACM SIGCOMM, Barcelona, Spain, Aug. 2009.\n\nLess hashing, same performance: Building a better Bloom filter. A Kirsch, M Mitzenmacher, Random Structures & Algorithms. 332A. Kirsch and M. Mitzenmacher. Less hashing, same perfor- mance: Building a better Bloom filter. Random Structures & Algorithms, 33(2):187-218, 2008.\n\nSILT: A memory-efficient, high-performance key-value store. H Lim, B Fan, D G Andersen, M Kaminsky, Proc. 23rd ACM Symposium on Operating Systems Principles (SOSP). 23rd ACM Symposium on Operating Systems Principles (SOSP)Cascais, PortugalH. Lim, B. Fan, D. G. Andersen, and M. Kaminsky. SILT: A memory-efficient, high-performance key-value store. In Proc. 23rd ACM Symposium on Operating Systems Principles (SOSP), Cascais, Portugal, Oct. 2011.\n\nThe power of two random choices: A survey of techniques and results. M Mitzenmacher, A W Richa, R Sitaraman, Handbook of Randomized Computing. KluwerM. Mitzenmacher, A. W. Richa, and R. Sitaraman. The power of two random choices: A survey of techniques and results. In Handbook of Randomized Computing, pages 255-312. Kluwer, 2000.\n\nThe asymptotics of selecting the shortest of two, improved. M Mitzenmacher, B Vocking, Proc. the Annual Allerton Conference on Communication Control and Computing. the Annual Allerton Conference on Communication Control and Computing37M. Mitzenmacher and B. Vocking. The asymptotics of select- ing the shortest of two, improved. In Proc. the Annual Allerton Conference on Communication Control and Computing, vol- ume 37, pages 326-327, 1999.\n\nAn optimal bloom filter replacement. A Pagh, R Pagh, S S Rao, Proc. ASM-SIAM Symposium on Discrete Algorithms, SODA. ASM-SIAM Symposium on Discrete Algorithms, SODAA. Pagh, R. Pagh, and S. S. Rao. An optimal bloom filter replacement. In Proc. ASM-SIAM Symposium on Discrete Algorithms, SODA, 2005.\n\nCuckoo hashing. R Pagh, F Rodler, Journal of Algorithms. 512R. Pagh and F. Rodler. Cuckoo hashing. Journal of Algorithms, 51(2):122-144, May 2004.\n\nCache-, hash-and spaceefficient bloom filters. F Putze, P Sanders, S Johannes, Experimental Algorithms. Berlin / HeidelbergSpringerF. Putze, P. Sanders, and S. Johannes. Cache-, hash-and space- efficient bloom filters. In Experimental Algorithms, pages 108-121. Springer Berlin / Heidelberg, 2007.\n\nImplementing signatures for transactional memory. D Sanchez, L Yen, M D Hill, K Sankaralingam, Proc. the 40th Annual IEEE/ACM International Symposium on Microarchitecture. the 40th Annual IEEE/ACM International Symposium on MicroarchitectureWashington, DC, USAD. Sanchez, L. Yen, M. D. Hill, and K. Sankaralingam. Im- plementing signatures for transactional memory. In Proc. the 40th Annual IEEE/ACM International Symposium on Microar- chitecture, pages 123-133, Washington, DC, USA, 2007.\n\nFast hash table lookup using extended bloom filter: An aid to network processing. H Song, S Dharmapurikar, J Turner, J Lockwood, Proc. ACM SIGCOMM. ACM SIGCOMMPhiladelphia, PAH. Song, S. Dharmapurikar, J. Turner, and J. Lockwood. Fast hash table lookup using extended bloom filter: An aid to net- work processing. In Proc. ACM SIGCOMM, pages 181-192, Philadelphia, PA, Aug. 2005.\n\nBUFFALO: Bloom filter forwarding architecture for large organizations. M Yu, A Fabrikant, J Rexford, Proc. CoNEXT. CoNEXTM. Yu, A. Fabrikant, and J. Rexford. BUFFALO: Bloom filter forwarding architecture for large organizations. In Proc. CoNEXT, Dec. 2009.\n\nHigh Performance Ethernet Forwarding with Cuck-ooSwitch. D Zhou, B Fan, H Lim, D G Andersen, M Kaminsky, Scalable, Proc. 9th International Conference on emerging Networking EXperiments and Technologies (CoNEXT). 9th International Conference on emerging Networking EXperiments and Technologies (CoNEXT)D. Zhou, B. Fan, H. Lim, D. G. Andersen, and M. Kaminsky. Scalable, High Performance Ethernet Forwarding with Cuck- ooSwitch. In Proc. 9th International Conference on emerging Networking EXperiments and Technologies (CoNEXT), Dec. 2013.\n", "annotations": {"author": "[{\"end\":56,\"start\":48},{\"end\":74,\"start\":57},{\"end\":134,\"start\":75},{\"end\":205,\"start\":135},{\"end\":235,\"start\":206}]", "publisher": null, "author_last_name": "[{\"end\":55,\"start\":52},{\"end\":73,\"start\":65},{\"end\":91,\"start\":83},{\"end\":157,\"start\":145}]", "author_first_name": "[{\"end\":51,\"start\":48},{\"end\":62,\"start\":57},{\"end\":64,\"start\":63},{\"end\":82,\"start\":75},{\"end\":142,\"start\":135},{\"end\":144,\"start\":143}]", "author_affiliation": "[{\"end\":133,\"start\":122},{\"end\":204,\"start\":185},{\"end\":234,\"start\":207}]", "title": "[{\"end\":45,\"start\":1},{\"end\":280,\"start\":236}]", "venue": null, "abstract": "[{\"end\":1359,\"start\":421}]", "bib_ref": "[{\"attributes\":{\"ref_id\":\"b11\"},\"end\":1695,\"start\":1691},{\"attributes\":{\"ref_id\":\"b23\"},\"end\":1746,\"start\":1742},{\"attributes\":{\"ref_id\":\"b24\"},\"end\":1749,\"start\":1746},{\"attributes\":{\"ref_id\":\"b8\"},\"end\":1751,\"start\":1749},{\"attributes\":{\"ref_id\":\"b4\"},\"end\":1917,\"start\":1914},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":1972,\"start\":1969},{\"attributes\":{\"ref_id\":\"b20\"},\"end\":2795,\"start\":2791},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":5315,\"start\":5312},{\"attributes\":{\"ref_id\":\"b19\"},\"end\":6150,\"start\":6146},{\"attributes\":{\"ref_id\":\"b5\"},\"end\":6720,\"start\":6717},{\"attributes\":{\"ref_id\":\"b11\"},\"end\":6858,\"start\":6854},{\"attributes\":{\"ref_id\":\"b21\"},\"end\":7746,\"start\":7742},{\"attributes\":{\"ref_id\":\"b4\"},\"end\":8306,\"start\":8303},{\"attributes\":{\"ref_id\":\"b18\"},\"end\":8385,\"start\":8381},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":8811,\"start\":8808},{\"attributes\":{\"ref_id\":\"b13\"},\"end\":9571,\"start\":9567},{\"attributes\":{\"ref_id\":\"b21\"},\"end\":9911,\"start\":9907},{\"attributes\":{\"ref_id\":\"b19\"},\"end\":10329,\"start\":10325},{\"attributes\":{\"ref_id\":\"b7\"},\"end\":10349,\"start\":10346},{\"attributes\":{\"ref_id\":\"b20\"},\"end\":10626,\"start\":10622},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":12064,\"start\":12060},{\"attributes\":{\"ref_id\":\"b12\"},\"end\":12213,\"start\":12209},{\"attributes\":{\"ref_id\":\"b22\"},\"end\":12717,\"start\":12713},{\"attributes\":{\"ref_id\":\"b16\"},\"end\":12904,\"start\":12900},{\"attributes\":{\"ref_id\":\"b10\"},\"end\":12907,\"start\":12904},{\"attributes\":{\"ref_id\":\"b25\"},\"end\":12949,\"start\":12945},{\"attributes\":{\"ref_id\":\"b10\"},\"end\":15725,\"start\":15721},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":18806,\"start\":18802},{\"attributes\":{\"ref_id\":\"b12\"},\"end\":18809,\"start\":18806},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":21371,\"start\":21370},{\"attributes\":{\"ref_id\":\"b0\"},\"end\":22923,\"start\":22922},{\"attributes\":{\"ref_id\":\"b4\"},\"end\":23548,\"start\":23545},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":23551,\"start\":23550},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":23886,\"start\":23883},{\"attributes\":{\"ref_id\":\"b24\"},\"end\":28518,\"start\":28516},{\"attributes\":{\"ref_id\":\"b5\"},\"end\":35069,\"start\":35066},{\"attributes\":{\"ref_id\":\"b4\"},\"end\":35709,\"start\":35706},{\"attributes\":{\"ref_id\":\"b3\"},\"end\":36482,\"start\":36481},{\"attributes\":{\"ref_id\":\"b6\"},\"end\":38904,\"start\":38901},{\"attributes\":{\"ref_id\":\"b4\"},\"end\":39770,\"start\":39769},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":40162,\"start\":40159},{\"attributes\":{\"ref_id\":\"b15\"},\"end\":40498,\"start\":40494},{\"attributes\":{\"ref_id\":\"b21\"},\"end\":40739,\"start\":40735},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":41060,\"start\":41057},{\"attributes\":{\"ref_id\":\"b5\"},\"end\":41119,\"start\":41118},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":41352,\"start\":41349},{\"end\":41395,\"start\":41394},{\"attributes\":{\"ref_id\":\"b0\"},\"end\":41865,\"start\":41862},{\"attributes\":{\"ref_id\":\"b17\"},\"end\":44445,\"start\":44441},{\"attributes\":{\"ref_id\":\"b6\"},\"end\":47797,\"start\":47796},{\"attributes\":{\"ref_id\":\"b5\"},\"end\":56444,\"start\":56443}]", "figure": "[{\"attributes\":{\"id\":\"fig_0\"},\"end\":53577,\"start\":53508},{\"attributes\":{\"id\":\"fig_1\"},\"end\":53621,\"start\":53578},{\"attributes\":{\"id\":\"fig_3\"},\"end\":53968,\"start\":53622},{\"attributes\":{\"id\":\"fig_5\"},\"end\":54085,\"start\":53969},{\"attributes\":{\"id\":\"fig_6\"},\"end\":54434,\"start\":54086},{\"attributes\":{\"id\":\"fig_7\"},\"end\":54905,\"start\":54435},{\"attributes\":{\"id\":\"fig_8\"},\"end\":55012,\"start\":54906},{\"attributes\":{\"id\":\"fig_11\"},\"end\":55112,\"start\":55013},{\"attributes\":{\"id\":\"fig_12\"},\"end\":55267,\"start\":55113},{\"attributes\":{\"id\":\"tab_1\",\"type\":\"table\"},\"end\":55683,\"start\":55268},{\"attributes\":{\"id\":\"tab_2\",\"type\":\"table\"},\"end\":55754,\"start\":55684},{\"attributes\":{\"id\":\"tab_3\",\"type\":\"table\"},\"end\":55862,\"start\":55755},{\"attributes\":{\"id\":\"tab_5\",\"type\":\"table\"},\"end\":55939,\"start\":55863},{\"attributes\":{\"id\":\"tab_7\",\"type\":\"table\"},\"end\":56059,\"start\":55940}]", "paragraph": "[{\"end\":2346,\"start\":1361},{\"end\":3194,\"start\":2348},{\"end\":4521,\"start\":3196},{\"end\":4957,\"start\":4576},{\"end\":5635,\"start\":5018},{\"end\":6041,\"start\":5662},{\"end\":6081,\"start\":6043},{\"end\":6571,\"start\":6083},{\"end\":6829,\"start\":6573},{\"end\":8271,\"start\":6831},{\"end\":8789,\"start\":8273},{\"end\":9432,\"start\":8791},{\"end\":10550,\"start\":9434},{\"end\":11793,\"start\":10573},{\"end\":12354,\"start\":11795},{\"end\":13612,\"start\":12356},{\"end\":14121,\"start\":13645},{\"end\":15174,\"start\":14123},{\"end\":15431,\"start\":15203},{\"end\":16079,\"start\":15433},{\"end\":16753,\"start\":16090},{\"end\":17281,\"start\":16915},{\"end\":17414,\"start\":17312},{\"end\":18286,\"start\":17416},{\"end\":19036,\"start\":18288},{\"end\":20076,\"start\":19038},{\"end\":20596,\"start\":20170},{\"end\":21613,\"start\":20690},{\"end\":21976,\"start\":21615},{\"end\":22630,\"start\":22000},{\"end\":24288,\"start\":22632},{\"end\":24960,\"start\":24312},{\"end\":25029,\"start\":24962},{\"end\":26093,\"start\":25031},{\"end\":26605,\"start\":26095},{\"end\":27239,\"start\":26607},{\"end\":27484,\"start\":27302},{\"end\":27957,\"start\":27486},{\"end\":28673,\"start\":27959},{\"end\":29609,\"start\":28675},{\"end\":30652,\"start\":29623},{\"end\":30974,\"start\":30654},{\"end\":31416,\"start\":30998},{\"end\":32027,\"start\":31418},{\"end\":32316,\"start\":32109},{\"end\":32441,\"start\":32340},{\"end\":32715,\"start\":32443},{\"end\":33536,\"start\":32717},{\"end\":33748,\"start\":33571},{\"end\":33799,\"start\":33750},{\"end\":33935,\"start\":33801},{\"end\":34193,\"start\":33972},{\"end\":34778,\"start\":34195},{\"end\":35212,\"start\":34780},{\"end\":35710,\"start\":35251},{\"end\":36967,\"start\":35712},{\"end\":37110,\"start\":37000},{\"end\":37592,\"start\":37112},{\"end\":38266,\"start\":37594},{\"end\":38905,\"start\":38268},{\"end\":39334,\"start\":38907},{\"end\":39735,\"start\":39336},{\"end\":40128,\"start\":39750},{\"end\":40669,\"start\":40130},{\"end\":41578,\"start\":40703},{\"end\":41777,\"start\":41580},{\"end\":42335,\"start\":41779},{\"end\":42497,\"start\":42337},{\"end\":42610,\"start\":42499},{\"end\":43218,\"start\":42643},{\"end\":43937,\"start\":43220},{\"end\":44616,\"start\":43939},{\"end\":44806,\"start\":44618},{\"end\":45105,\"start\":44808},{\"end\":45611,\"start\":45128},{\"end\":46295,\"start\":45613},{\"end\":47027,\"start\":46297},{\"end\":47194,\"start\":47029},{\"end\":47427,\"start\":47196},{\"end\":48219,\"start\":47451},{\"end\":48457,\"start\":48221},{\"end\":48639,\"start\":48459},{\"end\":49002,\"start\":48641},{\"end\":49441,\"start\":49004},{\"end\":49833,\"start\":49464},{\"end\":50492,\"start\":49835},{\"end\":51188,\"start\":50494},{\"end\":51671,\"start\":51211},{\"end\":52630,\"start\":51686},{\"end\":52923,\"start\":52632},{\"end\":53507,\"start\":52943}]", "formula": "[{\"attributes\":{\"id\":\"formula_0\"},\"end\":16850,\"start\":16754},{\"attributes\":{\"id\":\"formula_1\"},\"end\":16914,\"start\":16850},{\"attributes\":{\"id\":\"formula_2\"},\"end\":17311,\"start\":17282},{\"attributes\":{\"id\":\"formula_3\"},\"end\":20160,\"start\":20077},{\"attributes\":{\"id\":\"formula_4\"},\"end\":20680,\"start\":20597},{\"attributes\":{\"id\":\"formula_5\"},\"end\":21999,\"start\":21977},{\"attributes\":{\"id\":\"formula_6\"},\"end\":27301,\"start\":27240},{\"attributes\":{\"id\":\"formula_7\"},\"end\":32108,\"start\":32028},{\"attributes\":{\"id\":\"formula_8\"},\"end\":33570,\"start\":33537},{\"attributes\":{\"id\":\"formula_10\"},\"end\":33971,\"start\":33936},{\"attributes\":{\"id\":\"formula_11\"},\"end\":40702,\"start\":40670}]", "table_ref": "[{\"end\":5157,\"start\":5150},{\"attributes\":{\"ref_id\":\"tab_5\"},\"end\":37078,\"start\":37071},{\"attributes\":{\"ref_id\":\"tab_5\"},\"end\":37137,\"start\":37130},{\"attributes\":{\"ref_id\":\"tab_7\"},\"end\":43498,\"start\":43491},{\"attributes\":{\"ref_id\":\"tab_7\"},\"end\":49624,\"start\":49617}]", "section_header": "[{\"end\":4574,\"start\":4524},{\"attributes\":{\"n\":\"2.\"},\"end\":4987,\"start\":4960},{\"attributes\":{\"n\":\"2.1\"},\"end\":5016,\"start\":4990},{\"end\":5660,\"start\":5638},{\"attributes\":{\"n\":\"2.2\"},\"end\":10571,\"start\":10553},{\"end\":13643,\"start\":13615},{\"attributes\":{\"n\":\"3.\"},\"end\":15201,\"start\":15177},{\"attributes\":{\"n\":\"3.1\"},\"end\":16088,\"start\":16082},{\"attributes\":{\"n\":\"3.2\"},\"end\":20168,\"start\":20162},{\"attributes\":{\"n\":\"3.3\"},\"end\":20688,\"start\":20682},{\"attributes\":{\"n\":\"4.\"},\"end\":24310,\"start\":24291},{\"end\":29621,\"start\":29612},{\"attributes\":{\"n\":\"5.\"},\"end\":30996,\"start\":30977},{\"attributes\":{\"n\":\"5.1\"},\"end\":32338,\"start\":32319},{\"attributes\":{\"n\":\"5.2\"},\"end\":35249,\"start\":35215},{\"attributes\":{\"n\":\"6.\"},\"end\":36998,\"start\":36970},{\"attributes\":{\"n\":\"7.\"},\"end\":39748,\"start\":39738},{\"attributes\":{\"n\":\"7.1\"},\"end\":42641,\"start\":42613},{\"attributes\":{\"n\":\"7.2\"},\"end\":45126,\"start\":45108},{\"end\":47449,\"start\":47430},{\"attributes\":{\"n\":\"7.3\"},\"end\":49462,\"start\":49444},{\"attributes\":{\"n\":\"7.4\"},\"end\":51209,\"start\":51191},{\"attributes\":{\"n\":\"8.\"},\"end\":51684,\"start\":51674},{\"attributes\":{\"n\":\"9.\"},\"end\":52941,\"start\":52926},{\"end\":53589,\"start\":53579},{\"end\":53980,\"start\":53970},{\"end\":54097,\"start\":54087},{\"end\":54437,\"start\":54436},{\"end\":54917,\"start\":54907},{\"end\":55024,\"start\":55014},{\"end\":55124,\"start\":55114},{\"end\":55873,\"start\":55864},{\"end\":55950,\"start\":55941}]", "table": "[{\"end\":55683,\"start\":55344},{\"end\":55754,\"start\":55738},{\"end\":55862,\"start\":55846}]", "figure_caption": "[{\"end\":53577,\"start\":53510},{\"end\":53621,\"start\":53591},{\"end\":53968,\"start\":53624},{\"end\":54085,\"start\":53982},{\"end\":54434,\"start\":54099},{\"end\":54905,\"start\":54438},{\"end\":55012,\"start\":54919},{\"end\":55112,\"start\":55026},{\"end\":55267,\"start\":55126},{\"end\":55344,\"start\":55270},{\"end\":55738,\"start\":55686},{\"end\":55846,\"start\":55757},{\"end\":55939,\"start\":55875},{\"end\":56059,\"start\":55952}]", "figure_ref": "[{\"attributes\":{\"ref_id\":\"fig_1\"},\"end\":10837,\"start\":10829},{\"attributes\":{\"ref_id\":\"fig_1\"},\"end\":11511,\"start\":11503},{\"end\":23897,\"start\":23889},{\"end\":27989,\"start\":27981},{\"end\":28695,\"start\":28687},{\"end\":29166,\"start\":29158},{\"end\":29185,\"start\":29174},{\"end\":29732,\"start\":29724},{\"end\":30506,\"start\":30498},{\"attributes\":{\"ref_id\":\"fig_5\"},\"end\":34514,\"start\":34506},{\"attributes\":{\"ref_id\":\"fig_6\"},\"end\":37235,\"start\":37227},{\"attributes\":{\"ref_id\":\"fig_8\"},\"end\":45675,\"start\":45667},{\"attributes\":{\"ref_id\":\"fig_11\"},\"end\":47664,\"start\":47656},{\"end\":48004,\"start\":47996},{\"end\":49832,\"start\":49824},{\"attributes\":{\"ref_id\":\"fig_11\"},\"end\":49889,\"start\":49881},{\"attributes\":{\"ref_id\":\"fig_12\"},\"end\":50783,\"start\":50775}]", "bib_author_first_name": "[{\"end\":56662,\"start\":56661},{\"end\":56664,\"start\":56663},{\"end\":56674,\"start\":56673},{\"end\":56691,\"start\":56690},{\"end\":56702,\"start\":56701},{\"end\":56712,\"start\":56711},{\"end\":56714,\"start\":56713},{\"end\":56726,\"start\":56725},{\"end\":56740,\"start\":56739},{\"end\":56750,\"start\":56749},{\"end\":56760,\"start\":56759},{\"end\":56762,\"start\":56761},{\"end\":56774,\"start\":56773},{\"end\":57065,\"start\":57064},{\"end\":57067,\"start\":57066},{\"end\":57318,\"start\":57317},{\"end\":57328,\"start\":57327},{\"end\":57344,\"start\":57343},{\"end\":57634,\"start\":57633},{\"end\":57644,\"start\":57643},{\"end\":57660,\"start\":57659},{\"end\":57673,\"start\":57672},{\"end\":57682,\"start\":57681},{\"end\":57997,\"start\":57996},{\"end\":58007,\"start\":58006},{\"end\":58023,\"start\":58022},{\"end\":58290,\"start\":58289},{\"end\":58302,\"start\":58301},{\"end\":58312,\"start\":58311},{\"end\":58325,\"start\":58324},{\"end\":58332,\"start\":58331},{\"end\":58605,\"start\":58604},{\"end\":58607,\"start\":58606},{\"end\":58822,\"start\":58821},{\"end\":58839,\"start\":58838},{\"end\":58856,\"start\":58855},{\"end\":58858,\"start\":58857},{\"end\":59146,\"start\":59145},{\"end\":59164,\"start\":59163},{\"end\":59453,\"start\":59452},{\"end\":59460,\"start\":59459},{\"end\":59462,\"start\":59461},{\"end\":59474,\"start\":59473},{\"end\":59774,\"start\":59773},{\"end\":59781,\"start\":59780},{\"end\":59788,\"start\":59787},{\"end\":59799,\"start\":59798},{\"end\":59801,\"start\":59800},{\"end\":60091,\"start\":60090},{\"end\":60107,\"start\":60106},{\"end\":60117,\"start\":60116},{\"end\":60588,\"start\":60587},{\"end\":60595,\"start\":60594},{\"end\":60597,\"start\":60596},{\"end\":60605,\"start\":60604},{\"end\":60612,\"start\":60611},{\"end\":60614,\"start\":60613},{\"end\":61015,\"start\":61014},{\"end\":61025,\"start\":61024},{\"end\":61038,\"start\":61037},{\"end\":61045,\"start\":61039},{\"end\":61059,\"start\":61058},{\"end\":61071,\"start\":61070},{\"end\":61378,\"start\":61377},{\"end\":61388,\"start\":61387},{\"end\":61650,\"start\":61649},{\"end\":61657,\"start\":61656},{\"end\":61664,\"start\":61663},{\"end\":61666,\"start\":61665},{\"end\":61678,\"start\":61677},{\"end\":62106,\"start\":62105},{\"end\":62122,\"start\":62121},{\"end\":62124,\"start\":62123},{\"end\":62133,\"start\":62132},{\"end\":62430,\"start\":62429},{\"end\":62446,\"start\":62445},{\"end\":62851,\"start\":62850},{\"end\":62859,\"start\":62858},{\"end\":62867,\"start\":62866},{\"end\":62869,\"start\":62868},{\"end\":63129,\"start\":63128},{\"end\":63137,\"start\":63136},{\"end\":63308,\"start\":63307},{\"end\":63317,\"start\":63316},{\"end\":63328,\"start\":63327},{\"end\":63610,\"start\":63609},{\"end\":63621,\"start\":63620},{\"end\":63628,\"start\":63627},{\"end\":63630,\"start\":63629},{\"end\":63638,\"start\":63637},{\"end\":64133,\"start\":64132},{\"end\":64141,\"start\":64140},{\"end\":64158,\"start\":64157},{\"end\":64168,\"start\":64167},{\"end\":64503,\"start\":64502},{\"end\":64509,\"start\":64508},{\"end\":64522,\"start\":64521},{\"end\":64747,\"start\":64746},{\"end\":64755,\"start\":64754},{\"end\":64762,\"start\":64761},{\"end\":64769,\"start\":64768},{\"end\":64771,\"start\":64770},{\"end\":64783,\"start\":64782}]", "bib_author_last_name": "[{\"end\":56563,\"start\":56555},{\"end\":56671,\"start\":56665},{\"end\":56688,\"start\":56675},{\"end\":56699,\"start\":56692},{\"end\":56709,\"start\":56703},{\"end\":56723,\"start\":56715},{\"end\":56737,\"start\":56727},{\"end\":56747,\"start\":56741},{\"end\":56757,\"start\":56751},{\"end\":56771,\"start\":56763},{\"end\":56780,\"start\":56775},{\"end\":57073,\"start\":57068},{\"end\":57325,\"start\":57319},{\"end\":57341,\"start\":57329},{\"end\":57354,\"start\":57345},{\"end\":57641,\"start\":57635},{\"end\":57657,\"start\":57645},{\"end\":57670,\"start\":57661},{\"end\":57679,\"start\":57674},{\"end\":57691,\"start\":57683},{\"end\":58004,\"start\":57998},{\"end\":58020,\"start\":58008},{\"end\":58030,\"start\":58024},{\"end\":58299,\"start\":58291},{\"end\":58309,\"start\":58303},{\"end\":58322,\"start\":58313},{\"end\":58329,\"start\":58326},{\"end\":58336,\"start\":58333},{\"end\":58614,\"start\":58608},{\"end\":58836,\"start\":58823},{\"end\":58853,\"start\":58840},{\"end\":58865,\"start\":58859},{\"end\":59161,\"start\":59147},{\"end\":59173,\"start\":59165},{\"end\":59457,\"start\":59454},{\"end\":59471,\"start\":59463},{\"end\":59483,\"start\":59475},{\"end\":59778,\"start\":59775},{\"end\":59785,\"start\":59782},{\"end\":59796,\"start\":59789},{\"end\":59808,\"start\":59802},{\"end\":60104,\"start\":60092},{\"end\":60114,\"start\":60108},{\"end\":60128,\"start\":60118},{\"end\":60592,\"start\":60589},{\"end\":60602,\"start\":60598},{\"end\":60609,\"start\":60606},{\"end\":60617,\"start\":60615},{\"end\":61022,\"start\":61016},{\"end\":61035,\"start\":61026},{\"end\":61056,\"start\":61046},{\"end\":61068,\"start\":61060},{\"end\":61080,\"start\":61072},{\"end\":61385,\"start\":61379},{\"end\":61401,\"start\":61389},{\"end\":61654,\"start\":61651},{\"end\":61661,\"start\":61658},{\"end\":61675,\"start\":61667},{\"end\":61687,\"start\":61679},{\"end\":62119,\"start\":62107},{\"end\":62130,\"start\":62125},{\"end\":62143,\"start\":62134},{\"end\":62443,\"start\":62431},{\"end\":62454,\"start\":62447},{\"end\":62856,\"start\":62852},{\"end\":62864,\"start\":62860},{\"end\":62873,\"start\":62870},{\"end\":63134,\"start\":63130},{\"end\":63144,\"start\":63138},{\"end\":63314,\"start\":63309},{\"end\":63325,\"start\":63318},{\"end\":63337,\"start\":63329},{\"end\":63618,\"start\":63611},{\"end\":63625,\"start\":63622},{\"end\":63635,\"start\":63631},{\"end\":63652,\"start\":63639},{\"end\":64138,\"start\":64134},{\"end\":64155,\"start\":64142},{\"end\":64165,\"start\":64159},{\"end\":64177,\"start\":64169},{\"end\":64506,\"start\":64504},{\"end\":64519,\"start\":64510},{\"end\":64530,\"start\":64523},{\"end\":64752,\"start\":64748},{\"end\":64759,\"start\":64756},{\"end\":64766,\"start\":64763},{\"end\":64780,\"start\":64772},{\"end\":64792,\"start\":64784},{\"end\":64802,\"start\":64794}]", "bib_entry": "[{\"attributes\":{\"id\":\"b0\"},\"end\":56612,\"start\":56553},{\"attributes\":{\"id\":\"b1\"},\"end\":57002,\"start\":56614},{\"attributes\":{\"id\":\"b2\",\"matched_paper_id\":7931252},\"end\":57227,\"start\":57004},{\"attributes\":{\"id\":\"b3\",\"matched_paper_id\":576086},\"end\":57578,\"start\":57229},{\"attributes\":{\"id\":\"b4\",\"matched_paper_id\":16602678},\"end\":57945,\"start\":57580},{\"attributes\":{\"id\":\"b5\",\"matched_paper_id\":1560675},\"end\":58204,\"start\":57947},{\"attributes\":{\"id\":\"b6\",\"matched_paper_id\":2159505},\"end\":58546,\"start\":58206},{\"attributes\":{\"id\":\"b7\",\"matched_paper_id\":5244878},\"end\":58774,\"start\":58548},{\"attributes\":{\"id\":\"b8\",\"matched_paper_id\":2839865},\"end\":59066,\"start\":58776},{\"attributes\":{\"id\":\"b9\",\"matched_paper_id\":14929369},\"end\":59370,\"start\":59068},{\"attributes\":{\"id\":\"b10\",\"matched_paper_id\":2567232},\"end\":59707,\"start\":59372},{\"attributes\":{\"id\":\"b11\",\"matched_paper_id\":4779754},\"end\":60027,\"start\":59709},{\"attributes\":{\"id\":\"b12\",\"matched_paper_id\":9620441},\"end\":60509,\"start\":60029},{\"attributes\":{\"id\":\"b13\",\"matched_paper_id\":13163134},\"end\":60958,\"start\":60511},{\"attributes\":{\"id\":\"b14\",\"matched_paper_id\":12041351},\"end\":61311,\"start\":60960},{\"attributes\":{\"id\":\"b15\",\"matched_paper_id\":2754699},\"end\":61587,\"start\":61313},{\"attributes\":{\"id\":\"b16\",\"matched_paper_id\":51258},\"end\":62034,\"start\":61589},{\"attributes\":{\"id\":\"b17\",\"matched_paper_id\":1057195},\"end\":62367,\"start\":62036},{\"attributes\":{\"id\":\"b18\",\"matched_paper_id\":1566516},\"end\":62811,\"start\":62369},{\"attributes\":{\"id\":\"b19\",\"matched_paper_id\":5507317},\"end\":63110,\"start\":62813},{\"attributes\":{\"id\":\"b20\",\"matched_paper_id\":2447135},\"end\":63258,\"start\":63112},{\"attributes\":{\"id\":\"b21\",\"matched_paper_id\":187572},\"end\":63557,\"start\":63260},{\"attributes\":{\"id\":\"b22\",\"matched_paper_id\":6994600},\"end\":64048,\"start\":63559},{\"attributes\":{\"id\":\"b23\",\"matched_paper_id\":1761842},\"end\":64429,\"start\":64050},{\"attributes\":{\"id\":\"b24\",\"matched_paper_id\":1420589},\"end\":64687,\"start\":64431},{\"attributes\":{\"id\":\"b25\"},\"end\":65226,\"start\":64689}]", "bib_title": "[{\"end\":57062,\"start\":57004},{\"end\":57315,\"start\":57229},{\"end\":57631,\"start\":57580},{\"end\":57994,\"start\":57947},{\"end\":58287,\"start\":58206},{\"end\":58602,\"start\":58548},{\"end\":58819,\"start\":58776},{\"end\":59143,\"start\":59068},{\"end\":59450,\"start\":59372},{\"end\":59771,\"start\":59709},{\"end\":60088,\"start\":60029},{\"end\":60585,\"start\":60511},{\"end\":61012,\"start\":60960},{\"end\":61375,\"start\":61313},{\"end\":61647,\"start\":61589},{\"end\":62103,\"start\":62036},{\"end\":62427,\"start\":62369},{\"end\":62848,\"start\":62813},{\"end\":63126,\"start\":63112},{\"end\":63305,\"start\":63260},{\"end\":63607,\"start\":63559},{\"end\":64130,\"start\":64050},{\"end\":64500,\"start\":64431},{\"end\":64744,\"start\":64689}]", "bib_author": "[{\"end\":56565,\"start\":56555},{\"end\":56673,\"start\":56661},{\"end\":56690,\"start\":56673},{\"end\":56701,\"start\":56690},{\"end\":56711,\"start\":56701},{\"end\":56725,\"start\":56711},{\"end\":56739,\"start\":56725},{\"end\":56749,\"start\":56739},{\"end\":56759,\"start\":56749},{\"end\":56773,\"start\":56759},{\"end\":56782,\"start\":56773},{\"end\":57075,\"start\":57064},{\"end\":57327,\"start\":57317},{\"end\":57343,\"start\":57327},{\"end\":57356,\"start\":57343},{\"end\":57643,\"start\":57633},{\"end\":57659,\"start\":57643},{\"end\":57672,\"start\":57659},{\"end\":57681,\"start\":57672},{\"end\":57693,\"start\":57681},{\"end\":58006,\"start\":57996},{\"end\":58022,\"start\":58006},{\"end\":58032,\"start\":58022},{\"end\":58301,\"start\":58289},{\"end\":58311,\"start\":58301},{\"end\":58324,\"start\":58311},{\"end\":58331,\"start\":58324},{\"end\":58338,\"start\":58331},{\"end\":58616,\"start\":58604},{\"end\":58838,\"start\":58821},{\"end\":58855,\"start\":58838},{\"end\":58867,\"start\":58855},{\"end\":59163,\"start\":59145},{\"end\":59175,\"start\":59163},{\"end\":59459,\"start\":59452},{\"end\":59473,\"start\":59459},{\"end\":59485,\"start\":59473},{\"end\":59780,\"start\":59773},{\"end\":59787,\"start\":59780},{\"end\":59798,\"start\":59787},{\"end\":59810,\"start\":59798},{\"end\":60106,\"start\":60090},{\"end\":60116,\"start\":60106},{\"end\":60130,\"start\":60116},{\"end\":60594,\"start\":60587},{\"end\":60604,\"start\":60594},{\"end\":60611,\"start\":60604},{\"end\":60619,\"start\":60611},{\"end\":61024,\"start\":61014},{\"end\":61037,\"start\":61024},{\"end\":61058,\"start\":61037},{\"end\":61070,\"start\":61058},{\"end\":61082,\"start\":61070},{\"end\":61387,\"start\":61377},{\"end\":61403,\"start\":61387},{\"end\":61656,\"start\":61649},{\"end\":61663,\"start\":61656},{\"end\":61677,\"start\":61663},{\"end\":61689,\"start\":61677},{\"end\":62121,\"start\":62105},{\"end\":62132,\"start\":62121},{\"end\":62145,\"start\":62132},{\"end\":62445,\"start\":62429},{\"end\":62456,\"start\":62445},{\"end\":62858,\"start\":62850},{\"end\":62866,\"start\":62858},{\"end\":62875,\"start\":62866},{\"end\":63136,\"start\":63128},{\"end\":63146,\"start\":63136},{\"end\":63316,\"start\":63307},{\"end\":63327,\"start\":63316},{\"end\":63339,\"start\":63327},{\"end\":63620,\"start\":63609},{\"end\":63627,\"start\":63620},{\"end\":63637,\"start\":63627},{\"end\":63654,\"start\":63637},{\"end\":64140,\"start\":64132},{\"end\":64157,\"start\":64140},{\"end\":64167,\"start\":64157},{\"end\":64179,\"start\":64167},{\"end\":64508,\"start\":64502},{\"end\":64521,\"start\":64508},{\"end\":64532,\"start\":64521},{\"end\":64754,\"start\":64746},{\"end\":64761,\"start\":64754},{\"end\":64768,\"start\":64761},{\"end\":64782,\"start\":64768},{\"end\":64794,\"start\":64782},{\"end\":64804,\"start\":64794}]", "bib_venue": "[{\"end\":56659,\"start\":56614},{\"end\":57100,\"start\":57075},{\"end\":57373,\"start\":57356},{\"end\":57737,\"start\":57693},{\"end\":58052,\"start\":58032},{\"end\":58357,\"start\":58338},{\"end\":58648,\"start\":58616},{\"end\":58884,\"start\":58867},{\"end\":59203,\"start\":59175},{\"end\":59507,\"start\":59485},{\"end\":59827,\"start\":59810},{\"end\":60211,\"start\":60130},{\"end\":60672,\"start\":60619},{\"end\":61099,\"start\":61082},{\"end\":61433,\"start\":61403},{\"end\":61752,\"start\":61689},{\"end\":62177,\"start\":62145},{\"end\":62531,\"start\":62456},{\"end\":62928,\"start\":62875},{\"end\":63167,\"start\":63146},{\"end\":63362,\"start\":63339},{\"end\":63729,\"start\":63654},{\"end\":64196,\"start\":64179},{\"end\":64544,\"start\":64532},{\"end\":64899,\"start\":64804},{\"end\":57397,\"start\":57375},{\"end\":58363,\"start\":58359},{\"end\":58915,\"start\":58886},{\"end\":59536,\"start\":59509},{\"end\":59861,\"start\":59829},{\"end\":60279,\"start\":60213},{\"end\":60742,\"start\":60674},{\"end\":61128,\"start\":61101},{\"end\":61828,\"start\":61754},{\"end\":62602,\"start\":62533},{\"end\":62977,\"start\":62930},{\"end\":63383,\"start\":63364},{\"end\":63819,\"start\":63731},{\"end\":64225,\"start\":64198},{\"end\":64552,\"start\":64546},{\"end\":64990,\"start\":64901}]"}}}, "year": 2023, "month": 12, "day": 17}