{"id": 5360764, "updated": "2023-09-27 20:17:37.417", "metadata": {"title": "Frustratingly Easy Domain Adaptation", "authors": "[{\"first\":\"Hal\",\"last\":\"Daum'e\",\"middle\":[]}]", "venue": "ACL 2007", "journal": null, "publication_date": {"year": 2009, "month": null, "day": null}, "abstract": "We describe an approach to domain adaptation that is appropriate exactly in the case when one has enough ``target'' data to do slightly better than just using only ``source'' data. Our approach is incredibly simple, easy to implement as a preprocessing step (10 lines of Perl!) and outperforms state-of-the-art approaches on a range of datasets. Moreover, it is trivially extended to a multi-domain adaptation problem, where one has data from a variety of different domains.", "fields_of_study": "[\"Computer Science\"]", "external_ids": {"arxiv": "0907.1815", "mag": "2952362487", "acl": "P07-1033", "pubmed": null, "pubmedcentral": null, "dblp": "conf/acl/Daume07", "doi": null}}, "content": {"source": {"pdf_hash": "4b7c8063892ca57131bd71b9c839d970ee8b0226", "pdf_src": "Arxiv", "pdf_uri": "[\"https://arxiv.org/pdf/0907.1815v1.pdf\"]", "oa_url_match": false, "oa_info": null}, "grobid": {"id": "dd6ba5ed0fe79043d1fc1f7ea5504b76c4a89239", "type": "plain-text", "url": "s3://ai2-s2-pdf-extraction-prod/parse-results/s2orc_worker/4b7c8063892ca57131bd71b9c839d970ee8b0226.txt", "contents": "\nFrustratingly Easy Domain Adaptation\n10 Jul 2009\n\nHal Daum\u00e9 \nSchool of Computing\nUniversity of Utah Salt Lake City\n84112Utah\n\nIii \nSchool of Computing\nUniversity of Utah Salt Lake City\n84112Utah\n\nFrustratingly Easy Domain Adaptation\n10 Jul 2009\nWe describe an approach to domain adaptation that is appropriate exactly in the case when one has enough \"target\" data to do slightly better than just using only \"source\" data. Our approach is incredibly simple, easy to implement as a preprocessing step (10 lines of Perl!) and outperforms stateof-the-art approaches on a range of datasets. Moreover, it is trivially extended to a multidomain adaptation problem, where one has data from a variety of different domains.\n\nIntroduction\n\nThe task of domain adaptation is to develop learning algorithms that can be easily ported from one domain to another-say, from newswire to biomedical documents. This problem is particularly interesting in NLP because we are often in the situation that we have a large collection of labeled data in one \"source\" domain (say, newswire) but truly desire a model that performs well in a second \"target\" domain. The approach we present in this paper is based on the idea of transforming the domain adaptation learning problem into a standard supervised learning problem to which any standard algorithm may be applied (eg., maxent, SVMs, etc.). Our transformation is incredibly simple: we augment the feature space of both the source and target data and use the result as input to a standard learning algorithm.\n\nThere are roughly two varieties of the domain adaptation problem that have been addressed in the literature: the fully supervised case and the semi-supervised case. The fully supervised case models the following scenario. We have access to a large, annotated corpus of data from a source domain. In addition, we spend a little money to annotate a small corpus in the target domain. We want to leverage both annotated datasets to obtain a model that performs well on the target domain. The semisupervised case is similar, but instead of having a small annotated target corpus, we have a large but unannotated target corpus. In this paper, we focus exclusively on the fully supervised case.\n\nOne particularly nice property of our approach is that it is incredibly easy to implement: the Appendix provides a 10 line, 194 character Perl script for performing the complete transformation (available at http://hal3.name/easyadapt.pl.gz). In addition to this simplicity, our algorithm performs as well as (or, in some cases, better than) current state of the art techniques.\n\n\nProblem Formalization and Prior Work\n\nTo facilitate discussion, we first introduce some notation. Denote by X the input space (typically either a real vector or a binary vector), and by Y the output space. We will write D s to denote the distribution over source examples and D t to denote the distribution over target examples. We assume access to a samples D s \u223c D s of source examples from the source domain, and samples D t \u223c D t of target examples from the target domain. We will assume that D s is a collection of N examples and D t is a collection of M examples (where, typically, N \u226b M ). Our goal is to learn a function h : X \u2192 Y with low expected loss with respect to the target domain.\n\nFor the purposes of discussion, we will suppose that X = R F and that Y = {\u22121, +1}. However, most of the techniques described in this section (as well as our own technique) are more general.\n\nThere are several \"obvious\" ways to attack the domain adaptation problem without developing new algorithms. Many of these are presented and evaluated by Daum\u00e9 III and Marcu (2006).\n\nThe SRCONLY baseline ignores the target data and trains a single model, only on the source data.\n\nThe TGTONLY baseline trains a single model only on the target data.\n\nThe ALL baseline simply trains a standard learning algorithm on the union of the two datasets.\n\nA potential problem with the ALL baseline is that if N \u226b M , then D s may \"wash out\" any affect D t might have. We will discuss this problem in more detail later, but one potential solution is to re-weight examples from D s . For instance, if N = 10 \u00d7 M , we may weight each example from the source domain by 0.1. The next baseline, WEIGHTED, is exactly this approach, with the weight chosen by cross-validation.\n\nThe PRED baseline is based on the idea of using the output of the source classifier as a feature in the target classifier. Specifically, we first train a SRCONLY model. Then we run the SRCONLY model on the target data (training, development and test). We use the predictions made by the SRCONLY model as additional features and train a second model on the target data, augmented with this new feature.\n\nIn the LININT baseline, we linearly interpolate the predictions of the SRCONLY and the TG-TONLY models. The interpolation parameter is adjusted based on target development data.\n\nThese baselines are actually surprisingly difficult to beat. To date, there are two models that have successfully defeated them on a handful of datasets. The first model, which we shall refer to as the PRIOR model, was first introduced by Chelba and Acero (2004). The idea of this model is to use the SRCONLY model as a prior on the weights for a second model, trained on the target data. Chelba and Acero (2004) describe this approach within the context of a maximum entropy classifier, but the idea is more general. In particular, for many learning algorithms (maxent, SVMs, averaged perceptron, naive Bayes, etc.), one regularizes the weight vector toward zero. In other words, all of these algorithms contain a regularization term on the weights w of the form \u03bb ||w|| 2 2 . In the generalized PRIOR model, we simply replace this regularization term with \u03bb ||w \u2212 w s || 2 2 , where w s is the weight vector learned in the SRCONLY model. 1 In this way, the model trained on the target data \"prefers\" to have weights that are similar to the weights from the SR-CONLY model, unless the data demands otherwise. Daum\u00e9 III and Marcu (2006) provide empirical evidence on four datasets that the PRIOR model outperforms the baseline approaches.\n\nMore recently, Daum\u00e9 III and Marcu (2006) presented an algorithm for domain adaptation for maximum entropy classifiers. The key idea of their approach is to learn three separate models. One model captures \"source specific\" information, one captures \"target specific\" information and one captures \"general\" information. The distinction between these three sorts of information is made on a per-example basis. In this way, each source example is considered either source specific or general, while each target example is considered either target specific or general. Daum\u00e9 III and Marcu (2006) present an EM algorithm for training their model. This model consistently outperformed all the baseline approaches as well as the PRIOR model. Unfortunately, despite the empirical success of this algorithm, it is quite complex to implement and is roughly 10 to 15 times slower than training the PRIOR model.\n\n\nAdaptation by Feature Augmentation\n\nIn this section, we describe our approach to the domain adaptation problem. Essentially, all we are going to do is take each feature in the original problem and make three versions of it: a general version, a source-specific version and a target-specific version. The augmented source data will contain only general and source-specific versions. The augmented target data contains general and target-specific versions.\n\nTo state this more formally, first recall the notation from Section 2: X and Y are the input and output spaces, respectively; D s is the source domain data set and D t is the target domain data set. Suppose for simplicity that X = R F for some F > 0. We will define our augmented input space byX = R 3F . Then, define mappings \u03a6 s , \u03a6 t : X \u2192X for mapping the source and target data respectively. These are defined by Eq (1)\n, where 0 = 0, 0, . . . , 0 \u2208 R F is the zero vector. \u03a6 s (x) = x, x, 0 , \u03a6 t (x) = x, 0, x(1)\nBefore we proceed with a formal analysis of this transformation, let us consider why it might be expected to work. Suppose our task is part of speech tagging, our source domain is the Wall Street Journal and our target domain is a collection of reviews of computer hardware. Here, a word like \"the\" should be tagged as a determiner in both cases. However, a word like \"monitor\" is more likely to be a verb in the WSJ and more likely to be a noun in the hardware corpus. Consider a simple case where X = R 2 , where x 1 indicates if the word is \"the\" and x 2 indicates if the word is \"monitor.\" Then, inX ,x 1 andx 2 will be \"general\" versions of the two indicator functions,x 3 andx 4 will be source-specific versions, and x 5 andx 6 will be target-specific versions.\n\nNow, consider what a learning algorithm could do to capture the fact that the appropriate tag for \"the\" remains constant across the domains, and the tag for \"monitor\" changes. In this case, the model can set the \"determiner\" weight vector to something like 1, 0, 0, 0, 0, 0 . This places high weight on the common version of \"the\" and indicates that \"the\" is most likely a determiner, regardless of the domain. On the other hand, the weight vector for \"noun\" might look something like 0, 0, 0, 0, 0, 1 , indicating that the word \"monitor\" is a noun only in the target domain. Similar, the weight vector for \"verb\" might look like 0, 0, 0, 1, 0, 0 , indicating the \"monitor\" is a verb only in the source domain.\n\nNote that this expansion is actually redundant. We could equally well use \u03a6 s (x) = x, x and \u03a6 t (x) = x, 0 . However, it turns out that it is easier to analyze the first case, so we will stick with that. Moreover, the first case has the nice property that it is straightforward to generalize it to the multidomain adaptation problem: when there are more than two domains. In general, for K domains, the augmented feature space will consist of K +1 copies of the original feature space.\n\n\nA Kernelized Version\n\nIt is straightforward to derive a kernelized version of the above approach. We do not exploit this property in our experiments-all are conducted with a simple linear kernel. However, by deriving the kernelized version, we gain some insight into the method. For this reason, we sketch the derivation here.\n\nSuppose that the data points x are drawn from a reproducing kernel Hilbert space X with kernel K : X \u00d7 X \u2192 R, with K positive semi-definite. Then, K can be written as the dot product (in X ) of two (perhaps infinite-dimensional) vectors:\nK(x, x \u2032 ) = \u03a6(x), \u03a6(x \u2032 ) X . Define \u03a6 s and \u03a6 t in terms of \u03a6, as: \u03a6 s (x) = \u03a6(x), \u03a6(x), 0 (2) \u03a6 t (x) = \u03a6(x), 0, \u03a6(x)\nNow, we can compute the kernel product between \u03a6 s and \u03a6 t in the expanded RKHS by making use of the original kernel K. We denote the expanded kernel byK(x, x \u2032 ). It is simplest to first de-scribeK(x, x \u2032 ) when x and x \u2032 are from the same domain, then analyze the case when the domain differs. When the domain is the same, we get:\nK(x, x \u2032 ) = \u03a6(x), \u03a6(x \u2032 ) X + \u03a6(x), \u03a6(x \u2032 ) X = 2K(x, x \u2032 ). When they are from different domains, we get:K(x, x \u2032 ) = \u03a6(x), \u03a6(x \u2032 ) X = K(x, x \u2032 ).\nPutting this together, we have:\nK(x, x \u2032 ) = 2K(x, x \u2032 ) same domain K(x, x \u2032 ) diff. domain(3)\nThis is an intuitively pleasing result. What it says is that-considering the kernel as a measure of similarity-data points from the same domain are \"by default\" twice as similar as those from different domains. Loosely speaking, this means that data points from the target domain have twice as much influence as source points when making predictions about test target data.\n\n\nAnalysis\n\nWe first note an obvious property of the featureaugmentation approach. Namely, it does not make learning harder, in a minimum Bayes error sense. A more interesting statement would be that it makes learning easier, along the lines of the result of (Ben-David et al., 2006) -note, however, that their results are for the \"semi-supervised\" domain adaptation problem and so do not apply directly. As yet, we do not know a proper formalism in which to analyze the fully supervised case.\n\nIt turns out that the feature-augmentation method is remarkably similar to the PRIOR model 2 . Suppose we learn feature-augmented weights in a classifier regularized by an \u2113 2 norm (eg., SVMs, maximum entropy). We can denote by w s the sum of the \"source\" and \"general\" components of the learned weight vector, and by w t the sum of the \"target\" and \"general\" components, so that w s and w t are the predictive weights for each task. Then, the regularization condition on the entire weight vector is approximately ||w g || 2 + ||w s \u2212 w g || 2 + ||w t \u2212 w g || 2 , with free parameter w g which can be chosen to minimize this sum. This leads to a regularizer proportional to ||w s \u2212 w t || 2 , akin to the PRIOR model.\n\nGiven this similarity between the featureaugmentation method and the PRIOR model, one might wonder why we expect our approach to do better. Our belief is that this occurs because we optimize w s and w t jointly, not sequentially. First, this means that we do not need to cross-validate to estimate good hyperparameters for each task (though in our experiments, we do not use any hyperparameters). Second, and more importantly, this means that the single supervised learning algorithm that is run is allowed to regulate the trade-off between source/target and general weights. In the PRIOR model, we are forced to use the prior variance on in the target learning scenario to do this ourselves.\n\n\nMulti-domain adaptation\n\nOur formulation is agnostic to the number of \"source\" domains. In particular, it may be the case that the source data actually falls into a variety of more specific domains. This is simple to account for in our model. In the two-domain case, we ex-2 Thanks an anonymous reviewer for pointing this out! panded the feature space from R F to R 3F . For a K-domain problem, we simply expand the feature space to R (K+1)F in the obvious way (the \"+1\" corresponds to the \"general domain\" while each of the other 1 . . . K correspond to a single task).\n\n\nResults\n\nIn this section we describe experimental results on a wide variety of domains. First we describe the tasks, then we present experimental results, and finally we look more closely at a few of the experiments.\n\n\nTasks\n\nAll tasks we consider are sequence labeling tasks (either named-entity recognition, shallow parsing or part-of-speech tagging) on the following datasets: CNN-Recap. This is a recapitalization task introduced by Chelba and Acero (2004) and also used by Daum\u00e9 III and Marcu (2006). The source domain is newswire and the target domain is the output of an ASR system.\n\nTreebank-Chunk. This is a shallow parsing task based on the data from the Penn Treebank. This data comes from a variety of domains: the standard WSJ domain (we use the same data as for CoNLL 2000), the ATIS switchboard domain, and the Brown corpus (which is, itself, assembled from six subdomains).  Treebank-Brown. This is identical to the Treebank-Chunk task, except that we consider all of the Brown corpus to be a single domain.\n\nIn all cases (except for CNN-Recap), we use roughly the same feature set, which has become somewhat standardized: lexical information (words, stems, capitalization, prefixes and suffixes), membership on gazetteers, etc. For the CNN-Recap task, we use identical feature to those used by both Chelba and Acero (2004) and Daum\u00e9 III and Marcu (2006): the current, previous and next word, and 1-3 letter prefixes and suffixes.\n\nStatistics on the tasks and datasets are in Table 1.\n\nIn all cases, we use the SEARN algorithm for solving the sequence labeling problem (Daum\u00e9 III et al., 2007) with an underlying averaged perceptron classifier; implementation due to (Daum\u00e9 III, 2004). For structural features, we make a second-order Markov assumption and only place a bias feature on the transitions. For simplicity, we optimize and report only on label accuracy (but require that our outputs be parsimonious: we do not allow \"I-NP\" to follow \"B-PP,\" for instance). We do this for three reasons. First, our focus in this work is on building better learning algorithms and introducing a more complicated measure only serves to mask these effects. Second, it is arguable that a measure like F 1 is inappropriate for chunking tasks (Manning, 2006). Third, we can easily compute statistical significance over accuracies using McNemar's test.\n\n\nExperimental Results\n\nThe full-somewhat daunting-table of results is presented in Table 2. The first two columns specify the task and domain. For the tasks with only a single source and target, we simply report results on the target. For the multi-domain adaptation tasks, we report results for each setting of the target (where all other data-sets are used as different \"source\" domains). The next set of eight columns are the error rates for the task, using one of the different techniques (\"AUGMENT\" is our proposed technique). For each row, the error rate of the best performing technique is bolded (as are all techniques whose performance is not statistically significantly different at the 95% level). The \"T<S\" column is contains a \"+\" whenever TGTONLY outperforms SRCONLY (this will become important shortly). The final column indicates when AUGMENT comes in first. 3 There are several trends to note in the results. Excluding for a moment the \"br-*\" domains on the Treebank-Chunk task, our technique always performs best. Still excluding \"br-*\", the clear secondplace contestant is the PRIOR model, a finding consistent with prior research. When we repeat the Treebank-Chunk task, but lumping all of the \"br-*\" data together into a single \"brown\" domain, the story reverts to what we expected before: our algorithm performs best, followed by the PRIOR method.\n\nImportantly, this simple story breaks down on the Treebank-Chunk task for the eight sections of the Brown corpus. For these, our AUGMENT technique performs rather poorly. Moreover, there is no clear winning approach on this task. Our hypothesis is that the common feature of these examples is that these are exactly the tasks for which SRCONLY outperforms TGTONLY (with one exception: CoNLL). This seems like a plausible explanation, since it im-  plies that the source and target domains may not be that different. If the domains are so similar that a large amount of source data outperforms a small amount of target data, then it is unlikely that blowing up the feature space will help.\n\nWe additionally ran the MEGAM model (Daum\u00e9 III and Marcu, 2006) on these data (though not in the multi-conditional case; for this, we considered the single source as the union of all sources). The results are not displayed in Table 2 to save space. For the majority of results, MEGAM performed roughly comparably to the best of the systems in the table. In particular, it was not statistically significantly different that AUGMENT on: ACE-NER, CoNLL, PubMed, Treebank-chunk-wsj, Treebank-chunk-swbd3, CNN and Treebank-brown. It did outperform AUGMENT on the Treebank-chunk on the Treebank-chunk-br-* data sets, but only outperformed the best other model on these data sets for br-cg, br-cm and br-cp. However, despite its advantages on these data sets, it was quite significantly slower to train: a single run required about ten times longer than any of the other models (including AUGMENT), and also required five-to-ten iterations of cross-validation to tune its hyperparameters so as to achieve these results. \n\n\nModel Introspection\n\nOne explanation of our model's improved performance is simply that by augmenting the feature space, we are creating a more powerful model. While this may be a partial explanation, here we show that what the model learns about the various domains actually makes some plausible sense.\n\nWe perform this analysis only on the ACE-NER data by looking specifically at the learned weights. That is, for any given feature f , there will be seven versions of f : one corresponding to the \"crossdomain\" f and seven corresponding to each domain. We visualize these weights, using Hinton diagrams, to see how the weights vary across domains.\n\nFor example, consider the feature \"current word has an initial capital letter and is then followed by one or more lower-case letters.\" This feature is presumably useless for data that lacks capitalization information, but potentially quite useful for other domains. In Figure 1 we shown a Hinton diagram for this figure. Each column in this figure correspond to a domain (the top row is the \"general domain\").\n\nEach row corresponds to a class. 4 Black boxes correspond to negative weights and white boxes correspond to positive weights. The size of the box depicts the absolute value of the weight. As we can see from Figure 1, the /Aa+/ feature is a very good indicator of entity-hood (it's value is strongly positive for all four entity classes), regardless of domain (i.e., for the \"*\" domain). The lack of boxes in the \"bn\" column means that, beyond the settings in \"*\", the broadcast news is agnostic with respect to this feature. This makes sense: there is no capitalization in broadcast news domain, so there would be no sense is setting these weights to anything by zero. The usenet column is filled with negative weights. While this may seem strange, it is due to the fact that many email addresses and URLs match this pattern, but are not entities. Figure 2 depicts a similar figure for the feature \"word is 'bush' at the current position\" (this figure is case sensitive). 5 These weights are somewhat harder to interpret. What is happening is that \"by default\" the word \"bush\" is going to be a person-this is because it rarely appears referring to a plant and so even in the capitalized domains like broadcast con-4 Technically there are many more classes than are shown here. We do not depict the smallest classes, and have merged the \"Begin-*\" and \"In-*\" weights for each entity type. 5 The scale of weights across features is not comparable, so do not try to compare Figure 1  versations, if it appears at all, it is a person. The exception is that in the conversations data, people do actually talk about bushes as plants, and so the weights are set accordingly. The weights are high in the usenet domain because people tend to talk about the president without capitalizing his name. Figure 3 presents the Hinton diagram for the feature \"word at the current position is 'the\"' (again, case-sensitive). In general, it appears, \"the\" is a common word in entities in all domain except for broadcast news and conversations. The exceptions are broadcast news and conversations. These exceptions crop up because of the capitalization issue.\n\nIn Figure 4, we show the diagram for the feature \"previous word is 'the'.\" The only domain for which this is a good feature of entity-hood is broadcast conversations (to a much lesser extent, newswire). This occurs because of four phrases very common in the broadcast conversations and rare elsewhere: \"the Iraqi people\" (\"Iraqi\" is a GPE), \"the Pentagon\" (an ORG), \"the Bush (cabinet|advisors|. . . )\" (PER), and \"the South\" (LOC). Finally, Figure 5 shows the Hinton diagram for the feature \"the current word is on a list of common names\" (this feature is case-insensitive). All around, this is a good feature for picking out people and nothing else. The two exceptions are: it is also a good feature for other entity types for broadcast news and it is not quite so good for people in usenet. The first is easily explained: in broadcast news, it is very common to refer to countries and organizations by the name of their respective leaders. This is essentially a metonymy issue, but as the data is annotated, these are marked by their true referent. For usenet, it is because the list of names comes from news data, but usenet names are more diverse.\n\nIn general, the weights depicte for these features make some intuitive sense (in as much as weights for any learned algorithm make intuitive sense). It is particularly interesting to note that while there are some regularities to the patterns in the five diagrams, it is definitely not the case that there are, eg., two domains that behave identically across all features. This supports the hypothesis that the reason our algorithm works so well on this data is because the domains are actually quite well separated.\n\n\nDiscussion\n\nIn this paper we have described an incredibly simple approach to domain adaptation that-under a common and easy-to-verify condition-outperforms previous approaches. While it is somewhat frustrating that something so simple does so well, it is perhaps not surprising. By augmenting the feature space, we are essentially forcing the learning algorithm to do the adaptation for us. Good supervised learning algorithms have been developed over decades, and so we are essentially just leveraging all that previous work. Our hope is that this approach is so simple that it can be used for many more realworld tasks than we have presented here with little effort. Finally, it is very interesting to note that using our method, shallow parsing error rate on the CoNLL section of the treebank improves from 5.35 to 5.11. While this improvement is small, it is real, and may carry over to full parsing. The most important avenue of future work is to develop a formal framework under which we can analyze this (and other supervised domain adaptation models) theoretically. Currently our results only state that this augmentation procedure doesn't make the learning harder -we would like to know that it actually makes it easier. An additional future direction is to explore the kernelization interpretation further: why should we use 2 as the \"similarity\" between domains-we could introduce a hyperparamter \u03b1 that indicates the similarity between domains and could be tuned via cross-validation.\n\nFigure 1 :\n1Hinton diagram for feature /Aa+/ at current position.\n\nFigure 2 :\n2Hinton diagram for feature /bush/ at current position.\n\nFigure 4 :\n4Hinton diagram for feature /the/ at previous position.\n\nFigure 5 :\n5Hinton diagram for membership on a list of names at current position.\n\nTable 1 :\n1Task statistics; columns are task, domain, size of the training, development and test sets, and the number of unique features in the training set.\n\nTable 2 :\n2Task results.\nFor the maximum entropy, SVM and naive Bayes learning algorithms, modifying the regularization term is simple because it appears explicitly. For the perceptron algorithm, one can obtain an equivalent regularization by performing standard perceptron updates, but using (w + w s ) \u22a4 x for making predictions rather than simply w \u22a4 x.\nOne advantage of using the averaged perceptron for all experiments is that the only tunable hyperparameter is the number of iterations. In all cases, we run 20 iterations and choose the one with the lowest error on development data.\nAcknowledgments.We thank the three anonymous reviewers, as well as Ryan McDonald and John Blitzer for very helpful comments and insights.\nAnalysis of representations for domain adaptation. Ben-David, Advances in Neural Information Processing Systems (NIPS). Ben-David et al.2006] Shai Ben-David, John Blitzer, Koby Crammer, and Fernando Pereira. 2006. Analysis of rep- resentations for domain adaptation. In Advances in Neural Information Processing Systems (NIPS).\n\nDomain adaptation with structural correspondence learning. [ Blitzer, Proceedings of the Conference on Empirical Methods in Natural Language Processing. the Conference on Empirical Methods in Natural Language ProcessingEMNLP[Blitzer et al.2006] John Blitzer, Ryan McDonald, and Fernando Pereira. 2006. Domain adaptation with structural correspon- dence learning. In Proceedings of the Conference on Empir- ical Methods in Natural Language Processing (EMNLP).\n\nAdaptation of maximum entropy classifier: Little data can help a lot. Alex Acero2004] Ciprian Chelba, Acero, Proceedings of the Conference on Empirical Methods in Natural Language Processing (EMNLP). the Conference on Empirical Methods in Natural Language Processing (EMNLP)Barcelona, Spain[Chelba and Acero2004] Ciprian Chelba and Alex Acero. 2004. Adaptation of maximum entropy classifier: Little data can help a lot. In Proceedings of the Conference on Empir- ical Methods in Natural Language Processing (EMNLP), Barcelona, Spain.\n\nDomain adaptation for statistical classifiers. Daum\u00e9, Iii Daum\u00e9, Daniel Marcu, Journal of Artificial Intelligence Research. 26Daum\u00e9 III and Marcu2006] Hal Daum\u00e9 III and Daniel Marcu. 2006. Domain adaptation for statistical classifiers. Journal of Artificial Intelligence Research, 26.\n\nSearch-based structured prediction. Iii Daum\u00e9, Machine Learning Journal. submitted[Daum\u00e9 III et al.2007] Hal Daum\u00e9 III, John Langford, and Daniel Marcu. 2007. Search-based structured prediction. Machine Learning Journal (submitted).\n\nNotes on CG and LM-BFGS optimization of logistic regression. Daum\u00e9, Iii Daum\u00e9, Paper available at http://pub.hal3.name/#daume04cg-bfgs[Daum\u00e9 III2004] Hal Daum\u00e9 III. 2004. Notes on CG and LM- BFGS optimization of logistic regression. Paper available at http://pub.hal3.name/#daume04cg-bfgs, implementation available at http://hal3.name/megam/, August.\n\nDoing named entity recognition? Don't optimize for F1. Post on the NLPers Blog. Christopher Manning, Christopher Manning. 2006. Do- ing named entity recognition? Don't optimize for F1. Post on the NLPers Blog, 25 August.\n", "annotations": {"author": "[{\"end\":126,\"start\":51},{\"end\":196,\"start\":127}]", "publisher": null, "author_last_name": "[{\"end\":60,\"start\":55}]", "author_first_name": "[{\"end\":54,\"start\":51},{\"end\":130,\"start\":127}]", "author_affiliation": "[{\"end\":125,\"start\":62},{\"end\":195,\"start\":132}]", "title": "[{\"end\":37,\"start\":1},{\"end\":233,\"start\":197}]", "venue": null, "abstract": "[{\"end\":714,\"start\":246}]", "bib_ref": "[{\"end\":1367,\"start\":1342},{\"attributes\":{\"ref_id\":\"b3\"},\"end\":3676,\"start\":3650},{\"end\":5200,\"start\":5194},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":5350,\"start\":5327},{\"attributes\":{\"ref_id\":\"b3\"},\"end\":6074,\"start\":6048},{\"attributes\":{\"ref_id\":\"b3\"},\"end\":6219,\"start\":6193},{\"attributes\":{\"ref_id\":\"b3\"},\"end\":6769,\"start\":6743},{\"attributes\":{\"ref_id\":\"b3\"},\"end\":14653,\"start\":14627},{\"attributes\":{\"ref_id\":\"b3\"},\"end\":15519,\"start\":15493},{\"attributes\":{\"ref_id\":\"b4\"},\"end\":15758,\"start\":15734},{\"attributes\":{\"ref_id\":\"b5\"},\"end\":15849,\"start\":15832},{\"attributes\":{\"ref_id\":\"b6\"},\"end\":16410,\"start\":16395},{\"end\":17381,\"start\":17380},{\"attributes\":{\"ref_id\":\"b3\"},\"end\":18629,\"start\":18602},{\"end\":22032,\"start\":22031}]", "figure": "[{\"attributes\":{\"id\":\"fig_0\"},\"end\":26020,\"start\":25954},{\"attributes\":{\"id\":\"fig_1\"},\"end\":26088,\"start\":26021},{\"attributes\":{\"id\":\"fig_2\"},\"end\":26156,\"start\":26089},{\"attributes\":{\"id\":\"fig_3\"},\"end\":26239,\"start\":26157},{\"attributes\":{\"id\":\"tab_2\",\"type\":\"table\"},\"end\":26398,\"start\":26240},{\"attributes\":{\"id\":\"tab_4\",\"type\":\"table\"},\"end\":26424,\"start\":26399}]", "paragraph": "[{\"end\":1535,\"start\":730},{\"end\":2225,\"start\":1537},{\"end\":2604,\"start\":2227},{\"end\":3303,\"start\":2645},{\"end\":3495,\"start\":3305},{\"end\":3677,\"start\":3497},{\"end\":3775,\"start\":3679},{\"end\":3844,\"start\":3777},{\"end\":3940,\"start\":3846},{\"end\":4354,\"start\":3942},{\"end\":4757,\"start\":4356},{\"end\":4936,\"start\":4759},{\"end\":6176,\"start\":4938},{\"end\":7077,\"start\":6178},{\"end\":7534,\"start\":7116},{\"end\":7960,\"start\":7536},{\"end\":8823,\"start\":8056},{\"end\":9535,\"start\":8825},{\"end\":10023,\"start\":9537},{\"end\":10352,\"start\":10048},{\"end\":10591,\"start\":10354},{\"end\":11045,\"start\":10713},{\"end\":11227,\"start\":11196},{\"end\":11665,\"start\":11292},{\"end\":12159,\"start\":11678},{\"end\":12879,\"start\":12161},{\"end\":13573,\"start\":12881},{\"end\":14146,\"start\":13601},{\"end\":14365,\"start\":14158},{\"end\":14738,\"start\":14375},{\"end\":15172,\"start\":14740},{\"end\":15595,\"start\":15174},{\"end\":15649,\"start\":15597},{\"end\":16503,\"start\":15651},{\"end\":17874,\"start\":16528},{\"end\":18564,\"start\":17876},{\"end\":19579,\"start\":18566},{\"end\":19885,\"start\":19603},{\"end\":20231,\"start\":19887},{\"end\":20642,\"start\":20233},{\"end\":22782,\"start\":20644},{\"end\":23936,\"start\":22784},{\"end\":24454,\"start\":23938},{\"end\":25953,\"start\":24469}]", "formula": "[{\"attributes\":{\"id\":\"formula_0\"},\"end\":8055,\"start\":7961},{\"attributes\":{\"id\":\"formula_1\"},\"end\":10712,\"start\":10592},{\"attributes\":{\"id\":\"formula_2\"},\"end\":11195,\"start\":11046},{\"attributes\":{\"id\":\"formula_3\"},\"end\":11291,\"start\":11228}]", "table_ref": "[{\"attributes\":{\"ref_id\":\"tab_2\"},\"end\":15648,\"start\":15641},{\"attributes\":{\"ref_id\":\"tab_4\"},\"end\":16595,\"start\":16588},{\"attributes\":{\"ref_id\":\"tab_4\"},\"end\":18799,\"start\":18792}]", "section_header": "[{\"attributes\":{\"n\":\"1\"},\"end\":728,\"start\":716},{\"attributes\":{\"n\":\"2\"},\"end\":2643,\"start\":2607},{\"attributes\":{\"n\":\"3\"},\"end\":7114,\"start\":7080},{\"attributes\":{\"n\":\"3.1\"},\"end\":10046,\"start\":10026},{\"attributes\":{\"n\":\"3.2\"},\"end\":11676,\"start\":11668},{\"attributes\":{\"n\":\"3.3\"},\"end\":13599,\"start\":13576},{\"attributes\":{\"n\":\"4\"},\"end\":14156,\"start\":14149},{\"attributes\":{\"n\":\"4.1\"},\"end\":14373,\"start\":14368},{\"attributes\":{\"n\":\"4.2\"},\"end\":16526,\"start\":16506},{\"attributes\":{\"n\":\"4.3\"},\"end\":19601,\"start\":19582},{\"attributes\":{\"n\":\"5\"},\"end\":24467,\"start\":24457},{\"end\":25965,\"start\":25955},{\"end\":26032,\"start\":26022},{\"end\":26100,\"start\":26090},{\"end\":26168,\"start\":26158},{\"end\":26250,\"start\":26241},{\"end\":26409,\"start\":26400}]", "table": null, "figure_caption": "[{\"end\":26020,\"start\":25967},{\"end\":26088,\"start\":26034},{\"end\":26156,\"start\":26102},{\"end\":26239,\"start\":26170},{\"end\":26398,\"start\":26252},{\"end\":26424,\"start\":26411}]", "figure_ref": "[{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":20510,\"start\":20502},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":20859,\"start\":20851},{\"attributes\":{\"ref_id\":\"fig_1\"},\"end\":21500,\"start\":21492},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":22122,\"start\":22114},{\"end\":22440,\"start\":22432},{\"attributes\":{\"ref_id\":\"fig_2\"},\"end\":22795,\"start\":22787},{\"attributes\":{\"ref_id\":\"fig_3\"},\"end\":23234,\"start\":23226}]", "bib_author_first_name": "[{\"end\":27517,\"start\":27516},{\"end\":27991,\"start\":27987},{\"end\":28509,\"start\":28506},{\"end\":28523,\"start\":28517},{\"end\":28777,\"start\":28774},{\"end\":29043,\"start\":29040},{\"end\":29415,\"start\":29404}]", "bib_author_last_name": "[{\"end\":27188,\"start\":27179},{\"end\":27525,\"start\":27518},{\"end\":28017,\"start\":27992},{\"end\":28024,\"start\":28019},{\"end\":28504,\"start\":28499},{\"end\":28515,\"start\":28510},{\"end\":28529,\"start\":28524},{\"end\":28783,\"start\":28778},{\"end\":29038,\"start\":29033},{\"end\":29049,\"start\":29044},{\"end\":29423,\"start\":29416}]", "bib_entry": "[{\"attributes\":{\"id\":\"b0\",\"matched_paper_id\":10908021},\"end\":27455,\"start\":27128},{\"attributes\":{\"id\":\"b1\",\"matched_paper_id\":15978939},\"end\":27915,\"start\":27457},{\"attributes\":{\"id\":\"b2\"},\"end\":28450,\"start\":27917},{\"attributes\":{\"id\":\"b3\",\"matched_paper_id\":14154185},\"end\":28736,\"start\":28452},{\"attributes\":{\"id\":\"b4\",\"matched_paper_id\":704519},\"end\":28970,\"start\":28738},{\"attributes\":{\"id\":\"b5\"},\"end\":29322,\"start\":28972},{\"attributes\":{\"id\":\"b6\"},\"end\":29544,\"start\":29324}]", "bib_title": "[{\"end\":27177,\"start\":27128},{\"end\":27514,\"start\":27457},{\"end\":27985,\"start\":27917},{\"end\":28497,\"start\":28452},{\"end\":28772,\"start\":28738}]", "bib_author": "[{\"end\":27190,\"start\":27179},{\"end\":27527,\"start\":27516},{\"end\":28019,\"start\":27987},{\"end\":28026,\"start\":28019},{\"end\":28506,\"start\":28499},{\"end\":28517,\"start\":28506},{\"end\":28531,\"start\":28517},{\"end\":28785,\"start\":28774},{\"end\":29040,\"start\":29033},{\"end\":29051,\"start\":29040},{\"end\":29425,\"start\":29404}]", "bib_venue": "[{\"end\":27676,\"start\":27610},{\"end\":28207,\"start\":28117},{\"end\":27246,\"start\":27190},{\"end\":27608,\"start\":27527},{\"end\":28115,\"start\":28026},{\"end\":28574,\"start\":28531},{\"end\":28809,\"start\":28785},{\"end\":29031,\"start\":28972},{\"end\":29402,\"start\":29324}]"}}}, "year": 2023, "month": 12, "day": 17}