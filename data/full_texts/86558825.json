{"id": 86558825, "updated": "2022-02-23 22:21:45.549", "metadata": {"title": "Automatically Assessing Code Understandability", "authors": "[{\"first\":\"Simone\",\"last\":\"Scalabrino\",\"middle\":[]},{\"first\":\"Gabriele\",\"last\":\"Bavota\",\"middle\":[]},{\"first\":\"Christopher\",\"last\":\"Vendome\",\"middle\":[]},{\"first\":\"Mario\",\"last\":\"Linares-V\u00e1squez\",\"middle\":[]},{\"first\":\"Denys\",\"last\":\"Poshyvanyk\",\"middle\":[]},{\"first\":\"Rocco\",\"last\":\"Oliveto\",\"middle\":[]}]", "venue": "IEEE Transactions on Software Engineering", "journal": "IEEE Transactions on Software Engineering", "publication_date": {"year": 2021, "month": null, "day": null}, "abstract": "Understanding software is an inherent requirement for many maintenance and evolution tasks. Without a thorough understanding of the code, developers would not be able to fix bugs or add new features timely. Measuring code understandability might be useful to guide developers in writing better code, and could also help in estimating the effort required to modify code components. Unfortunately, there are no metrics designed to assess the understandability of code snippets. In this work, we perform an extensive evaluation of 121 existing as well as new code-related, documentation-related, and developer-related metrics. We try to (i) correlate each metric with understandability and (ii) build models combining metrics to assess understandability. To do this, we use 444 human evaluations from 63 developers and we obtained a bold negative result: none of the 121 experimented metrics is able to capture code understandability, not even the ones assumed to assess quality attributes apparently related, such as code readability and complexity. While we observed some improvements while combining metrics in models, their effectiveness is still far from making them suitable for practical applications. Finally, we conducted interviews with five professional developers to understand the factors that influence their ability to understand code snippets, aiming at identifying possible new metrics.", "fields_of_study": "[\"Computer Science\"]", "external_ids": {"arxiv": null, "mag": "2915605461", "acl": null, "pubmed": null, "pubmedcentral": null, "dblp": "journals/tse/ScalabrinoBVLPO21", "doi": "10.1109/tse.2019.2901468"}}, "content": {"source": {"pdf_hash": "c2895c2682ff708b214fb41bccf3a4c172af8637", "pdf_src": "IEEE", "pdf_uri": null, "oa_url_match": false, "oa_info": null}, "grobid": {"id": "1c0750fc6f933b4e36d016086ec930140f0600b7", "type": "plain-text", "url": "s3://ai2-s2-pdf-extraction-prod/parse-results/s2orc_worker/c2895c2682ff708b214fb41bccf3a4c172af8637.txt", "contents": "\nAutomatically Assessing Code Understandability\n\n\nMember, IEEESimone Scalabrino \nMember, IEEEGabriele Bavota \nMember, IEEEChristopher Vendome \nMember, IEEEMario Linares-V Asquez \nMember, IEEEDenys Poshyvanyk \nMember, IEEERocco Oliveto \nAutomatically Assessing Code Understandability\n10.1109/TSE.2019.2901468Index Terms-Software metricscode understandabilityempirical studynegative result\nUnderstanding software is an inherent requirement for many maintenance and evolution tasks. Without a thorough understanding of the code, developers would not be able to fix bugs or add new features timely. Measuring code understandability might be useful to guide developers in writing better code, and could also help in estimating the effort required to modify code components. Unfortunately, there are no metrics designed to assess the understandability of code snippets. In this work, we perform an extensive evaluation of 121 existing as well as new code-related, documentation-related, and developer-related metrics. We try to (i) correlate each metric with understandability and (ii) build models combining metrics to assess understandability. To do this, we use 444 human evaluations from 63 developers and we obtained a bold negative result: none of the 121 experimented metrics is able to capture code understandability, not even the ones assumed to assess quality attributes apparently related, such as code readability and complexity. While we observed some improvements while combining metrics in models, their effectiveness is still far from making them suitable for practical applications. Finally, we conducted interviews with five professional developers to understand the factors that influence their ability to understand code snippets, aiming at identifying possible new metrics.\n\nINTRODUCTION\n\nD EVELOPERS spend most of their time ($ 70 percent) understanding code [1]. While such a finding might look surprising, it only highlights the pivotal role that code understanding plays in any code-related activity, such as feature implementation or bug fixing. While the importance of code understandability is undisputed for maintenancerelated activities [2], [3], [4], [5], [6], [7], there is no empirical foundation suggesting how to objectively assess the understandability of a given piece of code. Indeed, our knowledge of factors affecting (positively or negatively) code understandability is basically tied to common beliefs or is focused on the cognitive process adopted when understanding code [8], [9]. For example, we commonly assume that code complexity can be used to assess the effort required to understand a given piece of code. However, there is no empirical evidence that this is actually the case. Similarly, researchers have designed models and proposed metrics to evaluate the readability of code by correlating them with the readability perceived by developers [10], [11], [12], [13], [14], [15]. This typically means that the developers participating in the evaluation are required to read a fragment of code and rate its readability on a given scale (e.g., from 1: low to 5: high readability). However, the perceived readability is something different from the actual understandability of the code; a developer could find a piece of code readable while still experiencing difficulties in understanding it, for example due to unknown APIs used. Let us consider the code fragment listed below:\n\nAsyncHttpClient client=new AsyncHttpClient(); String cookies=CookieManager.getInstance(). getCookie(url); Log.e(TAG, cookies); client.addHeader(SM.COOKIE, cookies);\n\nA developer, as well as all readability metrics proposed in the literature [10], [11], [12], [13], [14], [15], would consider this snippet of code as readable, since it is concise and utilizes meaningful identifier names. Nevertheless, this snippet of code is not necessarily easy to understand for any given developer, because the used APIs could be unknown to her and even poorly documented. For example, the developer may not understand the implications of the getCookie\u00f0url\u00de method call without prior experience using the API or without reading related documentation, e.g., she might not know whether getCookie\u00f0url\u00de could throw an exception, return a null value, or produce some side effects.\n\nHaving a metric to estimate the effort required to understand a given piece of code would have a strong impact on several software engineering tasks. For example, it would be possible to use such a metric to (i) improve the estimation of the time needed to fix a bug (the lower the understandability, the higher the time to comprehend the code and thus to fix the bug); (ii) create search-based refactoring recommender systems using code understandability as a fitness function; or (iii) assess the quality of code changes during code reviews.\n\nWhile we have possible proxies for code understandability, such as code complexity and readability, we do not (i) know whether these proxies actually correlate with the effort required to understand a piece of code, and (ii) have a metric able to provide an estimation for code understandability. Previous attempts to define a code understandability model [4], [6], [16] have not been empirically evaluated, considered understandability as a factor in a quality model [2], [17], or measured understandability at the level of a whole software system [18].\n\nIn this work, we investigate 121 metrics to determine the extent to which they correlate with code understandability. These metrics can be categorized into three types: (i) coderelated metrics (105 metrics), (ii) documentation-related metrics (11), and (iii) developer-related metrics (5). The code-related metrics are comprised of classic code metrics, like LOC and cyclomatic complexity, and readability metrics, like text coherence [14], [15] and code indentation [10]. As the aforementioned example illustrates, a developer may be able to read some code snippet, but it may use unknown code. Thus, we included existing documentationrelated metrics, like the availability of external documentation, and introduced nine new documentation-related metrics. Finally, we included developer-related metrics to understand the extent to which the developer's experience and background might influence code comprehension.\n\nTo carry out our investigation, we performed a study with 63 participants using the 121 metrics to determine their correlation with the understandability of code snippets. Each participant was required to understand up to eight code snippets, leading to a total of 444 evaluations. We consider understandability from two perspectives: perceived and actual understandability of the code snippets. The participants were presented a code snippet to understand and they were asked whether they could understand it (perceived understandability). If their answer was positive, they were asked to answer three verification questions (actual understandability). We also monitored the time spent understanding each snippet to estimate the effort.\n\nBy performing an extensive statistical analysis, we obtained a negative empirical result: none of the considered metrics exhibit a significant correlation with either the perceived or the actual understandability. This result was quite surprising to us, especially considering the involvement in our study of complexity and readability metrics generally thought to influence code understandability. Then, we exploited classification and regression models utilizing combinations of metrics to predict proxies of code understandability. While these models represent a step ahead as compared to the single metrics taken in isolation, their prediction accuracy is still too low to make them useful in practice. Finally, we interviewed five developers to better understand their perspective when it comes to understanding a code snippet and to infer factors that could be exploited in future metrics to automatically assess code understandability.\n\nThe main contributions of this work, as compared to our ASE'17 paper [19] that it extends, are the following:\n\nWe increased the size of our dataset from 324 evaluations by 46 developers to 444 evaluations by 63 developers to increase the confidence in our findings; We used combinations of feature models to predict the independent variables that we define as proxies of understandability; We conducted structured interviews with five experienced developers to understand what makes code understandable/not understandable to them; we used such information to propose possible future directions for code understandability assessment. Paper Structure. Section 2 provides background information about code characteristics possibly related to its understandability. Section 3 describes the 121 metrics used in our empirical study, while Section 4 presents the proxies we used to assess the developers' understandability of a given code snippet. The design and results of the study are presented in Sections 5 and 6, respectively. Section 7 discusses the threats that could affect our findings, while Section 8 concludes the paper and highlights future research directions.\n\n\nBACKGROUND & RELATED WORK\n\nIn this section, we describe metrics and models that have been proposed to measure code readability. All these metrics have been included in our study. Afterwards, we briefly describe related work presenting metrics for measuring understandability (at system level) as a single quality attribute and as part of a quality model.\n\n\nCode Readability\n\nIdentifiers and comments play a crucial role in program comprehension, since developers express domain knowledge through the names that they assign to the code entities at different levels (i.e., packages, classes, methods, variables) [20], [21], [22], [23], [24]. Thus, source code lexicon impacts the psychological complexity of a program [14], [25]. Another aspect that also contributes to the readability (and potentially understandability) of source code are structural aspects such as indentation, code entity length [10], [11], and visual/spatial aspects such as syntax highlighting, code formatting, and visual areas covered by code entities [12].\n\nAll the aforementioned aspects have been used as features in binary classifiers able to predict the readability of code snippets [10], [11], [12], [14], [15]. In the model by Buse and Weimer [10], source code structural aspects (e.g., number of branches, loops, operators, blank lines, comments) represent the underlying features in the classifier. The model was trained a-priori on 100 small snippets; the snippets were tagged manually as readable or non-readable by 120 human annotators. The reported results provide evidence that readability can be estimated automatically.\n\nPosnett et al. [11] proposed a model based on a reduced set of the features introduced by Buse and Weimer. An empirical evaluation conducted on the same dataset used by Buse and Weimer [10] indicated that the model by Posnett et al. is more accurate than the one by Buse and Weimer.\n\nDorn introduced a readability model which relies on a larger set of features grouped in four categories: visual, spatial, alignment, and linguistic [12]. Some of the new features are computed by aggregating some structural features in different ways: for example, some of them rely on Discrete Fourier Transform (DFT) to capture the regularity/irregularity of variations of the structural metrics over different lines/columns. This larger set of features highlights the fact that structural aspects are not the only ones that should be considered for code readability; aspects representing and modeling how the code is read on the screen, such as syntax highlighting, variable naming standards, and operators alignment, should be also considered. Dorn trained and validated the model on a new dataset, including programs in Java, Python, and CUDA, for a total of 360 snippets. Such a model achieved a higher accuracy as compared to the one by Buse and Weimer.\n\nScalabrino et al. [14], [15] proposed and evaluated a set of features based entirely on source code lexicon analysis (e.g., consistency between source code and comments, specificity of the identifiers, textual coherence, comments readability). The model was evaluated on the two datasets previously introduced by Buse and Weimer [10] and Dorn [12] and on a new dataset, composed of 200 Java snippets, manually evaluated by nine developers. The results indicated that combining the features (i.e., structural+textual) improves the accuracy of code readability models.\n\n\nSoftware/Code Understandability\n\nWhile readable code might directly impact program comprehension, code readability metrics are not sufficient to measure to what extent the code allows developers to understand its purpose, relationships between code entities, and the latent semantics at the low-level (e.g., statements, beacons, motifs) and high-level structures (e.g., packages, classes). Program understanding is a non-trivial mental process that requires building high-level abstractions from code statements or visualizations/models [4], [9]. There have been several metrics designed to evaluate software understandability by focusing on complexity as well as sourcelevel metrics.\n\nLin et al. [4] proposed a model for assessing understandability by building an understandability matrix from fuzzy maximum membership estimation for population of fog index, comment ratio, the number of components, CFS, Halstead Complexity, and DMSP. The authors then used PCA and factor analysis to get the weights for the column vectors, which can be multiplied by the matrix to get the Synthesis Vector of Understandability. Finally, the understandability is calculated by using the fuzzy integral. The authors did not empirically evaluate the proposed metric.\n\nMisra and Akman [26] performed a comparative study between existing cognitive complexity measures and their proposed measure: cognitive weight complexity measure (CWCM), which assigns weights to software components by analyzing their control structures. The authors performed a theoretical validation of these metrics based on the properties proposed by Weyuker [27]. They found that only one metric, Cognitive Information Complexity Measure (CICM), satisfied all nine properties, while the others satisfied seven of the nine.\n\nThongmak et al. [3] considered aspect-oriented software dependence graphs to assess understandability of aspectoriented software, while Srinivasulu et al. [6] used rough sets and rough entropy (to filter outliers) when considering the following metrics: fog index, comment ration, the number of components, CFS, Halstead Complexity, and DMSC. These metrics are computed at system level for nine projects, and subsequently the rough entropy outlier factor was calculated for the metrics to identify the outliers, which correspond to either highly understandable or not understandable software based on the metric values.\n\nCapiluppi et al. [18] proposed a measure of understandability that can be evaluated in an automated manner. The proposed measure considers: (i) the percentage of micromodules (i.e., the numbers of files) that are within the macro-modules (i.e., the directories), and (ii) the relative size of the micro-modules. The authors calculated the proposed measure on the history of 19 open source projects, finding that understandability typically increased during the life-cycle of the systems. Yet, no evaluation is provided for such a measure.\n\nUnderstandability has also been a factor in quality models to assess software maintainability. Aggarwal et al. [2] investigated the maintainability of software and proposed a fuzzy model, which is composed of three parts: (i) readability of code, (ii) documentation quality, and (iii) understandability of the software. To quantify understandability, the authors utilize a prior work that defines language of software as the symbols used, excluding reserved words. The authors constructed rules based on the ranges of the three factors to determine maintainability.\n\nSimilarly, Chen et al. [7] investigated the COCOMO II Software Understandability factors by conducting a study with six graduate students asked to accomplish 44 maintenance tasks, and found that higher quality structure, higher quality organization, and more self-descriptive code were all correlated with less effort spent on the tasks, which leads to high maintainability.\n\nBansiya and Davis [28] proposed a model where metrics are related to several quality attributes, including understandability. In terms of understandability, the model considers encapsulation and cohesion to have positive influences, while abstraction, coupling, polymorphism, complexity, and design size have a negative influence. The authors validated the model by analyzing several versions of two applications and found that understandability decreases as a system evolves with many new features. Additionally, 13 evaluators analyzed 14 versions of a project and the authors found a correlation between the evaluators' overall assessment of quality and the models assessment for 11 out of 13 evaluators.\n\nIt is worth noting that we do not consider the above discussed understandability metrics [3], [4], [6], [17], [18], [26], [28] in our study since they are defined at system-level (i.e., they provide an overall indication of the system understandability), while we are interested in studying whether it is possible to measure the understandability of a given code snippet, as already done in the literature for code readability. Instead, we included in our study the metrics used by Kasto and Whalley [29] to study the understandability of code snippets in an educational context. Specifically, Kasto and Whalley analyzed the performance of 93 students in their final examination for the Java programming course and they correlated their results with five metrics.\n\nSeveral studies have explored software understandability and program comprehension with either students or practitioners. Shima et al. considered the understandability of a software system by assessing the probability that a system can be correctly reconstructed from its components [30]. The authors asked eight students to reconstruct a system and the results suggest that faults tend to occur in hard to understand files or very simple files. Roehm et al. performed an observational study with 28 developers to identify the steps developers perform when understanding software and the artifacts they investigate [5]. The authors found that developers are more inclined towards relying upon source code as well as discussing with colleagues over utilizing the documentation. The authors also identified some behaviors that improve comprehension, such as consistent naming conventions or meaningful names.\n\nUnderstandability has been mostly analyzed from the perspective of (i) the quality attribute at the software level, i.e., understandability as the \"The capability of the software product to enable the user to understand whether the software is suitable, and how it can be used for particular tasks and conditions of use\" [31]; and (ii) the theories, challenges, and models for program understanding at cognitive levels [8], [9]. However, as of today, we still lack models for assessing code understandability at snippet-level, similarly to code readability. The only work we found that relates to a code understandability model is based on complexity and size source code level metrics [4], [16].\n\nMore recently, Trockman et al. [32] analyzed the dataset we released as part of our ASE'17 work [19] that this paper extends. They showed that it is possible to define classification models with some discriminatory power by combining the 121 metrics considered in our study. Specifically, they use LASSO regression [32] to classify evaluations as understandable or not understandable. In this paper, we also experiment with combinations of metrics to predict the understandability of a given code snippet. However, we (i) rely on our new and larger dataset featuring 22 percent more data points as compared to the one we previously released; and (ii) we experiment with both classification and regression techniques, and use several different proxies for the dependent variable (i.e., code understandability), as compared to the single one used by Trockman et al. [32].\n\n\nCANDIDATE PREDICTORS FOR CODE UNDERSTANDABILITY\n\nUnderstandability is a multifaceted property of source code and, as well as readability, is subjective in nature. In readability, the subjectivity is represented by personal taste and habits, while in understandability it lies in the previous knowledge of a developer and in her mental models [8].\n\nConsider a method of an Android activity in a mobile app; its understandability might be high for an Android developer, while it could be low for a Java developer with no experience in Android. In this section, we briefly discuss the 121 metrics considered in our study aimed at assessing their ability to capture the understandability of a given piece of code. Table 1 shows the complete list of metrics: rows contain the basic metrics and columns indicate how the metrics are aggregated (e.g., the Identifiers length for a given code snippet is computed, as suggested by previous work [10], as the average and as the maximum length of the identifiers used in the snippet). We report in boldface the new metrics introduced in the our previous work [19]. It is worth noting that the number of metrics shown in Table 1 does not add up to the 121 metrics considered in our study. This is due to the fact that some forms of aggregation, e.g., \"Visual\" and \"Area\", include multiple types of aggregating the same measure. For example, each metric aggregated as \"Visual\" should be counted twice (i.e., \"Visual X\" and \"Visual Y\"). Indeed, for these metrics, a \"virtual\" color is assigned to each character in the code, based on the type of the token it belongs to (e.g., characters of identifiers have color 1, while characters of keywords have color 2), thus creating a matrix of colors for the snippet. Then, the variation of colors is computed both on the X and on the Y axis of such a matrix [12], thus resulting in two different forms of aggregation. The complete list of metrics is available in our replication package [33]. In the following subsections, we discuss the considered metrics grouped by their type.\n\n\nCode-Related Metrics\n\nMost of the metrics considered in our study assess source code properties. We include the five metrics used by Kasto and Whalley [29]: cyclomatic complexity [34], which estimates the number of linear independent paths of the snippet average number of nested blocks, which measures the average codeblock nesting in the snippet, number of parameters, number of statements and number of operands, i.e., number of identifiers. We also include in this category all the code-related readability metrics defined in the literature [10], [11], [12], [14]. These include the ones by Buse and Weimer [10], assessing properties for a single line of code (e.g., number of identifiers or line length) and then aggregated (with the maximum and/or the average) to work at the level of \"code snippet\".\n\nLines of code (LOC), token entropy and Halstead's volume are used by Posnett et al. [11] in the context of readability prediction. Dorn [12] presents a variation to the basic metrics introduced by Buse and Weimer [10], measuring the bandwidth of the Discrete Fourier Transform (DFT) of the metrics, the absolute and the relative area of characters belonging to different token categories (e.g., identifiers, keywords or comments), the alignment of characters through different lines, and the number of identifiers containing words belonging to an English dictionary. Note that the arearelated metrics defined by Dorn are computed both in an absolute way (e.g., total area of comments) and in a relative way (e.g., area of comments divided by area of strings). These variants are not explicitly reported in Table 1 due to space constraints, but are considered in our study and listed in our replication package [33].\n\nScalabrino et al. [14] define Narrow Meaning Identifiers (NMI), Number of Meanings (NM), Identifiers Terms In Dictionary (ITID) and Textual Coherence (TC) to capture the readability of a code snippet. Such metrics are computed line-by-line (ITID), identifier-by-identifier (NMI and NM) or block-by-block (TC); the authors aggregate the measures using minimum, average and maximum, in order to have a single measure for the snippet. We also use code readability, as defined by Scalabrino et al. [14], as a separate metric, combining together the previously listed metrics. We followed the steps described by Scalabrino et al. to define the readability model by using a logistic classifier that we train on the 420 Java snippets available in the literature [10], [12], [14].\n\nWe also introduce a new code-related metric, the Invoked Methods Signature Quality (IMSQ), which measures the quality of the signature of the internal methods invoked by a given code snippet s (i.e., methods belonging to the same system of s) in terms of readability and representativeness.\n\nWe define the Method Signature Quality (MSQ) of an invoked method m as:\nMSQ\u00f0m\u00de \u00bc 1 jIS\u00f0m\u00dej X id2IS\u00f0m\u00de IQ\u00f0id\u00de;\nwhere IS(m) is the set of identifiers used in the m's signature (i.e., method name and parameters) and IQ(id) is defined as:\n\nIQ\u00f0id\u00de \u00bc 1 2 \u00f0Rd\u00f0id\u00de \u00fe Rp\u00f0id\u00de\u00de; id is a method name Rd\u00f0id\u00de;\n\ni d is a parameter name :\n\nIQ(id) captures the quality of an identifier in terms of its readability (Rd) and its representativeness (Rp). The idea behind the readability is that an identifier should be  [19] composed of a (possibly small) set of meaningful words. To measure Rd for an identifier (id), we (i) split id into the words composing it, (ii) expand each word to bring it in its original form (e.g., ptr ! pointer), (iii) create a new identifier id exp composed by the expanded words separated by a \"_\", and (iv) measure the Levenshtein distance between id and id exp . The Levenshtein distance between two strings a and b measures the minimum number of single-character changes needed to transform a into b. The conjecture behind IQ(id) is that the higher the Levenshtein distance between id and id exp , the higher the mental effort required for the developer to understand the meaning of the identifier by mentally splitting and expanding it during program comprehension. Note also that we separate the expanded terms in id exp by using \"_\" in order to penalize, by increasing the Levenshtein distance, identifiers composed by several words. For example, the identifier printOnStdOut is first split into print, on, std, out; then, each word is expanded, which has no effect on the first two words, but expands std into standard and out into output. Therefore, printOnStdOut is transformed in print on standard output.\n\nTo have Rd(id) defined in [0, 1], we normalize the Levenshtein distance (L) between id and id exp as follows:\nRd\u00f0id\u00de \u00bc 1 \u00c0 L\u00f0id; id exp \u00de max\u00f0jidj; jid exp j\u00de ;\nwhere max\u00f0jidj; jid exp j\u00de represents the longest identifier among the two. When the distance equals zero, the readability of the identifier equals one, indicating no need for expansion/splitting (i.e., id is composed by a single expanded word). Note that in the implementation of Rd(id), we used a semi-automatic approach to split/expand identifiers. We first used a naive automatic splitting technique, based on camel case and underscores; then, we automatically checked the presence of each resulting word in an English dictionary. If the word was not found, we manually expanded/further split the specific word. For example, for the word \"cmdline\" there would not be automatic split. Since the word \"cmdline\" does not exist in the dictionary, we manually convert it to \"command\" and \"line\". We save all the manual substitutions in order to minimize the human effort. In the literature, there are many automatic approaches for identifier splitting/expansion, but we preferred to implement a simpler and more effective strategy at this stage, since the number of identifiers to split/expand was limited and our goal was to assess the correlation of the defined metrics with the understandability effort. Thus, we wanted to be sure to avoid introducing imprecision while computing the metrics.\n\nWhen dealing with the identifier used to name a method, we also verify whether it is representative of what the method does (Rp). We compute the textual overlap between the terms used in the identifier and in the method body. We tokenize the method body to define its dictionary. Then, we count the number of times each word from the identifier (expanded or not) is contained in the dictionary extracted from the method body. We consider only names and verbs from the identifiers, ignoring other parts of speech such as conjunctions, since they do not carry semantic information.\n\nFollowing the printOnStdOut example, we check whether the method body contains the words print, standard, std, output, and out. We measure the representativeness as the ratio between the number of words from the identifier (i.e., method name) contained in the method body, and the total number of words in the identifier. If all the words from the identifier are used in m's body, we assume that the method name is representative of m and thus, should ease the understanding of methods invoking m. If, instead, words are not found in the method body, this could hinder the understandability of the methods invoking m.\n\nIn our study, we consider the minimum, the average, and the maximum values of the MSQ metric for a given code snippet (e.g., the average MSQ of all methods invoked in the code snippet).\n\n\nDocumentation-Related Metrics\n\nScalabrino et al. [14] introduced three metrics to capture the quality of the internal documentation of a snippet: Comments Readability (CR) measures the readability of the comments in a snippet using the Flesch reading-ease test [35]; Comments and Identifiers Consistency (CIC) measures the consistency between comments and code; and CIC syn , a variant of CIC, which takes synonyms into account.\n\nWe also introduce two new metrics aimed at capturing the quality of both the internal (MIDQ) and external (AEDQ) documentation available for code components used in a given snippet. The Methods Internal Documentation Quality (MIDQ) for a snippet s acts as a proxy for the internal documentation (i.e., Javadoc) available for the internal methods (the ones belonging to the same project as s) invoked in s. Given m an internal invoked method, we compute MIDQ(m) using a variation of the approach proposed by Schreck et al. [36]:\nMIDQ\u00f0m\u00de \u00bc 1 2 DIR\u00f0m\u00de \u00fe readability D \u00f0m\u00de ;\nwhere DIR(m) is the Documented Items Ratio computed as the number of documented items in m divided by the number of documentable items in m. We consider as documentable items for m (i) its parameters, (ii) the exceptions it throws, and (iii) its return value. Such items are considered as documented if there is an explicit reference to them in the Javadoc through the tags @param, @throws and @returns. readability D \u00f0m\u00de represents, instead, the readability of the Javadoc comments assessed using the Flesch reading-ease test [35]. The higher MIDQ the higher the internal documentation quality for m. We consider the minimum, the average, and the maximum values of the MSQ metric for a given code snippet.\n\nConcerning the API External Documentation Quality (AEDQ), it tries to capture the amount of information about APIs used in the given snippet s that can be acquired from external sources of documentation, such as Q&A websites. The conjecture is that if external documentation is available, it is more likely that developers are able to understand the usage of an API in a code snippet s. We compute the availability of external documentation for each external class c used in s via the AEDQ(c) metric. First, we identify all Stack Overflow discussions related to c by running the following query: title:\"how to\" <c> hasaccepted:yes [java] In other words, we select all Stack Overflow discussions that (i) contain \"how to\" and the class name in the title, (ii) have an accepted answer, and (iii) concern Java (since our study has been performed on Java snippets). Then, we sum the votes assigned by the Stack Overflow users to the question in each retrieved discussion, in order to have a quantitative information about the interest of the developers' community in such a class. We assume that higher interest in a given API class implies a higher availability of external sources of information (e.g., discussions, code examples, etc.). We consider in our study the minimum, the average, and the maximum values of the AEDQ metric for the external classes used in s.\n\n\nDeveloper-Related Metrics\n\nSince understandability is a very subjective feature of code, we introduced three developer-related metrics. We measure the programming experience of the developer who is required to understand a snippet (PE gen and PE spec ) and the popularity of the API used in the snippet (EAP).\n\nThe common wisdom is that the higher the programming experience of developers, the higher their capability of understanding code. PE gen measures the programming experience (in years) of a developer in general (i.e., in any programming language). PE spec assesses instead the programming experience (in years) of a developer in the programming language in which a given snippet s is implemented. The higher PE spec , the higher the developer's knowledge about the libraries available for such a programming language.\n\nWith External API Popularity (EAP), we aim at capturing the popularity of the external APIs used in a given snippet. The assumption is that the lower the popularity, the lower the probability that a typical developer knows the API. If the developer is not aware of the APIs used in a snippet, it is likely that she has to look for its documentation or to inspect its source code, thus spending more effort in code understanding.\n\nWe rely on an external base of Java classes E to estimate the popularity of an external class. We chose as E a 10 percent random sample of classes from Java/Android projects hosted on GitHub in 2016, totaling $ 2M classes from $ 57K Java projects. We used Google BigQuery to extract all the imports of all the classes belonging to such projects using a regular expression. Then, we counted the number of times each class imported in E occurred in the import statements. Note that in Java it is possible to import entire packages (e.g., import java:util:\u00c3). In this case, it is difficult to identify the actual classes imported from the package. For this reason, we applied the following strategy. Let us assume that a class, Foo, is imported only once with the statement import bar:Foo, but it is part of a quite popular package, bar, that is imported 100 times in E through the statement import bar:\u00c3. The class Foo2, belonging to the same package, is imported 99 times with the statement import bar:Foo2. In this case, we increase the number of occurrences of classes belonging to imported package in a proportional way. In the presented example, we add 1 to the number of Foo's imports, and 99 to the number of Foo2 imports. We found that imports of entire packages represent only 2.6 percent of all the imports and, therefore, their impact is very low. EAP(c) is defined as the number of c imports normalized over the number of imports of c max , where c max is the most imported class we found in E (i.e., java:util:List).\n\n\nPROXIES FOR CODE UNDERSTANDABILITY\n\nCode understandability can affect two aspects of code understanding: the correctness (i.e., how well the developer is able to understand a snippet), and the time needed to understand the snippet. Moreover, as previously shown [19], developers might perceive that they understand a given code without actually understanding it. Since understandability is composed by several facets, we introduce six proxies of code understandability. These proxies can be used to (i) study the correlation between the candidate predictor variables introduced in Section 3, and (ii) as dependent variables in techniques aimed at predicting code understandability: 1) Perceived Binary Understandability (PBU). This is a binary categorical variable that is true if a developer perceives that she understood a given code, and false otherwise.\n\n\n2) Time Needed for Perceived Understandability (TNPU).\n\nThis is a continuous variable in < \u00fe , measuring the time spent by the developer to comprehend a given code before having a clear idea on whether she understood it or not. 3) Actual Understandability (AU). This is a continuous variable in \u00bd0; 1, measuring the actual understanding of the inspected code. A possible way of measuring actual understandability is through verification questions. For example, the developer understanding the code could be required to answer three questions, and the percentage of correct answers is used to assess AU. 4) Actual Binary Understandability (ABU k% ). This is a binary categorical variable derived from AU. It is true if AU is greater than k, false otherwise. ABU k% is basically a proxy to classify snippets of code as understandable or not based on the level of actual understanding developers are able to achieve while inspecting it. 5) Timed Actual Understandability (TAU). This is a continuous variable in \u00bd0; 1, derived from AU and TNPU. It gets a value of 0 if the developer perceives that she did not understand the snippet. Otherwise, it is computed as:\nTAU \u00bc AU 1 \u00c0 TNPU max TNPU ;\nwhere AU and TNPU are the variables previously defined. The higher AU, the higher TAU, while the higher TNPU, the lower TAU. We take into account the relative time ( TNPU max TNPU ) instead of the absolute time, so that TAU gives the same importance to both the correctness achieved (AU) and the time needed (TNPU). max TNPU is, indeed, the maximum TNPU measured on the snippet.\n\n(6) Binary Deceptiveness (BD k% ). This is a binary categorical variable derived from PBU and ABU k% , which is true if PBU is true and ABU k% is false, and false otherwise. BD k% indicates whether a developer can be deceived by a method in terms of its understandability (i.e., she incorrectly thinks she understood the method).\n\n\nEMPIRICAL STUDY DESIGN\n\nThe goal of our study is to assess the extent to which the considered 121 metrics are related to code understandability and what developers consider as understandable/not understandable. The perspective is of researchers interested in (i) analyzing whether code-related, documentation-related, and developer-related metrics can be used to assess the understandability level of a given piece of code, and (ii) investigating characteristics of code considered as important for developers during program comprehension. This study aims at answering the following research questions:\n\nRQ 0 How does code understandability change among developers and snippets? In this preliminary research question, we would like to check whether understandability changes more among different developers or among different snippets; RQ 1 What is the correlation between the 121 considered metrics and the understandability level of a given developer for a specific code snippet? Given the wide and heterogeneous set of considered metrics, answering this research question would allow us and, in general, the research community to understand how far we are from defining a set of metrics capable of automatically and objectively assessing code understandability; RQ 2 Is it possible to define understandability models able to predict code understandability? Given a snippet of code, we want to determine whether combining metrics in a model can effectively capture the level of understandability of that code; RQ 3 How do developers determine the understandability of code?\n\nWhile the first two questions relate to metrics to assess understandability, it is also important to consider the perspective of developers when trying to understand code. To this end, we aim to deepen our analysis by asking experienced developers what makes a certain code snippet understandable or not understandable.\n\n\nData Collection\n\nThe context of the study consists of objects, i.e., Java methods, and subjects, i.e., software developers. We first describe the selection of the code snippets we considered. Then, we present the subjects that we selected for the survey, which we conducted to answer RQ 1 and RQ 2 , and the procedure that we used to acquire the data. Finally, we introduce the subjects we selected for the interviews we conducted to answer RQ 3 and the interviewing process we followed. Selection of Code Snippets. We selected 50 Java/Android methods extracted from ten popular systems listed in Table 2 (five methods from each system). We first extracted all the methods having 50 AE 20 ELOCs (i.e., Effective Lines Of Code, excluding blank and comment lines) from the systems. The choice of the methods' size (i.e., 50 AE 20 ELOCs) was driven by the decision of excluding methods that are too trivial or too complex to understand.\n\nAfterwards, we computed all the metrics described in Section 3 for the selected methods. 1 Then, we used a greedy algorithm for center selection [37] to select the 50 most representative methods based on the defined metrics. Given a set of candidate methods M and a set of already selected centers C, the algorithm chooses, in each iteration, arg max m2M dist\u00f0C; m\u00de, i.e., the candidate method which is the farthest possible (in terms of considered metrics) from the already selected centers of which the first center is randomly selected. In order to select exactly five snippets from each system, we used the set of candidate methods from a specific system as M until the five methods for such a system were selected; then, we changed M with the set of candidate methods from another system, and so on, until jCj = 50. Note that (i) we did not empty the C set when changing the candidate methods (i.e., when moving from one system to another) to always keep track of the methods selected up to that moment, thus avoiding the risk of adding to C methods similar to the ones already in C; (ii) we did not run the algorithm on the union of all candidate methods to ensure the selection of five methods per system (thus increasing the heterogeneity of the final sample).\n\nSelection of the Participants to the Survey. After selecting the 50 methods and computing the values of the metrics for each of these 50 methods, we needed to define a groundtruth, which reports the understandability of each method. To this aim, we invited 63 Java developers and CS students to participate in a survey, where they were required to understand the selected methods. The survey was implemented in a Web application and featured the following steps. First, we collected demographic data about participants: (i) years of experience in programming and more specifically in Java, and (ii) current position (e.g., CS student, developer etc.). This information was used in part to compute the developer-related metrics. We asked participants for consent to anonymously use the gathered data. We do not report developers' names and e-mail addresses for privacy reasons.\n\nSurvey Procedure. After this preliminary step, each participant was required to understand a subset of eight 1. Excluding the \"Developer programming experience\" and the \"Developer Java experience\" methods randomly selected from the 50 methods. The Web application was designed to automatically balance the number of evaluations for each of the 50 methods (i.e., the number of participants understanding each method was roughly the same). In total, we collected 444 evaluations across the 50 methods ($ 8.9 evaluations per method on average), since not all participants completed the survey.\n\nThe eight methods were presented individually (i.e., each method on a different page) to participants, and the Web application allowed navigation of the method and access to the methods/classes invoked/used by it. Also, participants were allowed to browse the Web to collect information about types, APIs, data structures, etc. used in the method. This was done to simulate the typical understanding process performed by developers. We asked participants to carefully read and fully understand each method. Participants could, at any moment, click on the button \"I understood the method\" or the button \"I cannot understand the method\". In both cases, the Web application stored the time spent, in seconds, by the developer for the method's understanding before clicking on one of the two buttons. If the participant clicked on \"I understood the method\", the method was hidden and she was required to answer three verification questions about the method she just inspected. The provided answers were stored for future analysis.\n\nIn particular, one of the questions we asked was about the identifiers used in the method (e.g., what does \"CMS\" mean?); a second question was about the purpose of a call to an internal method (e.g., What does the invoked method X do?); and the third question was about the purpose of using an external component in the snippet (e.g., JDBC APIs). These questions capture different aspects of code comprehension: knowing the meaning of the names used in a snippet is necessary to have a generic idea about the topic of the snippet; understanding the purpose of internal/external method calls is important to have full awareness of what happens when such methods are used, which requires (i) knowledge about the application domain of the project (internal methods) and (ii) knowledge about the used technology (external methods). Knowing the correct answer to all the questions is a necessary condition to say that a developer fully understood a snippet.\n\nSelection of the Participants for the Interviews. To perform a more in-depth qualitative analysis, we conducted semistructured interviews with five experienced developers recruited using convenience sampling, listed in Table 3. We tried to select developers with diverse specializations: the three professional developers work in different areas (Android, front-end, back-end); one of the two PhD students had a previous experience in industry, while the other one did not. The developers provided consent to include their names in this paper. We do not directly associate the names to the performance in the tasks.\n\nInterviews Procedure. To guide the interviews, we selected 4 methods among the 50 that we used to answer the other research questions. Such methods where (i) the one with the highest mean TAU, i.e., the most understandable one, (ii) the one with the lowest mean TAU, i.e., the least understandable one, (iii) the one with the highest standard deviation in TAU, i.e., the one for which the understandability seems to be most subjective, and (iv) the one that has the highest TNPU and a number of BD 50% = true greater than zero, i.e., the method that, despite being analyzed for the longest time, still makes some developers incorrectly believe that they understood it.\n\nWe use TAU as a proxy for understandability to select the first three snippets as it takes into account both the actual understandability and the time taken to understand the snippet. Table 4 shows the four methods we selected. For each method, we asked the five developers to read and understand it, thinking aloud, if they wanted. Before the participants started to read and understand the snippet, we asked them how familiar they were with the system to which the snippet belongs and with the APIs used in the snippet. For each snippet, after the participants concluded the understanding phase, we asked precise questions: Q 1 : \"do you think this snippet is understandable?\"; Q 2 : \"what makes this method understandable/not understandable to you?\"; Q 3 : \"is it possible to modify the method to make it more understandable? If yes, how?\". If the participants understood the snippet, we asked the purpose of the snippet to ensure they actually understood it, unless they explained it while they thought aloud during the interview. Finally, we registered the time the participants took to understand the snippets.\n\n\nAnalysis Method\n\nIn the context of our study, we measure the understandability level using the previously defined proxies of code understandability (Section 4).  We measure Perceived Binary Understandability (PBU) using the initial declaration of the participants: if they clicked on \"I cannot understand the method\" button, PBU is false, while it is true otherwise (i.e., the participant clicked on \"I understood the method\").\n\nWe measure Time Needed for Perceived Understandability (TNPU) as time, in seconds, spent by the participant while inspecting the method before clicking on \"I understood the method\". This metric cannot be computed when the participant clicked on \"I cannot understand the method\".\n\nWe measure Actual Understandability (AU) as the percentage of correct answers given by the participants to the three verification questions. If the participant clicked on the \"I cannot understand the method\" button, AU is 0.\n\nWe measure Actual Binary Understandability (ABU k% ), with k \u00bc 50. Therefore, ABU 50% is true when participants correctly answer at least two of the three verification questions, and false otherwise.\n\nTo measure Timed Actual Understandability (TAU), we use the previously defined formula, which combines AU and TNPU. TAU gets value 0 if the participant clicked on the \"I cannot understand the method\" button. In this context, we used a modified version of TNPU in which outliers (detected using the Tukey's test [38], with k \u00bc 3) are replaced with the maximum value of TNPU which is not an outlier. We did this because the maximum value of TNPU in our dataset is 1,649 seconds, much greater than the third quartile (164 seconds). Using the real maximum value would have flattened down all the relative times.\n\nFinally, we measure Binary Deceptiveness (BD k% ), with k \u00bc 50, using the previously defined formula which combines PBU and ABU 50% .\n\nWe computed these six variables for each of the 444 evaluations performed by participants (i.e., for each method that each participant tried to understand). We excluded 2 of the 121 considered metrics (i.e., NMI min and ITID min ), because the value of such metrics was 0 for all the snippets.\n\nRQ 0 : Variation of Code Understandability. To answer RQ 0 , we analyzed how the values of our proxies for code understandability vary among different evaluators (for the same snippet) and different snippets (for the same evaluator). For each proxy P , we computed the mean variance of P among different evaluators (for the same snippet) using the formula\nV s \u00f0P \u00de \u00bc P n i\u00bc1 var\u00f0P i \u00de n ,\nwhere n is the number of snippets in our dataset and P i is the vector containing the values of P for the snippet i. The higher V s , the larger the differences in terms of understandability among different evaluators for the same snippets. Similarly, we computed the variations among different snippets for the same evaluator as V d \u00f0P \u00de \u00bc\nP n i\u00bc1 var\u00f0P i \u00de n ,\nwhere n is the number of developers and P i is the vector containing the evaluations of the developer i. Again, the higher V d , the higher the differences in understandability among different snippets for the same evaluator.\n\nRQ 1 : Correlation With Single Metrics. To answer RQ 1 , we first verified which metrics strongly correlate among the 121. This was done to exclude redundant metrics, which capture the same information in different ways, from our analysis. We compute the Kendall rank correlation coefficient (i.e., Kendall's t) [39] to determine whether there are pairs exhibiting a strong correlation. We adopted the Kendall's t, since it does not assume the data to be normally distributed nor the existence of a straight linear relationship between the analyzed pairs of metrics. Cohen [40] provided a set of guidelines for the interpretation of the correlation coefficient. It is assumed that there is no correlation when 0 jtj < 0:1, small correlation when 0:1 jtj < 0:3, medium correlation when 0:3 jtj < 0:7, and strong correlation when 0:7 jtj 1. For each pair of metrics exhibiting a strong correlation (i.e., with a Kendall's jtj ! 0:7), we excluded the ones which presented the highest number of missing values 2 or one at random, when the number of missing values were equal. This allowed us to reduce the number of investigated metrics from 121 to 73. Finally, we computed the Kendall correlation between each of the remaining 73 metrics and PBU, TNPU, AU, BD 50% , and TAU to verify whether some of them are able to capture the (actual and perceived) understandability of code. We did not compute the correlation with ABU 50% , since, in this case, it would have been redundant, because we already compute the correlation with AU.\n\nRQ 2 : Performance of Multi-Metrics Models. To answer RQ 2 , we tried to combine the metrics defined in Section 3 to predict the six proxies of understandability previously defined. Since the number of metrics is high as compared to the number of instances, we performed a preliminary phase of feature selection. First, we removed the features highly correlated among each others (as previously done for RQ 1 ); then, we removed Area Keywords/Comments, because of the high number of missing values (124, more than 30 percent of the instances), which could be problematic for some of the used machine learning techniques.\n\nTo build a model for predicting PBU, ABU 50% , and BD 50% , we use a broad selection of classifiers defined in the literature, since such variables are nominal. Specifically, we use (i) Logistic Regression [41], (ii) Bayes Networks [42], (iii) Support Vector Machines (SMO algorithm [43]), (iv) Neural Networks (Multilayer Perceptron), (v) k-Nearest-Neighbors [44], and (vi) Random Forest [45]. As the first step, we use 10 percent of each dataset to tune the hyperparameters and we removed such instances from the dataset used in the experiment. We focus on the main parameters of each technique and, specifically, we tune: (i) number of hidden layers, learning rate, and momentum for Multilayer Perceptron; (ii) k, weighting method, and distance metric for kNN; (iii) kernel, exponent, and complexity for SMO; (iv) number of features for Random Forest. To do this, we use an exhaustive search approach on a reduced search space, i.e., we defined discrete values for each parameters (at most 10 values) and then we try all of the possible combinations. We search for the combination of parameters that achieves the best AUC using leave-one-out cross-validation on the tuning set. Note we did not tune hyper-parameters for Logistic Regression and Bayes Networks, since they do not rely on any particular parameter.\n\nBoth PBU and BD 50% were unbalanced: PBU presented a high number of positive instances ($ 69 percent), while BD 50% a high number of negative instances ($ 80 percent).\n\nTo have balanced models, we use the SMOTE filter [46] on the training sets to generate artificial instances for the minority classes. Moreover, while Random Forest is designed to automatically select the best features, for the other algorithms it is important to have an adequate number of features in relation to the number of instances. To achieve this goal, for those techniques, we performed a second round of feature selection using linear floating forward selection with a wrapper strategy. We used Logistic Regression as the classifier for the wrapper and AUC (Area Under the Curve) as the metric for the evaluation of the effectiveness of each subset of features, computed with a 5-fold cross validation. We report the average F-Measure of the classes of each variable and the AUC of all the classifiers for the three variables to show the effectiveness of combinations of metrics defined in the literature in the prediction of the nominal proxies of understandability.\n\nFor the other proxies, i.e., TNPU, AU and TAU, we use several regression techniques defined in the literature, since such variables are numeric. Specifically, we use (i) Linear Regression, (ii) Support Vector Machines (SMOreg [47]), (iii) Neural Networks (Multilayer Perceptron), (iv) k-Nearest-Neighbors [44] and (v) Random Forest [45]. In this case, we report the correlation of the predicted values with the actual values and the MAE (Mean Absolute Error) of the prediction, computed as P n i \u00f0jx i \u00c0x \u00c3 i j\u00de n . We use the same approach that we used for classification to tune the parameters of the regressors and to select the best features. In this case, we look for the parameters and the features that minimize the mean absolute error. We use linear regression as regressor in the wrapper strategy.\n\nBoth classifiers and regression models need to be trained and tested on different datasets to avoid overfitting (i.e., the model would fit the specific data, but not generalize). For this reason, we performed leave-one-out cross-validation where we divided the dataset in 444 folds, i.e., each fold contains exactly one instance. For each iteration, one of the folds was used as test set and the union of the other folds as training set for our models. Therefore, for each evaluated instance, we train our models on the whole dataset without the test instance. This solution is ideal in this context for two reasons: (i) since our dataset may be small for regression techniques to be effective, we cannot afford to reduce the number of instances for the training phase; (ii) this type of validation allows us to use all the evaluations of the same developer (except for the one that has to be tested) in the training phase. This would allow machine learning techniques to define rules specific for the developer itself. It is worth highlighting that we do not aim at comparing different machine learning techniques. Instead, our goal is to understand if any technique is able to effectively combine the considered metrics to capture code understandability. Finally, to answer RQ 3 , we transcribed the interviews and we summarized the responses into comments. Then, we clustered the comments into topics and we counted how many developers mentioned each topic. For example, if a developer said that he was confused by the name of a specific identifier and another developer said that identifier names were good for a snippet, we clustered such comments together in the category \"quality of identifiers\". Finally, we report in the results (i) the answers given by the participants to the precise question we asked them at the end of the analysis of each snippet, and (ii) interesting insights that we could obtain during the interviews.\n\n\nReplication Package\n\nThe data used in our study is publicly available [33]. We provide the research community with our dataset reporting the (perceived and actual) understandability achieved by the 63 participants, hoping that the availability of such a dataset will help foster research on the definition of a metric to automatically assess code understandability.\n\n\nEMPIRICAL STUDY RESULTS\n\nIn this section, we present the results of our empirical study. Fig. 1 provides information about the participants involved in RQ 1 (same dataset is used for RQ 2 as well). The majority of them ($ 60 percent) are CS bachelor's students-mixed in terms of years of programming experience. The sample of participants also includes nine master's students, three PhD students, and thirteen professional developers.\n\n\nRQ 0 Variation of Code Understandability\n\nWe report in Table 5 both V s and V d for TNPU, AU, and TAU, i.e., the numeric proxies we previously defined. We also report the values of V s for the different categories of participants. The table shows that V s is slightly higher than V d for all the proxies. This shows that the understandability depends more on the developer than on the snippet he/she is evaluating, even if such a difference is not very high. Also, it is worth noting that V s \u00f0AU\u00de decreases if we divide the developers in categories based on their professional position. This means that different categories of developers achieve more similar levels of correctness. Specifically, professional developers and Master's students seem to be the most cohesive groups in terms of correctness (i.e., the groups that exhibit the lowest variance). The same happens (but with lower differences) for V s \u00f0TAU\u00de. On the other  hand, for V s \u00f0TNPU\u00de there are categories with lower intergroup variations (i.e., Master's students and PhD students), while others have higher variations (i.e., Bachelor's students and professional developers).\n\nSummary for RQ 0 . Code understandability depends slightly more on the developers rather than on the code snippets.\n\n\nRQ 1 : Correlation With Single Metrics\n\nWhen evaluating the metrics on a larger number of evaluations and by considering more proxies for code understandability, we still observe the negative results that were shown in our previous study [19]: Very few metrics have a correlation with understandability higher than j0:1j. Specifically, 8 metrics have a weak correlation with PBU, only one with TNPU, 13 with AU, 13 with TAU, and 2 with BD 50% . Note that, since we only observed weak correlations, these metrics are very unlikely to be appropriate proxies for code understandability. 51 out of the 73 metrics considered showed no correlation at all with any of the proxies. The metric which has the highest correlation with PBU are two: (i) maximum line length (t % \u00c00:13), which is one of the metrics introduced by Buse and Weimer [10] for readability prediction; (ii) PE spec (t % 0:13), which measures the Java experience of the developer. Note that Buse and Weimer also found that Maximum line length is the most important one for readability prediction in their model [10]. Therefore, this reinforces the fact that, generally, developers tend to perceive code with long lines as less pleasant. The correlation with PE spec , instead, shows that developers with more experience in the specific programming language tend to have a slightly higher confidence and they tend to perceive snippets of code as understandable more frequently than developers with less experience. Finally, we observed other low correlations with PBU: NM avg (-0.12), i.e., when words used for identifiers have many meanings, they make developers perceive the snippet as slightly less understandable; MIDQ min (0.12), i.e., the higher the minimum quality of the internal documentation, the higher the perceived understandability; average identifiers' length (-0.12), i.e., shorter identifiers slightly help perceiving the code as more understandable.\n\nWhile in our previous study we showed that ten of the metrics have a slight correlation with TNPU, replicating this work on a larger number of evaluations reduced the number to just a single metric, i.e., DFT of conditionals (0.11).\n\nThe metric that has the highest correlation with AU is average Textual Coherence (t % \u00c00:16). The fact that such a correlation is negative is surprising, because we expected a higher Textual Coherence to imply a higher understandability. Also, we found that number of parameters negatively correlates with AU (t % \u00c00:13) (i.e., the larger the number of parameters, the lower the actual understandability of the method). We found a similar result also in RQ 3 when interviewing developers. Other examples of metrics correlated with AU are PE spec (t % 0:13) and DFT of conditionals (t % \u00c00:13).\n\nThe metric with the highest correlation with TAU is DFT of conditionals (t % \u00c00: 16). This suggests that high complexity reduces the understandability of a snippet. It should be noted that for TAU, which is expression of actual understandability, we observe only a slight correlation with the programming experience (t % 0:11 for PE spec ).\n\nFinally, only two metrics, i.e., number of literals (visual X) and DFT of conditionals, are slightly correlated with BD 50% (t % 0:11 and 0.1, respectively). All the other metrics show a negligible correlation.\n\nSummary for RQ 1 . None of the metrics we considered achieve a medium/strong correlation with any of the proxies of code understandability we defined.\n\n\nRQ 2 : Performance of Multi-Metrics Models\n\nWe report the performance of models that combine metrics dividing them as classification, for PBU, ABU 50% and BD 50% , and regression, for TNPU, AU and TAU.\n\n\nClassification\n\nFirst, we report in Table 6 the features selected for the models of at least two of the proxies (the replication package contains the complete list of features for each proxy). It is worth noting that, in some cases, they are the same we found useful in RQ 1 . However, some features that alone seem to be not important, become useful when combined with the other features. For example, #literals (Visual X) achieves a correlation of 0.11 just with BD 50% when used alone, but, combined with others, it is selected as a good feature for the models of four out of the six proxies. Table 7 shows the F-Measure and AUC of the classification of PBU, ABU 50% , and BD 50% . Since we use Logistic Regression for feature selection, we do not include it directly in the comparison among the techniques. It is worth noting that the AUC achieved by Random Forest and Multilayer Perceptron for the classification of ABU 50% seems to suggest that it is possible to classify with a good level of confidence snippets as actually understandable or actually not understandable. Looking at the F-Measure, however, it is clear that we are quite far from having a practical classifier for actual understandability. Also, looking at the classification accuracy, 33 percent of the instances are wrongly classified by the best model.\n\nSuch results are even more negative for PBU and, above all, BD 50% . For PBU the maximum F-Measure is $ 0.66. On \nTC (avg) \u00c2 \u00c2 \u00c2 \u00c2 \u00c2 NMI (avg) \u00c2 \u00c2 \u00c2 \u00c2 \u00c2 PE (spec) \u00c2 \u00c2 \u00c2 \u00c2 \u00c2 #literals (Visual X) \u00c2 \u00c2 \u00c2 \u00c2 Indentation length (DFT) \u00c2 \u00c2 \u00c2 #operators/#identifiers (area) \u00c2 \u00c2 #conditionals (DFT) \u00c2 \u00c2 PE (gen) \u00c2 \u00c2 #parameters \u00c2 \u00c2 #comparisons (DFT) \u00c2 \u00c2 #conditionals (avg) \u00c2 \u00c2 Line length (max) \u00c2 \u00c2\nthe other hand, the best F-measure for BD 50% is 0.77, achieved by Random Forest. However, this positive result hides the fact that such a classifier has good results only on negative instances. Both precision and recall for the positive class are, indeed, very low (mean 0.31 and 0.51 for precision and recall, respectively). In general, looking at the F-Measure of the minority classes, which are perceived as not understandable and deceptive, such values are much lower (i.e., 0.48 and 0.37, respectively), despite the fact that we used SMOTE to balance the training sets. We can conclude that the combination of the considered metrics shows a slight discriminatory power for actual binary understandability (ABU 50% ); however, we are quite far from a practically useful prediction model of actual/perceived understandability and deceptiveness.\n\n\nRegression\n\nIn Table 8, we report the performance of the regression models for TNPU, AU and TAU. The first thing that is very clear is that our models are not able to predict TNPU (Time Needed for Perceived Understandability). The highest correlation for TNPU is only 0.18, higher than the correlation achieved by single metrics, but still very low. The Mean Absolute Error is also very high. On average, we can expect a prediction of TNPU to be wrong by about 2 minutes. Considering that the average TNPU is 143.4 seconds, without excluding outliers, it is clear that any prediction of TNPU made with the state of the art metrics is practically useless. On the other hand, it can be seen that there is a good improvement in the correlation for both AU and TAU, when using combinations of metrics rather than single metrics. The maximum correlations are 0.37 and 0.36, respectively, leading to a medium correlation. However, it is worth noticing that the Mean Absolute Error is quite high. In our context, the MAE of 0.29 for AU means that we should expect our model to be wrong by one answer, on average (0:29 % 0:33). If our model predicts that AU is 0.66 (the participant gives two correct answers out of three), it may be that she gives one or three correct answers, thus making this prediction poorly actionable except for corner cases (predicted AU very low or very high).\n\nFinally, because of the results of RQ 0 , i.e., that understandability depends much more on the developer, we tried to use the professional position of the developer as an additional feature in our combined models (RQ 2 ). We observed a slight improvement in the regression performance of TAU (Correlation: +0.07; MAE: -0.02) and AU (Correlation: +0.02; MAE: +0.00), while we achieved lower classification performance for BD 50% (F-measure: -0.06; AUC: -0.02), and comparable regression and classification performance for PBU (F-measure: -0.02; AUC: +0.01), ABU 50% (F-measure: +0.07; AUC: -0.02), and TNPU (Correlation: +0.03; MAE: +7.5). However, the improvement relates only to the maximum scores achieved: not all the machine learning techniques achieve better results.\n\nSummary for RQ 2 . Combining the state-of-the-art metrics can result in models that show some discriminatory power in the prediction of some proxies of code understandability (i.e., ABU 50% , AU and TAU). However, such predictions are not sufficiently good yet to be used in practice.\n\n\nRQ 3 : Structured Interviews with Developers\n\nWe report the results of the interviews by presenting the developer responses grouped by each type of code snippet. The interviews lasted roughly between one and two hours each. For space limitations, we report the complete code snippets in our replication package [33].\n\n\nThe Most Understandable Method\n\nAll the developers correctly described the functionality implemented in the method, and all of them answered positively to Q 1 (i.e., they think the method is understandable). The average time needed to understand the method was about 2.5 minutes. As expected, this was the method understood most quickly.\n\nThe single aspect that makes this method highly understandable, according to the developers, is the easy/clear task it implements. Other positive aspects of the method as for understandability (Q 2 ) are that it is very tidy (good readability, in general) and it implements a single task. Carlo highlighed that the names are very well chosen. However, both Salvatore and Giovanni put emphasis on the many repetitions in the code. Salvatore said that, to some extent, repetition and alignment are positive, because they help the brain ignoring part of the code that is not useful to read. On the other hand, Giovanni thinks that repetitions make the method \"poorly maintainable and less elegant\"; however, he does not think that repetitions hinder understandability.\n\nThree developers agreed that there is no negative aspect in terms of understandability, and it would not be possible to have a more understandable version of the method (Q 3 ). On the other hand, Salvatore thinks that the repetition of the actual parameter \"hoverbar\" for all the constructors and the lack of alignment forces the reader to check if it is actually true that all the constructors are called with such an  actual parameter, and this slightly increases the time needed to understand the method. He would have aligned all the actual parameters of the constructors in the list (Fig. 2). Matteo thinks that the name \"hoverbar\" is not very clear, and documentation is lacking for it. He also thinks that the abstract return type makes the method slightly less understandable, because it is necessary to understand what kinds of concrete types can be returned. He said that, from his experience, there is often a trade-off between understandability and maintainability. In this case, using abstract types is necessary to make the method more maintainable (e.g., all the classes that implement the same interface have the same signature, and it is easier to extend this system). However, this makes the implemented mechanism (and the system) harder to understand. While reading and understanding the method, the developers used different approaches. Some of the developers looked at class and internal dependencies of the method (i.e., the context in which such method exists); some looked as well at some of the classes used in the method and they inferred that they are very similar, which was helped by the names; some focused on the method itself. One of them searched on the internet for \"hoverbar\" to understand its meaning in this context. One of the developers also looked for information about the entire system and the repository (e.g., number of developers) and he looked at the documentation of the implemented interface to get information about the method to understand.\n\n\nThe Least Understandable Method\n\nFour developers out of five did not understand the second method. They admitted that fully understanding the method would have required much longer, and they asked to stop after about 5 minutes. One of them, on the other hand, took some extra time to analyze the classes used in the method (about 8 minutes, in total). In the end, he said he understood the method and he was able to describe what the method did. Three developers said that the method is not understandable (Q 1 ), while the other two, surprisingly, said that the method is understandable. The developer, who did not fully understand the method but perceived it as understandable, explained that he roughly understood the method, but the lack of knowledge about the system made him say that it would take more time to properly understand it.\n\nTwo developers highlighted that the positive aspects of the method (Q 2 ) are that it implements just one task. One of them also generally liked the names used for the identifiers. On the other hand, all the developers listed many negative aspects. The most negative aspect highlighted is the complete lack of comments and internal documentation (all the developers). Also, the fact that the method belongs to a big and untidy class makes the method itself less understandable (2 out of 5 developers). The developers also generally complained about the low readability of the method (4 out of 5 developers). Matteo and Carlo pointed out that another negative aspect is that the method is highly dependent on some internal classes/methods that are hard to understand. Stefano, Salvatore and Matteo did not like the presence of many exit points for the method; Salvatore and Matteo also said that the high number of parameters strongly reduces its understandability (confirming what we found answering RQ 1 ), and Matteo precised that some of the parameters are not used at all. Stefano and Matteo did not like some identifiers names (e.g., areTablesIdentifiers), which they considered potentially misleading. Matteo thinks that this method has too many responsibilities. For example, the first thing the method does is to load a schema, based on the value of one of the parameters, but he thinks that it would be better to directly have a parameter with the loaded schema. Also, he thinks that the application domain is quite complex.\n\nAll the developers answered Q 3 saying that they would improve the understandability of the method by adding comments and improving its readability. Matteo said that he would (i) change the order of the parameters (e.g., putting the schema as the first parameter), (ii) use exceptions instead of SCHEMA_NOT_FOUND instances, and (iii) start with a check for exceptional behaviors (that lead to SCHEMA_NOT_FOUND) and the normal behavior after that.\n\nAlso, in this case, the developers used different approaches to read and understand the snippet. One developer tried to look for the internal documentation of the used classes (which is lacking); two developers looked at the code of the used classes; one developer strongly relied on the names of the identifiers. Finally, one developer said that he would have used the debugger to understand the snippet (i.e., he would have analyzed the dynamic behavior of the code). He explained that understanding this snippet only looking at code statically would take longer.\n\n\nThe Most Controversial Method\n\nFour out of five developers were able to understand the method with a low effort ( 2 minutes). One of the developers took longer (5 minutes). He explained that he had no experience with SQL dialects. However, in the end, all of them were able to understand the method. Three of the developers were familiar with SQL dialects and Hibernate, and they took shorter than the average to understand the snippet. All the developers agreed that the method is understandable (Q 1 ). However, three out of five developers explicitly said that a good knowledge of SQL dialects and, partially, of Hibernate is necessary to understand this method; conversely, one developer said that the lack of knowledge on SQL dialects would have just increased the time needed to understand, but the method would have been easy to understand anyway.\n\nAll the developers appreciated the good names and the good quality of comments and Javadoc (Q 2 ) and four out of five developers said that there are no negative aspects of this method in terms of understandability and that they would not change it (Q 3 ). Matteo, on the other hand, said that, in general, he would have divided the method in three private methods: one for the columns, one for the SQL properties, and one for the functions. However, he said that it is not strictly necessary in this specific case, because the dialect is easy.\n\nThe interviews suggest that this method was the most controversial in our study due to differences in background among the developers. Such subjectivity may have strongly influenced the time needed to understand the snippet. While the subjectivity of this method emerged from the survey we conducted, on the other hand the five developers we interviewed seemed to agree that the method is understandable. This is most likely due to the fact that they are all professional and experienced developers.\n\n\nThe Most Deceiving Method\n\nThree out of five developers said that they understood the method and that they found the method understandable (Q 1 ). Two developers said that it would take longer to fully understand it. On average, the developers took about 5 minutes to understand the method. Interestingly, when we asked them to precisely describe what the method does, one of the developers noticed that he actually did not understand the reason why a for loop was in the method. Therefore, in the end, only two developers actually understood the method.\n\nDifferently from the other methods for which developers often highlighted more or less the same positive/negative aspects in terms of its understandability (Q 2 ), for this method, each of them talked about a different positive aspect. Salvatore said that, despite the nesting, the conditions are quite simple and the blocks of the conditions are short. According to him, this facilitates the understanding of causes and effects in the code. Conversely, Matteo said that he did not like the many nested if controls, which make it hard to understand, according to him. Giovanni liked the names used, and he found them quite clear. Carlo, instead, did not like them, but he said that the fact that all the internal methods called in this snippet were in the same class improved the understandability of the method. Stefano did not find any positive aspects about this method. On the other hand, the developers said that some names, such as \"surrogate\", are uncommon and abstract, and they may hinder the understandability of the method (2 out of 5 developers); Matteo points out that the name of the method itself (processChar) is too generic and ambiguous. The redundancy in some parts of the method is definitely a negative aspect. The method contains two very similar blocks of code (4 out of 5 developers). They all suggest to remove this repetition (Q 3 ).\n\nTo understand this snippet, three developers looked only at the code of the method, while two of them found it useful to look at the only method in the class that calls the snippet's method. Table 9 provides a summary of the factors that the developers mentioned at least once during the interview. The quality of the identifiers is mentioned by all of them, but also code readability and comments seem to be valuable, according to most of them.\n\nSummary for RQ 3 . There is a diverse set of aspects considered by developers during code understanding. The interviewed developers (mostly) agree on a subset of aspects that are desirable (e.g., good identifiers, readability, and presence of comments) or undesirable (e.g., too many exit points) for having understandable code. However, we found no agreement on many other aspects and, above all, on the adopted understanding process.\n\n\nDiscussion\n\nIn our previous study [19], we showed that no single metric has a non-weak correlation with any proxy of understandability. Increasing the size of our dataset further reduced the correlations. Most noticeably, the number of metrics with a correlation with TNPU higher than |0.1| were ten in our previous study, and this number has been reduced to just one with the larger dataset.\n\nWe also tried to combine these metrics in classification and regression models to predict different aspects of code understandability. In a previous study, Trockman et al. [32] used LASSO regression to classify ABU 50% , and they achieved an AUC of 0.64. We achieved a higher AUC for the classification of ABU 50% (0.72) and a comparable AUC for PBU (0.69) and BD 50% (0.70). However, looking at the F-Measure, it is clear that the prediction model would not be useful in practice. Compared to the readability models, understandability models are much less effective and practically unusable. Combining metrics in regression models to predict TNPU, AU and TAU also shows the limits of the metrics, which can achieve a maximum correlation of 0.37 (with AU). Therefore, we can confirm the negative result of our previous study: the metrics we investigated are not enough to capture code understandability. However, as previously hinted by Trockman et al. [32], combining metrics helps to achieve better results as compared to single metrics for most of the understandability proxies.\n\nIn the interviews that we conducted, we found that developers perceive readability as an aspect that highly influences code understandability. However, this contradicts our quantitative results. It is possible that we did not capture any correlation between readability and understandability because we measured the understandability effort only by using the time spent to understand a snippet as a proxy. A factor that we ignore here is the mental effort actually needed to understand a snippet. It could be that unreadable code makes developers more tired in the long run, but when focusing on a single snippet this does not result in noticeable differences in terms of comprehension time and it does not affect the correctness of the understandability process. Experienced developers, who had the chance of working both with readable and unreadable code for longer periods, consider this as an important aspect because they feel it affects their overall performance. The same may be true for other aspects associated to code readability (such as the quality of identifiers [14]). Most importantly, our interviews with developers show that each developer uses her own understanding process. When code is harder to understand, some look at the related classes, while others say they would run the code and use the debugger to understand it. One of the most surprising facts is that some developers found the least understandable snippet to be understandable. Finally, we found that the personal background of developers plays a crucial role in understanding: when the knowledge of a concept is lacking, it takes time to acquire such a knowledge. This may be the main limit of the metrics we introduced: We measure the \"knowledge\" contained in a snippet (e.g., with MIDQ and AEDQ), but we do not measure the knowledge that the developer already has. Our metrics may be valid for the \"average\" developer, but when we try to measure understandability at a personal level, they are not enough. This is confirmed by the results of RQ 0 , which show that our proxies of code understandability vary more when the same snippet is evaluated by different developers than when the same developer evaluates different snippets. Therefore, we can conclude that the effort in the prediction of code understandability should be directed in capturing subjective aspects of developers -their background knowledge and their experience -not only in quantitative terms (i.e., years of experience) but also in qualitative terms: the interviews suggest that when developers are not familiar with the topics in the code that they need to understand, they need to spend some time to search for information about them. Introducing new developer-related metrics considering their experience with specific topics (e.g., JDBC APIs) or design patterns (e.g., bridge design-pattern) could be useful to capture such aspects.\n\n\nTHREATS TO VALIDITY\n\nThreats to construct validity, concerning the relation between theory and observation, are mainly due to the measurements we performed, both in terms of the 121 metrics that we studied as well as when defining the six dependent variables for the understandability level. Concerning the 121 metrics, we tested our implementation and, when needed (e.g., for the IMSQ metric during the identifiers splitting/ expansion), relied on manual intervention to ensure the correctness of the computed metrics. As for the dependent variables, we tried to capture both the perceived and the actual code understandability in many ways. However, different results might be achieved combining correctness and time in different ways.\n\nThreats to internal validity concern external factors that we did not consider that could affect the variables and the relations being investigated. Since two of the understandability proxies are time-related (i.e., they are based on the time participants spent while understanding the code), it is possible that some participants were interrupted by external events while performing the comprehension task. For this reason, we replaced outliers for TNPU in the computation of TAU with the maximum TNPU that was not an outlier. An outlier was a participant requiring more than Q 3 \u00fe \u00f03 \u00c2 IQR\u00de seconds to understand a code snippet, where Q 3 is the third quartile and IQR is the Inter Quartile Range. We used leave-one-out cross-validation to evaluate all the models used to answer RQ 2 . This means that some of the evaluations of the same developer were used in the training set. This could allow the models to learn some peculiarities about the preferences of the developer. It is worth noting that such evaluations represent a large minority of the training instances (< 2 percent) and they are unlikely to heavily affect the trained model. Also, our assumption is that, in a real use-case scenario, developers might contribute understandability evaluations to the training set. We acknowledge that this assumption may not hold in all the contexts. As for RQ 3 , the think-aloud strategy we used to get qualitative data could have affected the performance of the developers. Previous studies were conducted to assess the limitations of the non-metacognitive protocols, such as think-aloud [48]: These studies conclude that the latency, i.e., the time needed to perform a task, is generally affected when using such protocols [49], [50], [51], [52]; on the other hand, most of them agree that there is no effect on the accuracy [49], [50], [51], [52], [53], [54]. To minimize such limitations, we did not ask questions while the developers were reading and understanding the code. Finally, it is worth noting that the results of the survey are valid for short-term comprehension tasks: it is possible that other factors affect understandability when developers need to comprehend code for long periods of time (e.g., a working day).\n\nThreats to conclusion validity concern the relation between the treatment and the outcome. The results of RQ 2 may depend on the used machine learning techniques. To limit this threat, we used the most common and widespread machine learning techniques, being careful to choose them from different families, such as tree-based, Bayesian, and neural networks. Also, such results may depend on the parameters used for the machine learning techniques. We always used the standard parameters provided by Weka [55] for all the machine learning techniques.\n\nThreats to external validity concern the generalizability of our findings. Our study has been performed on a large, but limited, set of metrics and by involving 63 participants comprehending a subset of 50 methods extracted from 10 Java systems. We increased the number of observation from our previous study [19] by 22 percent to improve the generalizability of our findings. All of the results hold for the considered population of participants and for Java code. Larger studies involving more participants and code snippets written in other languages should be performed to corroborate or contradict our results. The same is true for the developers involved in RQ 3 : even though the developers have diverse work experiences and specializations, they all were from the same country (Italy) with a similar educational background. Since we observed differences in their evaluation of code understandability, a more comprehensive study with a more diverse set of developers would be needed to generalize our results, and it may highlight other factors that underline the subjectivity of code understandability.\n\n\nCONCLUSION AND FUTURE WORK\n\nWe presented an empirical study investigating the correlation between code understandability and 121 metrics related to the code itself, to the available documentation, and to the developer who is understanding the code. We asked 63 developers to understand 50 Java snippets, and we gathered a total of 444 evaluations. We assessed the participants' perceived and actual understanding for each snippet they inspected and the time they needed for the comprehension process. Our results demonstrate that, in most of the cases, there is no correlation between the considered metrics and code understandability. In the few cases, where we observed a correlation, its magnitude is very small. Combining metrics generally results in models with some discriminatory power (classification) and with a higher correlation, compared to single metrics (regression). However, such models are still far from being usable in practice for the prediction of understandability. Finally, we reported interviews with software developers, which provide useful insights about what makes code understandable or not understandable. We noticed that each developer puts emphasis on some aspects of understandability, and they give a different level of importance to each aspect. Note that we used shallow/classic models in our study; deep models from the deep learning comunity should be used as part of future work, given their power to abstract and model complex relationships between input data and several abstraction layers, similar to the cognitive processes in the humans brain; as suggested by the interviews, developers exhibited some comonalities but also variabilities in the understandability process that might not be captured by classic models, thus, shallow models are not the best choice to predice/ measure understandability.\n\nOur study lays the foundations for future research on new metrics actually able to capture facets of code understandability. In our opinion, the state-of-the-art lacks developer-related metrics. Therefore, we think that future research should be aimed at defining more of such metrics to properly capture code understandability. To enable the research community to investigate this direction further, we publicly release our new dataset [33]. Simone Scalabrino received the bachelor's degree from the University of Molise, in 2013, defending a thesis about source code readability, advised by Rocco Oliveto and Denys Poshyvanyk, and the master's degree in computer science from the University of Salerno, in 2015, defending a thesis on Search Based Software Testing, advised by Andrea De Lucia. He is working toward the PhD degree at University of Molise, Italy. His research interests include software quality, testing and security. He received two ACM SIGSOFT Distinguished Paper awards at ICPC 2016 and ASE 2017. He served as Local Arrangement co-chair for SANER 2018. He is co-founder and CSO of datasound, a spin-off of the University of Molise. He is a member of the IEEE.\n\nGabriele Bavota received the PhD degree in computer science from the University of Salerno, Italy, in 2013. He is a senior assistant professor with the Universit a della Svizzera italiana (USI), Switzerland. His research interests include software maintenance, empirical software engineering, and mining software repository. He is the author of more than 110 papers appeared in international journals and conferences. He received four ACM SIGSOFT Distinguished Paper awards at ASE 2013, ESEC-FSE 2015, ICSE 2015, and ASE 2017, an IEEE TCSE Distinguished Paper award at ICSME 2018, the best paper award at SCAM 2012, and three distinguished reviewer awards at WCRE 2012, SANER 2015, and MSR 2015. He is the recipient of the 2018 ACM Sigsoft Early Career Researcher Award. He served as a Program Co-Chair for ICPC'16, SCAM'16, and SANER'17. He also serves and has served as organizing and program committee member of international conferences in the field of software engineering, such as ICSE, FSE, ASE, ICSME, MSR, SANER, ICPC, SCAM, and others. He is a member of the IEEE.\n\nChristopher Vendome received the BS degree in computer science from Emory University, in 2012, the MS degree in computer science from the College of William & Mary, in 2014, and the PhD degree in computer science from the College of William & Mary, in 2018. He is an assistant professor at Miami University in Ohio. His main research areas are software maintenance and evolution, mining software repositories, program comprehension, software provenance, and software licensing. He has received an ACM Distinguished Paper Award at ASE 2017. He is a member of ACM, IEEE, and IEEE Computer Society.\n\nMario Linares-V asquez received the BS degree in systems engineering from Universidad Nacional de Colombia, in 2005, the MS degree in systems engineering and computing from Universidad Nacional de Colombia, in 2009, and the PhD degree in computer science from the College of William and Mary, in 2016. He is an assistant professor at Universidad de los Andes in Colombia. His research interests include software evolution and maintenance, software architecture, mining software repositories, application of data mining and machine learning techniques to support software engineering tasks, and mobile development. He is a member of the IEEE.\n\nRQ 3 :\n3Structured Interviews with Developers.\n\nFig. 1 .\n1Participants to the study.\n\nFig. 2 .\n2Actual code vs aligned code (first snippet).\n\nTABLE 1 Candidate\n1Predictors for Code UnderstandabilityMetric \nNon-aggregated \nMin \nAvg \nMax \nDFT \nVisual \nArea \n\nCode \n\nCyclomatic comp. \n[29] \n#nested blocks \n[29] \n#parameters \n[29] \n#statements \n[29] \n#assignments \n[10] \n[12] \n#blank lines \n[10] \n#characters \n[10] \n#commas \n[10] \n[12] \n#comments \n[10] \n[12] \n[12] \n[12] \n#comparisons \n[10] \n[12] \n#conditionals \n[10] \n[12] \n#identifiers \n[29] \n[10] \n[10] \n[12] \n[12] \n[12] \n#keywords \n[10] \n[10] \n[12] \n[12] \n[12] \n#literals \n[12] \n[12] \n#loops \n[10] \n[12] \n#numbers \n[10] \n[10] \n[12] \n[12] \n[12] \n#operators \n[10] \n[12] \n[12] \n[12] \n#parenthesis \n[10] \n[12] \n#periods \n[10] \n[12] \n#spaces \n[10] \n[12] \n#strings \n[12] \n[12] \n#words \n[10] \nIndentation length \n[10] \n[10] \n[12] \nIdentifiers length \n[10] \n[10] \nLine length \n[10] \n[10] \n[12] \n#aligned blocks \n[12] \nExt. of alig. blocks \n[12] \nEntropy \n[11] \nLOC \n[11] \nVolume \n[11] \nNMI \n[14] \n[14] \n[14] \nNM \n[14] \n[14] \nITID \n[14] \n[14][12] \nTC \n[14] \n[14] \n[14] \nReadability \n[14] \nIMSQ \n[19] \n[19] \n[19] \n\nDocs \n\nCR \n[14] \nCIC \n[14] \n[14] \nCIC syn \n[14] \n[14] \nMIDQ \n[19] \n[19] \n[19] \nAEDQ \n[19] \n[19] \n[19] \n\nDevs \nEAP \n[19] \n[19] \n[19] \nPE gen \n[19] \nPE spec \n\n\nTABLE 2 Systems\n2Used in Our StudySystem \nJava KLOC Category \nDescription \n\nANTLR \n178 \nDesktop \nLexer-parser \nCar-report \n45 \nMobile \nCar costs monitoring \nHibernate \n948 \nFramework \nORM framework \nJenkins \n231 \nWeb \nContinuous integration \nK9 mail \n121 \nMobile \nMail client \nMyExpenses \n101 \nMobile \nBudget monitoring \nOpenCMS \n1059 \nWeb \nContent Management System \nPhoenix \n352 \nFramework \nRelational database engine \nSpring \n197 \nFramework Generic application framework \nWeka \n657 \nDesktop \nMachine-learning toolkit \n\n\n\nTABLE 3\n3Position and Experience of the Interviewed DevelopersName \nPosition \nProgramming \nexperience \n\nSalvatore Geremia \nPhD Student @ Unimol \n8 years \nGiovanni Grano \nPhD Student @ Uzh \n8 years \nStefano Dalla Palma Android developer @ Datasound \n5 years \nCarlo Branca \nFront-end developer @ Gatelab \n8 years \nMatteo Merola \nBack-end developer @ Bunq \n8 years \n\n\n\nTABLE 4 Methods\n4Used During the Interviews with DevelopersSystem \nClass \nMethod \nType \nURL \n\nOpenCMS \nCmsHoverbarContextMenuButton createContextMenu \nThe most understandable (TAU \u00bc 0:74) \nhttps://git.io/vpHzL \nPhoenix \nMetaDataEndpointImpl \ndoDropSchema \nThe least understandable (TAU \u00bc 0:06) \nhttps://git.io/vpHzm \nHibernate \nTimesTenDialect \nTimesTenDialect \nThe most subjective (sd\u00f0TAU\u00de \u00bc 0:46) \nhttps://git.io/vpHzs \nMyExpenses \nLazyFontSelector \nprocessChar \nThe most deceptive (TNPU \u00bc 391:0, #BD 50% \u00bc 2) https://git.io/vpHzZ \n\n\nTABLE 5\n5Mean Variance of the Proxies Among Snippets \nand Developers (Lower Values Imply More \nSimilar Scores) \n\nAU \nTNPU \nTAU \n\nV s \nP (BsC) \n0.11 \n61,683 \n0.08 \nV s \nP (MsC) \n0.06 \n4,209 \n0.03 \nV s \nP (PhD) \n0.09 \n24,924 \n0.10 \nV s \nP (Professional) \n0.07 \n42,425 \n0.07 \nV s \n\nP \n\n0.13 \n34,294 \n0.10 \nV d \n\nP \n\n0.12 \n26,109 \n0.09 \n\n\nTABLE 6 Features\n6Selected for at Least Two ProxiesFeature PBU ABU 50% BD 50% TNPU AU TAU\n\nTABLE 7 Classification\n7Results of PBU, ABU 50% , and BD 50%Classifier \nPBU \nABU 50% \nBD 50% \n\nF-Measure AUC F-Measure AUC F-Measure AUC \n\nLogistic \n0.68 \n0.71 \n0.63 \n0.71 \n0.72 \n0.71 \nkNN \n0.62 \n0.63 \n0.59 \n0.66 \n0.74 \n0.66 \nSMO \n0.64 \n0.63 \n0.63 \n0.63 \n0.71 \n0.63 \nNaive Bayes \n0.60 \n0.65 \n0.66 \n0.68 \n0.63 \n0.66 \nRandom Forest \n0.65 \n0.63 \n0.67 \n0.72 \n0.77 \n0.64 \nML Perceptron \n0.66 \n0.69 \n0.63 \n0.70 \n0.70 \n0.70 \n\n\n\nTABLE 8 Regression\n8Results of TNPU, AU, and TAURegressor \nTNPU \nAU \nTAU \n\nCorrelation MAE Correlation MAE Correlation MAE \n\nLinear Regression \n0.14 \n132.9 \n0.35 \n0.30 \n0.36 \n0.27 \nkNN \n0.11 \n137.1 \n0.26 \n0.31 \n0.21 \n0.28 \nSMOreg \n0.17 \n114.4 \n0.36 \n0.29 \n0.29 \n0.27 \nRandom Forest \n0.09 \n147.0 \n0.34 \n0.29 \n0.29 \n0.28 \nML Perceptron \n0.18 \n124.8 \n0.37 \n0.30 \n0.36 \n0.27 \n\n\nTABLE 9 Factors\n9Mentioned by the ParticipantsFactor \nMM \nSG \nGG \nSD \nCB \n\nQuality of Identifiers \n\u00c2 \n\u00c2 \n\u00c2 \n\u00c2 \n\u00c2 \nCode Readability \n\u00c2 \n\u00c2 \n\u00c2 \n\u00c2 \nPresence of Comments \n\u00c2 \n\u00c2 \n\u00c2 \n\u00c2 \n# Exit Points \n\u00c2 \n\u00c2 \n\u00c2 \nDocumentation Quality \n\u00c2 \n\u00c2 \n\u00c2 \n# Responsibilities \n\u00c2 \n\u00c2 \n\u00c2 \nQuality of the Class \n\u00c2 \n\u00c2 \n\u00c2 \n# Parameters \n\u00c2 \n\u00c2 \nNesting \n\u00c2 \n\u00c2 \nQuality of Dependencies \n\u00c2 \n\u00c2 \nApplication Domain \n\u00c2 \n\u00c2 \nCode repetitions \n\u00c2 \n\u00c2 \nBroken Lines \n\u00c2 \n\u00c2 \nControl Flow \n\u00c2 \n\u00c2 \n\nIEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 47, NO. 3, MARCH 2021\n. Some metrics cannot be computed in some cases. For example, \"Area of comments/literals\" cannot be computed if the method does not contain literals.\n\" For more information on this or any other computing topic, please visit our Digital Library at www.computer.org/csdl.\nACKNOWLEDGMENTSBavota was supported in part by the SNF project JITRA, No. 172479. Poshyvanyk was supported in part by the NSF CCF-1525902 grant. Any opinions, findings, and conclusions expressed herein are the authors and do not necessarily reflect those of the sponsors.Rocco Oliveto is associate professor with the University of Molise, Italy, where he is also the chair of the Computer Science bachelor's and master's programs and the director of the Software and Knowledge Engineering Lab (STAKE Lab). He coauthored about 150 papers on topics related to software traceability, software maintenance and evolution, search-based software engineering, and empirical software engineering. His activities span various international software engineering research communities. He has served as organizing and program committee member of several international conferences in the field of software engineering. He was program co-chair of ICPC 2015, TEFSE 2015 and 2009, SCAM 2014, WCRE 2013 and 2012. He was also general chair at SANER 2018. He is also co-founder and CEO of datasound, a spin-off of the University of Molise aiming at efficiently exploiting the priceless heritage that can be extracted from big data. He is a member of the IEEE. More information available at: https://dibt.unimol.it/staff/ oliveto/\nI know what you did last summer -an investigation of how developers spend their time. R Minelli, A Mocci, M Lanza, Proc. 23rd IEEE Int. Conf. Program Comprehension. 23rd IEEE Int. Conf. Program ComprehensionR. Minelli, A. Mocci, and M. Lanza, \"I know what you did last sum- mer -an investigation of how developers spend their time,\" in Proc. 23rd IEEE Int. Conf. Program Comprehension, 2015, pp. 25-35.\n\nAn integrated measure of software maintainability. K K Aggarwal, Y Singh, J K Chhabra, Proc. Annu. Rel. Maintainability Symp. Annu. Rel. Maintainability SympK. K. Aggarwal, Y. Singh, and J. K. Chhabra, \"An integrated mea- sure of software maintainability,\" in Proc. Annu. Rel. Maintainabil- ity Symp., 2002, pp. 235-241.\n\nMeasuring Understandability of Aspect-Oriented Code. M Thongmak, P Muenchaisri, SpringerBerlin, GermanyM. Thongmak and P. Muenchaisri, Measuring Understandability of Aspect-Oriented Code. Berlin, Germany: Springer, 2011, pp. 43-54.\n\nA model for measuring software understandability. J C Lin, K C Wu, Proc. 6th IEEE Int. Conf. Comput. Inf. Technol. 6th IEEE Int. Conf. Comput. Inf. TechnolJ. C. Lin and K. C. Wu, \"A model for measuring software under- standability,\" in Proc. 6th IEEE Int. Conf. Comput. Inf. Technol., 2006, pp. 192-192.\n\nHow do professional developers comprehend software. T Roehm, R Tiarks, R Koschke, W Maalej, Proc. 34th Int. Conf. Softw. Eng. 34th Int. Conf. Softw. EngT. Roehm, R. Tiarks, R. Koschke, and W. Maalej, \"How do profes- sional developers comprehend software?\" in Proc. 34th Int. Conf. Softw. Eng., 2012, pp. 255-265.\n\nEvaluation of Software Understandability Using Rough Sets. D Srinivasulu, A Sridhar, D P Mohapatra, SpringerNew Delhi, IndiaD. Srinivasulu, A. Sridhar, and D. P. Mohapatra, Evaluation of Soft- ware Understandability Using Rough Sets. New Delhi, India: Springer, 2014, pp. 939-946.\n\nC Chen, R Alfayez, K Srisopha, L Shi, B Boehm, Evaluating Human-Assessed Software Maintainability Metrics. SingaporeSpringerC. Chen, R. Alfayez, K. Srisopha, L. Shi, and B. Boehm, Evaluating Human-Assessed Software Maintainability Metrics. Singapore: Springer, 2016, pp. 120-132.\n\nTheories, methods and tools in program comprehension: past, present and future. M A Storey, Proc. 13th Int. Workshop Program Comprehension. 13th Int. Workshop Program ComprehensionM. A. Storey, \"Theories, methods and tools in program compre- hension: past, present and future,\" in Proc. 13th Int. Workshop Pro- gram Comprehension, 2005, pp. 181-191.\n\nHow do program understanding tools affect how programmers understand programs?. M A D Storey, K Wong, H A Muller, \" in Proc. 4th Work. Conf. Reverse Eng. M. A. D. Storey, K. Wong, and H. A. Muller, \"How do program understanding tools affect how programmers understand pro- grams?\" in Proc. 4th Work. Conf. Reverse Eng., 1997, pp. 12-21.\n\nLearning a metric for code readability. R P L Buse, W Weimer, IEEE Trans. Softw. Eng. 364R. P. L. Buse and W. Weimer, \"Learning a metric for code read- ability,\" IEEE Trans. Softw. Eng., vol. 36, no. 4, pp. 546-558, Jul./Aug. 2010.\n\nA simpler model of software readability. D Posnett, A Hindle, P T Devanbu, Proc. 8th Work. Conf. Mining Softw. Repositories. 8th Work. Conf. Mining Softw. RepositoriesD. Posnett, A. Hindle, and P. T. Devanbu, \"A simpler model of software readability,\" in Proc. 8th Work. Conf. Mining Softw. Reposi- tories, 2011, pp. 73-82.\n\nA general software readability model. J Dorn, Department of Computer Science, Univ. VirginiaMaster's thesisJ. Dorn, \"A general software readability model,\" Master's thesis, Department of Computer Science, Univ. Virginia, 2012. [Online].\n\nModeling readability to improve unit tests. E Daka, J Campos, G Fraser, J Dorn, W Weimer, Proc. 10th Joint Meet. 10th Joint MeetE. Daka, J. Campos, G. Fraser, J. Dorn, and W. Weimer, \"Modeling readability to improve unit tests,\" in Proc. 10th Joint Meet. Eur. Softw. Eng. Conf. ACM SIGSOFT Symp. Foundations Softw. Eng., 2015, pp. 107-118.\n\nImproving code readability models with textual features. S Scalabrino, M Linares-V Asquez, D Poshyvanyk, R Oliveto, Proc. 24th IEEE Int. Conf. Program Comprehension. 24th IEEE Int. Conf. Program ComprehensionS. Scalabrino, M. Linares-V asquez, D. Poshyvanyk, and R. Oliveto, \"Improving code readability models with textual features,\" in Proc. 24th IEEE Int. Conf. Program Comprehension, 2016, pp. 1-10.\n\nA comprehensive model for code readability. S Scalabrino, M Linares-V Asquez, D Poshyvanyk, R Oliveto, J. Softw.: Evolution Process. 306Art. no. e1958S. Scalabrino, M. Linares-V asquez, D. Poshyvanyk, and R. Oliveto, \"A comprehensive model for code readability,\" J. Softw.: Evolution Process, vol. 30, no. 6, Jun. 2018, Art. no. e1958.\n\nEvaluation of software understandability based on fuzzy matrix. J.-C Lin, K.-C Wu, Proc. IEEE Int. Conf. Fuzzy Syst. IEEE Int. Conf. Fuzzy SystJ.-C. Lin and K.-C. Wu, \"Evaluation of software understandability based on fuzzy matrix,\" in Proc. IEEE Int. Conf. Fuzzy Syst., 2008, pp. 887-892.\n\nAn exploratory study of the effect of aspect-oriented programming on maintainability. M Bartsch, R Harrison, Softw. Quality J. 161M. Bartsch and R. Harrison, \"An exploratory study of the effect of aspect-oriented programming on maintainability,\" Softw. Quality J., vol. 16, no. 1, pp. 23-44, 2008.\n\nEvolution of understandability in OSS projects. A Capiluppi, M Morisio, P Lago, Proc. 8th Eur. Conf. Softw. Maintenance Reengineering. 8th Eur. Conf. Softw. Maintenance ReengineeringA. Capiluppi, M. Morisio, and P. Lago, \"Evolution of understand- ability in OSS projects,\" in Proc. 8th Eur. Conf. Softw. Maintenance Reengineering, 2004, pp. 58-66.\n\nAutomatically assessing code understandability: How far are we. S Scalabrino, G Bavota, C Vendome, M Linares-V Asquez, D Poshyvanyk, R Oliveto, Proc. 32nd IEEE/ACM Int. Conf. Automated Softw. Eng. 32nd IEEE/ACM Int. Conf. Automated Softw. EngS. Scalabrino, G. Bavota, C. Vendome, M. Linares-V asquez, D. Poshyvanyk, and R. Oliveto, \"Automatically assessing code understandability: How far are we?\" in Proc. 32nd IEEE/ACM Int. Conf. Automated Softw. Eng., 2017, pp. 417-427.\n\nEffective identifier names for comprehension and memory. D Lawrie, C Morrell, H Feild, D Binkley, Innovations Syst. and Softw. Eng. 34D. Lawrie, C. Morrell, H. Feild, and D. Binkley, \"Effective identi- fier names for comprehension and memory,\" Innovations Syst. and Softw. Eng., vol. 3, no. 4, pp. 303-318, 2007.\n\nWhat's in a name? a study of identifiers. D Lawrie, C Morrell, H Feild, D Binkley, Proc. 14th Int. Conf. Program Comprehension. 14th Int. Conf. Program ComprehensionD. Lawrie, C. Morrell, H. Feild, and D. Binkley, \"What's in a name? a study of identifiers,\" in Proc. 14th Int. Conf. Program Com- prehension, 2006.\n\nRestructuring program identifier names. B Caprile, P Tonella, Proc. Int. Conf. Softw. Maintenance. Int. Conf. Softw. MaintenanceB. Caprile and P. Tonella, \"Restructuring program identifier names,\" in Proc. Int. Conf. Softw. Maintenance, 2000, pp. 97-107.\n\nSyntactic identifier conciseness and consistency. D Lawrie, H Feild, D Binkley, Proc. 6th Int. Work. Conf. Source Code Anal. Manipulation. 6th Int. Work. Conf. Source Code Anal. ManipulationD. Lawrie, H. Feild, and D. Binkley, \"Syntactic identifier concise- ness and consistency,\" in Proc. 6th Int. Work. Conf. Source Code Anal. Manipulation, 2006, pp. 139-148.\n\nMining source code to automatically split identifiers for software analysis. E Enslen, E Hill, L L Pollock, K Vijay-Shanker, Proc. 6th Work. Conf. Mining Softw. Repositories. 6th Work. Conf. Mining Softw. RepositoriesE. Enslen, E. Hill, L. L. Pollock, and K. Vijay-Shanker, \"Mining source code to automatically split identifiers for software analysis,\" in Proc. 6th Work. Conf. Mining Softw. Repositories, 2009, pp. 71-80.\n\nLinguistic antipatterns: What they are and how developers perceive them. V Arnaoudova, M Dipenta, G Antoniol, Empirical Softw. Eng. 211V. Arnaoudova, M. DiPenta, and G. Antoniol, \"Linguistic antipat- terns: What they are and how developers perceive them,\" Empiri- cal Softw. Eng., vol. 21, no. 1, pp. 104-158, 2015.\n\nComparative study of cognitive complexity measures. S Misra, I Akman, Proc. 23rd Int. Symp. Comput. 23rd Int. Symp. ComputS. Misra and I. Akman, \"Comparative study of cognitive complex- ity measures,\" in Proc. 23rd Int. Symp. Comput. Inf. Sci., Oct. 2008, pp. 1-4.\n\nEvaluating software complexity measures. E J Weyuker, IEEE Trans. Softw. Eng. 149E. J. Weyuker, \"Evaluating software complexity measures,\" IEEE Trans. Softw. Eng., vol. 14, no. 9, pp. 1357-1365, Sep. 1988.\n\nA hierarchical model for objectoriented design quality assessment. J Bansiya, C G Davis, IEEE Trans. Softw. Eng. 281J. Bansiya and C. G. Davis, \"A hierarchical model for object- oriented design quality assessment,\" IEEE Trans. Softw. Eng., vol. 28, no. 1, pp. 4-17, Jan. 2002.\n\nMeasuring the difficulty of code comprehension tasks using software metrics. N Kasto, J Whalley, Proc. 15th Australasian Comput. 15th Australasian ComputN. Kasto and J. Whalley, \"Measuring the difficulty of code com- prehension tasks using software metrics,\" in Proc. 15th Austral- asian Comput. Edu. Conf., 2013, pp. 59-65.\n\nAn approach to experimental evaluation of software understandability. K Shima, Y Takemura, K Matsumoto, Proc. Int. Symp. Empirical Softw. Eng. Int. Symp. Empirical Softw. EngK. Shima, Y. Takemura, and K. Matsumoto, \"An approach to experimental evaluation of software understandability,\" in Proc. Int. Symp. Empirical Softw. Eng., 2002, pp. 48-55.\n\nISO/IEC 9126-1:2001(E): Software Engineering -Product Quality -Part 1: Quality Model, ISO/IEC Std. ISO/IEC 9126-1:2001(E): Software Engineering -Product Quality - Part 1: Quality Model, ISO/IEC Std., 2001.\n\nautomatically assessing code understandability\" reanalyzed: Combined metrics matter. A Trockman, K Cates, M Mozina, T Nguyen, C , B Vasilescu, Proc. 15th Int. Conf. Mining Softwa Repositories. 15th Int. Conf. Mining Softwa RepositoriesA. Trockman, K. Cates, M. Mozina, T. Nguyen, C. K\u20ac astner, and B. Vasilescu, \"\"automatically assessing code understandability\" reanalyzed: Combined metrics matter,\" in Proc. 15th Int. Conf. Mining Softwa Repositories, 2018, pp. 314-318.\n\nReplication package. S Scalabrino, G Bavota, C Vendome, M Linares-V Asquez, D Poshyvanyk, R Oliveto, S. Scalabrino, G. Bavota, C. Vendome, M. Linares-V asquez, D. Poshyvanyk, and R. Oliveto, \"Replication package,\" 2019. [Online].\n\nA complexity measure. T J Mccabe, IEEE Trans. Softw. Eng. 4T. J. McCabe, \"A complexity measure,\" IEEE Trans. Softw. Eng., no. 4, pp. 308-320, Dec. 1976.\n\nHow to Write Plain English: A Book for Lawyers and Consumers. R F Flesch, HarpercollinsNew York, NY, USAR. F. Flesch, How to Write Plain English: A Book for Lawyers and Con- sumers. New York, NY, USA: Harpercollins, 1979.\n\nHow documentation evolves over time. D Schreck, V Dallmeier, T Zimmermann, Proc. 9th Int. Workshop Principles Softw. Evolution. 9th Int. Workshop Principles Softw. EvolutionD. Schreck, V. Dallmeier, and T. Zimmermann, \"How documentation evolves over time,\" in Proc. 9th Int. Workshop Principles Softw. Evolu- tion, 2007, pp. 4-10.\n\nAlgorithm Design. J Kleinberg, E Tardos, Pearson Education IndiaNoida, Uttar Pradesh, IndiaJ. Kleinberg and E. Tardos, Algorithm Design. Noida, Uttar Pradesh, India: Pearson Education India.\n\nExploratory data analysis. J W Tukey, Addison Wesley Longman, IncReading, MAJ. W. Tukey, \"Exploratory data analysis,\" Addison Wesley Long- man, Inc., Reading, MA, 1977.\n\nA new measure of rank correlation. M G Kendall, Biometrika. 301-2M. G. Kendall, \"A new measure of rank correlation,\" Biometrika, vol. 30, no. 1-2, 1938, Art. no. 81.\n\nStatistical Power Analysis for the Behavioral Sciences. J Cohen, Lawrence Earlbaum AssociatesMahwah, NJ, USA2nd ed.J. Cohen, Statistical Power Analysis for the Behavioral Sciences, 2nd ed. Mahwah, NJ, USA: Lawrence Earlbaum Associates, 1988.\n\nRidge estimators in logistic regression. S , Le Cessie, J C Van Houwelingen, Appl. statistics. 41S. Le Cessie and J. C. Van Houwelingen, \"Ridge estimators in logistic regression,\" Appl. statistics, vol. 41, pp. 191-201, 1992.\n\nEstimating continuous distributions in Bayesian classifiers. G H John, P Langley, Proc. 11th Conf. Uncertainty Artif. Intell. 11th Conf. Uncertainty Artif. IntellG. H. John and P. Langley, \"Estimating continuous distributions in Bayesian classifiers,\" in Proc. 11th Conf. Uncertainty Artif. Intell., 1995, pp. 338-345.\n\nFast training of support vector machines using sequential minimal optimization. J Platt, Advances in Kernel Methods-Support Vector Learning. Cambridge, MA, USAMIT PressJ. Platt, \"Fast training of support vector machines using sequential minimal optimization,\" in Advances in Kernel Methods-Support Vec- tor Learning, Cambridge, MA, USA: MIT Press, 1999, pp. 185-208.\n\nInstance-based learning algorithms. D W Aha, D Kibler, M K Albert, Mach. Learn. 61D. W. Aha, D. Kibler, and M. K. Albert, \"Instance-based learning algorithms,\" Mach. Learn., vol. 6, no. 1, pp. 37-66, 1991.\n\nRandom forests. L Breiman, Mach. Learn. 451L. Breiman, \"Random forests,\" Mach. Learn., vol. 45, no. 1, pp. 5-32, 2001.\n\nSmote: Synthetic minority over-sampling technique. N V Chawla, K W Bowyer, L O Hall, W P Kegelmeyer, J. Artif. Intell. Res. 16N. V. Chawla, K. W. Bowyer, L. O. Hall, and W. P. Kegelmeyer, \"Smote: Synthetic minority over-sampling technique,\" J. Artif. Intell. Res., vol. 16, pp. 321-357, 2002.\n\nImprovements to the SMO algorithm for SVM regression. S K Shevade, S S Keerthi, C Bhattacharyya, K R K Murthy, IEEE Trans. Neural Netw. 115S. K. Shevade, S. S. Keerthi, C. Bhattacharyya, and K. R. K. Murthy, \"Improvements to the SMO algorithm for SVM regression,\" IEEE Trans. Neural Netw., vol. 11, no. 5, pp. 1188-1193, Sep. 2000.\n\nThe Think-Aloud Controversy in Second Language Research. M A Bowles, Evanston, IL, USA: RoutledgeM. A. Bowles, The Think-Aloud Controversy in Second Language Research. Evanston, IL, USA: Routledge, 2010.\n\nMethodological issues in judgment and decision-making research: Concurrent verbal protocol validity and simultaneous traces of process. S F Biggs, A J Rosman, G K Sergenian, J. Behavioral Decision Making. 63S. F. Biggs, A. J. Rosman, and G. K. Sergenian, \"Methodological issues in judgment and decision-making research: Concurrent verbal protocol validity and simultaneous traces of process,\" J. Behavioral Decision Making, vol. 6, no. 3, pp. 187-206, 1993.\n\nVerbal protocol accuracy in fault diagnosis. J A Brinkman, Ergonom. 3611J. A. Brinkman, \"Verbal protocol accuracy in fault diagnosis,\" Ergonom., vol. 36, no. 11, pp. 1381-1397, 1993.\n\nDoes thinking aloud influence the structure of cognitive processes. U Lass, W Klettke, G , P Ruhlender, Oculomotor Control Cognitive Processes. R. Schmid & D. ZambarbieriAmsterdamNorth-Holland Publishing CoU. Lass, W. Klettke, G. L\u20ac uer, and P. Ruhlender, \"Does thinking aloud influence the structure of cognitive processes,\" In R. Schmid & D. Zambarbieri (Eds.), Oculomotor Control Cognitive Processes, pp. 385-396, Amsterdam: North-Holland Publishing Co.\n\nEvaluation of concurrent thinking aloud using eye-tracking data. D Rhenius, G Deffner, Proc. Human Factors Society Annu. Meeting. Human Factors Society Annu. Meeting34D. Rhenius and G. Deffner, \"Evaluation of concurrent thinking aloud using eye-tracking data,\" in Proc. Human Factors Society Annu. Meeting, 1990, vol. 34, pp. 1265-1269.\n\nAssessing cue usage in performance contexts: A comparison between eye-movement and concurrent verbal report methods. A Williams, K Davids, Behavior Res. Methods Instruments Comput. 293A. Williams and K. Davids, \"Assessing cue usage in performance contexts: A comparison between eye-movement and concurrent verbal report methods,\" Behavior Res. Methods Instruments Com- put., vol. 29, no. 3, pp. 364-375, 1997.\n\nReactivity in concurrent think-aloud protocols: Issues for research. J F Stratman, L Hamp-Lyons, Speaking about Writing: Reflections Res. Methodology. 8J. F. Stratman and L. Hamp-Lyons, \"Reactivity in concurrent think-aloud protocols: Issues for research,\" Speaking about Writing: Reflections Res. Methodology, vol. 8, pp. 89-111, 1994.\n\nThe weka data mining software: An update. M Hall, E Frank, G Holmes, B Pfahringer, P Reutemann, I H Witten, ACM SIGKDD Explorations Newsletter. 111M. Hall, E. Frank, G. Holmes, B. Pfahringer, P. Reutemann, and I. H. Witten, \"The weka data mining software: An update,\" ACM SIGKDD Explorations Newsletter, vol. 11, no. 1, pp. 10-18, 2009.\n", "annotations": {"author": "[{\"end\":80,\"start\":50},{\"end\":109,\"start\":81},{\"end\":142,\"start\":110},{\"end\":178,\"start\":143},{\"end\":208,\"start\":179},{\"end\":235,\"start\":209}]", "publisher": null, "author_last_name": "[{\"end\":79,\"start\":69},{\"end\":108,\"start\":102},{\"end\":141,\"start\":134},{\"end\":177,\"start\":161},{\"end\":207,\"start\":197},{\"end\":234,\"start\":227}]", "author_first_name": "[{\"end\":68,\"start\":62},{\"end\":101,\"start\":93},{\"end\":133,\"start\":122},{\"end\":160,\"start\":155},{\"end\":196,\"start\":191},{\"end\":226,\"start\":221}]", "author_affiliation": null, "title": "[{\"end\":47,\"start\":1},{\"end\":282,\"start\":236}]", "venue": null, "abstract": "[{\"end\":1788,\"start\":388}]", "bib_ref": "[{\"attributes\":{\"ref_id\":\"b0\"},\"end\":1878,\"start\":1875},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":2164,\"start\":2161},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":2169,\"start\":2166},{\"attributes\":{\"ref_id\":\"b3\"},\"end\":2174,\"start\":2171},{\"attributes\":{\"ref_id\":\"b4\"},\"end\":2179,\"start\":2176},{\"attributes\":{\"ref_id\":\"b5\"},\"end\":2184,\"start\":2181},{\"attributes\":{\"ref_id\":\"b6\"},\"end\":2189,\"start\":2186},{\"attributes\":{\"ref_id\":\"b7\"},\"end\":2512,\"start\":2509},{\"attributes\":{\"ref_id\":\"b8\"},\"end\":2517,\"start\":2514},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":2893,\"start\":2889},{\"attributes\":{\"ref_id\":\"b10\"},\"end\":2899,\"start\":2895},{\"attributes\":{\"ref_id\":\"b11\"},\"end\":2905,\"start\":2901},{\"attributes\":{\"ref_id\":\"b12\"},\"end\":2911,\"start\":2907},{\"attributes\":{\"ref_id\":\"b13\"},\"end\":2917,\"start\":2913},{\"attributes\":{\"ref_id\":\"b14\"},\"end\":2923,\"start\":2919},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":3668,\"start\":3664},{\"attributes\":{\"ref_id\":\"b10\"},\"end\":3674,\"start\":3670},{\"attributes\":{\"ref_id\":\"b11\"},\"end\":3680,\"start\":3676},{\"attributes\":{\"ref_id\":\"b12\"},\"end\":3686,\"start\":3682},{\"attributes\":{\"ref_id\":\"b13\"},\"end\":3692,\"start\":3688},{\"attributes\":{\"ref_id\":\"b14\"},\"end\":3698,\"start\":3694},{\"attributes\":{\"ref_id\":\"b3\"},\"end\":5191,\"start\":5188},{\"attributes\":{\"ref_id\":\"b5\"},\"end\":5196,\"start\":5193},{\"attributes\":{\"ref_id\":\"b15\"},\"end\":5202,\"start\":5198},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":5303,\"start\":5300},{\"attributes\":{\"ref_id\":\"b16\"},\"end\":5309,\"start\":5305},{\"attributes\":{\"ref_id\":\"b17\"},\"end\":5385,\"start\":5381},{\"attributes\":{\"ref_id\":\"b10\"},\"end\":5635,\"start\":5631},{\"attributes\":{\"ref_id\":\"b4\"},\"end\":5676,\"start\":5673},{\"attributes\":{\"ref_id\":\"b13\"},\"end\":5827,\"start\":5823},{\"attributes\":{\"ref_id\":\"b14\"},\"end\":5833,\"start\":5829},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":5859,\"start\":5855},{\"attributes\":{\"ref_id\":\"b18\"},\"end\":8061,\"start\":8057},{\"attributes\":{\"ref_id\":\"b19\"},\"end\":9773,\"start\":9769},{\"attributes\":{\"ref_id\":\"b20\"},\"end\":9779,\"start\":9775},{\"attributes\":{\"ref_id\":\"b21\"},\"end\":9785,\"start\":9781},{\"attributes\":{\"ref_id\":\"b22\"},\"end\":9791,\"start\":9787},{\"attributes\":{\"ref_id\":\"b23\"},\"end\":9797,\"start\":9793},{\"attributes\":{\"ref_id\":\"b13\"},\"end\":9879,\"start\":9875},{\"attributes\":{\"ref_id\":\"b24\"},\"end\":9885,\"start\":9881},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":10061,\"start\":10057},{\"attributes\":{\"ref_id\":\"b10\"},\"end\":10067,\"start\":10063},{\"attributes\":{\"ref_id\":\"b11\"},\"end\":10188,\"start\":10184},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":10324,\"start\":10320},{\"attributes\":{\"ref_id\":\"b10\"},\"end\":10330,\"start\":10326},{\"attributes\":{\"ref_id\":\"b11\"},\"end\":10336,\"start\":10332},{\"attributes\":{\"ref_id\":\"b13\"},\"end\":10342,\"start\":10338},{\"attributes\":{\"ref_id\":\"b14\"},\"end\":10348,\"start\":10344},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":10386,\"start\":10382},{\"attributes\":{\"ref_id\":\"b10\"},\"end\":10788,\"start\":10784},{\"end\":10867,\"start\":10859},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":10958,\"start\":10954},{\"attributes\":{\"ref_id\":\"b11\"},\"end\":11205,\"start\":11201},{\"attributes\":{\"ref_id\":\"b13\"},\"end\":12036,\"start\":12032},{\"attributes\":{\"ref_id\":\"b14\"},\"end\":12042,\"start\":12038},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":12347,\"start\":12343},{\"attributes\":{\"ref_id\":\"b11\"},\"end\":12361,\"start\":12357},{\"attributes\":{\"ref_id\":\"b3\"},\"end\":13123,\"start\":13120},{\"attributes\":{\"ref_id\":\"b8\"},\"end\":13128,\"start\":13125},{\"attributes\":{\"ref_id\":\"b3\"},\"end\":13283,\"start\":13280},{\"attributes\":{\"ref_id\":\"b25\"},\"end\":13854,\"start\":13850},{\"attributes\":{\"ref_id\":\"b26\"},\"end\":14200,\"start\":14196},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":14381,\"start\":14378},{\"attributes\":{\"ref_id\":\"b5\"},\"end\":14520,\"start\":14517},{\"attributes\":{\"ref_id\":\"b17\"},\"end\":15004,\"start\":15000},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":15637,\"start\":15634},{\"attributes\":{\"ref_id\":\"b6\"},\"end\":16116,\"start\":16113},{\"attributes\":{\"ref_id\":\"b27\"},\"end\":16488,\"start\":16484},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":17266,\"start\":17263},{\"attributes\":{\"ref_id\":\"b3\"},\"end\":17271,\"start\":17268},{\"attributes\":{\"ref_id\":\"b5\"},\"end\":17276,\"start\":17273},{\"attributes\":{\"ref_id\":\"b16\"},\"end\":17282,\"start\":17278},{\"attributes\":{\"ref_id\":\"b17\"},\"end\":17288,\"start\":17284},{\"attributes\":{\"ref_id\":\"b25\"},\"end\":17294,\"start\":17290},{\"attributes\":{\"ref_id\":\"b27\"},\"end\":17300,\"start\":17296},{\"attributes\":{\"ref_id\":\"b28\"},\"end\":17678,\"start\":17674},{\"attributes\":{\"ref_id\":\"b29\"},\"end\":18226,\"start\":18222},{\"attributes\":{\"ref_id\":\"b4\"},\"end\":18557,\"start\":18554},{\"attributes\":{\"ref_id\":\"b30\"},\"end\":19172,\"start\":19168},{\"attributes\":{\"ref_id\":\"b7\"},\"end\":19269,\"start\":19266},{\"attributes\":{\"ref_id\":\"b8\"},\"end\":19274,\"start\":19271},{\"attributes\":{\"ref_id\":\"b3\"},\"end\":19536,\"start\":19533},{\"attributes\":{\"ref_id\":\"b15\"},\"end\":19542,\"start\":19538},{\"attributes\":{\"ref_id\":\"b31\"},\"end\":19580,\"start\":19576},{\"attributes\":{\"ref_id\":\"b18\"},\"end\":19645,\"start\":19641},{\"attributes\":{\"ref_id\":\"b31\"},\"end\":19864,\"start\":19860},{\"attributes\":{\"ref_id\":\"b31\"},\"end\":20413,\"start\":20409},{\"attributes\":{\"ref_id\":\"b7\"},\"end\":20762,\"start\":20759},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":21356,\"start\":21352},{\"attributes\":{\"ref_id\":\"b18\"},\"end\":21518,\"start\":21514},{\"attributes\":{\"ref_id\":\"b11\"},\"end\":22258,\"start\":22254},{\"attributes\":{\"ref_id\":\"b32\"},\"end\":22387,\"start\":22383},{\"attributes\":{\"ref_id\":\"b28\"},\"end\":22633,\"start\":22629},{\"attributes\":{\"ref_id\":\"b33\"},\"end\":22661,\"start\":22657},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":23027,\"start\":23023},{\"attributes\":{\"ref_id\":\"b10\"},\"end\":23033,\"start\":23029},{\"attributes\":{\"ref_id\":\"b11\"},\"end\":23039,\"start\":23035},{\"attributes\":{\"ref_id\":\"b13\"},\"end\":23045,\"start\":23041},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":23093,\"start\":23089},{\"attributes\":{\"ref_id\":\"b10\"},\"end\":23374,\"start\":23370},{\"attributes\":{\"ref_id\":\"b11\"},\"end\":23426,\"start\":23422},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":23503,\"start\":23499},{\"attributes\":{\"ref_id\":\"b32\"},\"end\":24200,\"start\":24196},{\"attributes\":{\"ref_id\":\"b13\"},\"end\":24225,\"start\":24221},{\"attributes\":{\"ref_id\":\"b13\"},\"end\":24701,\"start\":24697},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":24962,\"start\":24958},{\"attributes\":{\"ref_id\":\"b11\"},\"end\":24968,\"start\":24964},{\"attributes\":{\"ref_id\":\"b13\"},\"end\":24974,\"start\":24970},{\"attributes\":{\"ref_id\":\"b18\"},\"end\":25773,\"start\":25769},{\"attributes\":{\"ref_id\":\"b13\"},\"end\":29895,\"start\":29891},{\"attributes\":{\"ref_id\":\"b34\"},\"end\":30107,\"start\":30103},{\"attributes\":{\"ref_id\":\"b35\"},\"end\":30798,\"start\":30794},{\"attributes\":{\"ref_id\":\"b34\"},\"end\":31374,\"start\":31370},{\"end\":32188,\"start\":32182},{\"attributes\":{\"ref_id\":\"b18\"},\"end\":35973,\"start\":35969},{\"attributes\":{\"ref_id\":\"b0\"},\"end\":41392,\"start\":41391},{\"attributes\":{\"ref_id\":\"b36\"},\"end\":41451,\"start\":41447},{\"attributes\":{\"ref_id\":\"b37\"},\"end\":49881,\"start\":49877},{\"attributes\":{\"ref_id\":\"b38\"},\"end\":51900,\"start\":51896},{\"attributes\":{\"ref_id\":\"b39\"},\"end\":52161,\"start\":52157},{\"attributes\":{\"ref_id\":\"b40\"},\"end\":53946,\"start\":53942},{\"attributes\":{\"ref_id\":\"b41\"},\"end\":53972,\"start\":53968},{\"attributes\":{\"ref_id\":\"b42\"},\"end\":54023,\"start\":54019},{\"attributes\":{\"ref_id\":\"b43\"},\"end\":54100,\"start\":54096},{\"attributes\":{\"ref_id\":\"b44\"},\"end\":54129,\"start\":54125},{\"attributes\":{\"ref_id\":\"b45\"},\"end\":55274,\"start\":55270},{\"attributes\":{\"ref_id\":\"b46\"},\"end\":56430,\"start\":56426},{\"attributes\":{\"ref_id\":\"b43\"},\"end\":56509,\"start\":56505},{\"attributes\":{\"ref_id\":\"b44\"},\"end\":56536,\"start\":56532},{\"attributes\":{\"ref_id\":\"b32\"},\"end\":59020,\"start\":59016},{\"attributes\":{\"ref_id\":\"b18\"},\"end\":61255,\"start\":61251},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":61849,\"start\":61845},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":62090,\"start\":62086},{\"attributes\":{\"ref_id\":\"b15\"},\"end\":63856,\"start\":63853},{\"attributes\":{\"ref_id\":\"b32\"},\"end\":70010,\"start\":70006},{\"attributes\":{\"ref_id\":\"b18\"},\"end\":81250,\"start\":81246},{\"attributes\":{\"ref_id\":\"b31\"},\"end\":81782,\"start\":81778},{\"attributes\":{\"ref_id\":\"b31\"},\"end\":82563,\"start\":82559},{\"attributes\":{\"ref_id\":\"b13\"},\"end\":83769,\"start\":83765},{\"attributes\":{\"ref_id\":\"b47\"},\"end\":87920,\"start\":87916},{\"attributes\":{\"ref_id\":\"b48\"},\"end\":88056,\"start\":88052},{\"attributes\":{\"ref_id\":\"b49\"},\"end\":88062,\"start\":88058},{\"attributes\":{\"ref_id\":\"b50\"},\"end\":88068,\"start\":88064},{\"attributes\":{\"ref_id\":\"b51\"},\"end\":88074,\"start\":88070},{\"attributes\":{\"ref_id\":\"b48\"},\"end\":88158,\"start\":88154},{\"attributes\":{\"ref_id\":\"b49\"},\"end\":88164,\"start\":88160},{\"attributes\":{\"ref_id\":\"b50\"},\"end\":88170,\"start\":88166},{\"attributes\":{\"ref_id\":\"b51\"},\"end\":88176,\"start\":88172},{\"attributes\":{\"ref_id\":\"b52\"},\"end\":88182,\"start\":88178},{\"attributes\":{\"ref_id\":\"b53\"},\"end\":88188,\"start\":88184},{\"attributes\":{\"ref_id\":\"b54\"},\"end\":89068,\"start\":89064},{\"attributes\":{\"ref_id\":\"b18\"},\"end\":89424,\"start\":89420},{\"attributes\":{\"ref_id\":\"b32\"},\"end\":92511,\"start\":92507}]", "figure": "[{\"attributes\":{\"id\":\"fig_0\"},\"end\":95611,\"start\":95564},{\"attributes\":{\"id\":\"fig_1\"},\"end\":95649,\"start\":95612},{\"attributes\":{\"id\":\"fig_2\"},\"end\":95705,\"start\":95650},{\"attributes\":{\"id\":\"tab_0\",\"type\":\"table\"},\"end\":96877,\"start\":95706},{\"attributes\":{\"id\":\"tab_1\",\"type\":\"table\"},\"end\":97401,\"start\":96878},{\"attributes\":{\"id\":\"tab_2\",\"type\":\"table\"},\"end\":97767,\"start\":97402},{\"attributes\":{\"id\":\"tab_3\",\"type\":\"table\"},\"end\":98303,\"start\":97768},{\"attributes\":{\"id\":\"tab_4\",\"type\":\"table\"},\"end\":98638,\"start\":98304},{\"attributes\":{\"id\":\"tab_5\",\"type\":\"table\"},\"end\":98729,\"start\":98639},{\"attributes\":{\"id\":\"tab_6\",\"type\":\"table\"},\"end\":99150,\"start\":98730},{\"attributes\":{\"id\":\"tab_7\",\"type\":\"table\"},\"end\":99524,\"start\":99151},{\"attributes\":{\"id\":\"tab_8\",\"type\":\"table\"},\"end\":99976,\"start\":99525}]", "paragraph": "[{\"end\":3421,\"start\":1804},{\"end\":3587,\"start\":3423},{\"end\":4285,\"start\":3589},{\"end\":4830,\"start\":4287},{\"end\":5386,\"start\":4832},{\"end\":6303,\"start\":5388},{\"end\":7042,\"start\":6305},{\"end\":7986,\"start\":7044},{\"end\":8097,\"start\":7988},{\"end\":9156,\"start\":8099},{\"end\":9513,\"start\":9186},{\"end\":10189,\"start\":9534},{\"end\":10767,\"start\":10191},{\"end\":11051,\"start\":10769},{\"end\":12012,\"start\":11053},{\"end\":12580,\"start\":12014},{\"end\":13267,\"start\":12616},{\"end\":13832,\"start\":13269},{\"end\":14360,\"start\":13834},{\"end\":14981,\"start\":14362},{\"end\":15521,\"start\":14983},{\"end\":16088,\"start\":15523},{\"end\":16464,\"start\":16090},{\"end\":17172,\"start\":16466},{\"end\":17937,\"start\":17174},{\"end\":18845,\"start\":17939},{\"end\":19543,\"start\":18847},{\"end\":20414,\"start\":19545},{\"end\":20763,\"start\":20466},{\"end\":22475,\"start\":20765},{\"end\":23284,\"start\":22500},{\"end\":24201,\"start\":23286},{\"end\":24975,\"start\":24203},{\"end\":25267,\"start\":24977},{\"end\":25340,\"start\":25269},{\"end\":25503,\"start\":25379},{\"end\":25564,\"start\":25505},{\"end\":25591,\"start\":25566},{\"end\":26995,\"start\":25593},{\"end\":27106,\"start\":26997},{\"end\":28452,\"start\":27158},{\"end\":29033,\"start\":28454},{\"end\":29652,\"start\":29035},{\"end\":29839,\"start\":29654},{\"end\":30270,\"start\":29873},{\"end\":30799,\"start\":30272},{\"end\":31549,\"start\":30843},{\"end\":32915,\"start\":31551},{\"end\":33227,\"start\":32945},{\"end\":33745,\"start\":33229},{\"end\":34175,\"start\":33747},{\"end\":35704,\"start\":34177},{\"end\":36564,\"start\":35743},{\"end\":37726,\"start\":36623},{\"end\":38134,\"start\":37756},{\"end\":38465,\"start\":38136},{\"end\":39070,\"start\":38492},{\"end\":40043,\"start\":39072},{\"end\":40364,\"start\":40045},{\"end\":41300,\"start\":40384},{\"end\":42570,\"start\":41302},{\"end\":43448,\"start\":42572},{\"end\":44040,\"start\":43450},{\"end\":45068,\"start\":44042},{\"end\":46022,\"start\":45070},{\"end\":46639,\"start\":46024},{\"end\":47309,\"start\":46641},{\"end\":48427,\"start\":47311},{\"end\":48857,\"start\":48447},{\"end\":49137,\"start\":48859},{\"end\":49363,\"start\":49139},{\"end\":49564,\"start\":49365},{\"end\":50173,\"start\":49566},{\"end\":50308,\"start\":50175},{\"end\":50603,\"start\":50310},{\"end\":50960,\"start\":50605},{\"end\":51334,\"start\":50994},{\"end\":51582,\"start\":51357},{\"end\":53112,\"start\":51584},{\"end\":53734,\"start\":53114},{\"end\":55050,\"start\":53736},{\"end\":55219,\"start\":55052},{\"end\":56198,\"start\":55221},{\"end\":57006,\"start\":56200},{\"end\":58943,\"start\":57008},{\"end\":59311,\"start\":58967},{\"end\":59748,\"start\":59339},{\"end\":60893,\"start\":59793},{\"end\":61010,\"start\":60895},{\"end\":62941,\"start\":61053},{\"end\":63175,\"start\":62943},{\"end\":63770,\"start\":63177},{\"end\":64112,\"start\":63772},{\"end\":64324,\"start\":64114},{\"end\":64476,\"start\":64326},{\"end\":64680,\"start\":64523},{\"end\":66010,\"start\":64699},{\"end\":66125,\"start\":66012},{\"end\":67250,\"start\":66402},{\"end\":68631,\"start\":67265},{\"end\":69406,\"start\":68633},{\"end\":69692,\"start\":69408},{\"end\":70011,\"start\":69741},{\"end\":70351,\"start\":70046},{\"end\":71118,\"start\":70353},{\"end\":73110,\"start\":71120},{\"end\":73953,\"start\":73146},{\"end\":75488,\"start\":73955},{\"end\":75936,\"start\":75490},{\"end\":76503,\"start\":75938},{\"end\":77360,\"start\":76537},{\"end\":77906,\"start\":77362},{\"end\":78407,\"start\":77908},{\"end\":78964,\"start\":78437},{\"end\":80325,\"start\":78966},{\"end\":80772,\"start\":80327},{\"end\":81209,\"start\":80774},{\"end\":81604,\"start\":81224},{\"end\":82687,\"start\":81606},{\"end\":85582,\"start\":82689},{\"end\":86322,\"start\":85606},{\"end\":88558,\"start\":86324},{\"end\":89109,\"start\":88560},{\"end\":90221,\"start\":89111},{\"end\":92068,\"start\":90252},{\"end\":93248,\"start\":92070},{\"end\":94323,\"start\":93250},{\"end\":94920,\"start\":94325},{\"end\":95563,\"start\":94922}]", "formula": "[{\"attributes\":{\"id\":\"formula_0\"},\"end\":25378,\"start\":25341},{\"attributes\":{\"id\":\"formula_1\"},\"end\":27157,\"start\":27107},{\"attributes\":{\"id\":\"formula_2\"},\"end\":30842,\"start\":30800},{\"attributes\":{\"id\":\"formula_3\"},\"end\":37755,\"start\":37727},{\"attributes\":{\"id\":\"formula_4\"},\"end\":50993,\"start\":50961},{\"attributes\":{\"id\":\"formula_5\"},\"end\":51356,\"start\":51335},{\"attributes\":{\"id\":\"formula_6\"},\"end\":66401,\"start\":66126}]", "table_ref": "[{\"attributes\":{\"ref_id\":\"tab_0\"},\"end\":21134,\"start\":21127},{\"attributes\":{\"ref_id\":\"tab_0\"},\"end\":21582,\"start\":21575},{\"attributes\":{\"ref_id\":\"tab_0\"},\"end\":24099,\"start\":24092},{\"attributes\":{\"ref_id\":\"tab_1\"},\"end\":40971,\"start\":40964},{\"attributes\":{\"ref_id\":\"tab_2\"},\"end\":46250,\"start\":46243},{\"attributes\":{\"ref_id\":\"tab_3\"},\"end\":47502,\"start\":47495},{\"attributes\":{\"ref_id\":\"tab_4\"},\"end\":59813,\"start\":59806},{\"attributes\":{\"ref_id\":\"tab_5\"},\"end\":64726,\"start\":64719},{\"attributes\":{\"ref_id\":\"tab_6\"},\"end\":65286,\"start\":65279},{\"attributes\":{\"ref_id\":\"tab_7\"},\"end\":67275,\"start\":67268},{\"attributes\":{\"ref_id\":\"tab_8\"},\"end\":80525,\"start\":80518}]", "section_header": "[{\"attributes\":{\"n\":\"1\"},\"end\":1802,\"start\":1790},{\"attributes\":{\"n\":\"2\"},\"end\":9184,\"start\":9159},{\"attributes\":{\"n\":\"2.1\"},\"end\":9532,\"start\":9516},{\"attributes\":{\"n\":\"2.2\"},\"end\":12614,\"start\":12583},{\"attributes\":{\"n\":\"3\"},\"end\":20464,\"start\":20417},{\"attributes\":{\"n\":\"3.1\"},\"end\":22498,\"start\":22478},{\"attributes\":{\"n\":\"3.2\"},\"end\":29871,\"start\":29842},{\"attributes\":{\"n\":\"3.3\"},\"end\":32943,\"start\":32918},{\"attributes\":{\"n\":\"4\"},\"end\":35741,\"start\":35707},{\"end\":36621,\"start\":36567},{\"attributes\":{\"n\":\"5\"},\"end\":38490,\"start\":38468},{\"attributes\":{\"n\":\"5.1\"},\"end\":40382,\"start\":40367},{\"attributes\":{\"n\":\"5.2\"},\"end\":48445,\"start\":48430},{\"attributes\":{\"n\":\"5.3\"},\"end\":58965,\"start\":58946},{\"attributes\":{\"n\":\"6\"},\"end\":59337,\"start\":59314},{\"attributes\":{\"n\":\"6.1\"},\"end\":59791,\"start\":59751},{\"attributes\":{\"n\":\"6.2\"},\"end\":61051,\"start\":61013},{\"attributes\":{\"n\":\"6.3\"},\"end\":64521,\"start\":64479},{\"attributes\":{\"n\":\"6.3.1\"},\"end\":64697,\"start\":64683},{\"attributes\":{\"n\":\"6.3.2\"},\"end\":67263,\"start\":67253},{\"attributes\":{\"n\":\"6.4\"},\"end\":69739,\"start\":69695},{\"attributes\":{\"n\":\"6.4.1\"},\"end\":70044,\"start\":70014},{\"attributes\":{\"n\":\"6.4.2\"},\"end\":73144,\"start\":73113},{\"attributes\":{\"n\":\"6.4.3\"},\"end\":76535,\"start\":76506},{\"attributes\":{\"n\":\"6.4.4\"},\"end\":78435,\"start\":78410},{\"attributes\":{\"n\":\"6.5\"},\"end\":81222,\"start\":81212},{\"attributes\":{\"n\":\"7\"},\"end\":85604,\"start\":85585},{\"attributes\":{\"n\":\"8\"},\"end\":90250,\"start\":90224},{\"end\":95571,\"start\":95565},{\"end\":95621,\"start\":95613},{\"end\":95659,\"start\":95651},{\"end\":95724,\"start\":95707},{\"end\":96894,\"start\":96879},{\"end\":97410,\"start\":97403},{\"end\":97784,\"start\":97769},{\"end\":98312,\"start\":98305},{\"end\":98656,\"start\":98640},{\"end\":98753,\"start\":98731},{\"end\":99170,\"start\":99152},{\"end\":99541,\"start\":99526}]", "table": "[{\"end\":96877,\"start\":95763},{\"end\":97401,\"start\":96913},{\"end\":97767,\"start\":97465},{\"end\":98303,\"start\":97828},{\"end\":98638,\"start\":98314},{\"end\":99150,\"start\":98791},{\"end\":99524,\"start\":99200},{\"end\":99976,\"start\":99572}]", "figure_caption": "[{\"end\":95611,\"start\":95573},{\"end\":95649,\"start\":95623},{\"end\":95705,\"start\":95661},{\"end\":95763,\"start\":95726},{\"end\":96913,\"start\":96896},{\"end\":97465,\"start\":97412},{\"end\":97828,\"start\":97786},{\"end\":98729,\"start\":98658},{\"end\":98791,\"start\":98755},{\"end\":99200,\"start\":99172},{\"end\":99572,\"start\":99543}]", "figure_ref": "[{\"attributes\":{\"ref_id\":\"fig_1\"},\"end\":59409,\"start\":59403},{\"attributes\":{\"ref_id\":\"fig_2\"},\"end\":71716,\"start\":71708}]", "bib_author_first_name": "[{\"end\":101714,\"start\":101713},{\"end\":101725,\"start\":101724},{\"end\":101734,\"start\":101733},{\"end\":102083,\"start\":102082},{\"end\":102085,\"start\":102084},{\"end\":102097,\"start\":102096},{\"end\":102106,\"start\":102105},{\"end\":102108,\"start\":102107},{\"end\":102407,\"start\":102406},{\"end\":102419,\"start\":102418},{\"end\":102637,\"start\":102636},{\"end\":102639,\"start\":102638},{\"end\":102646,\"start\":102645},{\"end\":102648,\"start\":102647},{\"end\":102944,\"start\":102943},{\"end\":102953,\"start\":102952},{\"end\":102963,\"start\":102962},{\"end\":102974,\"start\":102973},{\"end\":103265,\"start\":103264},{\"end\":103280,\"start\":103279},{\"end\":103291,\"start\":103290},{\"end\":103293,\"start\":103292},{\"end\":103488,\"start\":103487},{\"end\":103496,\"start\":103495},{\"end\":103507,\"start\":103506},{\"end\":103519,\"start\":103518},{\"end\":103526,\"start\":103525},{\"end\":103849,\"start\":103848},{\"end\":103851,\"start\":103850},{\"end\":104200,\"start\":104199},{\"end\":104204,\"start\":104201},{\"end\":104214,\"start\":104213},{\"end\":104222,\"start\":104221},{\"end\":104224,\"start\":104223},{\"end\":104498,\"start\":104497},{\"end\":104502,\"start\":104499},{\"end\":104510,\"start\":104509},{\"end\":104732,\"start\":104731},{\"end\":104743,\"start\":104742},{\"end\":104753,\"start\":104752},{\"end\":104755,\"start\":104754},{\"end\":105054,\"start\":105053},{\"end\":105298,\"start\":105297},{\"end\":105306,\"start\":105305},{\"end\":105316,\"start\":105315},{\"end\":105326,\"start\":105325},{\"end\":105334,\"start\":105333},{\"end\":105652,\"start\":105651},{\"end\":105666,\"start\":105665},{\"end\":105686,\"start\":105685},{\"end\":105700,\"start\":105699},{\"end\":106043,\"start\":106042},{\"end\":106057,\"start\":106056},{\"end\":106077,\"start\":106076},{\"end\":106091,\"start\":106090},{\"end\":106403,\"start\":106399},{\"end\":106413,\"start\":106409},{\"end\":106713,\"start\":106712},{\"end\":106724,\"start\":106723},{\"end\":106974,\"start\":106973},{\"end\":106987,\"start\":106986},{\"end\":106998,\"start\":106997},{\"end\":107339,\"start\":107338},{\"end\":107353,\"start\":107352},{\"end\":107363,\"start\":107362},{\"end\":107374,\"start\":107373},{\"end\":107394,\"start\":107393},{\"end\":107408,\"start\":107407},{\"end\":107807,\"start\":107806},{\"end\":107817,\"start\":107816},{\"end\":107828,\"start\":107827},{\"end\":107837,\"start\":107836},{\"end\":108106,\"start\":108105},{\"end\":108116,\"start\":108115},{\"end\":108127,\"start\":108126},{\"end\":108136,\"start\":108135},{\"end\":108419,\"start\":108418},{\"end\":108430,\"start\":108429},{\"end\":108685,\"start\":108684},{\"end\":108695,\"start\":108694},{\"end\":108704,\"start\":108703},{\"end\":109075,\"start\":109074},{\"end\":109085,\"start\":109084},{\"end\":109093,\"start\":109092},{\"end\":109095,\"start\":109094},{\"end\":109106,\"start\":109105},{\"end\":109495,\"start\":109494},{\"end\":109509,\"start\":109508},{\"end\":109520,\"start\":109519},{\"end\":109791,\"start\":109790},{\"end\":109800,\"start\":109799},{\"end\":110046,\"start\":110045},{\"end\":110048,\"start\":110047},{\"end\":110279,\"start\":110278},{\"end\":110290,\"start\":110289},{\"end\":110292,\"start\":110291},{\"end\":110567,\"start\":110566},{\"end\":110576,\"start\":110575},{\"end\":110886,\"start\":110885},{\"end\":110895,\"start\":110894},{\"end\":110907,\"start\":110906},{\"end\":111456,\"start\":111455},{\"end\":111468,\"start\":111467},{\"end\":111477,\"start\":111476},{\"end\":111487,\"start\":111486},{\"end\":111497,\"start\":111496},{\"end\":111501,\"start\":111500},{\"end\":111865,\"start\":111864},{\"end\":111879,\"start\":111878},{\"end\":111889,\"start\":111888},{\"end\":111900,\"start\":111899},{\"end\":111920,\"start\":111919},{\"end\":111934,\"start\":111933},{\"end\":112097,\"start\":112096},{\"end\":112099,\"start\":112098},{\"end\":112291,\"start\":112290},{\"end\":112293,\"start\":112292},{\"end\":112489,\"start\":112488},{\"end\":112500,\"start\":112499},{\"end\":112513,\"start\":112512},{\"end\":112802,\"start\":112801},{\"end\":112815,\"start\":112814},{\"end\":113003,\"start\":113002},{\"end\":113005,\"start\":113004},{\"end\":113181,\"start\":113180},{\"end\":113183,\"start\":113182},{\"end\":113369,\"start\":113368},{\"end\":113597,\"start\":113596},{\"end\":113602,\"start\":113600},{\"end\":113612,\"start\":113611},{\"end\":113614,\"start\":113613},{\"end\":113844,\"start\":113843},{\"end\":113846,\"start\":113845},{\"end\":113854,\"start\":113853},{\"end\":114183,\"start\":114182},{\"end\":114507,\"start\":114506},{\"end\":114509,\"start\":114508},{\"end\":114516,\"start\":114515},{\"end\":114526,\"start\":114525},{\"end\":114528,\"start\":114527},{\"end\":114694,\"start\":114693},{\"end\":114849,\"start\":114848},{\"end\":114851,\"start\":114850},{\"end\":114861,\"start\":114860},{\"end\":114863,\"start\":114862},{\"end\":114873,\"start\":114872},{\"end\":114875,\"start\":114874},{\"end\":114883,\"start\":114882},{\"end\":114885,\"start\":114884},{\"end\":115146,\"start\":115145},{\"end\":115148,\"start\":115147},{\"end\":115159,\"start\":115158},{\"end\":115161,\"start\":115160},{\"end\":115172,\"start\":115171},{\"end\":115189,\"start\":115188},{\"end\":115193,\"start\":115190},{\"end\":115482,\"start\":115481},{\"end\":115484,\"start\":115483},{\"end\":115766,\"start\":115765},{\"end\":115768,\"start\":115767},{\"end\":115777,\"start\":115776},{\"end\":115779,\"start\":115778},{\"end\":115789,\"start\":115788},{\"end\":115791,\"start\":115790},{\"end\":116134,\"start\":116133},{\"end\":116136,\"start\":116135},{\"end\":116341,\"start\":116340},{\"end\":116349,\"start\":116348},{\"end\":116360,\"start\":116359},{\"end\":116364,\"start\":116363},{\"end\":116796,\"start\":116795},{\"end\":116807,\"start\":116806},{\"end\":117186,\"start\":117185},{\"end\":117198,\"start\":117197},{\"end\":117549,\"start\":117548},{\"end\":117551,\"start\":117550},{\"end\":117563,\"start\":117562},{\"end\":117860,\"start\":117859},{\"end\":117868,\"start\":117867},{\"end\":117877,\"start\":117876},{\"end\":117887,\"start\":117886},{\"end\":117901,\"start\":117900},{\"end\":117914,\"start\":117913},{\"end\":117916,\"start\":117915}]", "bib_author_last_name": "[{\"end\":101722,\"start\":101715},{\"end\":101731,\"start\":101726},{\"end\":101740,\"start\":101735},{\"end\":102094,\"start\":102086},{\"end\":102103,\"start\":102098},{\"end\":102116,\"start\":102109},{\"end\":102416,\"start\":102408},{\"end\":102431,\"start\":102420},{\"end\":102643,\"start\":102640},{\"end\":102651,\"start\":102649},{\"end\":102950,\"start\":102945},{\"end\":102960,\"start\":102954},{\"end\":102971,\"start\":102964},{\"end\":102981,\"start\":102975},{\"end\":103277,\"start\":103266},{\"end\":103288,\"start\":103281},{\"end\":103303,\"start\":103294},{\"end\":103493,\"start\":103489},{\"end\":103504,\"start\":103497},{\"end\":103516,\"start\":103508},{\"end\":103523,\"start\":103520},{\"end\":103532,\"start\":103527},{\"end\":103858,\"start\":103852},{\"end\":104211,\"start\":104205},{\"end\":104219,\"start\":104215},{\"end\":104231,\"start\":104225},{\"end\":104507,\"start\":104503},{\"end\":104517,\"start\":104511},{\"end\":104740,\"start\":104733},{\"end\":104750,\"start\":104744},{\"end\":104763,\"start\":104756},{\"end\":105059,\"start\":105055},{\"end\":105303,\"start\":105299},{\"end\":105313,\"start\":105307},{\"end\":105323,\"start\":105317},{\"end\":105331,\"start\":105327},{\"end\":105341,\"start\":105335},{\"end\":105663,\"start\":105653},{\"end\":105683,\"start\":105667},{\"end\":105697,\"start\":105687},{\"end\":105708,\"start\":105701},{\"end\":106054,\"start\":106044},{\"end\":106074,\"start\":106058},{\"end\":106088,\"start\":106078},{\"end\":106099,\"start\":106092},{\"end\":106407,\"start\":106404},{\"end\":106416,\"start\":106414},{\"end\":106721,\"start\":106714},{\"end\":106733,\"start\":106725},{\"end\":106984,\"start\":106975},{\"end\":106995,\"start\":106988},{\"end\":107003,\"start\":106999},{\"end\":107350,\"start\":107340},{\"end\":107360,\"start\":107354},{\"end\":107371,\"start\":107364},{\"end\":107391,\"start\":107375},{\"end\":107405,\"start\":107395},{\"end\":107416,\"start\":107409},{\"end\":107814,\"start\":107808},{\"end\":107825,\"start\":107818},{\"end\":107834,\"start\":107829},{\"end\":107845,\"start\":107838},{\"end\":108113,\"start\":108107},{\"end\":108124,\"start\":108117},{\"end\":108133,\"start\":108128},{\"end\":108144,\"start\":108137},{\"end\":108427,\"start\":108420},{\"end\":108438,\"start\":108431},{\"end\":108692,\"start\":108686},{\"end\":108701,\"start\":108696},{\"end\":108712,\"start\":108705},{\"end\":109082,\"start\":109076},{\"end\":109090,\"start\":109086},{\"end\":109103,\"start\":109096},{\"end\":109120,\"start\":109107},{\"end\":109506,\"start\":109496},{\"end\":109517,\"start\":109510},{\"end\":109529,\"start\":109521},{\"end\":109797,\"start\":109792},{\"end\":109806,\"start\":109801},{\"end\":110056,\"start\":110049},{\"end\":110287,\"start\":110280},{\"end\":110298,\"start\":110293},{\"end\":110573,\"start\":110568},{\"end\":110584,\"start\":110577},{\"end\":110892,\"start\":110887},{\"end\":110904,\"start\":110896},{\"end\":110917,\"start\":110908},{\"end\":111465,\"start\":111457},{\"end\":111474,\"start\":111469},{\"end\":111484,\"start\":111478},{\"end\":111494,\"start\":111488},{\"end\":111511,\"start\":111502},{\"end\":111876,\"start\":111866},{\"end\":111886,\"start\":111880},{\"end\":111897,\"start\":111890},{\"end\":111917,\"start\":111901},{\"end\":111931,\"start\":111921},{\"end\":111942,\"start\":111935},{\"end\":112106,\"start\":112100},{\"end\":112300,\"start\":112294},{\"end\":112497,\"start\":112490},{\"end\":112510,\"start\":112501},{\"end\":112524,\"start\":112514},{\"end\":112812,\"start\":112803},{\"end\":112822,\"start\":112816},{\"end\":113011,\"start\":113006},{\"end\":113191,\"start\":113184},{\"end\":113375,\"start\":113370},{\"end\":113609,\"start\":113603},{\"end\":113630,\"start\":113615},{\"end\":113851,\"start\":113847},{\"end\":113862,\"start\":113855},{\"end\":114189,\"start\":114184},{\"end\":114513,\"start\":114510},{\"end\":114523,\"start\":114517},{\"end\":114535,\"start\":114529},{\"end\":114702,\"start\":114695},{\"end\":114858,\"start\":114852},{\"end\":114870,\"start\":114864},{\"end\":114880,\"start\":114876},{\"end\":114896,\"start\":114886},{\"end\":115156,\"start\":115149},{\"end\":115169,\"start\":115162},{\"end\":115186,\"start\":115173},{\"end\":115200,\"start\":115194},{\"end\":115491,\"start\":115485},{\"end\":115774,\"start\":115769},{\"end\":115786,\"start\":115780},{\"end\":115801,\"start\":115792},{\"end\":116145,\"start\":116137},{\"end\":116346,\"start\":116342},{\"end\":116357,\"start\":116350},{\"end\":116374,\"start\":116365},{\"end\":116804,\"start\":116797},{\"end\":116815,\"start\":116808},{\"end\":117195,\"start\":117187},{\"end\":117205,\"start\":117199},{\"end\":117560,\"start\":117552},{\"end\":117574,\"start\":117564},{\"end\":117865,\"start\":117861},{\"end\":117874,\"start\":117869},{\"end\":117884,\"start\":117878},{\"end\":117898,\"start\":117888},{\"end\":117911,\"start\":117902},{\"end\":117923,\"start\":117917}]", "bib_entry": "[{\"attributes\":{\"id\":\"b0\",\"matched_paper_id\":3710899},\"end\":102029,\"start\":101627},{\"attributes\":{\"id\":\"b1\",\"matched_paper_id\":60639321},\"end\":102351,\"start\":102031},{\"attributes\":{\"id\":\"b2\"},\"end\":102584,\"start\":102353},{\"attributes\":{\"id\":\"b3\",\"matched_paper_id\":5108064},\"end\":102889,\"start\":102586},{\"attributes\":{\"id\":\"b4\",\"matched_paper_id\":9956794},\"end\":103203,\"start\":102891},{\"attributes\":{\"id\":\"b5\"},\"end\":103485,\"start\":103205},{\"attributes\":{\"id\":\"b6\"},\"end\":103766,\"start\":103487},{\"attributes\":{\"id\":\"b7\",\"matched_paper_id\":17007528},\"end\":104117,\"start\":103768},{\"attributes\":{\"id\":\"b8\",\"matched_paper_id\":1645176},\"end\":104455,\"start\":104119},{\"attributes\":{\"id\":\"b9\",\"matched_paper_id\":650129},\"end\":104688,\"start\":104457},{\"attributes\":{\"id\":\"b10\",\"matched_paper_id\":7200084},\"end\":105013,\"start\":104690},{\"attributes\":{\"id\":\"b11\"},\"end\":105251,\"start\":105015},{\"attributes\":{\"id\":\"b12\",\"matched_paper_id\":6519970},\"end\":105592,\"start\":105253},{\"attributes\":{\"id\":\"b13\",\"matched_paper_id\":1489233},\"end\":105996,\"start\":105594},{\"attributes\":{\"id\":\"b14\",\"matched_paper_id\":51970521},\"end\":106333,\"start\":105998},{\"attributes\":{\"id\":\"b15\",\"matched_paper_id\":12787012},\"end\":106624,\"start\":106335},{\"attributes\":{\"id\":\"b16\",\"matched_paper_id\":7719846},\"end\":106923,\"start\":106626},{\"attributes\":{\"id\":\"b17\",\"matched_paper_id\":99762},\"end\":107272,\"start\":106925},{\"attributes\":{\"id\":\"b18\",\"matched_paper_id\":2326336},\"end\":107747,\"start\":107274},{\"attributes\":{\"id\":\"b19\",\"matched_paper_id\":305331},\"end\":108061,\"start\":107749},{\"attributes\":{\"id\":\"b20\"},\"end\":108376,\"start\":108063},{\"attributes\":{\"id\":\"b21\",\"matched_paper_id\":37578133},\"end\":108632,\"start\":108378},{\"attributes\":{\"id\":\"b22\",\"matched_paper_id\":3809988},\"end\":108995,\"start\":108634},{\"attributes\":{\"id\":\"b23\",\"matched_paper_id\":14588224},\"end\":109419,\"start\":108997},{\"attributes\":{\"id\":\"b24\",\"matched_paper_id\":16034273},\"end\":109736,\"start\":109421},{\"attributes\":{\"id\":\"b25\",\"matched_paper_id\":18527976},\"end\":110002,\"start\":109738},{\"attributes\":{\"id\":\"b26\",\"matched_paper_id\":42595830},\"end\":110209,\"start\":110004},{\"attributes\":{\"id\":\"b27\",\"matched_paper_id\":58377173},\"end\":110487,\"start\":110211},{\"attributes\":{\"id\":\"b28\",\"matched_paper_id\":27433285},\"end\":110813,\"start\":110489},{\"attributes\":{\"id\":\"b29\",\"matched_paper_id\":1016248},\"end\":111161,\"start\":110815},{\"attributes\":{\"id\":\"b30\"},\"end\":111368,\"start\":111163},{\"attributes\":{\"id\":\"b31\",\"matched_paper_id\":48362565},\"end\":111841,\"start\":111370},{\"attributes\":{\"id\":\"b32\"},\"end\":112072,\"start\":111843},{\"attributes\":{\"id\":\"b33\",\"matched_paper_id\":9116234},\"end\":112226,\"start\":112074},{\"attributes\":{\"id\":\"b34\"},\"end\":112449,\"start\":112228},{\"attributes\":{\"id\":\"b35\",\"matched_paper_id\":8450751},\"end\":112781,\"start\":112451},{\"attributes\":{\"id\":\"b36\"},\"end\":112973,\"start\":112783},{\"attributes\":{\"id\":\"b37\"},\"end\":113143,\"start\":112975},{\"attributes\":{\"id\":\"b38\",\"matched_paper_id\":120478295},\"end\":113310,\"start\":113145},{\"attributes\":{\"id\":\"b39\"},\"end\":113553,\"start\":113312},{\"attributes\":{\"id\":\"b40\",\"matched_paper_id\":123582503},\"end\":113780,\"start\":113555},{\"attributes\":{\"id\":\"b41\",\"matched_paper_id\":667586},\"end\":114100,\"start\":113782},{\"attributes\":{\"id\":\"b42\",\"matched_paper_id\":1099857},\"end\":114468,\"start\":114102},{\"attributes\":{\"id\":\"b43\",\"matched_paper_id\":44971656},\"end\":114675,\"start\":114470},{\"attributes\":{\"id\":\"b44\",\"matched_paper_id\":89141},\"end\":114795,\"start\":114677},{\"attributes\":{\"id\":\"b45\",\"matched_paper_id\":1554582},\"end\":115089,\"start\":114797},{\"attributes\":{\"id\":\"b46\",\"matched_paper_id\":12742298},\"end\":115422,\"start\":115091},{\"attributes\":{\"id\":\"b47\"},\"end\":115627,\"start\":115424},{\"attributes\":{\"id\":\"b48\",\"matched_paper_id\":62624181},\"end\":116086,\"start\":115629},{\"attributes\":{\"id\":\"b49\",\"matched_paper_id\":38091303},\"end\":116270,\"start\":116088},{\"attributes\":{\"id\":\"b50\"},\"end\":116728,\"start\":116272},{\"attributes\":{\"id\":\"b51\",\"matched_paper_id\":62242854},\"end\":117066,\"start\":116730},{\"attributes\":{\"id\":\"b52\",\"matched_paper_id\":143842896},\"end\":117477,\"start\":117068},{\"attributes\":{\"id\":\"b53\"},\"end\":117815,\"start\":117479},{\"attributes\":{\"id\":\"b54\",\"matched_paper_id\":13861754},\"end\":118153,\"start\":117817}]", "bib_title": "[{\"end\":101711,\"start\":101627},{\"end\":102080,\"start\":102031},{\"end\":102634,\"start\":102586},{\"end\":102941,\"start\":102891},{\"end\":103846,\"start\":103768},{\"end\":104197,\"start\":104119},{\"end\":104495,\"start\":104457},{\"end\":104729,\"start\":104690},{\"end\":105295,\"start\":105253},{\"end\":105649,\"start\":105594},{\"end\":106040,\"start\":105998},{\"end\":106397,\"start\":106335},{\"end\":106710,\"start\":106626},{\"end\":106971,\"start\":106925},{\"end\":107336,\"start\":107274},{\"end\":107804,\"start\":107749},{\"end\":108103,\"start\":108063},{\"end\":108416,\"start\":108378},{\"end\":108682,\"start\":108634},{\"end\":109072,\"start\":108997},{\"end\":109492,\"start\":109421},{\"end\":109788,\"start\":109738},{\"end\":110043,\"start\":110004},{\"end\":110276,\"start\":110211},{\"end\":110564,\"start\":110489},{\"end\":110883,\"start\":110815},{\"end\":111453,\"start\":111370},{\"end\":112094,\"start\":112074},{\"end\":112486,\"start\":112451},{\"end\":113178,\"start\":113145},{\"end\":113594,\"start\":113555},{\"end\":113841,\"start\":113782},{\"end\":114180,\"start\":114102},{\"end\":114504,\"start\":114470},{\"end\":114691,\"start\":114677},{\"end\":114846,\"start\":114797},{\"end\":115143,\"start\":115091},{\"end\":115763,\"start\":115629},{\"end\":116131,\"start\":116088},{\"end\":116338,\"start\":116272},{\"end\":116793,\"start\":116730},{\"end\":117183,\"start\":117068},{\"end\":117546,\"start\":117479},{\"end\":117857,\"start\":117817}]", "bib_author": "[{\"end\":101724,\"start\":101713},{\"end\":101733,\"start\":101724},{\"end\":101742,\"start\":101733},{\"end\":102096,\"start\":102082},{\"end\":102105,\"start\":102096},{\"end\":102118,\"start\":102105},{\"end\":102418,\"start\":102406},{\"end\":102433,\"start\":102418},{\"end\":102645,\"start\":102636},{\"end\":102653,\"start\":102645},{\"end\":102952,\"start\":102943},{\"end\":102962,\"start\":102952},{\"end\":102973,\"start\":102962},{\"end\":102983,\"start\":102973},{\"end\":103279,\"start\":103264},{\"end\":103290,\"start\":103279},{\"end\":103305,\"start\":103290},{\"end\":103495,\"start\":103487},{\"end\":103506,\"start\":103495},{\"end\":103518,\"start\":103506},{\"end\":103525,\"start\":103518},{\"end\":103534,\"start\":103525},{\"end\":103860,\"start\":103848},{\"end\":104213,\"start\":104199},{\"end\":104221,\"start\":104213},{\"end\":104233,\"start\":104221},{\"end\":104509,\"start\":104497},{\"end\":104519,\"start\":104509},{\"end\":104742,\"start\":104731},{\"end\":104752,\"start\":104742},{\"end\":104765,\"start\":104752},{\"end\":105061,\"start\":105053},{\"end\":105305,\"start\":105297},{\"end\":105315,\"start\":105305},{\"end\":105325,\"start\":105315},{\"end\":105333,\"start\":105325},{\"end\":105343,\"start\":105333},{\"end\":105665,\"start\":105651},{\"end\":105685,\"start\":105665},{\"end\":105699,\"start\":105685},{\"end\":105710,\"start\":105699},{\"end\":106056,\"start\":106042},{\"end\":106076,\"start\":106056},{\"end\":106090,\"start\":106076},{\"end\":106101,\"start\":106090},{\"end\":106409,\"start\":106399},{\"end\":106418,\"start\":106409},{\"end\":106723,\"start\":106712},{\"end\":106735,\"start\":106723},{\"end\":106986,\"start\":106973},{\"end\":106997,\"start\":106986},{\"end\":107005,\"start\":106997},{\"end\":107352,\"start\":107338},{\"end\":107362,\"start\":107352},{\"end\":107373,\"start\":107362},{\"end\":107393,\"start\":107373},{\"end\":107407,\"start\":107393},{\"end\":107418,\"start\":107407},{\"end\":107816,\"start\":107806},{\"end\":107827,\"start\":107816},{\"end\":107836,\"start\":107827},{\"end\":107847,\"start\":107836},{\"end\":108115,\"start\":108105},{\"end\":108126,\"start\":108115},{\"end\":108135,\"start\":108126},{\"end\":108146,\"start\":108135},{\"end\":108429,\"start\":108418},{\"end\":108440,\"start\":108429},{\"end\":108694,\"start\":108684},{\"end\":108703,\"start\":108694},{\"end\":108714,\"start\":108703},{\"end\":109084,\"start\":109074},{\"end\":109092,\"start\":109084},{\"end\":109105,\"start\":109092},{\"end\":109122,\"start\":109105},{\"end\":109508,\"start\":109494},{\"end\":109519,\"start\":109508},{\"end\":109531,\"start\":109519},{\"end\":109799,\"start\":109790},{\"end\":109808,\"start\":109799},{\"end\":110058,\"start\":110045},{\"end\":110289,\"start\":110278},{\"end\":110300,\"start\":110289},{\"end\":110575,\"start\":110566},{\"end\":110586,\"start\":110575},{\"end\":110894,\"start\":110885},{\"end\":110906,\"start\":110894},{\"end\":110919,\"start\":110906},{\"end\":111467,\"start\":111455},{\"end\":111476,\"start\":111467},{\"end\":111486,\"start\":111476},{\"end\":111496,\"start\":111486},{\"end\":111500,\"start\":111496},{\"end\":111513,\"start\":111500},{\"end\":111878,\"start\":111864},{\"end\":111888,\"start\":111878},{\"end\":111899,\"start\":111888},{\"end\":111919,\"start\":111899},{\"end\":111933,\"start\":111919},{\"end\":111944,\"start\":111933},{\"end\":112108,\"start\":112096},{\"end\":112302,\"start\":112290},{\"end\":112499,\"start\":112488},{\"end\":112512,\"start\":112499},{\"end\":112526,\"start\":112512},{\"end\":112814,\"start\":112801},{\"end\":112824,\"start\":112814},{\"end\":113013,\"start\":113002},{\"end\":113193,\"start\":113180},{\"end\":113377,\"start\":113368},{\"end\":113600,\"start\":113596},{\"end\":113611,\"start\":113600},{\"end\":113632,\"start\":113611},{\"end\":113853,\"start\":113843},{\"end\":113864,\"start\":113853},{\"end\":114191,\"start\":114182},{\"end\":114515,\"start\":114506},{\"end\":114525,\"start\":114515},{\"end\":114537,\"start\":114525},{\"end\":114704,\"start\":114693},{\"end\":114860,\"start\":114848},{\"end\":114872,\"start\":114860},{\"end\":114882,\"start\":114872},{\"end\":114898,\"start\":114882},{\"end\":115158,\"start\":115145},{\"end\":115171,\"start\":115158},{\"end\":115188,\"start\":115171},{\"end\":115202,\"start\":115188},{\"end\":115493,\"start\":115481},{\"end\":115776,\"start\":115765},{\"end\":115788,\"start\":115776},{\"end\":115803,\"start\":115788},{\"end\":116147,\"start\":116133},{\"end\":116348,\"start\":116340},{\"end\":116359,\"start\":116348},{\"end\":116363,\"start\":116359},{\"end\":116376,\"start\":116363},{\"end\":116806,\"start\":116795},{\"end\":116817,\"start\":116806},{\"end\":117197,\"start\":117185},{\"end\":117207,\"start\":117197},{\"end\":117562,\"start\":117548},{\"end\":117576,\"start\":117562},{\"end\":117867,\"start\":117859},{\"end\":117876,\"start\":117867},{\"end\":117886,\"start\":117876},{\"end\":117900,\"start\":117886},{\"end\":117913,\"start\":117900},{\"end\":117925,\"start\":117913}]", "bib_venue": "[{\"end\":101834,\"start\":101792},{\"end\":102188,\"start\":102157},{\"end\":102741,\"start\":102701},{\"end\":103043,\"start\":103017},{\"end\":103603,\"start\":103594},{\"end\":103948,\"start\":103908},{\"end\":104857,\"start\":104815},{\"end\":105381,\"start\":105366},{\"end\":105802,\"start\":105760},{\"end\":106478,\"start\":106452},{\"end\":107107,\"start\":107060},{\"end\":107516,\"start\":107471},{\"end\":108228,\"start\":108191},{\"end\":108506,\"start\":108477},{\"end\":108824,\"start\":108773},{\"end\":109214,\"start\":109172},{\"end\":109860,\"start\":109838},{\"end\":110642,\"start\":110618},{\"end\":110989,\"start\":110958},{\"end\":111605,\"start\":111563},{\"end\":112624,\"start\":112579},{\"end\":113944,\"start\":113908},{\"end\":114261,\"start\":114243},{\"end\":116451,\"start\":116442},{\"end\":116895,\"start\":116860},{\"end\":101790,\"start\":101742},{\"end\":102155,\"start\":102118},{\"end\":102404,\"start\":102353},{\"end\":102699,\"start\":102653},{\"end\":103015,\"start\":102983},{\"end\":103262,\"start\":103205},{\"end\":103592,\"start\":103534},{\"end\":103906,\"start\":103860},{\"end\":104271,\"start\":104233},{\"end\":104541,\"start\":104519},{\"end\":104813,\"start\":104765},{\"end\":105051,\"start\":105015},{\"end\":105364,\"start\":105343},{\"end\":105758,\"start\":105710},{\"end\":106129,\"start\":106101},{\"end\":106450,\"start\":106418},{\"end\":106751,\"start\":106735},{\"end\":107058,\"start\":107005},{\"end\":107469,\"start\":107418},{\"end\":107879,\"start\":107847},{\"end\":108189,\"start\":108146},{\"end\":108475,\"start\":108440},{\"end\":108771,\"start\":108714},{\"end\":109170,\"start\":109122},{\"end\":109551,\"start\":109531},{\"end\":109836,\"start\":109808},{\"end\":110080,\"start\":110058},{\"end\":110322,\"start\":110300},{\"end\":110616,\"start\":110586},{\"end\":110956,\"start\":110919},{\"end\":111260,\"start\":111163},{\"end\":111561,\"start\":111513},{\"end\":111862,\"start\":111843},{\"end\":112130,\"start\":112108},{\"end\":112288,\"start\":112228},{\"end\":112577,\"start\":112526},{\"end\":112799,\"start\":112783},{\"end\":113000,\"start\":112975},{\"end\":113203,\"start\":113193},{\"end\":113366,\"start\":113312},{\"end\":113648,\"start\":113632},{\"end\":113906,\"start\":113864},{\"end\":114241,\"start\":114191},{\"end\":114548,\"start\":114537},{\"end\":114715,\"start\":114704},{\"end\":114919,\"start\":114898},{\"end\":115225,\"start\":115202},{\"end\":115479,\"start\":115424},{\"end\":115832,\"start\":115803},{\"end\":116154,\"start\":116147},{\"end\":116414,\"start\":116376},{\"end\":116858,\"start\":116817},{\"end\":117247,\"start\":117207},{\"end\":117628,\"start\":117576},{\"end\":117959,\"start\":117925}]"}}}, "year": 2023, "month": 12, "day": 17}