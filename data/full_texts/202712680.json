{"id": 202712680, "updated": "2023-10-06 22:36:24.42", "metadata": {"title": "CodeSearchNet Challenge: Evaluating the State of Semantic Code Search", "authors": "[{\"first\":\"Hamel\",\"last\":\"Husain\",\"middle\":[]},{\"first\":\"Ho-Hsiang\",\"last\":\"Wu\",\"middle\":[]},{\"first\":\"Tiferet\",\"last\":\"Gazit\",\"middle\":[]},{\"first\":\"Miltiadis\",\"last\":\"Allamanis\",\"middle\":[]},{\"first\":\"Marc\",\"last\":\"Brockschmidt\",\"middle\":[]}]", "venue": "ArXiv", "journal": "ArXiv", "publication_date": {"year": 2019, "month": 9, "day": 20}, "abstract": "Semantic code search is the task of retrieving relevant code given a natural language query. While related to other information retrieval tasks, it requires bridging the gap between the language used in code (often abbreviated and highly technical) and natural language more suitable to describe vague concepts and ideas. To enable evaluation of progress on code search, we are releasing the CodeSearchNet Corpus and are presenting the CodeSearchNet Challenge, which consists of 99 natural language queries with about 4k expert relevance annotations of likely results from CodeSearchNet Corpus. The corpus contains about 6 million functions from open-source code spanning six programming languages (Go, Java, JavaScript, PHP, Python, and Ruby). The CodeSearchNet Corpus also contains automatically generated query-like natural language for 2 million functions, obtained from mechanically scraping and preprocessing associated function documentation. In this article, we describe the methodology used to obtain the corpus and expert labels, as well as a number of simple baseline solutions for the task. We hope that CodeSearchNet Challenge encourages researchers and practitioners to study this interesting task further and will host a competition and leaderboard to track the progress on the challenge. We are also keen on extending CodeSearchNet Challenge to more queries and programming languages in the future.", "fields_of_study": "[\"Computer Science\",\"Mathematics\"]", "external_ids": {"arxiv": "1909.09436", "mag": "2973529529", "acl": null, "pubmed": null, "pubmedcentral": null, "dblp": "journals/corr/abs-1909-09436", "doi": null}}, "content": {"source": {"pdf_hash": "fc2e67fc2e04f2ef6cf2dd5784ba3dcb0e8a6bba", "pdf_src": "Arxiv", "pdf_uri": "[\"https://arxiv.org/pdf/1909.09436v2.pdf\"]", "oa_url_match": false, "oa_info": null}, "grobid": {"id": "ee47666e999858ad576571e6cd3c4709e34e7538", "type": "plain-text", "url": "s3://ai2-s2-pdf-extraction-prod/parse-results/s2orc_worker/fc2e67fc2e04f2ef6cf2dd5784ba3dcb0e8a6bba.txt", "contents": "\nCodeSearchNet Challenge Evaluating the State of Semantic Code Search\n\n\nHamel Husain hamelsmu@github.com \nMicrosoft Research\n\n\nHo-Hsiang Wu hohsiangwu@github.com \nMicrosoft Research\n\n\nTiferet Gazit tiferet@github.com \nMicrosoft Research\n\n\nGithub Miltiadis \nMicrosoft Research\n\n\nAllamanis Marc Brockschmidt \nMicrosoft Research\n\n\nCodeSearchNet Challenge Evaluating the State of Semantic Code Search\n\nSemantic code search is the task of retrieving relevant code given a natural language query. While related to other information retrieval tasks, it requires bridging the gap between the language used in code (often abbreviated and highly technical) and natural language more suitable to describe vague concepts and ideas.To enable evaluation of progress on code search, we are releasing the CodeSearchNet Corpus and are presenting the CodeSearch-Net Challenge, which consists of 99 natural language queries with about 4k expert relevance annotations of likely results from Code-SearchNet Corpus. The corpus contains about 6 million functions from open-source code spanning six programming languages (Go, Java, JavaScript, PHP, Python, and Ruby). The CodeSearchNet Corpus also contains automatically generated query-like natural language for 2 million functions, obtained from mechanically scraping and preprocessing associated function documentation. In this article, we describe the methodology used to obtain the corpus and expert labels, as well as a number of simple baseline solutions for the task.We hope that CodeSearchNet Challenge encourages researchers and practitioners to study this interesting task further and will host a competition and leaderboard to track the progress on the challenge. We are also keen on extending CodeSearchNet Challenge to more queries and programming languages in the future.\n\nINTRODUCTION\n\nThe deep learning revolution has fundamentally changed how we approach perceptive tasks such as image and speech recognition and has shown substantial successes in working with natural language data. These have been driven by the co-evolution of large (labelled) datasets, substantial computational capacity, and a number of advances in machine learning models.\n\nHowever, deep learning models still struggle on highly structured data. One example is semantic code search: while search on natural language documents and even images has made great progress, searching code is often still unsatisfying. Standard information retrieval methods do not work well in the code search domain, as there is often little shared vocabulary between search terms and results (e.g. consider a method called deserialize_JSON_obj_from_stream that may be a correct result for the query \"read JSON data\"). Even more problematic is that evaluating methods for this task is extremely hard, as there are no substantial datasets that were created for this task; instead, the community tries to make do with small datasets from related contexts (e.g. pairing questions on web forums to code chunks found in answers).\n\nTo tackle this problem, we have defined the CodeSearchNet Challenge on top of a new CodeSearchNet Corpus. The Code-SearchNet Corpus was programmatically obtained by scraping open-source repositories and pairing individual functions with their (processed) documentation as natural language annotation. It is large enough (2 million datapoints) to enable training of highcapacity deep neural models on the task. We discuss this process in detail in section 2 and also release the data preprocessing pipeline to encourage further research in this area.\n\nThe CodeSearchNet Challenge is defined on top of this, providing realistic queries and expert annotations for likely results. Concretely, in version 1.0, it consists of 99 natural languages queries paired with likely results for each of six considered programming languages (Go, Java, JavaScript, PHP, Python, and Ruby). Each query/result pair was labeled by a human expert, indicating the relevance of the result for the query. We discuss the methodology in detail in section 3.\n\nFinally, we create a number of baseline methods using a range of state-of-the-art neural sequence processing techniques (bag of words, RNNs, CNNs, attentional models) and evaluate them on our datasets. We discuss these models in section 4 and present some preliminary results.\n\n\nTHE CODE SEARCH CORPUS\n\nAs it is economically infeasible to create a dataset large enough for training high-capacity models using expert annotations, we instead create a proxy dataset of lower quality. For this, we follow other attempts in the literature [5,6,9,11] and pair functions in open-source software with the natural language present in their respective documentation. However, to do so requires a number of preprocessing steps and heuristics. In the following, we discuss some general principles and decisions driven by in-depth analysis of common error cases.\n\nCodeSearchNet Corpus Collection. We collect the corpus from publicly available open-source non-fork GitHub repositories, using libraries.io to identify all projects which are used by at least one other project, and sort them by \"popularity\" as indicated by the number of stars and forks. Then, we remove any projects that do not have a license or whose license does not explicitly permit the re-distribution of parts of the project. We then tokenize all Go, Java, JavaScript, Python, PHP and Ruby functions (or methods) using TreeSitter -GitHub's universal parser -and, where available, their respective documentation text using a heuristic regular expression. \ni , d i ) where c i is some function documented by d i .\nTo make the data more realistic proxy for code search tasks, we then implement a number of preprocessing steps:\n\n\u2022 Documentation d i is truncated to the first full paragraph, to make the length more comparable to search queries and remove in-depth discussion of function arguments and return values. \u2022 Pairs in which d i is shorter than three tokens are removed, since we do not expect such comments to be informative. \u2022 Functions c i whose implementation is shorter than three lines are removed, these often include unimplemented methods, getters, setters, etc. \u2022 Functions whose name contains the substring \"test\" are removed. Similarly, we remove constructors and standard extension methods such as __str__ in Python or toString in Java. \u2022 We remove duplicates from the dataset by identifying (near) duplicate functions and only keeping one copy of them (we use the methods described in Allamanis [1], Lopes et al. [18]). This removes multiple versions of auto-generated code and cases of copy & pasting. The filtered corpus and the data extraction code are released at https://github.com/github/CodeSearchNet. Dataset Statistics. The resulting dataset contains about 2 million pairs of function-documentation pairs and about another 4 million functions without an associated documentation (Table 1). We split the dataset in 80-10-10 train/valid/test proportions. We suggest that users of the dataset employ the same split.\n\nLimitations. Unsurpsingly, the scraped dataset is quite noisy. First, documentation is fundamentally different from queries, and hence uses other forms of language. It is often written at the same time and by the same author as the documented code, and hence tends to use the same vocabulary, unlike search queries. Second, despite our data cleaning efforts we are unable to know the extent to which each documentation d i accurately describes its associated code snippet c i . For example, a number of comments are outdated with regard to the code that they describe. Finally, we know that some documentation is written in other languages, whereas our CodeSearchNet Challenge evaluation dataset focuses on English queries.\n\n\nTHE CODE SEARCH CHALLENGE\n\nTo evaluate on the CodeSearchNet Challenge, a method has to return a set of relevant results from CodeSearchNet Corpus for each of 99 pre-defined natural language queries. Note that the task is somewhat simplified from a general code search task by only allowing full functions/methods as results, and not arbitrary chunks of code. 1 The CodeSearchNet Challenge evaluation dataset consists of the 99 queries with relevance annotations for a small number of functions from our corpus likely to be returned. These annotations were collected from a small set of expert programmers, but we are looking forward to widening the annotation set going forward.\n\nQuery Collection. To ensure that our query set is representative, we obtained common search queries from Bing that had high clickthrough rates to code and combined these with intent rewrites in StaQC [24]. We then manually filtered out queries that were clearly technical keywords (e.g. the exact name of a function such as tf.gather_nd) to obtain a set of 99 natural language queries. While most of the collected queries are generic, some of them are language-specific.\n\nExpert Annotations. Obviously, we cannot annotate all query/function pairs. To filter this down to a more realistically-sized set, we used our implementations of baseline methods and ensembled them (see section 4) to generate 10 candidate results per query and programming language. Concretely, we used ensembles of all neural models and ElasticSearch to generate candidate results, merge the suggestions and pick the top 10. We used a simple web interface for the annotation process. The web interface firsts shows instructions (see Figure 1) and then allows the annotator to pick a programming language. Then, one query/function pair is shown at a time, as shown in Figure 2. A link to the origin of the shown function is included, as initial experiments showed that some annotators found inspecting the context of the code snippet helpful to judge relevance. The order of query/code pairs shown to the user is randomized but weakly ordered by the number of expert annotations already collected. Annotators are unlikely to see several results for the same query unless they handle many examples. By randomizing the order, we aim to allow users to score the relevance of each pair individually without encouraging comparisons of different results for the same query.\n\nAnnotation Statistics. We collected 4 026 annotations across six programming languages and prioritized coverage over multiple annotations per query-snippet pair. Our annotators are volunteers with software engineering, data science and research roles and were asked to only annotate examples for languages they had significant experience with. This led to a skewed distribution of annotations w.r.t. the considered programming languages.\n\nWe observed that the obtained relevance scores are distributed differently for each language ( Table 2). For example, the relevance scores for Python are evenly distributed across the four categories while for JavaScript the annotations are skewed towards lower relevance scores. There is a number of potential reasons for this, such as the quality of the used corpus, language-specific interactions    with our pre-filtering strategy, the queries we collected, higher expected relevance standards in the JavaScript community, etc.\n\nFor the 891 query-code pairs where we have more than one annotation, we compute the squared Cohen's kappa interannotator agreement to estimate the quality of the task. The agreement is moderate with Cohen \u03ba = 0.47. This is somewhat expected given that this task was relatively open-ended, as we will discuss next.\n\nQualitative Observations. During the annotation process we made some observations in discussions with the annotators and through the notes they provided in the web interface (see Fig. 2). These comments point to some general issues in implementing code search:\n\nCode Quality A subset of the results being returned are functionally correct code, but of low quality, even though they originated in reasonably popular projects. In this context, low quality refers to unsatisfactory readability, bad security practices, known antipatterns and potentially slow code. Some annotators felt the need to give lower relevance scores to low-quality code as they would prefer not to see such results. Query Ambiguity Queries are often ambiguous without additional context. For example, the query \"how to determine if a string is a valid word\" can have different correct interpretations depending on the domain-specific meaning of \"valid word\". Library vs. Project Specific Often a search yields code that is very specific to a given project (e.g. using internal utility functions), whereas other times the code is very general and verbose (e.g. containing code that could be factored out). Which of these is preferable depends on the context of the query, which we did not explicitly specify when asking for annotations. Context Some results were semantically correct, but not relying on related helper functions and thus not self-contained. Some annotators were uncertain if such results should be considered relevant. Directionality A common problem in results were functions implementing the inverse functionality of the query, e.g. \"convert int to string\" would be answered by stringToInt. This suggests that the baseline models used for pre-filtering have trouble with understanding such semantic aspects.\n\n\nEvaluation of Ranking Models\n\nTo track the progress on the CodeSearchNet Challenge we have deployed a Weights & Biases leaderboard at https://app.wandb.ai/ github/codesearchnet/benchmark. We hope that this leaderboard will allow the community to better compare solutions to the code search task.\n\nMetrics. We used normalized discounted cumulative gain (NDCG) to evaluate each competing method. NDCG is a commonly used metric [19] in information retrieval. We compute two variants of NDCG: (a) NDCG computed over the subset of functions with human annotations (\"Within\") (b) NDCG over the whole Code-SearchNet Corpus (\"All\"). We make this distinction as the NDCG score computed over the whole corpus may not necessarily represent the quality of a search tool, as a new tool may yield relevant but not-annotated functions. \n\n\nBASELINE CODESEARCH MODELS\n\nWe implemented a range of baseline models for the code search task, using standard techniques from neural sequence processing and web search.\n\n\nJoint Vector Representations for Code Search\n\nFollowing earlier work [11,20], we use joint embeddings of code and queries to implement a neural search system. Our architecture employs one encoder per input (natural or programming) language and trains them to map inputs into a single, joint vector space. Our training objective is to map code and the corresponding language onto vectors that are near to each other, as we can then implement a search method by embedding the query and then returning the set of code snippets that are \"near\" in embedding space. Although more complex models considering more interactions between queries and code can perform better [20], generating a single vector per query/snippet allows for efficient indexing and search. To learn these embedding functions, we combine standard sequence encoder models in the architecture shown in Figure 3. First, we preprocess the input sequences according to their semantics: identifiers appearing in code tokens are split into subtokens (i.e. a variable camelCase yields two subtokens camel and case), and natural language tokens are split using byte-pair encoding (BPE) [10,21].\n\nThen, the token sequences are processed to obtain (contextualized) token embeddings, using one of the following architectures.\n\nNeural Bag of Words where each (sub)token is embedded to a learnable embedding (vector representation). Bidirectional RNN models where we employ the GRU cell [7] to summarize the input sequence. 1D Convolutional Neural Network over the input sequence of tokens [15]. Self-Attention where multi-head attention [22] is used to compute representations of each token in the sequence.\n\nThe token embeddings are then combined into a sequence embedding using a pooling function, for which we have implemented mean/max-pooling and an attention-like weighted sum mechanism.\n\nFor all models, we set the dimensionality of the embedding space to 128. During training we are given a set of N pairs (c i , d i ) of code and natural language descriptions and have instantiated a code encoder E c and a query encoder E q . We train by minimizing the loss\n\u2212 1 N i log exp(E c (c i ) \u22a4 E q (d i )) j exp(E c (c j ) \u22a4 E q (d i )) ,\ni.e. maximize the inner product of the code and query encodings of the pair, while minimizing the inner product between each c i and the distractor snippets c j (i j). Note that we have experimented with other similar objectives (e.g. considering cosine similarity and max-margin approaches) without significant changes in results on our validation dataset. The code for the baselines can be found at https://github.com/github/CodeSearchNet. At test time, we index all functions in CodeSearchNet Corpus using Annoy. Annoy offers fast, approximate nearest neighbor indexing and search. The index includes all functions in the Code-SearchNet Corpus, including those that do not have an associated documentation comment.\n\n\nElasticSearch Baseline\n\nIn our experiments, we additionally included ElasticSearch, a widely used search engine with the default parameters. We configured it with an index using two fields for every function in our dataset: the function name, split into subtokens; and the text of the entire function. We use the default ElasticSearch tokenizer.\n\n\nEvaluation\n\nFollowing the training/validation/testing data split, we train our baseline models using our objective from above. While it does not directly correspond to the real target task of code search, it has been widely used as a proxy for training similar models [6,23].\n\nFor testing purposes on CodeSearchNet Corpus, we fix a set of 999 distractor snippets c j for each test pair (c i , d i ) and test all trained models. Table 3 presents the Mean Reciprocal Rank results on this task. Overall, we see that the models achieve relatively good performance on this task, with the self-attention-based model performing best. This is not unexpected, as the self-attention model has the highest capacity of all considered models.\n\nWe have also run our baselines on CodeSearchNet Challenge and show the results in Table 4. Here, the neural bag of words model performs very well, whereas the stronger neural models on the training task do less well. We note that the bag of words model is particularly good at keyword matching, which seems to be a crucial facility in implementing search methods. This hypothesis is further validated by the fact that the non-neural ElasticSearch-based baseline performs the best among all baselines models we have tested. As noted by Cambronero et al. [6], this can be attributed to the fact that the training data constructed from code documentation is not a good match for the code search task.\n\n\nRELATED WORK\n\nApplying machine learning to code has been widely considered [2]. A few academic works have looked into related tasks. First, semantic parsing has received a lot of attention in the NLP community.   Although most approaches are usually aimed towards creating an executable representation of a natural language utterance with a domain-specific language, general-purpose languages have been recently considered by Hashimoto et al. [13], Lin et al. [16], Ling et al. [17], Yin and Neubig [25]. Iyer et al. [14] generate code from natural language within the context of existing methods, whereas Allamanis et al. [3], Alon et al. [4] consider the task of summarizing functions to their names. Finally, Fernandes et al. [9] consider the task of predicting the documentation text from source code.\n\nMore related to CodeSearchNet is prior work in code search with deep learning. In the last few years there has been research in this area ( Cambronero et al. [6], Gu et al. [11,12], Yao et al. [23]), and architectures similar to those discussed previously have been shown to work to some extent. Recently, Cambronero et al. [6] looked into the same problem that CodeSearchNet is concerned with and reached conclusions similar to those discussed here. In contrast to the aforementioned works, here we provide a humanannotated dataset of relevance scores and test a few more neural search architectures along with a standard information retrieval baseline.\n\n\nCONCLUSIONS & OPEN CHALLENGES\n\nWe hope that CodeSearchNet is a good step towards engaging with the machine learning, IR and NLP communities towards developing new machine learning models that understand source code and natural language. Despite the fact this report gives emphasis on semantic code search we look forward to other uses of the presented datasets. There are still plenty of open challenges in this area.\n\n\u2022 Our ElasticSearch baseline, that performs traditional keywordbased search, performs quite well. It has the advantage of being able to efficiently use rare terms, which often appear in code. Researching neural methods that can efficiently and accurately represent rare terms will improve performance. \u2022 Code semantics such as control and data flow are not exploited explicitly by existing methods, and instead search methods seem to be mainly operate on identifiers (such as variable and function) names. How to leverage semantics to improve results remains an open problem. \u2022 Recently, in NLP, pretraining methods such as BERT [8] have found great success. Can similar methods be useful for the encoders considered in this work? \u2022 Our data covers a wide range of general-purpose code queries.\n\nHowever, anecdotal evidence indicates that queries in specific projects are usually more specialized. Adapting search methods to such use cases could yield substantial performance improvements. \u2022 Code quality of the searched snippets was a recurrent issue with our expert annotators. Despite its subjective nature, there seems to be agreement on what constitutes very bad code. Using code quality as an additional signal that allows for filtering of bad results (at least when better results are available) could substantially improve satisfaction of search users.\n\nFigure 1 :\n1Instructions provided to annotators.\n\nFigure 2 :\n2Interface used for relevance annotation.\n\nFigure 3 :\n3Model Architecture Overview.\n\n\nFiltering. To generate training data for the CodeSearchNet Challenge, we first consider only those functions in the corpus arXiv:1909.09436v2 [cs.LG] 27 Sep 2019Number of Functions \n\nw/ documentation \nAll \n\nGo \n347 789 \n726 768 \nJava \n542 991 1 569 889 \nJavaScript \n157 988 1 857 835 \nPHP \n717 313 \n977 821 \nPython \n503 502 1 156 085 \nRuby \n57 393 \n164 048 \n\nAll \n2 326 976 6 452 446 \n\nTable 1: Dataset Size Statistics \n\nthat have documentation associated with them. This yields a set \nof pairs (c \n\nTable 2 :\n2Annotation Dataset Statistics\n\nTable 3 :\n3Mean Reciprocal Rank (MRR) on Test Set of CodeSearchNet Corpus. This evaluates for our training task, where \ngiven the documentation comment as a query, the models try to rank the correct code snippet highly among 999 distractor \nsnippets. \n\nEncoder \nCodeSearchNet Challenge-NDCG Within \nCodeSearchNet Challenge-NDCG All \n\nText \nCode \nGo \nJava \nJS \nPHP Python \nRuby \nAvg \nGo \nJava \nJS \nPHP Python \nRuby \nAvg \n\nElasticSearch \n0.307 0.257 0.318 0.338 \n0.406 \n0.395 0.337 \n0.186 0.190 0.204 0.199 \n0.256 \n0.197 0.205 \nNBoW \nNBoW \n0.221 \n0.179 \n0.226 \n0.194 \n0.279 \n0.382 \n0.247 \n0.130 \n0.121 \n0.175 \n0.123 \n0.223 0.212 \n0.164 \n1D-CNN 1D-CNN \n0.132 \n0.246 \n0.131 \n0.332 \n0.341 \n0.327 \n0.252 \n0.059 \n0.128 \n0.044 \n0.135 \n0.166 \n0.115 \n0.108 \nbiRNN \nbiRNN \n0.073 \n0.145 \n0.099 \n0.154 \n0.169 \n0.113 \n0.126 \n0.019 \n0.062 \n0.025 \n0.045 \n0.064 \n0.030 \n0.041 \nSelfAtt \nSelfAtt \n0.096 \n0.140 \n0.139 \n0.184 \n0.292 0.417 \n0.211 \n0.049 \n0.100 \n0.061 \n0.094 \n0.181 \n0.190 \n0.113 \n\n\n\nTable 4 :\n4NDCG Baseline Results on CodeSearchNet Challenge. \"Within\" computes the NDCG only on the functions within the human-annotated examples. \"All\" computes NDCG over all functions in the CodeSearchNet Corpus.\nNote that on a sufficiently large dataset, this is not a significant restriction: more commonly implemented functionality almost always appears factored out into a function somewhere.\n\nThe Adverse Effects of Code Duplication in Machine Learning Models of Code. Miltiadis Allamanis, arXiv:1812.06469arXiv preprintMiltiadis Allamanis. 2018. The Adverse Effects of Code Duplication in Machine Learning Models of Code. arXiv preprint arXiv:1812.06469 (2018).\n\nA survey of machine learning for big code and naturalness. Miltiadis Allamanis, T Earl, Premkumar Barr, Charles Devanbu, Sutton, ACM Computing Surveys (CSUR). 5181Miltiadis Allamanis, Earl T Barr, Premkumar Devanbu, and Charles Sutton. 2018. A survey of machine learning for big code and naturalness. ACM Computing Surveys (CSUR) 51, 4 (2018), 81.\n\nA Convolutional Attention Network for Extreme Summarization of Source Code. Miltiadis Allamanis, Hao Peng, Charles Sutton, Proceedings of the International Conference on Machine Learning (ICML). the International Conference on Machine Learning (ICML)Miltiadis Allamanis, Hao Peng, and Charles Sutton. 2016. A Convolutional Attention Network for Extreme Summarization of Source Code. In Proceedings of the International Conference on Machine Learning (ICML).\n\nUri Alon, Omer Levy, Eran Yahav, arXiv:1808.01400Generating sequences from structured representations of code. 2arXiv preprintUri Alon, Omer Levy, and Eran Yahav. 2018. code2seq: Generating sequences from structured representations of code. arXiv preprint arXiv:1808.01400 (2018).\n\nA parallel corpus of Python functions and documentation strings for automated code documentation and code generation. Antonio Valerio, Miceli Barone, Rico Sennrich, arXiv:1707.02275arXiv preprintAntonio Valerio Miceli Barone and Rico Sennrich. 2017. A parallel corpus of Python functions and documentation strings for automated code documentation and code generation. arXiv preprint arXiv:1707.02275 (2017).\n\nJose Cambronero, Hongyu Li, Seohyun Kim, Koushik Sen, Satish Chandra, arXiv:1905.03813When Deep Learning Met Code Search. arXiv preprintJose Cambronero, Hongyu Li, Seohyun Kim, Koushik Sen, and Satish Chandra. 2019. When Deep Learning Met Code Search. arXiv preprint arXiv:1905.03813 (2019).\n\nKyunghyun Cho, Dzmitry Bart Van Merri\u00ebnboer, Yoshua Bahdanau, Bengio, On the Properties of Neural Machine Translation: Encoder-Decoder Approaches. Syntax, Semantics and Structure in Statistical Translation. Kyunghyun Cho, Bart van Merri\u00ebnboer, Dzmitry Bahdanau, and Yoshua Ben- gio. 2014. On the Properties of Neural Machine Translation: Encoder-Decoder Approaches. Syntax, Semantics and Structure in Statistical Translation (2014).\n\nBert: Pre-training of deep bidirectional transformers for language understanding. Jacob Devlin, Ming-Wei Chang, Kenton Lee, Kristina Toutanova, arXiv:1810.04805arXiv preprintJacob Devlin, Ming-Wei Chang, Kenton Lee, and Kristina Toutanova. 2018. Bert: Pre-training of deep bidirectional transformers for language understanding. arXiv preprint arXiv:1810.04805 (2018).\n\nPatrick Fernandes, Miltiadis Allamanis, Marc Brockschmidt, arXiv:1811.01824Structured Neural Summarization. arXiv preprintPatrick Fernandes, Miltiadis Allamanis, and Marc Brockschmidt. 2018. Structured Neural Summarization. arXiv preprint arXiv:1811.01824 (2018).\n\nA new algorithm for data compression. Philip Gage, The C Users Journal. 12Philip Gage. 1994. A new algorithm for data compression. The C Users Journal 12, 2 (1994), 23-38.\n\nDeep code search. Xiaodong Gu, Hongyu Zhang, Sunghun Kim, 2018 IEEE/ACM 40th International Conference on Software Engineering (ICSE). IEEEXiaodong Gu, Hongyu Zhang, and Sunghun Kim. 2018. Deep code search. In 2018 IEEE/ACM 40th International Conference on Software Engineering (ICSE). IEEE, 933-944.\n\nDeep API Learning. Xiaodong Gu, Hongyu Zhang, Dongmei Zhang, Sunghun Kim, Proceedings of the International Symposium on Foundations of Software Engineering (FSE). the International Symposium on Foundations of Software Engineering (FSE)Xiaodong Gu, Hongyu Zhang, Dongmei Zhang, and Sunghun Kim. 2016. Deep API Learning. In Proceedings of the International Symposium on Foundations of Software Engineering (FSE).\n\nA retrieve-and-edit framework for predicting structured outputs. B Tatsunori, Kelvin Hashimoto, Yonatan Guu, Percy S Oren, Liang, Advances in Neural Information Processing Systems. Tatsunori B Hashimoto, Kelvin Guu, Yonatan Oren, and Percy S Liang. 2018. A retrieve-and-edit framework for predicting structured outputs. In Advances in Neural Information Processing Systems. 10073-10083.\n\nSrinivasan Iyer, Ioannis Konstas, Alvin Cheung, Luke Zettlemoyer, arXiv:1808.09588Mapping language to code in programmatic context. arXiv preprintSrinivasan Iyer, Ioannis Konstas, Alvin Cheung, and Luke Zettlemoyer. 2018. Map- ping language to code in programmatic context. arXiv preprint arXiv:1808.09588 (2018).\n\nConvolutional neural networks for sentence classification. Yoon Kim, arXiv:1408.5882arXiv preprintYoon Kim. 2014. Convolutional neural networks for sentence classification. arXiv preprint arXiv:1408.5882 (2014).\n\nNL2Bash: A Corpus and Semantic Parser for Natural Language Interface to the Linux Operating System. Chenglong Xi Victoria Lin, Luke Wang, Michael D Zettlemoyer, Ernst, International Conference on Language Resources and Evaluation. Xi Victoria Lin, Chenglong Wang, Luke Zettlemoyer, and Michael D. Ernst. 2018. NL2Bash: A Corpus and Semantic Parser for Natural Language Interface to the Linux Operating System. In International Conference on Language Resources and Evaluation.\n\nLatent Predictor Networks for Code Generation. Wang Ling, Edward Grefenstette, Karl Moritz Hermann, Tomas Kocisky, Andrew Senior, Fumin Wang, Phil Blunsom, Proceedings of the Annual Meeting of the Association for Computational Linguistics (ACL). the Annual Meeting of the Association for Computational Linguistics (ACL)Wang Ling, Edward Grefenstette, Karl Moritz Hermann, Tomas Kocisky, Andrew Senior, Fumin Wang, and Phil Blunsom. 2016. Latent Predictor Networks for Code Generation. In Proceedings of the Annual Meeting of the Association for Computational Linguistics (ACL).\n\nD\u00e9j\u00e0Vu: a map of code duplicates on GitHub. V Cristina, Petr Lopes, Pedro Maj, Vaibhav Martins, Di Saini, Jakub Yang, Hitesh Zitny, Sajnani, Proceedings of the ACM on Programming Languages. 184OOPSLACristina V Lopes, Petr Maj, Pedro Martins, Vaibhav Saini, Di Yang, Jakub Zitny, Hitesh Sajnani, and Jan Vitek. 2017. D\u00e9j\u00e0Vu: a map of code duplicates on GitHub. Proceedings of the ACM on Programming Languages 1, OOPSLA (2017), 84.\n\nIntroduction to Information Retrieval. Christopher D Manning, Prabhakar Raghavan, Hinrich Sch\u00fctze, Cambridge University PressChristopher D. Manning, Prabhakar Raghavan, and Hinrich Sch\u00fctze. 2008. Intro- duction to Information Retrieval. Cambridge University Press.\n\nAn introduction to neural information retrieval. Nick Bhaskar Mitra, Craswell, Foundations and Trends\u00ae in Information Retrieval. 13Bhaskar Mitra, Nick Craswell, et al. 2018. An introduction to neural information retrieval. Foundations and Trends\u00ae in Information Retrieval 13, 1 (2018), 1-126.\n\nNeural machine translation of rare words with subword units. Rico Sennrich, Barry Haddow, Alexandra Birch, Proceedings of the Annual Meeting of the Association for Computational Linguistics (ACL). the Annual Meeting of the Association for Computational Linguistics (ACL)Rico Sennrich, Barry Haddow, and Alexandra Birch. 2016. Neural machine translation of rare words with subword units. In Proceedings of the Annual Meeting of the Association for Computational Linguistics (ACL).\n\nAttention is all you need. Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N Gomez, \u0141ukasz Kaiser, Illia Polosukhin, Advances in Neural Information Processing Systems. Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N Gomez, \u0141ukasz Kaiser, and Illia Polosukhin. 2017. Attention is all you need. In Advances in Neural Information Processing Systems. 5998-6008.\n\nCoaCor: Code Annotation for Code Retrieval with Reinforcement Learning. Ziyu Yao, Jayavardhan Reddy Peddamail, Huan Sun, Ziyu Yao, Jayavardhan Reddy Peddamail, and Huan Sun. 2019. CoaCor: Code Annotation for Code Retrieval with Reinforcement Learning. (2019).\n\nStaQC: A Systematically Mined Question-Code Dataset from Stack Overflow. Ziyu Yao, S Daniel, Wei-Peng Weld, Huan Chen, Sun, Proceedings of the 2018 World Wide Web Conference on World Wide Web. International World Wide Web Conferences Steering Committee. the 2018 World Wide Web Conference on World Wide Web. International World Wide Web Conferences Steering CommitteeZiyu Yao, Daniel S Weld, Wei-Peng Chen, and Huan Sun. 2018. StaQC: A Sys- tematically Mined Question-Code Dataset from Stack Overflow. In Proceedings of the 2018 World Wide Web Conference on World Wide Web. International World Wide Web Conferences Steering Committee, 1693-1703.\n\nA Syntactic Neural Model for General-Purpose Code Generation. Pengcheng Yin, Graham Neubig, Proceedings of the Annual Meeting of the Association for Computational Linguistics (ACL). the Annual Meeting of the Association for Computational Linguistics (ACL)Pengcheng Yin and Graham Neubig. 2017. A Syntactic Neural Model for General- Purpose Code Generation. Proceedings of the Annual Meeting of the Association for Computational Linguistics (ACL).\n", "annotations": {"author": "[{\"end\":126,\"start\":72},{\"end\":183,\"start\":127},{\"end\":238,\"start\":184},{\"end\":277,\"start\":239},{\"end\":327,\"start\":278}]", "publisher": null, "author_last_name": "[{\"end\":84,\"start\":78},{\"end\":139,\"start\":137},{\"end\":197,\"start\":192},{\"end\":255,\"start\":246},{\"end\":305,\"start\":293}]", "author_first_name": "[{\"end\":77,\"start\":72},{\"end\":136,\"start\":127},{\"end\":191,\"start\":184},{\"end\":245,\"start\":239},{\"end\":287,\"start\":278},{\"end\":292,\"start\":288}]", "author_affiliation": "[{\"end\":125,\"start\":106},{\"end\":182,\"start\":163},{\"end\":237,\"start\":218},{\"end\":276,\"start\":257},{\"end\":326,\"start\":307}]", "title": "[{\"end\":69,\"start\":1},{\"end\":396,\"start\":328}]", "venue": null, "abstract": "[{\"end\":1812,\"start\":398}]", "bib_ref": "[{\"attributes\":{\"ref_id\":\"b4\"},\"end\":4589,\"start\":4586},{\"attributes\":{\"ref_id\":\"b5\"},\"end\":4591,\"start\":4589},{\"attributes\":{\"ref_id\":\"b8\"},\"end\":4593,\"start\":4591},{\"attributes\":{\"ref_id\":\"b10\"},\"end\":4596,\"start\":4593},{\"attributes\":{\"ref_id\":\"b0\"},\"end\":6525,\"start\":6522},{\"attributes\":{\"ref_id\":\"b17\"},\"end\":6544,\"start\":6540},{\"attributes\":{\"ref_id\":\"b0\"},\"end\":8136,\"start\":8135},{\"attributes\":{\"ref_id\":\"b23\"},\"end\":8660,\"start\":8656},{\"attributes\":{\"ref_id\":\"b18\"},\"end\":13714,\"start\":13710},{\"attributes\":{\"ref_id\":\"b10\"},\"end\":14354,\"start\":14350},{\"attributes\":{\"ref_id\":\"b19\"},\"end\":14357,\"start\":14354},{\"attributes\":{\"ref_id\":\"b19\"},\"end\":14948,\"start\":14944},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":15427,\"start\":15423},{\"attributes\":{\"ref_id\":\"b20\"},\"end\":15430,\"start\":15427},{\"attributes\":{\"ref_id\":\"b6\"},\"end\":15722,\"start\":15719},{\"attributes\":{\"ref_id\":\"b14\"},\"end\":15826,\"start\":15822},{\"attributes\":{\"ref_id\":\"b21\"},\"end\":15874,\"start\":15870},{\"attributes\":{\"ref_id\":\"b5\"},\"end\":17813,\"start\":17810},{\"attributes\":{\"ref_id\":\"b22\"},\"end\":17816,\"start\":17813},{\"attributes\":{\"ref_id\":\"b5\"},\"end\":18829,\"start\":18826},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":19051,\"start\":19048},{\"attributes\":{\"ref_id\":\"b12\"},\"end\":19420,\"start\":19416},{\"attributes\":{\"ref_id\":\"b15\"},\"end\":19437,\"start\":19433},{\"attributes\":{\"ref_id\":\"b16\"},\"end\":19455,\"start\":19451},{\"attributes\":{\"ref_id\":\"b24\"},\"end\":19476,\"start\":19472},{\"attributes\":{\"ref_id\":\"b13\"},\"end\":19494,\"start\":19490},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":19599,\"start\":19596},{\"attributes\":{\"ref_id\":\"b3\"},\"end\":19616,\"start\":19613},{\"attributes\":{\"ref_id\":\"b8\"},\"end\":19705,\"start\":19702},{\"attributes\":{\"ref_id\":\"b5\"},\"end\":19941,\"start\":19938},{\"attributes\":{\"ref_id\":\"b10\"},\"end\":19957,\"start\":19953},{\"attributes\":{\"ref_id\":\"b11\"},\"end\":19960,\"start\":19957},{\"attributes\":{\"ref_id\":\"b22\"},\"end\":19977,\"start\":19973},{\"attributes\":{\"ref_id\":\"b5\"},\"end\":20107,\"start\":20104},{\"attributes\":{\"ref_id\":\"b7\"},\"end\":21488,\"start\":21485}]", "figure": "[{\"attributes\":{\"id\":\"fig_0\"},\"end\":22266,\"start\":22217},{\"attributes\":{\"id\":\"fig_1\"},\"end\":22320,\"start\":22267},{\"attributes\":{\"id\":\"fig_2\"},\"end\":22362,\"start\":22321},{\"attributes\":{\"id\":\"tab_0\",\"type\":\"table\"},\"end\":22863,\"start\":22363},{\"attributes\":{\"id\":\"tab_2\",\"type\":\"table\"},\"end\":22905,\"start\":22864},{\"attributes\":{\"id\":\"tab_4\",\"type\":\"table\"},\"end\":23883,\"start\":22906},{\"attributes\":{\"id\":\"tab_5\",\"type\":\"table\"},\"end\":24099,\"start\":23884}]", "paragraph": "[{\"end\":2189,\"start\":1828},{\"end\":3018,\"start\":2191},{\"end\":3569,\"start\":3020},{\"end\":4050,\"start\":3571},{\"end\":4328,\"start\":4052},{\"end\":4901,\"start\":4355},{\"end\":5564,\"start\":4903},{\"end\":5733,\"start\":5622},{\"end\":7048,\"start\":5735},{\"end\":7773,\"start\":7050},{\"end\":8454,\"start\":7803},{\"end\":8926,\"start\":8456},{\"end\":10195,\"start\":8928},{\"end\":10634,\"start\":10197},{\"end\":11167,\"start\":10636},{\"end\":11482,\"start\":11169},{\"end\":11744,\"start\":11484},{\"end\":13282,\"start\":11746},{\"end\":13580,\"start\":13315},{\"end\":14106,\"start\":13582},{\"end\":14278,\"start\":14137},{\"end\":15431,\"start\":14327},{\"end\":15559,\"start\":15433},{\"end\":15940,\"start\":15561},{\"end\":16125,\"start\":15942},{\"end\":16399,\"start\":16127},{\"end\":17191,\"start\":16474},{\"end\":17539,\"start\":17218},{\"end\":17817,\"start\":17554},{\"end\":18271,\"start\":17819},{\"end\":18970,\"start\":18273},{\"end\":19778,\"start\":18987},{\"end\":20434,\"start\":19780},{\"end\":20854,\"start\":20468},{\"end\":21650,\"start\":20856},{\"end\":22216,\"start\":21652}]", "formula": "[{\"attributes\":{\"id\":\"formula_0\"},\"end\":5621,\"start\":5565},{\"attributes\":{\"id\":\"formula_1\"},\"end\":16473,\"start\":16400}]", "table_ref": "[{\"end\":6924,\"start\":6915},{\"attributes\":{\"ref_id\":\"tab_2\"},\"end\":10739,\"start\":10731},{\"attributes\":{\"ref_id\":\"tab_4\"},\"end\":17977,\"start\":17970},{\"attributes\":{\"ref_id\":\"tab_5\"},\"end\":18362,\"start\":18355}]", "section_header": "[{\"attributes\":{\"n\":\"1\"},\"end\":1826,\"start\":1814},{\"attributes\":{\"n\":\"2\"},\"end\":4353,\"start\":4331},{\"attributes\":{\"n\":\"3\"},\"end\":7801,\"start\":7776},{\"attributes\":{\"n\":\"3.1\"},\"end\":13313,\"start\":13285},{\"attributes\":{\"n\":\"4\"},\"end\":14135,\"start\":14109},{\"attributes\":{\"n\":\"4.1\"},\"end\":14325,\"start\":14281},{\"attributes\":{\"n\":\"4.2\"},\"end\":17216,\"start\":17194},{\"attributes\":{\"n\":\"4.3\"},\"end\":17552,\"start\":17542},{\"attributes\":{\"n\":\"5\"},\"end\":18985,\"start\":18973},{\"attributes\":{\"n\":\"6\"},\"end\":20466,\"start\":20437},{\"end\":22228,\"start\":22218},{\"end\":22278,\"start\":22268},{\"end\":22332,\"start\":22322},{\"end\":22874,\"start\":22865},{\"end\":22916,\"start\":22907},{\"end\":23894,\"start\":23885}]", "table": "[{\"end\":22863,\"start\":22526},{\"end\":23883,\"start\":22918}]", "figure_caption": "[{\"end\":22266,\"start\":22230},{\"end\":22320,\"start\":22280},{\"end\":22362,\"start\":22334},{\"end\":22526,\"start\":22365},{\"end\":22905,\"start\":22876},{\"end\":24099,\"start\":23896}]", "figure_ref": "[{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":9470,\"start\":9462},{\"attributes\":{\"ref_id\":\"fig_1\"},\"end\":9604,\"start\":9596},{\"attributes\":{\"ref_id\":\"fig_1\"},\"end\":11669,\"start\":11663},{\"attributes\":{\"ref_id\":\"fig_2\"},\"end\":15154,\"start\":15146}]", "bib_author_first_name": "[{\"end\":24370,\"start\":24361},{\"end\":24624,\"start\":24615},{\"end\":24637,\"start\":24636},{\"end\":24653,\"start\":24644},{\"end\":24667,\"start\":24660},{\"end\":24990,\"start\":24981},{\"end\":25005,\"start\":25002},{\"end\":25019,\"start\":25012},{\"end\":25367,\"start\":25364},{\"end\":25378,\"start\":25374},{\"end\":25389,\"start\":25385},{\"end\":25771,\"start\":25764},{\"end\":25787,\"start\":25781},{\"end\":25800,\"start\":25796},{\"end\":26059,\"start\":26055},{\"end\":26078,\"start\":26072},{\"end\":26090,\"start\":26083},{\"end\":26103,\"start\":26096},{\"end\":26115,\"start\":26109},{\"end\":26357,\"start\":26348},{\"end\":26370,\"start\":26363},{\"end\":26399,\"start\":26393},{\"end\":26869,\"start\":26864},{\"end\":26886,\"start\":26878},{\"end\":26900,\"start\":26894},{\"end\":26914,\"start\":26906},{\"end\":27158,\"start\":27151},{\"end\":27179,\"start\":27170},{\"end\":27195,\"start\":27191},{\"end\":27460,\"start\":27454},{\"end\":27615,\"start\":27607},{\"end\":27626,\"start\":27620},{\"end\":27641,\"start\":27634},{\"end\":27917,\"start\":27909},{\"end\":27928,\"start\":27922},{\"end\":27943,\"start\":27936},{\"end\":27958,\"start\":27951},{\"end\":28368,\"start\":28367},{\"end\":28386,\"start\":28380},{\"end\":28405,\"start\":28398},{\"end\":28418,\"start\":28411},{\"end\":28700,\"start\":28690},{\"end\":28714,\"start\":28707},{\"end\":28729,\"start\":28724},{\"end\":28742,\"start\":28738},{\"end\":29068,\"start\":29064},{\"end\":29327,\"start\":29318},{\"end\":29349,\"start\":29345},{\"end\":29363,\"start\":29356},{\"end\":29365,\"start\":29364},{\"end\":29746,\"start\":29742},{\"end\":29759,\"start\":29753},{\"end\":29778,\"start\":29774},{\"end\":29785,\"start\":29779},{\"end\":29800,\"start\":29795},{\"end\":29816,\"start\":29810},{\"end\":29830,\"start\":29825},{\"end\":29841,\"start\":29837},{\"end\":30319,\"start\":30318},{\"end\":30334,\"start\":30330},{\"end\":30347,\"start\":30342},{\"end\":30360,\"start\":30353},{\"end\":30372,\"start\":30370},{\"end\":30385,\"start\":30380},{\"end\":30398,\"start\":30392},{\"end\":30755,\"start\":30744},{\"end\":30757,\"start\":30756},{\"end\":30776,\"start\":30767},{\"end\":30794,\"start\":30787},{\"end\":31024,\"start\":31020},{\"end\":31330,\"start\":31326},{\"end\":31346,\"start\":31341},{\"end\":31364,\"start\":31355},{\"end\":31779,\"start\":31773},{\"end\":31793,\"start\":31789},{\"end\":31807,\"start\":31803},{\"end\":31821,\"start\":31816},{\"end\":31838,\"start\":31833},{\"end\":31851,\"start\":31846},{\"end\":31853,\"start\":31852},{\"end\":31867,\"start\":31861},{\"end\":31881,\"start\":31876},{\"end\":32245,\"start\":32241},{\"end\":32262,\"start\":32251},{\"end\":32284,\"start\":32280},{\"end\":32507,\"start\":32503},{\"end\":32514,\"start\":32513},{\"end\":32531,\"start\":32523},{\"end\":32542,\"start\":32538},{\"end\":33148,\"start\":33139},{\"end\":33160,\"start\":33154}]", "bib_author_last_name": "[{\"end\":24380,\"start\":24371},{\"end\":24634,\"start\":24625},{\"end\":24642,\"start\":24638},{\"end\":24658,\"start\":24654},{\"end\":24675,\"start\":24668},{\"end\":24683,\"start\":24677},{\"end\":25000,\"start\":24991},{\"end\":25010,\"start\":25006},{\"end\":25026,\"start\":25020},{\"end\":25372,\"start\":25368},{\"end\":25383,\"start\":25379},{\"end\":25395,\"start\":25390},{\"end\":25779,\"start\":25772},{\"end\":25794,\"start\":25788},{\"end\":25809,\"start\":25801},{\"end\":26070,\"start\":26060},{\"end\":26081,\"start\":26079},{\"end\":26094,\"start\":26091},{\"end\":26107,\"start\":26104},{\"end\":26123,\"start\":26116},{\"end\":26361,\"start\":26358},{\"end\":26391,\"start\":26371},{\"end\":26408,\"start\":26400},{\"end\":26416,\"start\":26410},{\"end\":26876,\"start\":26870},{\"end\":26892,\"start\":26887},{\"end\":26904,\"start\":26901},{\"end\":26924,\"start\":26915},{\"end\":27168,\"start\":27159},{\"end\":27189,\"start\":27180},{\"end\":27208,\"start\":27196},{\"end\":27465,\"start\":27461},{\"end\":27618,\"start\":27616},{\"end\":27632,\"start\":27627},{\"end\":27645,\"start\":27642},{\"end\":27920,\"start\":27918},{\"end\":27934,\"start\":27929},{\"end\":27949,\"start\":27944},{\"end\":27962,\"start\":27959},{\"end\":28378,\"start\":28369},{\"end\":28396,\"start\":28387},{\"end\":28409,\"start\":28406},{\"end\":28423,\"start\":28419},{\"end\":28430,\"start\":28425},{\"end\":28705,\"start\":28701},{\"end\":28722,\"start\":28715},{\"end\":28736,\"start\":28730},{\"end\":28754,\"start\":28743},{\"end\":29072,\"start\":29069},{\"end\":29343,\"start\":29328},{\"end\":29354,\"start\":29350},{\"end\":29377,\"start\":29366},{\"end\":29384,\"start\":29379},{\"end\":29751,\"start\":29747},{\"end\":29772,\"start\":29760},{\"end\":29793,\"start\":29786},{\"end\":29808,\"start\":29801},{\"end\":29823,\"start\":29817},{\"end\":29835,\"start\":29831},{\"end\":29849,\"start\":29842},{\"end\":30328,\"start\":30320},{\"end\":30340,\"start\":30335},{\"end\":30351,\"start\":30348},{\"end\":30368,\"start\":30361},{\"end\":30378,\"start\":30373},{\"end\":30390,\"start\":30386},{\"end\":30404,\"start\":30399},{\"end\":30413,\"start\":30406},{\"end\":30765,\"start\":30758},{\"end\":30785,\"start\":30777},{\"end\":30802,\"start\":30795},{\"end\":31038,\"start\":31025},{\"end\":31048,\"start\":31040},{\"end\":31339,\"start\":31331},{\"end\":31353,\"start\":31347},{\"end\":31370,\"start\":31365},{\"end\":31787,\"start\":31780},{\"end\":31801,\"start\":31794},{\"end\":31814,\"start\":31808},{\"end\":31831,\"start\":31822},{\"end\":31844,\"start\":31839},{\"end\":31859,\"start\":31854},{\"end\":31874,\"start\":31868},{\"end\":31892,\"start\":31882},{\"end\":32249,\"start\":32246},{\"end\":32278,\"start\":32263},{\"end\":32288,\"start\":32285},{\"end\":32511,\"start\":32508},{\"end\":32521,\"start\":32515},{\"end\":32536,\"start\":32532},{\"end\":32547,\"start\":32543},{\"end\":32552,\"start\":32549},{\"end\":33152,\"start\":33149},{\"end\":33167,\"start\":33161}]", "bib_entry": "[{\"attributes\":{\"doi\":\"arXiv:1812.06469\",\"id\":\"b0\"},\"end\":24554,\"start\":24285},{\"attributes\":{\"id\":\"b1\",\"matched_paper_id\":207591052},\"end\":24903,\"start\":24556},{\"attributes\":{\"id\":\"b2\",\"matched_paper_id\":2723946},\"end\":25362,\"start\":24905},{\"attributes\":{\"doi\":\"arXiv:1808.01400\",\"id\":\"b3\"},\"end\":25644,\"start\":25364},{\"attributes\":{\"doi\":\"arXiv:1707.02275\",\"id\":\"b4\"},\"end\":26053,\"start\":25646},{\"attributes\":{\"doi\":\"arXiv:1905.03813\",\"id\":\"b5\"},\"end\":26346,\"start\":26055},{\"attributes\":{\"id\":\"b6\"},\"end\":26780,\"start\":26348},{\"attributes\":{\"doi\":\"arXiv:1810.04805\",\"id\":\"b7\"},\"end\":27149,\"start\":26782},{\"attributes\":{\"doi\":\"arXiv:1811.01824\",\"id\":\"b8\"},\"end\":27414,\"start\":27151},{\"attributes\":{\"id\":\"b9\",\"matched_paper_id\":59804030},\"end\":27587,\"start\":27416},{\"attributes\":{\"id\":\"b10\",\"matched_paper_id\":47021242},\"end\":27888,\"start\":27589},{\"attributes\":{\"id\":\"b11\",\"matched_paper_id\":11540100},\"end\":28300,\"start\":27890},{\"attributes\":{\"id\":\"b12\",\"matched_paper_id\":54446010},\"end\":28688,\"start\":28302},{\"attributes\":{\"doi\":\"arXiv:1808.09588\",\"id\":\"b13\"},\"end\":29003,\"start\":28690},{\"attributes\":{\"doi\":\"arXiv:1408.5882\",\"id\":\"b14\"},\"end\":29216,\"start\":29005},{\"attributes\":{\"id\":\"b15\",\"matched_paper_id\":3514435},\"end\":29693,\"start\":29218},{\"attributes\":{\"id\":\"b16\",\"matched_paper_id\":14434979},\"end\":30272,\"start\":29695},{\"attributes\":{\"id\":\"b17\",\"matched_paper_id\":5684578},\"end\":30703,\"start\":30274},{\"attributes\":{\"id\":\"b18\"},\"end\":30969,\"start\":30705},{\"attributes\":{\"id\":\"b19\",\"matched_paper_id\":57662599},\"end\":31263,\"start\":30971},{\"attributes\":{\"id\":\"b20\",\"matched_paper_id\":1114678},\"end\":31744,\"start\":31265},{\"attributes\":{\"id\":\"b21\",\"matched_paper_id\":13756489},\"end\":32167,\"start\":31746},{\"attributes\":{\"id\":\"b22\"},\"end\":32428,\"start\":32169},{\"attributes\":{\"id\":\"b23\",\"matched_paper_id\":3396350},\"end\":33075,\"start\":32430},{\"attributes\":{\"id\":\"b24\",\"matched_paper_id\":12718048},\"end\":33523,\"start\":33077}]", "bib_title": "[{\"end\":24613,\"start\":24556},{\"end\":24979,\"start\":24905},{\"end\":27452,\"start\":27416},{\"end\":27605,\"start\":27589},{\"end\":27907,\"start\":27890},{\"end\":28365,\"start\":28302},{\"end\":29316,\"start\":29218},{\"end\":29740,\"start\":29695},{\"end\":30316,\"start\":30274},{\"end\":31018,\"start\":30971},{\"end\":31324,\"start\":31265},{\"end\":31771,\"start\":31746},{\"end\":32501,\"start\":32430},{\"end\":33137,\"start\":33077}]", "bib_author": "[{\"end\":24382,\"start\":24361},{\"end\":24636,\"start\":24615},{\"end\":24644,\"start\":24636},{\"end\":24660,\"start\":24644},{\"end\":24677,\"start\":24660},{\"end\":24685,\"start\":24677},{\"end\":25002,\"start\":24981},{\"end\":25012,\"start\":25002},{\"end\":25028,\"start\":25012},{\"end\":25374,\"start\":25364},{\"end\":25385,\"start\":25374},{\"end\":25397,\"start\":25385},{\"end\":25781,\"start\":25764},{\"end\":25796,\"start\":25781},{\"end\":25811,\"start\":25796},{\"end\":26072,\"start\":26055},{\"end\":26083,\"start\":26072},{\"end\":26096,\"start\":26083},{\"end\":26109,\"start\":26096},{\"end\":26125,\"start\":26109},{\"end\":26363,\"start\":26348},{\"end\":26393,\"start\":26363},{\"end\":26410,\"start\":26393},{\"end\":26418,\"start\":26410},{\"end\":26878,\"start\":26864},{\"end\":26894,\"start\":26878},{\"end\":26906,\"start\":26894},{\"end\":26926,\"start\":26906},{\"end\":27170,\"start\":27151},{\"end\":27191,\"start\":27170},{\"end\":27210,\"start\":27191},{\"end\":27467,\"start\":27454},{\"end\":27620,\"start\":27607},{\"end\":27634,\"start\":27620},{\"end\":27647,\"start\":27634},{\"end\":27922,\"start\":27909},{\"end\":27936,\"start\":27922},{\"end\":27951,\"start\":27936},{\"end\":27964,\"start\":27951},{\"end\":28380,\"start\":28367},{\"end\":28398,\"start\":28380},{\"end\":28411,\"start\":28398},{\"end\":28425,\"start\":28411},{\"end\":28432,\"start\":28425},{\"end\":28707,\"start\":28690},{\"end\":28724,\"start\":28707},{\"end\":28738,\"start\":28724},{\"end\":28756,\"start\":28738},{\"end\":29074,\"start\":29064},{\"end\":29345,\"start\":29318},{\"end\":29356,\"start\":29345},{\"end\":29379,\"start\":29356},{\"end\":29386,\"start\":29379},{\"end\":29753,\"start\":29742},{\"end\":29774,\"start\":29753},{\"end\":29795,\"start\":29774},{\"end\":29810,\"start\":29795},{\"end\":29825,\"start\":29810},{\"end\":29837,\"start\":29825},{\"end\":29851,\"start\":29837},{\"end\":30330,\"start\":30318},{\"end\":30342,\"start\":30330},{\"end\":30353,\"start\":30342},{\"end\":30370,\"start\":30353},{\"end\":30380,\"start\":30370},{\"end\":30392,\"start\":30380},{\"end\":30406,\"start\":30392},{\"end\":30415,\"start\":30406},{\"end\":30767,\"start\":30744},{\"end\":30787,\"start\":30767},{\"end\":30804,\"start\":30787},{\"end\":31040,\"start\":31020},{\"end\":31050,\"start\":31040},{\"end\":31341,\"start\":31326},{\"end\":31355,\"start\":31341},{\"end\":31372,\"start\":31355},{\"end\":31789,\"start\":31773},{\"end\":31803,\"start\":31789},{\"end\":31816,\"start\":31803},{\"end\":31833,\"start\":31816},{\"end\":31846,\"start\":31833},{\"end\":31861,\"start\":31846},{\"end\":31876,\"start\":31861},{\"end\":31894,\"start\":31876},{\"end\":32251,\"start\":32241},{\"end\":32280,\"start\":32251},{\"end\":32290,\"start\":32280},{\"end\":32513,\"start\":32503},{\"end\":32523,\"start\":32513},{\"end\":32538,\"start\":32523},{\"end\":32549,\"start\":32538},{\"end\":32554,\"start\":32549},{\"end\":33154,\"start\":33139},{\"end\":33169,\"start\":33154}]", "bib_venue": "[{\"end\":25155,\"start\":25100},{\"end\":28125,\"start\":28053},{\"end\":30014,\"start\":29941},{\"end\":31535,\"start\":31462},{\"end\":32797,\"start\":32684},{\"end\":33332,\"start\":33259},{\"end\":24359,\"start\":24285},{\"end\":24713,\"start\":24685},{\"end\":25098,\"start\":25028},{\"end\":25473,\"start\":25413},{\"end\":25762,\"start\":25646},{\"end\":26175,\"start\":26141},{\"end\":26553,\"start\":26418},{\"end\":26862,\"start\":26782},{\"end\":27257,\"start\":27226},{\"end\":27486,\"start\":27467},{\"end\":27721,\"start\":27647},{\"end\":28051,\"start\":27964},{\"end\":28481,\"start\":28432},{\"end\":28820,\"start\":28772},{\"end\":29062,\"start\":29005},{\"end\":29447,\"start\":29386},{\"end\":29939,\"start\":29851},{\"end\":30462,\"start\":30415},{\"end\":30742,\"start\":30705},{\"end\":31098,\"start\":31050},{\"end\":31460,\"start\":31372},{\"end\":31943,\"start\":31894},{\"end\":32239,\"start\":32169},{\"end\":32682,\"start\":32554},{\"end\":33257,\"start\":33169}]"}}}, "year": 2023, "month": 12, "day": 17}