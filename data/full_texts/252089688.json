{"id": 252089688, "updated": "2023-12-14 07:45:34.481", "metadata": {"title": "Don\u2019t CWEAT It: Toward CWE Analysis Techniques in Early Stages of Hardware Design", "authors": "[{\"first\":\"Baleegh\",\"last\":\"Ahmad\",\"middle\":[]},{\"first\":\"Wei-Kai\",\"last\":\"Liu\",\"middle\":[]},{\"first\":\"Luca\",\"last\":\"Collini\",\"middle\":[]},{\"first\":\"Hammond\",\"last\":\"Pearce\",\"middle\":[]},{\"first\":\"Jason\",\"last\":\"Fung\",\"middle\":[\"M.\"]},{\"first\":\"Jonathan\",\"last\":\"Valamehr\",\"middle\":[]},{\"first\":\"Mohammad\",\"last\":\"Bidmeshki\",\"middle\":[]},{\"first\":\"Piotr\",\"last\":\"Sapiecha\",\"middle\":[]},{\"first\":\"Steve\",\"last\":\"Brown\",\"middle\":[]},{\"first\":\"Krishnendu\",\"last\":\"Chakrabarty\",\"middle\":[]},{\"first\":\"Ramesh\",\"last\":\"Karri\",\"middle\":[]},{\"first\":\"Benjamin\",\"last\":\"Tan\",\"middle\":[]}]", "venue": "2022 IEEE/ACM International Conference On Computer Aided Design (ICCAD)", "journal": "2022 IEEE/ACM International Conference On Computer Aided Design (ICCAD)", "publication_date": {"year": 2022, "month": 10, "day": 29}, "abstract": "To help prevent hardware security vulnerabilities from propagating to later design stages where fixes are costly, it is crucial to identify security concerns as early as possible, such as in RTL designs. In this work, we investigate the practical implications and feasibility of producing a set of security-specific scanners that operate on Verilog source files. The scanners indicate parts of code that might contain one of a set of MITRE\u2019s common weakness enumerations (CWEs). We explore the CWE database to characterize the scope and attributes of the CWEs and identify those that are amenable to static analysis. We prototype scanners and evaluate them on 11 open source designs \u2013 4 system-on-chips (SoC) and 7 processor cores \u2013 and explore the nature of identified weaknesses. Our analysis reported 53 potential weaknesses in the OpenPiton SoC used in Hack@DAC-21, 11 of which we confirmed as security concerns.", "fields_of_study": "[\"Computer Science\"]", "external_ids": {"arxiv": null, "mag": null, "acl": null, "pubmed": null, "pubmedcentral": null, "dblp": "conf/iccad/AhmadLCPFVBSBCK22", "doi": "10.1145/3508352.3549369"}}, "content": {"source": {"pdf_hash": "0728080315509181f89929f160e087fa92b25314", "pdf_src": "IEEE", "pdf_uri": "[\"https://export.arxiv.org/pdf/2209.01291v1.pdf\"]", "oa_url_match": false, "oa_info": {"license": null, "open_access_url": "https://arxiv.org/pdf/2209.01291", "status": "GREEN"}}, "grobid": {"id": "37a9267478372ebc24a1cc0dd64a0d2a08b10646", "type": "plain-text", "url": "s3://ai2-s2-science-parse-plus-prod/parse-results/s2orc_worker/0728080315509181f89929f160e087fa92b25314.txt", "contents": "\nDon't CWEAT It: Toward CWE Analysis Techniques in Early Stages of Hardware Design\nOctober 30-November 3, 2022\n\nBaleegh Ahmad \nNew York University\nDuke University\nNew York University\nNew York University\nIntel Corporation\nIntel Corporation\nIntel Corporation\nIntel Corporation\nIntel Corporation\nDuke University\nNew York University\nUniversity of Calgary\n\n\nWei-Kai Liu \nNew York University\nDuke University\nNew York University\nNew York University\nIntel Corporation\nIntel Corporation\nIntel Corporation\nIntel Corporation\nIntel Corporation\nDuke University\nNew York University\nUniversity of Calgary\n\n\nLuca Collini \nNew York University\nDuke University\nNew York University\nNew York University\nIntel Corporation\nIntel Corporation\nIntel Corporation\nIntel Corporation\nIntel Corporation\nDuke University\nNew York University\nUniversity of Calgary\n\n\nHammond Pearce \nNew York University\nDuke University\nNew York University\nNew York University\nIntel Corporation\nIntel Corporation\nIntel Corporation\nIntel Corporation\nIntel Corporation\nDuke University\nNew York University\nUniversity of Calgary\n\n\nJason M Fung \nNew York University\nDuke University\nNew York University\nNew York University\nIntel Corporation\nIntel Corporation\nIntel Corporation\nIntel Corporation\nIntel Corporation\nDuke University\nNew York University\nUniversity of Calgary\n\n\nJonathan Valamehr \nNew York University\nDuke University\nNew York University\nNew York University\nIntel Corporation\nIntel Corporation\nIntel Corporation\nIntel Corporation\nIntel Corporation\nDuke University\nNew York University\nUniversity of Calgary\n\n\nMohammad Bidmeshki \nNew York University\nDuke University\nNew York University\nNew York University\nIntel Corporation\nIntel Corporation\nIntel Corporation\nIntel Corporation\nIntel Corporation\nDuke University\nNew York University\nUniversity of Calgary\n\n\nPiotr Sapiecha \nNew York University\nDuke University\nNew York University\nNew York University\nIntel Corporation\nIntel Corporation\nIntel Corporation\nIntel Corporation\nIntel Corporation\nDuke University\nNew York University\nUniversity of Calgary\n\n\nSteve Brown \nNew York University\nDuke University\nNew York University\nNew York University\nIntel Corporation\nIntel Corporation\nIntel Corporation\nIntel Corporation\nIntel Corporation\nDuke University\nNew York University\nUniversity of Calgary\n\n\nKrishnendu Chakrabarty \nNew York University\nDuke University\nNew York University\nNew York University\nIntel Corporation\nIntel Corporation\nIntel Corporation\nIntel Corporation\nIntel Corporation\nDuke University\nNew York University\nUniversity of Calgary\n\n\nRamesh Karri \nNew York University\nDuke University\nNew York University\nNew York University\nIntel Corporation\nIntel Corporation\nIntel Corporation\nIntel Corporation\nIntel Corporation\nDuke University\nNew York University\nUniversity of Calgary\n\n\nBenjamin Tan \nNew York University\nDuke University\nNew York University\nNew York University\nIntel Corporation\nIntel Corporation\nIntel Corporation\nIntel Corporation\nIntel Corporation\nDuke University\nNew York University\nUniversity of Calgary\n\n\nBaleegh Ahmad \nNew York University\nDuke University\nNew York University\nNew York University\nIntel Corporation\nIntel Corporation\nIntel Corporation\nIntel Corporation\nIntel Corporation\nDuke University\nNew York University\nUniversity of Calgary\n\n\nWei-Kai Liu \nNew York University\nDuke University\nNew York University\nNew York University\nIntel Corporation\nIntel Corporation\nIntel Corporation\nIntel Corporation\nIntel Corporation\nDuke University\nNew York University\nUniversity of Calgary\n\n\nLuca Collini \nNew York University\nDuke University\nNew York University\nNew York University\nIntel Corporation\nIntel Corporation\nIntel Corporation\nIntel Corporation\nIntel Corporation\nDuke University\nNew York University\nUniversity of Calgary\n\n\nHammond Pearce \nNew York University\nDuke University\nNew York University\nNew York University\nIntel Corporation\nIntel Corporation\nIntel Corporation\nIntel Corporation\nIntel Corporation\nDuke University\nNew York University\nUniversity of Calgary\n\n\nJason M Fung \nNew York University\nDuke University\nNew York University\nNew York University\nIntel Corporation\nIntel Corporation\nIntel Corporation\nIntel Corporation\nIntel Corporation\nDuke University\nNew York University\nUniversity of Calgary\n\n\nJonathan Valamehr \nNew York University\nDuke University\nNew York University\nNew York University\nIntel Corporation\nIntel Corporation\nIntel Corporation\nIntel Corporation\nIntel Corporation\nDuke University\nNew York University\nUniversity of Calgary\n\n\nMohammad Bidmeshki \nNew York University\nDuke University\nNew York University\nNew York University\nIntel Corporation\nIntel Corporation\nIntel Corporation\nIntel Corporation\nIntel Corporation\nDuke University\nNew York University\nUniversity of Calgary\n\n\nPiotr Sapiecha \nNew York University\nDuke University\nNew York University\nNew York University\nIntel Corporation\nIntel Corporation\nIntel Corporation\nIntel Corporation\nIntel Corporation\nDuke University\nNew York University\nUniversity of Calgary\n\n\nSteve Brown \nNew York University\nDuke University\nNew York University\nNew York University\nIntel Corporation\nIntel Corporation\nIntel Corporation\nIntel Corporation\nIntel Corporation\nDuke University\nNew York University\nUniversity of Calgary\n\n\nKrishnendu Chakrabarty \nNew York University\nDuke University\nNew York University\nNew York University\nIntel Corporation\nIntel Corporation\nIntel Corporation\nIntel Corporation\nIntel Corporation\nDuke University\nNew York University\nUniversity of Calgary\n\n\nRamesh Karri \nNew York University\nDuke University\nNew York University\nNew York University\nIntel Corporation\nIntel Corporation\nIntel Corporation\nIntel Corporation\nIntel Corporation\nDuke University\nNew York University\nUniversity of Calgary\n\n\nBenjamin 2022 Tan \nNew York University\nDuke University\nNew York University\nNew York University\nIntel Corporation\nIntel Corporation\nIntel Corporation\nIntel Corporation\nIntel Corporation\nDuke University\nNew York University\nUniversity of Calgary\n\n\nDon't CWEAT It: Toward CWE Analysis Techniques in Early Stages of Hardware Design\n\nICCAD '22\nSan Diego, CA, USAOctober 30-November 3, 202210.1145/3508352.3549369ACM Reference Format: Don't CWEAT It: Toward CWE Analysis Techniques in Early Stages of Hardware Design. In IEEE/ACM International Conference on Computer-Aided Design (ICCAD '22), October 30-November 3, 2022, San Diego, CA, USA. ACM, New York, NY, USA, 9 pages. https://Hardware SecurityCWERTLLinting\nTo help prevent hardware security vulnerabilities from propagating to later design stages where fixes are costly, it is crucial to identify security concerns as early as possible, such as in RTL designs. In this work, we investigate the practical implications and feasibility of producing a set of security-specific scanners that operate on Verilog source files. The scanners indicate parts of code that might contain one of a set of MITRE's common weakness enumerations (CWEs). We explore the CWE database to characterize the scope and attributes of the CWEs and identify those that are amenable to static analysis. We prototype scanners and evaluate them on 11 open source designs -4 system-on-chips (SoC) and 7 processor cores -and explore the nature of identified weaknesses. Our analysis reported 53 potential weaknesses in the OpenPiton SoC used in Hack@DAC-21, 11 of which we confirmed as security concerns.CCS CONCEPTS\u2022 Security and privacy \u2192 Hardware security implementation; \u2022 Hardware \u2192 Electronic design automation.\n\nINTRODUCTION\n\nThe cost of correcting errors in hardware designs increases considerably in later stages of the product development cycle. Despite stringent requirements on functional correctness [34], hardware bugs, including security bugs, can persist [12]. A primary reason for this stems from the difficulty in evaluating security. Defining security properties and evaluating them is a complex process, requiring rare domain expertise. While several tools exist to support designers, such as linting tools [39], they often focus on checking functional correctness and only have limited features out-of-thebox for verifying security-related properties. Such tools can be used for some security-related checking [8,12] but considerable security-relevant expertise is required. These tools are designed to function on near-complete RTL code, performing comprehensive and time-consuming testing to ensure all aspects of a given system are compliant. However, improving security requires checks throughout the design cycle, including in the early stages of RTL design where a complete security specification is not yet available.\n\nRecently, industry-led efforts have added hardware-related issues to the Common Weakness Enumeration (CWE) list that is hosted by the MITRE Corporation [26]. The presence of a given weakness indicates that there are \"flaws, faults, bugs, or other errors in software or hardware implementation, code, design, or architecture that if left unaddressed could result in systems, networks, or hardware being vulnerable to attack\" [26]. CWEs serve as a \"common language\" for navigating weaknesses. Identifying different weaknesses requires different levels of context about the design, designers' intent, and security policies. To the best of our knowledge, early-stage analyses of hardware-based security weaknesses are largely a manual effort [12] that includes human inspection of hardware description language (HDL) code [8]. Ideally, this process of code inspection should be supported through automated scanning, with feedback to designers as they go. This analysis subsequently complements other later-stage efforts related to simulation/testing (e.g., [25]), and formal verification (e.g., [29,30]) as part of an overall security development lifecycle (SDL) (e.g., [14]).\n\nIn this work, we explore the practical implications and feasibility of automating the detection of hardware CWEs, focusing on a selection of weaknesses with minimal context. We investigate a set of CWEs as a case study, and we present our experience in implementing static analysis scanners to detect them, providing insights into the process of defining, implementing, and refining CWE scanners. Following a discussion of the motivation for our work (Section 2), our main contributions are:\n\n\u2022 We investigate the hardware CWE database for weaknesses that are potentially amenable to identification from source code analysis (Section 3). \u2022 We propose and prototype scanners to provide securityrelated feedback (Section 4). \u2022 We evaluate our proposed scanning algorithms on a series of open-source SoC and processor designs (Section 5) and discuss their limitations and other practical issues (Section 6).\n\n\nBACKGROUND 2.1 Related Work\n\nThere are several approaches to improving the security of hardware designs, including the use of a security development lifecycle (SDL) [14] that runs in parallel with traditional functionality driven development. The Planning stage is the first stage for SDL where security requirements are specified. This is followed by the Architecture and Design stages, where relevant threat models are considered. Checking the design against these security threat models is carried out in the Implementation and Verification stages. While Implementation consists of manual checks and static analysis of code, the bulk of validation is carried out in Verification where security properties expressed through assertions in HDLs are verified. Physical testing is also done after fabrication. The last stage is Release and Response. Several security analysis techniques can be used throughout this process. Recent work has proposed formal verification [9,19,29,30,32], Information Flow Tracking [6,10,21,41], fuzz testing [22,27,36,37], as well as run-time detection [20,28,31]. These techniques rely on simulation or they operate in the field, using complete or nearcomplete designs. To complement these, we focus on an earlier stage in the design process, specifically in the implementation phase. Our premise is that static analysis of register-transfer level (RTL) code can identify some security weaknesses, preventing them from propagating to the next stage.\n\nStatic analysis is an established approach used in software to identify errors and bugs; e.g., Lint was proposed in 1978 to analyze C code [23], and has since been adopted in many programming languages coining the term \"Linter\". Lint algorithms try to strike a balance between accuracy and practicality, as generated warnings are acceptable only in proportion to the real bugs uncovered. If too many false positives are raised, they obscure true problems.\n\nSeveral commercial and community tools offer linting capability for HDL (e.g, [1,39]), but they focus predominantly on functional and structure checks. They are comprehensive tools with several tags and parameters that can be configured to check for custom and predefined rules. Linting has been used to handle critical hardware issues like latches and clock gate timing validation [33]. Formal linting tools have been analyzed to find bugs in RTL before synthesis [40]. The idea of continuous linting is proposed in [18] to bring design errors to the attention of designers at a faster rate. While these works highlight the capability of linting for reducing the load on the verification stage, they do not look at hardware that could be functionally correct yet insecure. It is up to the security expertise of the designer to identify a lint message relevant to security.\n\n\nMotivation\n\nConsider the following scenario: an RTL designer works on several hardware modules, iterating the design and periodically checking it via simulation, synthesis, or manual review. As they work, they require frequent, fast feedback -for example, a simulation tool will report syntax errors and potentially help the designer avoid design bugs. For a more thorough check, the designer could use some kind of static analysis tool, such as a linter to check the source code against set guidelines [7] and raise warnings or error messages.\n\nTo explore the potential limitations of linting tools, we investigated an industry tool (Tool#1), and Verilator [1]. We set Verilator in lint-only mode with the -Wall flag (enables all checks and warnings) set. We set Tool#1 on the lint_rtl goal under the block-/initial_rtl methodology, appropriate for early-stage RTL design. After analyzing the hardware CWEs for those that are amenable to static analysis (discussed in Section 3), we implemented a small set of Verilog modules with weaknesses based on the examples on the MITRE website. The results are in Table 1. The default set of rules for Tool#1 could not find security-specific issues. However, as Tool#1 offers optional rules, it might be possible to find securityrelevant ones. A designer must identify security-relevant tags in the 936 available rules, a challenge! We identified seven rules covering finite state machine (FSM)-related problems, race conditions, and uninitialized registers that could lead to security bugs.\n\nWe ran Tool#1, adding the identified tags to the default RTL lint rules, on the HACK@DAC'21 SoC [12,17] and it raised 597 warnings in 84 seconds. Only 19 of the warnings were related to the optional tags with the rest raised by the default rules, representing considerable \"noise, \" i.e., issues not specific to security, although a designer can reduce noise by creating a custom goal with only the security-specific linting rules. With this setting, the linter was only able to detect potential issues related to state encoding in FSMs. We expected to detect FSM related issues with Tool#1 but they were not identified in our benchmarks. This probably happens because our implementation of FSMs does not follow standard FSM related patterns. Another plausible explanation is that basic lint checks with industry tools require the elaboration of the design and do not obtain all relevant information needed at the earlier analysis stage. The details of these stages are discussed in the next section. All in all, linters are not designed specifically with security in mind and require time and expertise to set them up for security-related tasks and to filter the results. We are thus motivated to investigate the feasibility of identifying security bugs with pre-elaboration static analysis to provide early-stage security feedback to designers. \n\n\nSTATIC ANALYSIS OF HARDWARE CWES\n\nThis work aims to improve security-specific analysis and feedback in early-stage RTL design by finding hardware CWEs. However, the CWE list comprises myriad weaknesses at different levels of specificity and abstraction. We first classify the CWEs based on our assessment of how amenable they are to static analysis, and then propose the framework for our CWE Analysis Techniques, CWEAT.\n\n\nClassifying CWEs for Scanning\n\nThere are 96 HW CWEs on MITRE's website [26] at the time of writing. In this section, we classify them by their amenability to detection, with our classification of the CWEs presented in Table 2.\n\nThe first delineation is whether the CWE is code-based or not. We exclude CWEs that do not originate in RTL designs (6). We consider whether the CWEs can be detected statically or dynamically (i.e. in a simulation or at run-time). Our approach focuses on CWEs that can be statically detected. CWEs such as CWE-1264, where de-synchronization between data and permission checking logic is evident only at run-time, require a different approach for detection (30 require functional simulation). We examine the CWEs that can be detected statically, classifying them based on the data required.\n\nSome bugs may be detectable using only static analysis of the RTL code, where the source is transformed into parse-trees, performing type-inferencing and detecting syntax errors. Here, the created parse-trees can be further analyzed using different algorithms to extract useful information for CWE identification. These can be classified into those that are directly detectable from the code (11), or those that may require additional context (21).\n\nOther CWEs can be further partitioned by the amount of \"extra information\" or context required to scan for a weakness (9 CWEs total). Static elaboration of the design entails binding instances to modules, resolving library references, processing defparam statements, unrolling for loops, flattening instance arrays, and replacing parameters with constants. The result after static elaboration is an elaborated parse tree. RTL elaboration then synthesizes the design using pre-defined primitives (e.g., AND, OR) and operators (e.g., add, multiply). The result of RTL elaboration is a synthesized RTL netlist. The remaining 16 CWEs do not have general symptoms among designs, so they cannot be formalized and identified, requiring manual analysis by IP security experts to detect.\n\nAs an example of the different types, consider the following. An incomplete FSM can be discovered by static analysis without any information from users (CWE-1245). In contrast, to identify the improper translation of security attributes by the fabric bridge (CWE-1311), additional information (context) regarding the fabric protocol is required. Even though several CWEs can be detected by static analysis, some issues do not manifest until the parse-tree is elaborated. For instance, incorrect default module parameters (CWE-1221) are difficult to find by static analysis. However, we can identify this issue through static elaboration, where all the parameters are calculated and propagated to each module. Moreover, cross-modular issues might demand RTL elaboration, e.g., CWE-1291. Still, some CWEs cannot be discovered at the RTL design stage, e.g., CWE-1278, which requires reverse-engineering protection.\n\nIn this work, we focus on static analysis of RTL source permodule with little to no context. Thus, CWEs that are specific Logic -where FSM logic contains \"gaps\" which could allow adversaries to put the system in an unknown or vulnerable state. CWE-1280: Access Control Check Implemented After Asset is Accessed -where an asset is accessible before the check on its access control signal. The asset should be accessible only after the check is successful, otherwise the security might be compromised. CWE-1262: Improper Access Control for Register Interface -where a register value is not write-protected or is not correctly protected, i.e., untrusted users can override the signal through the register interface. The protection mechanisms for security-relevant signals must be correctly implemented to avoid data leakage.\n\n\nCWEAT Framework\n\nTo assist in the detection of our targeted CWEs, we propose to create abstract syntax trees (ASTs) from Verilog source and traverse them with hand-crafted, heuristic detection algorithms (Section 4). Figure 1 illustrates the CWEAT framework, where the input is the design repository containing the source code. The design can comprise a single hardware intellectual property block (IP) through to an entire system-on-chip (SoC). Relevant source code files (in Verilog and/or SystemVerilog) are extracted from this repository and sorted in the order they should be analyzed. If a file has errors or does not have necessary dependencies, the tool ignores it. The final sorted source code list is sent to the Analyzer. The Analyzer runs on the entire set of source code files and produces ASTs -one per module. We use Verific [5] as the front-end parser to build the ASTs. Each scanner traverses every AST according to the detection algorithm for a CWE using the associated rules and keywords. Future work can add new scanners to the framework. We use keywords while searching for weaknesses for two reasons: (i) to locate 'security relevant' features in RTL (discussed in detail in Section 4), and (ii) to prune the search space for these weaknesses. The keyword-matching rules comprise matching and exclusion rules, e.g., ignoring clock when looking for lock. These rules could come from established design styles or might be provided by the designers. For our experiments, we devised keyword-matching rules by observing design styles.\n\n\nCWE DETECTION ALGORITHMS 4.1 Preliminaries\n\nOur heuristic detection algorithms work on the ASTs of an HDL design 1 . The AST can be extracted by a parser of choice for the preferred HDL. Each node of the AST represents a construct defined by the formal grammar of the HDL, e.g., a declaration, an expression or a module instance. The nodes are connected together to preserve the syntax expressed in the parsed design. Figure 2 shows an example of the AST of a Verilog module.\n\nA common design pattern to traverse ASTs is the Visitor Pattern [15]. This pattern involves defining a procedure that will be executed for each construct of interest. When a node is traversed, if a procedure for the construct exists, it is executed; otherwise, the children nodes are traversed. This allows for a built-in recursion that ends at leaf nodes or at specified constructs for which the children nodes are not traversed. A visitor accepts a node when it starts the traversal of the sub-tree with as root.    Figure 3 illustrates the scanner for CWE-1271. While traversing a data declaration node, candidates for security relevant registers are gathered and marked as unsafe. These candidates are then marked as safe based on the rest of the traversal.\n\n\nCWE Scanner Algorithms\nprocedure traverse( ) if . _ . \u210e ( _ , _ , ) then . ( ( _ , )) end if TRAVERSE( . ), TRAVERSE( . \u210e ) end procedure If\n\nScanner-1271:\n\nIn RTL, this happens if the security-relevant register is assigned a value inside a reset block. In the AST, this is identified through traversing various nodes based on flags set in the scanner. The flag is_reset_block is set when traversing a node which represents a reset block. The flag is_reset_lhs is set when traversing a node that is the left hand side of an assignment inside a reset block.  (III) Analyze FSM: After relevant information is gathered, the FSM is checked for several weaknesses. These include unreachable states, FSM deadlocks, and incomplete case statements. An unreachable state is shown as S4 in Figure 4(a); it is the initial state of a transition, but there is no way to get there, i.e., S4 is not present in the final state of any transition or on reset. An FSM deadlock is shown as S4 in Figure 4(b); it is the final state of a transition, but there is no way to get out i.e., it is not the initial state of any transition. A case statement representing an FSM is analyzed for completeness in addition to these FSM vulnerabilities. Completeness is verified if there is either a default statement present or if the number of case items equals the possibilities from the size of case condition. Figure 5 illustrates the scanner for CWE-1280. A traversal of the AST builds two lists containing information on read and write operations (reads and writes) lists respectively). The entries of the two lists are triples containing the Id, a reference to its parent SeqBlock, and its line number. After visiting the AST of the module and building the reads and writes lists, the algorithm iterates through these lists and compares each read entry with the write entries. If a read and a write have the same ids, are in the same SeqBlock, and if the read comes before the write, the updated value is not read, posing a potential weakness. \n\n\nScanner\n\n\nScanner-1280:\n\n\nScanner-1262: has a 2-step detection strategy: (I) Find the control signals for the registers associated with write transactions:\n\nWe only focus on registers that are not properly 'write protected', so only signals with names containing wdata are considered. As the AST is traversed, we use a stack to record the signals in the sensitivity lists in if/else statements and assign this set of signals to the registers within the same sequential block as the control signals. Irrelevant signals in sensitivity lists that are not 'controlling' (e.g., clock and reset are not control signals) are pruned. (II) Identify registers under improper control: After pruning, if the control signal set is empty, the corresponding register is regarded as unprotected because untrusted users could modify the register by issuing write transactions directly. We also compare the control signal sets for register arrays. Since an array of signals should have the same 'level' of protection, each entry should have the same number of control signals. Additionally, a warning will be raised if different entries do not have an identical set of control signals.\n\n\nEXPERIMENTAL WORK AND RESULTS\n\n\nOverview\n\nTo evaluate the practicality and limitations of the CWEAT framework, we implement the scanners detailed in Section 4 and apply them on several open-source designs. Our experiments characterize several elements of the framework, including the number of instances caught by CWEAT, the wall-clock performance of the scanners, and a detailed study of the warnings produced for an SoC. As part of our implementation, we curated a set of security-relevant keywords for signal names, the effect of which we also explore. Table 3 lists the designs on which we evaluated CWEAT. The first four entries in the table are SoCs consisting of cores and peripherals and the remaining designs are processors only. The SoCs include several peripherals to show applicability of scanners on modules outside of the core. The designs have diversity in terms of complexity of the cores and HDL languages (Verilog and SystemVerilog) and cover two popular open-source ISAs (RISC-V and OpenRISC). As there is no ground truth about the presence of CWEs, we manually inspect the warnings in our detailed analysis (Section 5.3). We ran our experiments on an AMD Ryzen 9 3950X 16-Core Processor, 64 GB DDR4 RAM, using Ubuntu 20.04. The framework uses Verific libraries (academic license), gcc 9.4.0, and Python 3.8.10. Table 3 summarizes the scanning results. The scanners analyzed as few as 1 to as many as 409 files per project, with up to \u223c76k lines of code (LoC). The scanner for CWE-1245 found the most potential instances of that CWE across the projects, while the scanner for CWE-1234 found the least. The mean running time for scanning was \u223c63 ms; producing the ASTs took around 3\u00d7 the time of running the collection of scanners on average, suggesting that these static analyzers could provide fast feedback to designers. For the Hack@DAC'21 SoC, we produce 53 security warnings; this is more targeted than the 597 warnings from a commercial tool (Section 2).\n\n\nInitial Analysis\n\nTo measure the portion of designs relevant to CWEs, we consider the number of 'relevant' AST nodes visited when running the different scanners. A node is considered 'relevant' if it needs to be traversed to detect the CWE. We also compare the number of relevant nodes visited by our scanners when keywords are used versus not used. This is shown in Table 4. The number of nodes traversed with keyword matches are, on average, 80.4\u00d7 fewer than the number of nodes in ASTs and 16.3\u00d7 fewer than nodes relevant to CWEs. Clearly, the keyword list used as part of scanning is an important aspect of making CWEAT practical.  We devised our set of keyword-matching rules based on our experience with various design styles. This includes our initial experiments with open source designs, review of bug examples in literature [8,12,25,37] and participation in hardware bug hunting competitions. For additional insight, we analyzed how often signals match our keywords across the different open-source projects. The results are reported in Figure 6. The frequency values are reported in log scale due to the high range of total identifiers across designs. The keywords cover a good portion of the considered benchmarks, indicating broad applicability for a framework like CWEAT to be used out-of-the-box in different projects. While our keywords are meaningful across the designs that we considered, our goal is not to provide the best set of keywords, but to show that keywords are an effective way to build security scanners. In real-world applications, performance can be improved by designers modifying keywords.\n\n\nDetailed Analysis\n\nWe evaluate each warning picked up by CWEAT and classify it as True Positive (T), Indeterminate (I), or False Positive (F). T means we confirmed the CWE's presence. Ascertaining if a CWE leads to an exploitable vulnerability is out of scope of this analysis. Conversely, F means we determined that the CWE was incorrectly flagged. In cases where we could not discern an instance into T or F, we classified it as I. Figure 7 shows our classification.\n\n\nFigure 6: Keyword frequency in select open-source HW\n\nTo explain our analysis and classifications of CWEAT's warnings, we discuss examples found in the Hack@DAC-2021 SoC, demonstrating the use of CWEAT and providing insights into the practicalities of using this approach. There are deliberate vulnerabilities implanted in this SoC, but we do not have access to a comprehensive list of those vulnerabilities. It is also not our goal to detect those deliberately inserted vulnerabilities.\n\n\nFigure 7: Classification of instances caught by CWEAT in SoCs.\n\nFor CWE-1234, two instances were identified (Figure 8). Figure 8(a) is part of the flush controller for the processor. If the highlighted condition is met, the Instruction Fetch, Decode and Execution stages are flushed. This is understandable when an exception is raised or when returning from an exception. Flushing the pipeline is also expected while entering the debug mode, however, whether the debug request should override exception-related signals depends on the design specification. If the intended flush mechanism is different, this instance could represent a vulnerability. Similar analysis follows for 8(b) which pertains to the implementation of un-stalling the core in the cases of interrupt and debug. We need more information for judging, hence we classify both warnings for the code in Figure 8 as I.\n\nFor CWE-1271, CWEAT picks up 13 instances: 6 T, 2 I and 5 F. An example is shown in Figure 9 in which we classify registers pmp_access_type_en and pmp_access_type_new as T and I respectively. This snippet belonging to the Direct Memory Access (DMA) module, shows the use of registers containing sensitive information for Physical Memory Protection (PMP) regions. The PMP access registers set the permissions to read and/or write for regions in the memory. To change the value of this register, pmp_access_type_en is used. It is a critical register but is not appropriately reset under a reset block. When the circuit is first brought out of reset, the state of pmp_access_type_en will be unknown. An attacker can deliberately bring the system in and out of reset to exploit this situation, hence we classify it as T. pmp_access_type_new also does not have a proper reset on initialization. But since its sole purpose is to store the next value of pmp_access_type_reg, which is appropriately reset, it cannot be clearly stated whether a weakness exists -hence, I. For CWE-1245, 17 instances were picked up by CWEAT: 4 T, 3 I and 10 F. Two T instances are shown in Figure 10. The first instance (Figure 10(a)) concerns a deadlock for the modular exponentiation module used in RSA implementation. There is no transition out of the state HOLD. On inspection, we see that the transition out of HOLD is possible only on the reset signal received from the RSA top module. This reset signal, however, is a combination of a reset signal and an internal signal which is modified in the write process of the RSA peripheral. This may allow room for communication with the RSA peripheral to put mod_exp in the HOLD state at will, causing denial of service. The second instance (Figure 10(b)) has an incomplete case statement with s13 not covered in the FSM for an AES interface. This leaves room for an adversary to bring the system to a state for which functionality is undefined, resulting in denial of service. Hence, both these instances are classified as T. However, we classified many instances picked up by CWEAT as F. This happens because particular styles of FSM implementation are not yet covered by 1245 scanner (e.g., multiple signals used in case condition, hard-coded one-hot encoded state variables or use of ternary operators). Instances were classified as I if they were not false positives and either had limited context or were too complex.\n\nFor CWE-1280, all detected instances were verified to be false positives (F). Figure 11 shows an example, taken from the modulo operator of the RSA module of the Ariane core. It highlights how p is accessed before being updated, but in this instance, it follows the For CWE-1262, CWEAT picks up 9 instances: 1 T, 2 I and 6 F. One T instance is shown in Figure 12(a). As specified in Section 4.2.5, we first collect a set of control signals for reglk_mem[0], which contains jtag_unlock, en, we, reglk_ctrl [3]. Note that the signals associated with clk and reset are pruned out. Since there are still four control signals for reglk_mem[0], it is write-protected. However, when we compare the control signals for the reglk_mem array, only reglk_mem[0] is controlled by reglk_ctrl [3], while other entries are controlled by reglk_ctrl [1], as highlighted in Figure 12(a). This difference might not be an issue if designers made it intentionally. Designers might use different signals to control a signal array, as shown in Figure 12(b) where each entry of acct_mem is controlled by different reglk_ctrl values. Since each entry of acct_mem represents different IPs' access control values, and each IP has different security levels, this array may not have the same control signals. However, in Figure 12(a), only one entry of reglk_mem has different control signals, without evidence to justify its legality and is classified as CWE-1262. We present an attack scenario to exploit this bug.\n\n\nUser Exploit for CWE-1262\n\nWhen we scanned the Hack@DAC-2021 SoC, they pointed to some files to potentially contain CWEs, including the one shown in Figure 12(a) where CWE-1262 is present. To verify the validity, we generate an attack scenario to confirm the vulnerability. As the code snippet shows, reglk_mem[0] is controlled by reglk_ctrl [3], while other bits of reglk_mem are controlled by reglk_ctrl [1]. This difference could be used by attackers if designers are not aware of it and set the reglk_ctrl [3] and reglk_ctrl [1]   respectively. The reglk_mem stores the control values for the registers in peripheral IPs, which appears to be reglk_ctrl in the modules. Once the protection for reglk_mem is bypassed, these control values can be reconfigured and several IPs' registers can be modified by attackers, resulting in the security issue.\n\nWe set the REGLK_REGLK value in reglk.h to 0xf6, which makes reglk_ctrl [3] 1 and allows untrusted users to override reglk_mem[0] at run-time. We ran the simulation on Hack@DAC-2021 platform and issued a write transaction to bypass reglk_ctrl protection to modify reglk_mem[0], leaving security-relevant signals in AES0, AES1, and SHA256 prone to leaks and modifications.\n\n\nDISCUSSION AND LIMITATIONS\n\nWhile developing our scanners, we faced a challenge: balancing accuracy (ratio of true positives over total instances caught by scanner) and comprehensiveness (number of true positives identified). This trade-off exists because, to increase comprehensiveness, we need to cast a wider net (increase keyword breadth) and traverse more source code. This will identify more weaknesses but can also flag more false positives. A decrease in accuracy of the tool makes it less practical to use. Conversely, if the goal is to more accurately identify weaknesses, some true positives will not be picked up, increasing the probability of weaknesses persisting in designs. While this trade-off is an important consideration for static analysis tools, the goal of this work is not to provide the best scanners, but to show that such static scanners can be implemented in a way that can be useful for designers to write more secure modules.\n\nAn approach to improve the scanners could involve \"learning\" the coding style of a given project, i.e., using user feedback to update the scanning. Interaction between designers and warnings generated can be used to iteratively increase accuracy. However, caution must be taken to avoid the pitfall of designers providing poor feedback (e.g., marking everything safe to avoid alarm fatigue). An example user-driven refinement is shown in Table 5, which shows the results after revising keywords in the scan of the Hack@DAC 2021 SoC. By default, we scan the design using a default list (first row). This includes matches with sensitive signal names in the true list and prunes out matched with the false list. The user can add signals they consider 'security-relevant'(second row). This results in more hits. The user can then mark certain signals as irrelevant by appending to the false list (third and fourth row). In this case, one true weakness is missed, but drastically improves the number of true positives as a fraction of the total number of instances/hits caught by the scanner. Our approach cannot guarantee the absence of a weakness when no warnings are produced. These 'false negatives' exist because we use heuristic detection of patterns. In our experiments, there are no benchmarks for comparison as we are in the initial stages of classifying, gathering, and understanding weaknesses in RTL. Our experimental evaluation focused on selected open-source designs with subsequent manual inspection to gauge effectiveness of scanners. In our manual inspection, we are somewhat limited when evaluating others' designs without complete context to understand intended implementation. Since documentation is limited and source code comments reveal partial information, evaluating instances picked up by scanners is limited by the expertise of the security evaluator. That said, if the examiner is also the designer, classification should be easier and faster. In an industry setting, there will be fewer uncertainties as documentation that conveys security-relevant information is more readily available. Design and security teams can work together to navigate potential concerns.\n\n\nCONCLUSIONS AND FUTURE WORK\n\nWe have shown that certain CWEs can be detected during the early RTL Implementation stage. In the 11 open-source designs, 180 instances were caught by CWEAT. We evaluated the 144 found in SoCs and confirmed weakness in 35 (24.31%) of the instances. 19 (13.1%) were indeterminate and 90 (62.5%) were not weaknesses. We have also shown that CWEAT restricts the search for particular weaknesses to a smaller subset. Instead of having to go over thousands of lines of source code, the search for specific issues is limited to a few signals and modules. By adding new scanners, other CWEs could be analyzed, increasing the level of security of the design.\n\nThe CWEs are varied in nature and can be detected at various stages. This provides two concrete directions for research. Firstly, scanners can be developed for the 21 CWEs that can be detected statically with specification files as shown in Table 2. Secondly, more accurate and comprehensive scanners can be developed for the CWEs we have targeted. Both approaches aim to standardize detection of hardware weaknesses, which we believe is significant.\n\nFigure 1 :Figure 2 :\n12CWEAT Framework. ASTs are extracted from the design and fed through CWE scanners SensList: (at 2) Sens: level, IdRef: a (at 2) SeqBlock: (at 2) BlockingAssign: (at 3) LHS: IdRef: out (at 3) RHS: Plus: IdRef: a, IntConst: 7 (at 3) DataDecl Example Abstract Syntax Tree of Verilog module Algorithm 1 : CWE-1234 Detector\n\nFigure 4 :\n4FSM weaknesses variables belonging to a specific FSM. (II) Extract FSM transitions: This traversal progresses according to the variables found in the previous step and gathers information from assignments of these variables. This information includes the previous state, next state, condition for transition and the location of assignment. The goal here is to collect the transitions of an FSM and add them to the FSM object.\n\nFigure 5 :\n5Traversal for CWE-1280\n\nFigure 8 :Figure 9 :\n89Debug overrides interrupt to un-stall core in Csr_regfile module Instances found by Scanner 1234. Highlighted are line(s) reported by scanner as a Instances found by Scanner 1271 in DMA module.\n\nFigure 10 :Figure 11 :\n1011Instances found by Scanner 1245. expected implementation and is not performing an access on an asset. Simple instances of CWE-1280 suggest flaws in the design and are unlikely to pass verification, while complex occurrences require more context to be detected. False positive detected by Scanner 1280.\n\n\nAn I instance found in acct_ctrl wrapper module.\n\nFigure 12 :\n12Instances found by Scanner 1262.\n\nTable 1 :\n1Out-of-the-box linting for securityCWE Module \nWeakness \nTool#1 Verilator CWEAT \n\n1234 \nLocked register \ndebug overrides lock \n\n\n\n1271 \nJTAG lock \njtag lock signal not reset \n\n\n\n1245 \nstate machine \nincomplete case statement \n\n\n\n1245 \nstate machine \nunreachable state \n\n\n\n1245 \nstate machine \nFSM deadlock \n\n\n\n1280 \nAccess control \naccess set after transfer \n\n\n\n1262 \nPeripheral sensor write signal not checked \n\nTable 2 :\n2Classification of Hardware CWEsDetection method \nCWEs \n# CWEs \n\nNon-RTL \n1053, 1059, 1261, 1273, 1248, 1266 \n6 \n\nFunctional simulation \n\n1342, 1296, 1246, 1303, 1193, 1279, 1281, 1323, 440, 1264, 1297 \n1191, 1258, 1272, 1313, 1324, 1223, 1224, 1233, 1263, 1251, 1315 \n1304, 1332, 441, 1268, 1294, 1190, 203 \n\n29 \n\nStatic analysis (no context) \n1234, 1245, 1262, 1271, 1280, 1244, 1231, 226, 1282, 1232, 1314 \n11 \n\nStatic analysis (with context) \n1318, 1291, 1311, 1312, 1302, 1326, 1310, 1209, 1269, 1257, 1316, \n1317, 1320, 1189, 1242, 1334, 1274, 1283, 1243, 1295, 1240, 1328 \n22 \n\nStatic/RTL elaboration \n1254, 1298, 1276, 1331, 1220, 1221, 276, 1260, 1299 \n9 \n\nManual analysis \n1252, 1253, 1192, 1277, 1267, 325, 1241, 1256, 1300, 1301, 1278 \n1319, 1255, 1338, 1351, 1247 \n16 \n\nto limited module-types, cross-modular CWEs, or those requiring \nsimulation are out of scope and are the focus of our future work. We \ntarget the following five CWEs as representatives for illustration. \nCWE-1234: Hardware Internal or Debug Modes Allow Override \nof Locks. A debug or debug-related signal overrides the value of an \ninternal security-relevant signal, e.g., a lock or access control signal. \nThis allows adversaries to reconfigure sensitive policy values or \ndisable security protections if they can get into debug mode. \nCWE-1271: Uninitialized Value on Reset for Registers with Security \nSettings. Registers with sensitive information like keys, lock bits or \naccess control bits do not default to secure postures on reset. \nCWE-1245: Improper Finite State Machines (FSMs) in Hardware \n\n\n\n1 Examples use a Verilog-like syntax but the concepts are applicable to all HDLs.Analyzer \n\nDesign \n\nVisitor A \n\nScanner E \n(keywords,rules) \n\nScanner A \n(keywords,rules) \n\nVisitor E \n\nASTs (1 per module) \n\n\n\n\nthe identifier matches one of the sensitive registers gathered from DataDecl:Mark the identifier safe the if_expr is categorized as potentially vulnerable. Relevant information is collected and appended to results. Next, the else and then statements of the ConditionalStatement are traversed sequentially. This recursion takes care of nested if-else statements.Conditional \nStatement \n\n1. Gather declarations that : \na. Are registers \nb. Match security register \nkeywords. \nc. Do not match false keywords \n2. Mark identifiers as unsafe \n\nData \nDecl \n\nElse \nStatement \n\nThen \nStatement \n\nif expression is \nreset condition? \n\nTrue \nis_reset_block = 1 \n\nFalse \nis_reset_block = 0 \n\nAssignment \n\nLHS \nTrue \nif is_reset_block? \n\nIdRef \n\nFigure 3: Traversal for CWE-1271 \n\n4.2.1 Scanner-1234: Algorithm 1 illustrates the scanner for CWE-\n1234. As the tree is traversed, the expression for the if statement in \nConditionalStatement node(s) is fetched as if_expr. if_expr \nis analyzed by checking whether it matches three conditions: (i) \npresence of a lock keyword from a list lock_kw, (ii) presence of a \ndebug keyword from a list dbg_kw, and (iii) presence of binary logic \noperators (e.g., or) that indicate 'overriding'. If these conditions are \nmet, \n\nTable 3 :\n3CWEAT Results SummaryDesign \nFiles/LoC(k) \nanalyzed \n\nFiles/LoC(k) \nnot analyz. \n\nTime (ms) \nAnalysis/ \nScan \n1234 \n1271 \n1245 \n1280 \n1262 \n\nH@DAC21 \n(Openpiton) [12, 17] \n328 / 67.3 \n112 / 18.2 \n354 / 76 \n2 \n13 17 12 \n9 \n\nH@DAC18 \n(Pulpissimo) [12, 17] \n409 / 76.3 \n116 / 16.2 \n322 / 142 \n0 \n9 \n26 20 10 \n\nHummingbirdv2 \n(E203) [35] \n128 / 48.3 \n8 / 1.8 \n254 / 27 \n0 \n1 \n2 \n0 \n2 \n\nOrpsoc [11] \n181 / 61.2 \n23 / 6.7 \n229 / 175 \n0 \n0 \n2 1 \n0 \n0 \n\nEH1 Swerv [13] \n1 / 15.9 \n0 / 0 \n744 / 142 \n0 \n0 \n0 \n0 \n0 \n\nIbex [2] \n34 / 7.6 \n3 / 1.4 \n34 / 44 \n2 \n1 \n0 \n0 \n0 \n\nCV32E40P [16] \n109 / 25.4 \n15 / 4.1 \n111 / 21 \n5 \n4 \n5 \n0 \n0 \n\nSCR1 [4] \n41 / 1.4 \n4 / 0.3 \n120 / 14 \n0 \n12 \n3 \n0 \n0 \n\nSERV [24] \n15 / 2.1 \n0 / 0 \n8 / 1 \n0 \n0 \n0 \n0 \n0 \n\nUltraembedded [38] \n17 / 5.7 \n1 / 0.5 \n28 / 7 \n0 \n0 \n0 \n0 \n0 \n\nMor1kx [3] \n46 / 20.7 \n3 / 0.7 \n95 / 53 \n0 \n3 \n0 \n1 \n0 \n\n\n\nTable 4 :\n4Fraction of relevant nodes for scanners. (r) is the % \nof nodes traversed for the scanner. (r+kw) is the % of nodes \ntraversed because of keyword matches. \n\nDesign \n1234 \n1262 \n1271 \n1245 1280 \nTotal \nr (%) \nr+kw (%) r(%) r+kw(%) r(%) r+kw(%) r(%) \nr(%) \nnodes (k) \n\nH@21 \n0.815 \n0.001 \n25.3 \n6.2 \n20.9 \n0.89 2.49 \n39.5 \n228 \nH@18 \n1.113 \n0 \n25.6 \n6.42 \n23.6 \n1.41 \n2.6 \n36.3 \n236 \ne203 \n0.361 \n0 \n22.1 \n1.4 \n25.8 \n0.55 0.84 \n29.1 \n182 \norpsoc 1.897 \n0 \n29.2 \n8.79 \n29.7 \n2.27 3.04 \n36.5 \n118 \nswerv \n0.235 \n0 \n0 \n35.69 \n0.6 \n35.71 \n0 \n53.2 \n1030 \nibex \n0.744 \n0.012 \n26.4 \n4.79 \n25.8 \n0.72 1.44 \n40.1 \n41 \ncv32 \n1.188 \n0.018 \n27.9 \n8.4 \n21.3 \n0.77 2.55 \n42.4 \n76 \nscr1 \n0.67 \n0 \n19.8 \n4.22 \n19.5 \n0.88 1.44 \n29.2 \n60 \nserv \n0.646 \n0 \n26.1 \n3.97 \n21.9 \n0.62 \n0 \n37.2 \n6 \nultraemb. 1.912 \n0 \n26.7 \n8.56 \n21.8 \n2.66 1.18 \n39.8 \n15 \nmor1kx 1.782 \n0 \n27.5 \n6.74 \n25.4 \n1.63 0.95 \n37.7 \n56 \n\n\n\nTable 5 :\n5Evolution of 1271 scanner with user feedbackUser Interaction Keywords \n# hits T I \nF T/ # hits \n\nNone \ntrue:{ \n, \n} false:{ \n} \n66 \n2 17 47 \n0.031 \n\nAdd 'access' \ntrue:{ \n, \n, \n} false:{ \n} \n75 \n7 19 49 \n0.095 \n\nPrune 'block' \ntrue:{ \n, \n, \n} false:{ \n, \n} \n47 \n6 11 30 \n0.128 \n\nPrune 'ar_lock' \n'aw_lock' \n\ntrue:{ \n, \n, \n} \nfalse:{ \n, \n, , } \n\n18 \n6 2 10 \n0.333 \n\n\nACKNOWLEDGMENTSWe thank Verific Design Automation for generously providing academic access to linkable libraries, examples, and documentation for their RTL parsers. This research work is supported in part by a gift from Intel Corporation. This work does not in any way constitute an Intel endorsement of a product or supplier. We acknowledge the support of the Natural Sciences and Engineering Research Council of Canada (NSERC), RGPIN-2022-03027.\nVerilator User's Guide -Verilator 4. 2022021. Verilator User's Guide -Verilator 4.202 documentation. https://verilator. org/guide/latest/#\n\n. Ibex Risc-V Core, date: 2017- 08-08T12:16:36Z2022. Ibex RISC-V Core. https://github.com/lowRISC/ibex original-date: 2017- 08-08T12:16:36Z.\n\n2022. mor1kx -an OpenRISC processor IP core. date: 2012-08-21T08:45:53Z2022. mor1kx -an OpenRISC processor IP core. https://github.com/openrisc/ mor1kx original-date: 2012-08-21T08:45:53Z.\n\n. Risc-V Core, date: 2017-05-09T04:29:07Z2022. SCR1 RISC-V Core. https://github.com/syntacore/scr1 original-date: 2017-05-09T04:29:07Z.\n\nVerific Design Automation. 2022. Verific Design Automation. https://www.verific.com/\n\nRegister transfer level information flow tracking for provably secure hardware design. Armaiti Ardeshiricham, Wei Hu, Joshua Marxen, Ryan Kastner, 10.23919/DATE.2017.7927266Design. Armaiti Ardeshiricham, Wei Hu, Joshua Marxen, and Ryan Kastner. 2017. Register transfer level information flow tracking for provably secure hardware design. In Design, Automation Test in Europe Conference Exhibition (DATE), 2017. 1691-1696. https://doi.org/10.23919/DATE.2017.7927266 ISSN: 1558-1101.\n\nPrinciples of Verifiable RTL Design. Lionel Bening, Harry Foster, 10.1007/0-306-47631-2_10Springer USBoston, MALionel Bening and Harry Foster. 2001. Principles of Verifiable RTL Design. Springer US, Boston, MA. https://doi.org/10.1007/0-306-47631-2_10\n\n. Mohammad Bidmeshki, Yunjie Zhang, Monir Zaman, Liwei Zhou, Yiorgos Makris, 10.1109/MDAT.2020.3013727Hunting Security Bugs in SoC Designs: Lessons Learned. IEEE Design & Test. 38Mohammad Bidmeshki, Yunjie Zhang, Monir Zaman, Liwei Zhou, and Yiorgos Makris. 2021. Hunting Security Bugs in SoC Designs: Lessons Learned. IEEE De- sign & Test 38, 1 (Feb. 2021), 22-29. https://doi.org/10.1109/MDAT.2020.3013727\n\nFormal Verification of Masked Hardware Implementations in the Presence of Glitches. Roderick Bloem, Hannes Gross, Rinat Iusupov, Bettina K\u00f6nighofer, Stefan Mangard, Johannes Winter, 10.1007/978-3-319-78375-8_11Advances in Cryptology -EUROCRYPT 2018. Jesper Buus Nielsen and Vincent RijmenChamSpringer International PublishingRoderick Bloem, Hannes Gross, Rinat Iusupov, Bettina K\u00f6nighofer, Stefan Man- gard, and Johannes Winter. 2018. Formal Verification of Masked Hardware Implementations in the Presence of Glitches. In Advances in Cryptology - EUROCRYPT 2018 (Lecture Notes in Computer Science), Jesper Buus Nielsen and Vincent Rijmen (Eds.). Springer International Publishing, Cham, 321-353. https://doi.org/10.1007/978-3-319-78375-8_11\n\nChallenges and Opportunities for Practical and Effective Dynamic Information Flow Tracking. Christopher Brant, Prakash Shrestha, Benjamin Mixon-Baca, Kejun Chen, Said Varlioglu, Nelly Elsayed, Yier Jin, Jedidiah Crandall, Daniela Oliveira, 10.1145/3483790Comput. Surveys. 5533Christopher Brant, Prakash Shrestha, Benjamin Mixon-Baca, Kejun Chen, Said Varlioglu, Nelly Elsayed, Yier Jin, Jedidiah Crandall, and Daniela Oliveira. 2021. Challenges and Opportunities for Practical and Effective Dynamic Information Flow Tracking. Comput. Surveys 55, 1 (Nov. 2021), 17:1-17:33. https://doi.org/10. 1145/3483790\n\ndate: 2013-08-19T19:24:09ZOpenRISC Community. 2021. orpsoc-cores. OpenRISC Community. 2021. orpsoc-cores. https://github.com/openrisc/orpsoc- cores original-date: 2013-08-19T19:24:09Z.\n\nHardfails: Insights into Software-Exploitable Hardware Bugs. Ghada Dessouky, David Gens, Patrick Haney, Garrett Persyn, Arun Kanuparthi, Hareesh Khattri, Jason Fung, Ahmad-Reza Sadeghi, Jeyavijayan Rajendran, Proceedings of the 28th USENIX Conference on Security Symposium (SEC'19). USENIX Association. the 28th USENIX Conference on Security Symposium (SEC'19). USENIX AssociationSanta Clara, CA, USA; Santa Clara, CA, USAGhada Dessouky, David Gens, Patrick Haney, Garrett Persyn, Arun Kanuparthi, Hareesh Khattri, Jason Fung, Ahmad-Reza Sadeghi, and Jeyavijayan Rajendran. 2019. Hardfails: Insights into Software-Exploitable Hardware Bugs. In Proceed- ings of the 28th USENIX Conference on Security Symposium (SEC'19). USENIX Association, Santa Clara, CA, USA, 213-230. event-place: Santa Clara, CA, USA.\n\nWestern Digital. 2022. EH1 RISC-V SweRV CoreTM 1.9 from Western Digital. Western Digital. 2022. EH1 RISC-V SweRV CoreTM 1.9 from Western Digital. https://github.com/chipsalliance/Cores-SweRV\n\nIntel Security Development Lifecycle. Vernetta Dorsey, Camille Morhardt, Technical Report. Intel CorporationVernetta Dorsey and Camille Morhardt. 2020. Intel Security Development Lifecycle. Technical Report. Intel Corporation. https://newsroom.intel.com/wp-content/ uploads/sites/11/2020/10/sdl-2020-whitepaper.pdf\n\nDesign patterns : elements of reusable object-oriented software. Erich Gamma, Addison-WesleyReading, MassErich Gamma. 1995. Design patterns : elements of reusable object-oriented software. Reading, Mass. : Addison-Wesley. http://archive.org/details/ designpatternsel00gamm\n\nNear-Threshold RISC-V Core With DSP Extensions for Scalable IoT Endpoint Devices. Michael Gautschi, Pasquale Davide Schiavone, Andreas Traber, Igor Loi, Antonio Pullini, Davide Rossi, Eric Flamand, Frank Gurkaynak, Luca Benini, 10.1109/TVLSI.2017.2654506Michael Gautschi, Pasquale Davide Schiavone, Andreas Traber, Igor Loi, Antonio Pullini, Davide Rossi, Eric Flamand, Frank Gurkaynak, and Luca Benini. 2017. Near-Threshold RISC-V Core With DSP Extensions for Scalable IoT Endpoint Devices. https://doi.org/10.1109/TVLSI.2017.2654506\n\nHACK@EVENT. 2022. HACK@DAC21 -HacK@EVENT. HACK@EVENT. 2022. HACK@DAC21 -HacK@EVENT. https://hackatevent. org/hackdac21/\n\nContinuous Linting with Automatic Debug. Daniel Hansson, 10.1109/MTV.2014.2515th International Microprocessor Test and Verification Workshop. Daniel Hansson. 2014. Continuous Linting with Automatic Debug. In 2014 15th International Microprocessor Test and Verification Workshop. 70-72. https: //doi.org/10.1109/MTV.2014.25 ISSN: 2332-5674.\n\nSoC interconnection protection through formal verification. Jiaji He, Xiaolong Guo, Travis Meade, Raj Dutta, Yiqiang Zhao, Yier Jin, 10.1016/j.vlsi.2018.09.007Integration. 64Jiaji He, Xiaolong Guo, Travis Meade, Raj Dutta, Yiqiang Zhao, and Yier Jin. 2019. SoC interconnection protection through formal verification. Integration 64 (Jan. 2019), 143-151. https://doi.org/10.1016/j.vlsi.2018.09.007\n\nSPECS: A Lightweight Runtime Mechanism for Protecting Software from Security-Critical Processor Bugs. Matthew Hicks, Cynthia Sturton, Samuel King, Jonathan Smith, 10.1145/2694344.2694366Proceedings of the Twentieth International Conference on Architectural Support for Programming Languages and Operating Systems -ASPLOS '15. the Twentieth International Conference on Architectural Support for Programming Languages and Operating Systems -ASPLOS '15Istanbul, TurkeyACM PressMatthew Hicks, Cynthia Sturton, Samuel King, and Jonathan Smith. 2015. SPECS: A Lightweight Runtime Mechanism for Protecting Software from Security- Critical Processor Bugs. In Proceedings of the Twentieth International Conference on Architectural Support for Programming Languages and Operating Systems - ASPLOS '15. ACM Press, Istanbul, Turkey, 517-529. https://doi.org/10.1145/ 2694344.2694366\n\nDetecting Hardware Trojans with Gate-Level Information-Flow Tracking. Wei Hu, Baolei Mao, Jason Oberg, Ryan Kastner, 10.1109/MC.2016.225ConferenceNameComputer. 49ComputerWei Hu, Baolei Mao, Jason Oberg, and Ryan Kastner. 2016. Detecting Hardware Trojans with Gate-Level Information-Flow Tracking. Computer 49, 8 (Aug. 2016), 44-52. https://doi.org/10.1109/MC.2016.225 Conference Name: Computer.\n\nDraft Standard for Security Annotation for Electronic Design Integration. Accellera Systems Initiative. 2021. Accellera Systems Initiative. 2021. Draft Standard for Security Annotation for Electronic Design Integration. https://www.accellera.org/images/downloads/ drafts-review/Accellera_SA-EDI_Standard_Draft_for_Public_Review.pdf\n\nLint, a C Program Checker. Stephen Johnson, COMP. SCI. TECH. REP. Stephen Johnson. 1978. Lint, a C Program Checker. In COMP. SCI. TECH. REP. 78-1273.\n\nRTL-ConTest: Concolic Testing on RTL for Detecting Security Vulnerabilities. Xingyu Meng, Shamik Kundu, Arun Kanuparthi, Kanad Basu, 10.1109/TCAD.2021.3066560IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems. Xingyu Meng, Shamik Kundu, Arun Kanuparthi, and Kanad Basu. 2021. RTL- ConTest: Concolic Testing on RTL for Detecting Security Vulnerabilities. IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems (2021), 1-1. https://doi.org/10.1109/TCAD.2021.3066560\n\nThe MITRE Corporation (MITRE). 2021. CWE-1194: CWE VIEW: Hardware Design. The MITRE Corporation (MITRE). 2021. CWE-1194: CWE VIEW: Hardware Design. https://cwe.mitre.org/data/definitions/1194.html\n\nHyperfuzzing for SoC security validation. Gourav Sujit Kumar Muduli, Pramod Takhar, Subramanyan, 10.1145/3400302.3415709Proceedings of the 39th International Conference on Computer-Aided Design (ICCAD '20). the 39th International Conference on Computer-Aided Design (ICCAD '20)New York, NY, USA, 1-9Association for Computing MachinerySujit Kumar Muduli, Gourav Takhar, and Pramod Subramanyan. 2020. Hy- perfuzzing for SoC security validation. In Proceedings of the 39th International Conference on Computer-Aided Design (ICCAD '20). Association for Computing Machinery, New York, NY, USA, 1-9. https://doi.org/10.1145/3400302.3415709\n\nWHISPER: A Tool for Run-Time Detection of Side-Channel Attacks. Maria Mushtaq, Jeremy Bricq, Muhammad Bhatti, Ayaz Akram, Vianney Lapotre, Guy Gogniat, Pascal Benoit, 10.1109/ACCESS.2020.2988370ConferenceNameIEEE Access. 8IEEE AccessMaria Mushtaq, Jeremy Bricq, Muhammad Bhatti, Ayaz Akram, Vianney Lapotre, Guy Gogniat, and Pascal Benoit. 2020. WHISPER: A Tool for Run-Time Detection of Side-Channel Attacks. IEEE Access 8 (2020), 83871-83900. https://doi.org/10. 1109/ACCESS.2020.2988370 Conference Name: IEEE Access.\n\nRigorous engineering for hardware security: Formal modelling and proof in the CHERI design and implementation process. Kyndylan Nienhuis, Alexandre Joannou, Thomas Bauereiss, Anthony Fox, Michael Roe, Brian Campbell, Matthew Naylor, Robert Norton, Simon Moore, Peter Neumann, Ian Stark, Robert Watson, Peter Sewell, 10.1109/SP40000.2020.000552020 IEEE Symposium on Security and Privacy (SP). 1003-1020. Kyndylan Nienhuis, Alexandre Joannou, Thomas Bauereiss, Anthony Fox, Michael Roe, Brian Campbell, Matthew Naylor, Robert Norton, Simon Moore, Peter Neumann, Ian Stark, Robert Watson, and Peter Sewell. 2020. Rigorous engi- neering for hardware security: Formal modelling and proof in the CHERI design and implementation process. In 2020 IEEE Symposium on Security and Privacy (SP). 1003-1020. https://doi.org/10.1109/SP40000.2020.00055 ISSN: 2375-1207.\n\nINVITED: Formal Verification of Security Critical Hardware-Firmware Interactions in Commercial SoCs. Sayak Ray, Nishant Ghosh, Ramya Masti, Arun Kanuparthi, Jason Fung, 56th ACM/IEEE Design Automation Conference (DAC). 1-4. Sayak Ray, Nishant Ghosh, Ramya Masti, Arun Kanuparthi, and Jason Fung. 2019. INVITED: Formal Verification of Security Critical Hardware-Firmware Interactions in Commercial SoCs. In 2019 56th ACM/IEEE Design Automation Conference (DAC). 1-4. ISSN: 0738-100X.\n\nPhoenix: Detecting and Recovering from Permanent Processor Design Bugs with Programmable Hardware. Smruti Sarangi, Abhishek Tiwari, Josep Torrellas, 10.1109/MICRO.2006.4139th Annual IEEE/ACM International Symposium on Microarchitecture (MICRO'06. Smruti Sarangi, Abhishek Tiwari, and Josep Torrellas. 2006. Phoenix: Detecting and Recovering from Permanent Processor Design Bugs with Programmable Hardware. In 2006 39th Annual IEEE/ACM International Symposium on Microar- chitecture (MICRO'06). 26-37. https://doi.org/10.1109/MICRO.2006.41 ISSN: 2379-3155.\n\nTowards the formal verification of security properties of a Network-on-Chip router. Johanna Sepulveda, Damian Aboul-Hassan, Georg Sigl, Bernd Becker, Matthias Sauer, 10.1109/ETS.2018.8400692IEEE 23rd European Test Symposium (ETS). 1-6. Johanna Sepulveda, Damian Aboul-Hassan, Georg Sigl, Bernd Becker, and Matthias Sauer. 2018. Towards the formal verification of security properties of a Network-on-Chip router. In 2018 IEEE 23rd European Test Symposium (ETS). 1-6. https://doi.org/10.1109/ETS.2018.8400692 ISSN: 1558-1780.\n\nAutomatic RTL coding correction Linting tool for critical issues. Nancy Soliman, Khaled Salah, Ahmed Madian, 10.1109/ICM.2018.870411730th International Conference on Microelectronics (ICM). Nancy Soliman, Khaled Salah, and Ahmed Madian. 2018. Automatic RTL coding correction Linting tool for critical issues. In 2018 30th International Conference on Microelectronics (ICM). 252-255. https://doi.org/10.1109/ICM.2018.8704117\n\nCoverage metrics for functional validation of hardware designs. Serdar Tasiran, Keutzer Keutzer, 10.1109/54.936247IEEE Design Test of Computers. 18Serdar Tasiran and Keutzer Keutzer. 2001. Coverage metrics for functional validation of hardware designs. IEEE Design Test of Computers 18, 4 (July 2001), 36-45. https://doi.org/10.1109/54.936247\n\ndate: 2020-07-29T06:28:49ZNuclei System Technology. 2022. Hummingbirdv2 E203 Core and SoC -GitHub. Nuclei System Technology. 2022. Hummingbirdv2 E203 Core and SoC -GitHub. https://github.com/riscv-mcu/e203_hbirdv2 original-date: 2020-07-29T06:28:49Z.\n\nTimothy Trippel, Kang Shin, Alex Chernyakhovsky, Garret Kelly, Dominic Rizzo, Matthew Hicks, arXiv:2102.02308arXiv: 2102.02308Fuzzing Hardware Like Software. Timothy Trippel, Kang Shin, Alex Chernyakhovsky, Garret Kelly, Dominic Rizzo, and Matthew Hicks. 2021. Fuzzing Hardware Like Software. arXiv:2102.02308 [cs] (Feb. 2021). http://arxiv.org/abs/2102.02308 arXiv: 2102.02308.\n\nAakash Tyagi, csAddison Crump, csAhmad-Reza Sadeghi, csGarrett Persyn, csJeyavijayan Rajendran, csPatrick Jauernig, csRahul Kande, csarXiv:2201.09941arXiv: 2201.09941TheHuzz: Instruction Fuzzing of Processors Using Golden-Reference Models for Finding Software-Exploitable Vulnerabilities. Aakash Tyagi, Addison Crump, Ahmad-Reza Sadeghi, Garrett Persyn, Jeyavijayan Rajendran, Patrick Jauernig, and Rahul Kande. 2022. TheHuzz: Instruction Fuzzing of Processors Using Golden-Reference Models for Finding Software-Exploitable Vulnerabilities. arXiv:2201.09941 [cs] (Jan. 2022). http://arxiv.org/abs/2201.09941 arXiv: 2201.09941.\n\n. Risc-V Core, date: 2014-08-31T10:38:22Zultraembedded. 2022. RISC-V Core. https://github.com/ultraembedded/riscv original-date: 2014-08-31T10:38:22Z.\n\nSynopsys VC SpyGlass Lint. vclint. 2022. Synopsys VC SpyGlass Lint. https://www.synopsys.com/ verification/static-and-formal-verification/vc-spyglass/vc-spyglass-lint.html\n\nStudy and Analysis of RTL Verification Tool. Akhilesh Yadav, Poonam Jindal, Devaraju Basappa, 10.1109/SCES50439.2020.92367472020 IEEE Students Conference on Engineering Systems (SCES). 1-6. Akhilesh Yadav, Poonam Jindal, and Devaraju Basappa. 2020. Study and Analysis of RTL Verification Tool. In 2020 IEEE Students Conference on Engineering Systems (SCES). 1-6. https://doi.org/10.1109/SCES50439.2020.9236747\n\nA Hardware Design Language for Timing-Sensitive Information-Flow Security. Danfeng Zhang, Yao Wang, Edward Suh, Andrew Myers, 10.1145/2694344.2694372Proceedings of the Twentieth International Conference on Architectural Support for Programming Languages and Operating Systems. the Twentieth International Conference on Architectural Support for Programming Languages and Operating SystemsIstanbul TurkeyACMDanfeng Zhang, Yao Wang, Edward Suh, and Andrew Myers. 2015. A Hardware Design Language for Timing-Sensitive Information-Flow Security. In Proceedings of the Twentieth International Conference on Architectural Support for Programming Languages and Operating Systems. ACM, Istanbul Turkey, 503-516. https://doi. org/10.1145/2694344.2694372\n", "annotations": {"author": "[{\"end\":352,\"start\":112},{\"end\":591,\"start\":353},{\"end\":831,\"start\":592},{\"end\":1073,\"start\":832},{\"end\":1313,\"start\":1074},{\"end\":1558,\"start\":1314},{\"end\":1804,\"start\":1559},{\"end\":2046,\"start\":1805},{\"end\":2285,\"start\":2047},{\"end\":2535,\"start\":2286},{\"end\":2775,\"start\":2536},{\"end\":3015,\"start\":2776},{\"end\":3256,\"start\":3016},{\"end\":3495,\"start\":3257},{\"end\":3735,\"start\":3496},{\"end\":3977,\"start\":3736},{\"end\":4217,\"start\":3978},{\"end\":4462,\"start\":4218},{\"end\":4708,\"start\":4463},{\"end\":4950,\"start\":4709},{\"end\":5189,\"start\":4951},{\"end\":5439,\"start\":5190},{\"end\":5679,\"start\":5440},{\"end\":5924,\"start\":5680}]", "publisher": null, "author_last_name": "[{\"end\":125,\"start\":120},{\"end\":364,\"start\":361},{\"end\":604,\"start\":597},{\"end\":846,\"start\":840},{\"end\":1086,\"start\":1082},{\"end\":1331,\"start\":1323},{\"end\":1577,\"start\":1568},{\"end\":1819,\"start\":1811},{\"end\":2058,\"start\":2053},{\"end\":2308,\"start\":2297},{\"end\":2548,\"start\":2543},{\"end\":2788,\"start\":2785},{\"end\":3029,\"start\":3024},{\"end\":3268,\"start\":3265},{\"end\":3508,\"start\":3501},{\"end\":3750,\"start\":3744},{\"end\":3990,\"start\":3986},{\"end\":4235,\"start\":4227},{\"end\":4481,\"start\":4472},{\"end\":4723,\"start\":4715},{\"end\":4962,\"start\":4957},{\"end\":5212,\"start\":5201},{\"end\":5452,\"start\":5447},{\"end\":5697,\"start\":5694}]", "author_first_name": "[{\"end\":119,\"start\":112},{\"end\":360,\"start\":353},{\"end\":596,\"start\":592},{\"end\":839,\"start\":832},{\"end\":1079,\"start\":1074},{\"end\":1081,\"start\":1080},{\"end\":1322,\"start\":1314},{\"end\":1567,\"start\":1559},{\"end\":1810,\"start\":1805},{\"end\":2052,\"start\":2047},{\"end\":2296,\"start\":2286},{\"end\":2542,\"start\":2536},{\"end\":2784,\"start\":2776},{\"end\":3023,\"start\":3016},{\"end\":3264,\"start\":3257},{\"end\":3500,\"start\":3496},{\"end\":3743,\"start\":3736},{\"end\":3983,\"start\":3978},{\"end\":3985,\"start\":3984},{\"end\":4226,\"start\":4218},{\"end\":4471,\"start\":4463},{\"end\":4714,\"start\":4709},{\"end\":4956,\"start\":4951},{\"end\":5200,\"start\":5190},{\"end\":5446,\"start\":5440},{\"end\":5688,\"start\":5680},{\"end\":5693,\"start\":5689}]", "author_affiliation": "[{\"end\":351,\"start\":127},{\"end\":590,\"start\":366},{\"end\":830,\"start\":606},{\"end\":1072,\"start\":848},{\"end\":1312,\"start\":1088},{\"end\":1557,\"start\":1333},{\"end\":1803,\"start\":1579},{\"end\":2045,\"start\":1821},{\"end\":2284,\"start\":2060},{\"end\":2534,\"start\":2310},{\"end\":2774,\"start\":2550},{\"end\":3014,\"start\":2790},{\"end\":3255,\"start\":3031},{\"end\":3494,\"start\":3270},{\"end\":3734,\"start\":3510},{\"end\":3976,\"start\":3752},{\"end\":4216,\"start\":3992},{\"end\":4461,\"start\":4237},{\"end\":4707,\"start\":4483},{\"end\":4949,\"start\":4725},{\"end\":5188,\"start\":4964},{\"end\":5438,\"start\":5214},{\"end\":5678,\"start\":5454},{\"end\":5923,\"start\":5699}]", "title": "[{\"end\":82,\"start\":1},{\"end\":6006,\"start\":5925}]", "venue": "[{\"end\":6017,\"start\":6008}]", "abstract": "[{\"end\":7414,\"start\":6387}]", "bib_ref": "[{\"attributes\":{\"ref_id\":\"b32\"},\"end\":7614,\"start\":7610},{\"attributes\":{\"ref_id\":\"b11\"},\"end\":7672,\"start\":7668},{\"attributes\":{\"ref_id\":\"b37\"},\"end\":7928,\"start\":7924},{\"attributes\":{\"ref_id\":\"b7\"},\"end\":8131,\"start\":8128},{\"attributes\":{\"ref_id\":\"b11\"},\"end\":8134,\"start\":8131},{\"attributes\":{\"ref_id\":\"b24\"},\"end\":8700,\"start\":8696},{\"attributes\":{\"ref_id\":\"b24\"},\"end\":8972,\"start\":8968},{\"attributes\":{\"ref_id\":\"b11\"},\"end\":9286,\"start\":9282},{\"attributes\":{\"ref_id\":\"b7\"},\"end\":9365,\"start\":9362},{\"attributes\":{\"ref_id\":\"b23\"},\"end\":9601,\"start\":9597},{\"attributes\":{\"ref_id\":\"b27\"},\"end\":9639,\"start\":9635},{\"attributes\":{\"ref_id\":\"b28\"},\"end\":9642,\"start\":9639},{\"attributes\":{\"ref_id\":\"b13\"},\"end\":9714,\"start\":9710},{\"attributes\":{\"ref_id\":\"b13\"},\"end\":10794,\"start\":10790},{\"attributes\":{\"ref_id\":\"b8\"},\"end\":11595,\"start\":11592},{\"attributes\":{\"ref_id\":\"b18\"},\"end\":11598,\"start\":11595},{\"attributes\":{\"ref_id\":\"b27\"},\"end\":11601,\"start\":11598},{\"attributes\":{\"ref_id\":\"b28\"},\"end\":11604,\"start\":11601},{\"attributes\":{\"ref_id\":\"b30\"},\"end\":11607,\"start\":11604},{\"attributes\":{\"ref_id\":\"b5\"},\"end\":11638,\"start\":11635},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":11641,\"start\":11638},{\"attributes\":{\"ref_id\":\"b20\"},\"end\":11644,\"start\":11641},{\"attributes\":{\"ref_id\":\"b39\"},\"end\":11647,\"start\":11644},{\"attributes\":{\"ref_id\":\"b21\"},\"end\":11666,\"start\":11662},{\"attributes\":{\"ref_id\":\"b25\"},\"end\":11669,\"start\":11666},{\"attributes\":{\"ref_id\":\"b34\"},\"end\":11672,\"start\":11669},{\"attributes\":{\"ref_id\":\"b35\"},\"end\":11675,\"start\":11672},{\"attributes\":{\"ref_id\":\"b19\"},\"end\":11711,\"start\":11707},{\"attributes\":{\"ref_id\":\"b26\"},\"end\":11714,\"start\":11711},{\"attributes\":{\"ref_id\":\"b29\"},\"end\":11717,\"start\":11714},{\"attributes\":{\"ref_id\":\"b22\"},\"end\":12249,\"start\":12245},{\"attributes\":{\"ref_id\":\"b0\"},\"end\":12644,\"start\":12641},{\"attributes\":{\"ref_id\":\"b37\"},\"end\":12647,\"start\":12644},{\"attributes\":{\"ref_id\":\"b31\"},\"end\":12949,\"start\":12945},{\"attributes\":{\"ref_id\":\"b38\"},\"end\":13032,\"start\":13028},{\"attributes\":{\"ref_id\":\"b17\"},\"end\":13084,\"start\":13080},{\"attributes\":{\"ref_id\":\"b6\"},\"end\":13945,\"start\":13942},{\"attributes\":{\"ref_id\":\"b0\"},\"end\":14100,\"start\":14097},{\"attributes\":{\"ref_id\":\"b11\"},\"end\":15074,\"start\":15070},{\"attributes\":{\"ref_id\":\"b16\"},\"end\":15077,\"start\":15074},{\"attributes\":{\"ref_id\":\"b24\"},\"end\":16822,\"start\":16818},{\"attributes\":{\"ref_id\":\"b5\"},\"end\":17094,\"start\":17091},{\"attributes\":{\"ref_id\":\"b20\"},\"end\":18013,\"start\":18009},{\"attributes\":{\"ref_id\":\"b4\"},\"end\":21376,\"start\":21373},{\"attributes\":{\"ref_id\":\"b14\"},\"end\":22632,\"start\":22628},{\"attributes\":{\"ref_id\":\"b7\"},\"end\":29338,\"start\":29335},{\"attributes\":{\"ref_id\":\"b11\"},\"end\":29341,\"start\":29338},{\"attributes\":{\"ref_id\":\"b23\"},\"end\":29344,\"start\":29341},{\"attributes\":{\"ref_id\":\"b35\"},\"end\":29347,\"start\":29344},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":34927,\"start\":34924},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":35200,\"start\":35197},{\"attributes\":{\"ref_id\":\"b0\"},\"end\":35254,\"start\":35251},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":36253,\"start\":36250},{\"attributes\":{\"ref_id\":\"b0\"},\"end\":36317,\"start\":36314},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":36421,\"start\":36418},{\"attributes\":{\"ref_id\":\"b0\"},\"end\":36440,\"start\":36437},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":36835,\"start\":36832}]", "figure": "[{\"attributes\":{\"id\":\"fig_0\"},\"end\":41754,\"start\":41413},{\"attributes\":{\"id\":\"fig_1\"},\"end\":42193,\"start\":41755},{\"attributes\":{\"id\":\"fig_2\"},\"end\":42229,\"start\":42194},{\"attributes\":{\"id\":\"fig_3\"},\"end\":42447,\"start\":42230},{\"attributes\":{\"id\":\"fig_4\"},\"end\":42777,\"start\":42448},{\"attributes\":{\"id\":\"fig_5\"},\"end\":42828,\"start\":42778},{\"attributes\":{\"id\":\"fig_6\"},\"end\":42876,\"start\":42829},{\"attributes\":{\"id\":\"tab_0\",\"type\":\"table\"},\"end\":43300,\"start\":42877},{\"attributes\":{\"id\":\"tab_1\",\"type\":\"table\"},\"end\":44898,\"start\":43301},{\"attributes\":{\"id\":\"tab_2\",\"type\":\"table\"},\"end\":45108,\"start\":44899},{\"attributes\":{\"id\":\"tab_3\",\"type\":\"table\"},\"end\":46359,\"start\":45109},{\"attributes\":{\"id\":\"tab_5\",\"type\":\"table\"},\"end\":47222,\"start\":46360},{\"attributes\":{\"id\":\"tab_6\",\"type\":\"table\"},\"end\":48122,\"start\":47223},{\"attributes\":{\"id\":\"tab_7\",\"type\":\"table\"},\"end\":48500,\"start\":48123}]", "paragraph": "[{\"end\":8542,\"start\":7430},{\"end\":9716,\"start\":8544},{\"end\":10209,\"start\":9718},{\"end\":10622,\"start\":10211},{\"end\":12104,\"start\":10654},{\"end\":12561,\"start\":12106},{\"end\":13436,\"start\":12563},{\"end\":13983,\"start\":13451},{\"end\":14972,\"start\":13985},{\"end\":16321,\"start\":14974},{\"end\":16744,\"start\":16358},{\"end\":16973,\"start\":16778},{\"end\":17564,\"start\":16975},{\"end\":18014,\"start\":17566},{\"end\":18794,\"start\":18016},{\"end\":19707,\"start\":18796},{\"end\":20530,\"start\":19709},{\"end\":22084,\"start\":20550},{\"end\":22562,\"start\":22131},{\"end\":23325,\"start\":22564},{\"end\":25346,\"start\":23485},{\"end\":26516,\"start\":25506},{\"end\":28498,\"start\":26561},{\"end\":30124,\"start\":28519},{\"end\":30595,\"start\":30146},{\"end\":31085,\"start\":30652},{\"end\":31969,\"start\":31152},{\"end\":34417,\"start\":31971},{\"end\":35905,\"start\":34419},{\"end\":36758,\"start\":35935},{\"end\":37131,\"start\":36760},{\"end\":38089,\"start\":37162},{\"end\":40278,\"start\":38091},{\"end\":40960,\"start\":40310},{\"end\":41412,\"start\":40962}]", "formula": "[{\"attributes\":{\"id\":\"formula_0\"},\"end\":23468,\"start\":23351}]", "table_ref": "[{\"attributes\":{\"ref_id\":\"tab_0\"},\"end\":14552,\"start\":14545},{\"attributes\":{\"ref_id\":\"tab_1\"},\"end\":16972,\"start\":16965},{\"attributes\":{\"ref_id\":\"tab_5\"},\"end\":27082,\"start\":27075},{\"attributes\":{\"ref_id\":\"tab_5\"},\"end\":27857,\"start\":27850},{\"attributes\":{\"ref_id\":\"tab_6\"},\"end\":28875,\"start\":28868},{\"attributes\":{\"ref_id\":\"tab_7\"},\"end\":38536,\"start\":38529},{\"attributes\":{\"ref_id\":\"tab_1\"},\"end\":41210,\"start\":41203}]", "section_header": "[{\"attributes\":{\"n\":\"1\"},\"end\":7428,\"start\":7416},{\"attributes\":{\"n\":\"2\"},\"end\":10652,\"start\":10625},{\"attributes\":{\"n\":\"2.2\"},\"end\":13449,\"start\":13439},{\"attributes\":{\"n\":\"3\"},\"end\":16356,\"start\":16324},{\"attributes\":{\"n\":\"3.1\"},\"end\":16776,\"start\":16747},{\"attributes\":{\"n\":\"3.2\"},\"end\":20548,\"start\":20533},{\"attributes\":{\"n\":\"4\"},\"end\":22129,\"start\":22087},{\"attributes\":{\"n\":\"4.2\"},\"end\":23350,\"start\":23328},{\"attributes\":{\"n\":\"4.2.2\"},\"end\":23483,\"start\":23470},{\"attributes\":{\"n\":\"4.2.3\"},\"end\":25356,\"start\":25349},{\"attributes\":{\"n\":\"4.2.4\"},\"end\":25372,\"start\":25359},{\"attributes\":{\"n\":\"4.2.5\"},\"end\":25504,\"start\":25375},{\"attributes\":{\"n\":\"5\"},\"end\":26548,\"start\":26519},{\"attributes\":{\"n\":\"5.1\"},\"end\":26559,\"start\":26551},{\"attributes\":{\"n\":\"5.2\"},\"end\":28517,\"start\":28501},{\"attributes\":{\"n\":\"5.3\"},\"end\":30144,\"start\":30127},{\"end\":30650,\"start\":30598},{\"end\":31150,\"start\":31088},{\"attributes\":{\"n\":\"5.4\"},\"end\":35933,\"start\":35908},{\"attributes\":{\"n\":\"6\"},\"end\":37160,\"start\":37134},{\"attributes\":{\"n\":\"7\"},\"end\":40308,\"start\":40281},{\"end\":41434,\"start\":41414},{\"end\":41766,\"start\":41756},{\"end\":42205,\"start\":42195},{\"end\":42251,\"start\":42231},{\"end\":42471,\"start\":42449},{\"end\":42841,\"start\":42830},{\"end\":42887,\"start\":42878},{\"end\":43311,\"start\":43302},{\"end\":46370,\"start\":46361},{\"end\":47233,\"start\":47224},{\"end\":48133,\"start\":48124}]", "table": "[{\"end\":43300,\"start\":42924},{\"end\":44898,\"start\":43344},{\"end\":45108,\"start\":44982},{\"end\":46359,\"start\":45472},{\"end\":47222,\"start\":46393},{\"end\":48122,\"start\":47235},{\"end\":48500,\"start\":48179}]", "figure_caption": "[{\"end\":41754,\"start\":41437},{\"end\":42193,\"start\":41768},{\"end\":42229,\"start\":42207},{\"end\":42447,\"start\":42254},{\"end\":42777,\"start\":42476},{\"end\":42828,\"start\":42780},{\"end\":42876,\"start\":42844},{\"end\":42924,\"start\":42889},{\"end\":43344,\"start\":43313},{\"end\":44982,\"start\":44901},{\"end\":45472,\"start\":45111},{\"end\":46393,\"start\":46372},{\"end\":48179,\"start\":48135}]", "figure_ref": "[{\"end\":20758,\"start\":20750},{\"end\":22513,\"start\":22505},{\"end\":23090,\"start\":23082},{\"attributes\":{\"ref_id\":\"fig_1\"},\"end\":24116,\"start\":24108},{\"attributes\":{\"ref_id\":\"fig_1\"},\"end\":24312,\"start\":24304},{\"attributes\":{\"ref_id\":\"fig_2\"},\"end\":24717,\"start\":24709},{\"end\":29556,\"start\":29548},{\"end\":30569,\"start\":30561},{\"end\":31205,\"start\":31196},{\"end\":31219,\"start\":31208},{\"end\":31963,\"start\":31955},{\"end\":32063,\"start\":32055},{\"end\":33143,\"start\":33134},{\"end\":33177,\"start\":33164},{\"end\":33748,\"start\":33735},{\"end\":34506,\"start\":34497},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":34781,\"start\":34772},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":35283,\"start\":35274},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":35448,\"start\":35439},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":35719,\"start\":35710},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":36069,\"start\":36057}]", "bib_author_first_name": "[{\"end\":49738,\"start\":49731},{\"end\":49757,\"start\":49754},{\"end\":49768,\"start\":49762},{\"end\":49781,\"start\":49777},{\"end\":50170,\"start\":50164},{\"end\":50184,\"start\":50179},{\"end\":50390,\"start\":50382},{\"end\":50408,\"start\":50402},{\"end\":50421,\"start\":50416},{\"end\":50434,\"start\":50429},{\"end\":50448,\"start\":50441},{\"end\":50881,\"start\":50873},{\"end\":50895,\"start\":50889},{\"end\":50908,\"start\":50903},{\"end\":50925,\"start\":50918},{\"end\":50944,\"start\":50938},{\"end\":50962,\"start\":50954},{\"end\":51634,\"start\":51623},{\"end\":51649,\"start\":51642},{\"end\":51668,\"start\":51660},{\"end\":51686,\"start\":51681},{\"end\":51697,\"start\":51693},{\"end\":51714,\"start\":51709},{\"end\":51728,\"start\":51724},{\"end\":51742,\"start\":51734},{\"end\":51760,\"start\":51753},{\"end\":52390,\"start\":52385},{\"end\":52406,\"start\":52401},{\"end\":52420,\"start\":52413},{\"end\":52435,\"start\":52428},{\"end\":52448,\"start\":52444},{\"end\":52468,\"start\":52461},{\"end\":52483,\"start\":52478},{\"end\":52500,\"start\":52490},{\"end\":52521,\"start\":52510},{\"end\":53369,\"start\":53361},{\"end\":53385,\"start\":53378},{\"end\":53709,\"start\":53704},{\"end\":54002,\"start\":53995},{\"end\":54021,\"start\":54013},{\"end\":54028,\"start\":54022},{\"end\":54047,\"start\":54040},{\"end\":54060,\"start\":54056},{\"end\":54073,\"start\":54066},{\"end\":54089,\"start\":54083},{\"end\":54101,\"start\":54097},{\"end\":54116,\"start\":54111},{\"end\":54132,\"start\":54128},{\"end\":54617,\"start\":54611},{\"end\":54976,\"start\":54971},{\"end\":54989,\"start\":54981},{\"end\":55001,\"start\":54995},{\"end\":55012,\"start\":55009},{\"end\":55027,\"start\":55020},{\"end\":55038,\"start\":55034},{\"end\":55418,\"start\":55411},{\"end\":55433,\"start\":55426},{\"end\":55449,\"start\":55443},{\"end\":55464,\"start\":55456},{\"end\":56254,\"start\":56251},{\"end\":56265,\"start\":56259},{\"end\":56276,\"start\":56271},{\"end\":56288,\"start\":56284},{\"end\":56944,\"start\":56937},{\"end\":57144,\"start\":57138},{\"end\":57157,\"start\":57151},{\"end\":57169,\"start\":57165},{\"end\":57187,\"start\":57182},{\"end\":57822,\"start\":57816},{\"end\":57849,\"start\":57843},{\"end\":58478,\"start\":58473},{\"end\":58494,\"start\":58488},{\"end\":58510,\"start\":58502},{\"end\":58523,\"start\":58519},{\"end\":58538,\"start\":58531},{\"end\":58551,\"start\":58548},{\"end\":58567,\"start\":58561},{\"end\":59057,\"start\":59049},{\"end\":59077,\"start\":59068},{\"end\":59093,\"start\":59087},{\"end\":59112,\"start\":59105},{\"end\":59125,\"start\":59118},{\"end\":59136,\"start\":59131},{\"end\":59154,\"start\":59147},{\"end\":59169,\"start\":59163},{\"end\":59183,\"start\":59178},{\"end\":59196,\"start\":59191},{\"end\":59209,\"start\":59206},{\"end\":59223,\"start\":59217},{\"end\":59237,\"start\":59232},{\"end\":59892,\"start\":59887},{\"end\":59905,\"start\":59898},{\"end\":59918,\"start\":59913},{\"end\":59930,\"start\":59926},{\"end\":59948,\"start\":59943},{\"end\":60375,\"start\":60369},{\"end\":60393,\"start\":60385},{\"end\":60407,\"start\":60402},{\"end\":60918,\"start\":60911},{\"end\":60936,\"start\":60930},{\"end\":60956,\"start\":60951},{\"end\":60968,\"start\":60963},{\"end\":60985,\"start\":60977},{\"end\":61423,\"start\":61418},{\"end\":61439,\"start\":61433},{\"end\":61452,\"start\":61447},{\"end\":61847,\"start\":61841},{\"end\":61864,\"start\":61857},{\"end\":62380,\"start\":62373},{\"end\":62394,\"start\":62390},{\"end\":62405,\"start\":62401},{\"end\":62428,\"start\":62422},{\"end\":62443,\"start\":62436},{\"end\":62458,\"start\":62451},{\"end\":62759,\"start\":62753},{\"end\":62776,\"start\":62769},{\"end\":62796,\"start\":62786},{\"end\":62815,\"start\":62808},{\"end\":62837,\"start\":62826},{\"end\":62858,\"start\":62851},{\"end\":62876,\"start\":62871},{\"end\":63759,\"start\":63751},{\"end\":63773,\"start\":63767},{\"end\":63790,\"start\":63782},{\"end\":64199,\"start\":64192},{\"end\":64210,\"start\":64207},{\"end\":64223,\"start\":64217},{\"end\":64235,\"start\":64229}]", "bib_author_last_name": "[{\"end\":49107,\"start\":49091},{\"end\":49434,\"start\":49423},{\"end\":49752,\"start\":49739},{\"end\":49760,\"start\":49758},{\"end\":49775,\"start\":49769},{\"end\":49789,\"start\":49782},{\"end\":50177,\"start\":50171},{\"end\":50191,\"start\":50185},{\"end\":50400,\"start\":50391},{\"end\":50414,\"start\":50409},{\"end\":50427,\"start\":50422},{\"end\":50439,\"start\":50435},{\"end\":50455,\"start\":50449},{\"end\":50887,\"start\":50882},{\"end\":50901,\"start\":50896},{\"end\":50916,\"start\":50909},{\"end\":50936,\"start\":50926},{\"end\":50952,\"start\":50945},{\"end\":50969,\"start\":50963},{\"end\":51640,\"start\":51635},{\"end\":51658,\"start\":51650},{\"end\":51679,\"start\":51669},{\"end\":51691,\"start\":51687},{\"end\":51707,\"start\":51698},{\"end\":51722,\"start\":51715},{\"end\":51732,\"start\":51729},{\"end\":51751,\"start\":51743},{\"end\":51769,\"start\":51761},{\"end\":52399,\"start\":52391},{\"end\":52411,\"start\":52407},{\"end\":52426,\"start\":52421},{\"end\":52442,\"start\":52436},{\"end\":52459,\"start\":52449},{\"end\":52476,\"start\":52469},{\"end\":52488,\"start\":52484},{\"end\":52508,\"start\":52501},{\"end\":52531,\"start\":52522},{\"end\":53376,\"start\":53370},{\"end\":53394,\"start\":53386},{\"end\":53715,\"start\":53710},{\"end\":54011,\"start\":54003},{\"end\":54038,\"start\":54029},{\"end\":54054,\"start\":54048},{\"end\":54064,\"start\":54061},{\"end\":54081,\"start\":54074},{\"end\":54095,\"start\":54090},{\"end\":54109,\"start\":54102},{\"end\":54126,\"start\":54117},{\"end\":54139,\"start\":54133},{\"end\":54625,\"start\":54618},{\"end\":54979,\"start\":54977},{\"end\":54993,\"start\":54990},{\"end\":55007,\"start\":55002},{\"end\":55018,\"start\":55013},{\"end\":55032,\"start\":55028},{\"end\":55042,\"start\":55039},{\"end\":55424,\"start\":55419},{\"end\":55441,\"start\":55434},{\"end\":55454,\"start\":55450},{\"end\":55470,\"start\":55465},{\"end\":56257,\"start\":56255},{\"end\":56269,\"start\":56266},{\"end\":56282,\"start\":56277},{\"end\":56296,\"start\":56289},{\"end\":56952,\"start\":56945},{\"end\":57149,\"start\":57145},{\"end\":57163,\"start\":57158},{\"end\":57180,\"start\":57170},{\"end\":57192,\"start\":57188},{\"end\":57841,\"start\":57823},{\"end\":57856,\"start\":57850},{\"end\":57869,\"start\":57858},{\"end\":58486,\"start\":58479},{\"end\":58500,\"start\":58495},{\"end\":58517,\"start\":58511},{\"end\":58529,\"start\":58524},{\"end\":58546,\"start\":58539},{\"end\":58559,\"start\":58552},{\"end\":58574,\"start\":58568},{\"end\":59066,\"start\":59058},{\"end\":59085,\"start\":59078},{\"end\":59103,\"start\":59094},{\"end\":59116,\"start\":59113},{\"end\":59129,\"start\":59126},{\"end\":59145,\"start\":59137},{\"end\":59161,\"start\":59155},{\"end\":59176,\"start\":59170},{\"end\":59189,\"start\":59184},{\"end\":59204,\"start\":59197},{\"end\":59215,\"start\":59210},{\"end\":59230,\"start\":59224},{\"end\":59244,\"start\":59238},{\"end\":59896,\"start\":59893},{\"end\":59911,\"start\":59906},{\"end\":59924,\"start\":59919},{\"end\":59941,\"start\":59931},{\"end\":59953,\"start\":59949},{\"end\":60383,\"start\":60376},{\"end\":60400,\"start\":60394},{\"end\":60417,\"start\":60408},{\"end\":60928,\"start\":60919},{\"end\":60949,\"start\":60937},{\"end\":60961,\"start\":60957},{\"end\":60975,\"start\":60969},{\"end\":60991,\"start\":60986},{\"end\":61431,\"start\":61424},{\"end\":61445,\"start\":61440},{\"end\":61459,\"start\":61453},{\"end\":61855,\"start\":61848},{\"end\":61872,\"start\":61865},{\"end\":62388,\"start\":62381},{\"end\":62399,\"start\":62395},{\"end\":62420,\"start\":62406},{\"end\":62434,\"start\":62429},{\"end\":62449,\"start\":62444},{\"end\":62464,\"start\":62459},{\"end\":62765,\"start\":62760},{\"end\":62782,\"start\":62777},{\"end\":62804,\"start\":62797},{\"end\":62822,\"start\":62816},{\"end\":62847,\"start\":62838},{\"end\":62867,\"start\":62859},{\"end\":62882,\"start\":62877},{\"end\":63394,\"start\":63383},{\"end\":63765,\"start\":63760},{\"end\":63780,\"start\":63774},{\"end\":63798,\"start\":63791},{\"end\":64205,\"start\":64200},{\"end\":64215,\"start\":64211},{\"end\":64227,\"start\":64224},{\"end\":64241,\"start\":64236}]", "bib_entry": "[{\"attributes\":{\"id\":\"b0\"},\"end\":49087,\"start\":48949},{\"attributes\":{\"doi\":\"date: 2017- 08-08T12:16:36Z\",\"id\":\"b1\"},\"end\":49229,\"start\":49089},{\"attributes\":{\"doi\":\"date: 2012-08-21T08:45:53Z\",\"id\":\"b2\"},\"end\":49419,\"start\":49231},{\"attributes\":{\"doi\":\"date: 2017-05-09T04:29:07Z\",\"id\":\"b3\"},\"end\":49556,\"start\":49421},{\"attributes\":{\"id\":\"b4\"},\"end\":49642,\"start\":49558},{\"attributes\":{\"doi\":\"10.23919/DATE.2017.7927266\",\"id\":\"b5\",\"matched_paper_id\":3913824},\"end\":50125,\"start\":49644},{\"attributes\":{\"doi\":\"10.1007/0-306-47631-2_10\",\"id\":\"b6\"},\"end\":50378,\"start\":50127},{\"attributes\":{\"doi\":\"10.1109/MDAT.2020.3013727\",\"id\":\"b7\"},\"end\":50787,\"start\":50380},{\"attributes\":{\"doi\":\"10.1007/978-3-319-78375-8_11\",\"id\":\"b8\",\"matched_paper_id\":3969446},\"end\":51529,\"start\":50789},{\"attributes\":{\"doi\":\"10.1145/3483790\",\"id\":\"b9\",\"matched_paper_id\":244547477},\"end\":52136,\"start\":51531},{\"attributes\":{\"doi\":\"date: 2013-08-19T19:24:09Z\",\"id\":\"b10\"},\"end\":52322,\"start\":52138},{\"attributes\":{\"id\":\"b11\",\"matched_paper_id\":199521054},\"end\":53129,\"start\":52324},{\"attributes\":{\"id\":\"b12\"},\"end\":53321,\"start\":53131},{\"attributes\":{\"id\":\"b13\"},\"end\":53637,\"start\":53323},{\"attributes\":{\"id\":\"b14\"},\"end\":53911,\"start\":53639},{\"attributes\":{\"doi\":\"10.1109/TVLSI.2017.2654506\",\"id\":\"b15\"},\"end\":54447,\"start\":53913},{\"attributes\":{\"id\":\"b16\"},\"end\":54568,\"start\":54449},{\"attributes\":{\"doi\":\"10.1109/MTV.2014.25\",\"id\":\"b17\",\"matched_paper_id\":2098670},\"end\":54909,\"start\":54570},{\"attributes\":{\"doi\":\"10.1016/j.vlsi.2018.09.007\",\"id\":\"b18\",\"matched_paper_id\":54445684},\"end\":55307,\"start\":54911},{\"attributes\":{\"doi\":\"10.1145/2694344.2694366\",\"id\":\"b19\",\"matched_paper_id\":16984442},\"end\":56179,\"start\":55309},{\"attributes\":{\"doi\":\"10.1109/MC.2016.225ConferenceName\",\"id\":\"b20\",\"matched_paper_id\":32457378},\"end\":56575,\"start\":56181},{\"attributes\":{\"id\":\"b21\"},\"end\":56908,\"start\":56577},{\"attributes\":{\"id\":\"b22\",\"matched_paper_id\":59749883},\"end\":57059,\"start\":56910},{\"attributes\":{\"doi\":\"10.1109/TCAD.2021.3066560\",\"id\":\"b23\",\"matched_paper_id\":236754677},\"end\":57574,\"start\":57061},{\"attributes\":{\"id\":\"b24\"},\"end\":57772,\"start\":57576},{\"attributes\":{\"doi\":\"10.1145/3400302.3415709\",\"id\":\"b25\",\"matched_paper_id\":227221656},\"end\":58407,\"start\":57774},{\"attributes\":{\"doi\":\"10.1109/ACCESS.2020.2988370ConferenceName\",\"id\":\"b26\",\"matched_paper_id\":218515932},\"end\":58928,\"start\":58409},{\"attributes\":{\"doi\":\"10.1109/SP40000.2020.00055\",\"id\":\"b27\",\"matched_paper_id\":202719807},\"end\":59784,\"start\":58930},{\"attributes\":{\"id\":\"b28\",\"matched_paper_id\":163164627},\"end\":60268,\"start\":59786},{\"attributes\":{\"doi\":\"10.1109/MICRO.2006.41\",\"id\":\"b29\",\"matched_paper_id\":9229652},\"end\":60825,\"start\":60270},{\"attributes\":{\"doi\":\"10.1109/ETS.2018.8400692\",\"id\":\"b30\",\"matched_paper_id\":49560099},\"end\":61350,\"start\":60827},{\"attributes\":{\"doi\":\"10.1109/ICM.2018.8704117\",\"id\":\"b31\",\"matched_paper_id\":145048144},\"end\":61775,\"start\":61352},{\"attributes\":{\"doi\":\"10.1109/54.936247\",\"id\":\"b32\",\"matched_paper_id\":15451445},\"end\":62119,\"start\":61777},{\"attributes\":{\"doi\":\"date: 2020-07-29T06:28:49Z\",\"id\":\"b33\"},\"end\":62371,\"start\":62121},{\"attributes\":{\"doi\":\"arXiv:2102.02308\",\"id\":\"b34\"},\"end\":62751,\"start\":62373},{\"attributes\":{\"id\":\"b35\"},\"end\":63379,\"start\":62753},{\"attributes\":{\"id\":\"b36\"},\"end\":63531,\"start\":63381},{\"attributes\":{\"id\":\"b37\"},\"end\":63704,\"start\":63533},{\"attributes\":{\"id\":\"b38\",\"matched_paper_id\":226265024},\"end\":64115,\"start\":63706},{\"attributes\":{\"id\":\"b39\",\"matched_paper_id\":207221430},\"end\":64861,\"start\":64117}]", "bib_title": "[{\"end\":49729,\"start\":49644},{\"end\":50871,\"start\":50789},{\"end\":51621,\"start\":51531},{\"end\":52383,\"start\":52324},{\"end\":54609,\"start\":54570},{\"end\":54969,\"start\":54911},{\"end\":55409,\"start\":55309},{\"end\":56249,\"start\":56181},{\"end\":56649,\"start\":56577},{\"end\":56935,\"start\":56910},{\"end\":57136,\"start\":57061},{\"end\":57814,\"start\":57774},{\"end\":58471,\"start\":58409},{\"end\":59047,\"start\":58930},{\"end\":59885,\"start\":59786},{\"end\":60367,\"start\":60270},{\"end\":60909,\"start\":60827},{\"end\":61416,\"start\":61352},{\"end\":61839,\"start\":61777},{\"end\":63749,\"start\":63706},{\"end\":64190,\"start\":64117}]", "bib_author": "[{\"end\":49109,\"start\":49091},{\"end\":49436,\"start\":49423},{\"end\":49754,\"start\":49731},{\"end\":49762,\"start\":49754},{\"end\":49777,\"start\":49762},{\"end\":49791,\"start\":49777},{\"end\":50179,\"start\":50164},{\"end\":50193,\"start\":50179},{\"end\":50402,\"start\":50382},{\"end\":50416,\"start\":50402},{\"end\":50429,\"start\":50416},{\"end\":50441,\"start\":50429},{\"end\":50457,\"start\":50441},{\"end\":50889,\"start\":50873},{\"end\":50903,\"start\":50889},{\"end\":50918,\"start\":50903},{\"end\":50938,\"start\":50918},{\"end\":50954,\"start\":50938},{\"end\":50971,\"start\":50954},{\"end\":51642,\"start\":51623},{\"end\":51660,\"start\":51642},{\"end\":51681,\"start\":51660},{\"end\":51693,\"start\":51681},{\"end\":51709,\"start\":51693},{\"end\":51724,\"start\":51709},{\"end\":51734,\"start\":51724},{\"end\":51753,\"start\":51734},{\"end\":51771,\"start\":51753},{\"end\":52401,\"start\":52385},{\"end\":52413,\"start\":52401},{\"end\":52428,\"start\":52413},{\"end\":52444,\"start\":52428},{\"end\":52461,\"start\":52444},{\"end\":52478,\"start\":52461},{\"end\":52490,\"start\":52478},{\"end\":52510,\"start\":52490},{\"end\":52533,\"start\":52510},{\"end\":53378,\"start\":53361},{\"end\":53396,\"start\":53378},{\"end\":53717,\"start\":53704},{\"end\":54013,\"start\":53995},{\"end\":54040,\"start\":54013},{\"end\":54056,\"start\":54040},{\"end\":54066,\"start\":54056},{\"end\":54083,\"start\":54066},{\"end\":54097,\"start\":54083},{\"end\":54111,\"start\":54097},{\"end\":54128,\"start\":54111},{\"end\":54141,\"start\":54128},{\"end\":54627,\"start\":54611},{\"end\":54981,\"start\":54971},{\"end\":54995,\"start\":54981},{\"end\":55009,\"start\":54995},{\"end\":55020,\"start\":55009},{\"end\":55034,\"start\":55020},{\"end\":55044,\"start\":55034},{\"end\":55426,\"start\":55411},{\"end\":55443,\"start\":55426},{\"end\":55456,\"start\":55443},{\"end\":55472,\"start\":55456},{\"end\":56259,\"start\":56251},{\"end\":56271,\"start\":56259},{\"end\":56284,\"start\":56271},{\"end\":56298,\"start\":56284},{\"end\":56954,\"start\":56937},{\"end\":57151,\"start\":57138},{\"end\":57165,\"start\":57151},{\"end\":57182,\"start\":57165},{\"end\":57194,\"start\":57182},{\"end\":57843,\"start\":57816},{\"end\":57858,\"start\":57843},{\"end\":57871,\"start\":57858},{\"end\":58488,\"start\":58473},{\"end\":58502,\"start\":58488},{\"end\":58519,\"start\":58502},{\"end\":58531,\"start\":58519},{\"end\":58548,\"start\":58531},{\"end\":58561,\"start\":58548},{\"end\":58576,\"start\":58561},{\"end\":59068,\"start\":59049},{\"end\":59087,\"start\":59068},{\"end\":59105,\"start\":59087},{\"end\":59118,\"start\":59105},{\"end\":59131,\"start\":59118},{\"end\":59147,\"start\":59131},{\"end\":59163,\"start\":59147},{\"end\":59178,\"start\":59163},{\"end\":59191,\"start\":59178},{\"end\":59206,\"start\":59191},{\"end\":59217,\"start\":59206},{\"end\":59232,\"start\":59217},{\"end\":59246,\"start\":59232},{\"end\":59898,\"start\":59887},{\"end\":59913,\"start\":59898},{\"end\":59926,\"start\":59913},{\"end\":59943,\"start\":59926},{\"end\":59955,\"start\":59943},{\"end\":60385,\"start\":60369},{\"end\":60402,\"start\":60385},{\"end\":60419,\"start\":60402},{\"end\":60930,\"start\":60911},{\"end\":60951,\"start\":60930},{\"end\":60963,\"start\":60951},{\"end\":60977,\"start\":60963},{\"end\":60993,\"start\":60977},{\"end\":61433,\"start\":61418},{\"end\":61447,\"start\":61433},{\"end\":61461,\"start\":61447},{\"end\":61857,\"start\":61841},{\"end\":61874,\"start\":61857},{\"end\":62390,\"start\":62373},{\"end\":62401,\"start\":62390},{\"end\":62422,\"start\":62401},{\"end\":62436,\"start\":62422},{\"end\":62451,\"start\":62436},{\"end\":62466,\"start\":62451},{\"end\":62769,\"start\":62753},{\"end\":62786,\"start\":62769},{\"end\":62808,\"start\":62786},{\"end\":62826,\"start\":62808},{\"end\":62851,\"start\":62826},{\"end\":62871,\"start\":62851},{\"end\":62886,\"start\":62871},{\"end\":63396,\"start\":63383},{\"end\":63767,\"start\":63751},{\"end\":63782,\"start\":63767},{\"end\":63800,\"start\":63782},{\"end\":64207,\"start\":64192},{\"end\":64217,\"start\":64207},{\"end\":64229,\"start\":64217},{\"end\":64243,\"start\":64229}]", "bib_venue": "[{\"end\":48984,\"start\":48949},{\"end\":49274,\"start\":49231},{\"end\":49583,\"start\":49558},{\"end\":49823,\"start\":49817},{\"end\":50162,\"start\":50127},{\"end\":50555,\"start\":50482},{\"end\":51037,\"start\":50999},{\"end\":51801,\"start\":51786},{\"end\":52202,\"start\":52164},{\"end\":52625,\"start\":52533},{\"end\":53202,\"start\":53131},{\"end\":53359,\"start\":53323},{\"end\":53702,\"start\":53639},{\"end\":53993,\"start\":53913},{\"end\":54489,\"start\":54449},{\"end\":54710,\"start\":54646},{\"end\":55081,\"start\":55070},{\"end\":55633,\"start\":55495},{\"end\":56339,\"start\":56331},{\"end\":56685,\"start\":56651},{\"end\":56974,\"start\":56954},{\"end\":57296,\"start\":57219},{\"end\":57648,\"start\":57576},{\"end\":57979,\"start\":57894},{\"end\":58628,\"start\":58617},{\"end\":59331,\"start\":59272},{\"end\":60008,\"start\":59955},{\"end\":60515,\"start\":60440},{\"end\":61061,\"start\":61017},{\"end\":61540,\"start\":61485},{\"end\":61920,\"start\":61891},{\"end\":62218,\"start\":62147},{\"end\":62529,\"start\":62499},{\"end\":63040,\"start\":62919},{\"end\":63558,\"start\":63533},{\"end\":63894,\"start\":63830},{\"end\":64392,\"start\":64266},{\"end\":51081,\"start\":51077},{\"end\":52746,\"start\":52627},{\"end\":55774,\"start\":55635},{\"end\":58073,\"start\":57981},{\"end\":64520,\"start\":64394}]"}}}, "year": 2023, "month": 12, "day": 17}