{"id": 59316445, "updated": "2023-10-01 21:39:49.075", "metadata": {"title": "On Learning Meaningful Code Changes via Neural Machine Translation", "authors": "[{\"first\":\"Michele\",\"last\":\"Tufano\",\"middle\":[]},{\"first\":\"Jevgenija\",\"last\":\"Pantiuchina\",\"middle\":[]},{\"first\":\"Cody\",\"last\":\"Watson\",\"middle\":[]},{\"first\":\"Gabriele\",\"last\":\"Bavota\",\"middle\":[]},{\"first\":\"Denys\",\"last\":\"Poshyvanyk\",\"middle\":[]}]", "venue": "2019 IEEE/ACM 41st International Conference on Software Engineering (ICSE)", "journal": "2019 IEEE/ACM 41st International Conference on Software Engineering (ICSE)", "publication_date": {"year": 2019, "month": 1, "day": 25}, "abstract": "Recent years have seen the rise of Deep Learning (DL) techniques applied to source code. Researchers have exploited DL to automate several development and maintenance tasks, such as writing commit messages, generating comments and detecting vulnerabilities among others. One of the long lasting dreams of applying DL to source code is the possibility to automate non-trivial coding activities. While some steps in this direction have been taken (e.g., learning how to fix bugs), there is still a glaring lack of empirical evidence on the types of code changes that can be learned and automatically applied by DL. Our goal is to make this first important step by quantitatively and qualitatively investigating the ability of a Neural Machine Translation (NMT) model to learn how to automatically apply code changes implemented by developers during pull requests. We train and experiment with the NMT model on a set of 236k pairs of code components before and after the implementation of the changes provided in the pull requests. We show that, when applied in a narrow enough context (i.e., small/medium-sized pairs of methods before/after the pull request changes), NMT can automatically replicate the changes implemented by developers during pull requests in up to 36% of the cases. Moreover, our qualitative analysis shows that the model is capable of learning and replicating a wide variety of meaningful code changes, especially refactorings and bug-fixing activities. Our results pave the way for novel research in the area of DL on code, such as the automatic learning and applications of refactoring.", "fields_of_study": "[\"Computer Science\"]", "external_ids": {"arxiv": "1901.09102", "mag": "2954823997", "acl": null, "pubmed": null, "pubmedcentral": null, "dblp": "conf/icse/TufanoPWBP19", "doi": "10.1109/icse.2019.00021"}}, "content": {"source": {"pdf_hash": "ecbf8d37fbea6ed515fa36038b2c84981c159cea", "pdf_src": "Arxiv", "pdf_uri": "[\"https://arxiv.org/pdf/1901.09102v1.pdf\"]", "oa_url_match": true, "oa_info": {"license": null, "open_access_url": "http://arxiv.org/pdf/1901.09102", "status": "GREEN"}}, "grobid": {"id": "a2b008a63e725265dca25ee2ed6eba2983627225", "type": "plain-text", "url": "s3://ai2-s2-pdf-extraction-prod/parse-results/s2orc_worker/ecbf8d37fbea6ed515fa36038b2c84981c159cea.txt", "contents": "\nOn Learning Meaningful Code Changes via Neural Machine Translation\n\n\nMichele Tufano mtufano@cs.wm.edu \nCollege of William and Mary\nWilliamsburgVirginiaUSA\n\nJevgenija Pantiuchina jevgenija.pantiuchina@usi.ch \nUniversit\u00e0 della Svizzera italiana (USI)\nLuganoSwitzerland\n\nCody Watson cawatson@cs.wm.edu \nCollege of William and Mary\nWilliamsburgVirginiaUSA\n\nGabriele Bavota gabriele.bavota@usi.ch \nUniversit\u00e0 della Svizzera italiana (USI)\nLuganoSwitzerland\n\nDenys Poshyvanyk \nCollege of William and Mary\nWilliamsburgVirginiaUSA\n\nOn Learning Meaningful Code Changes via Neural Machine Translation\nIndex Terms-Neural-Machine Translation; Empirical Study\nRecent years have seen the rise of Deep Learning (DL) techniques applied to source code. Researchers have exploited DL to automate several development and maintenance tasks, such as writing commit messages, generating comments and detecting vulnerabilities among others. One of the long lasting dreams of applying DL to source code is the possibility to automate non-trivial coding activities. While some steps in this direction have been taken (e.g., learning how to fix bugs), there is still a glaring lack of empirical evidence on the types of code changes that can be learned and automatically applied by DL.Our goal is to make this first important step by quantitatively and qualitatively investigating the ability of a Neural Machine Translation (NMT) model to learn how to automatically apply code changes implemented by developers during pull requests. We train and experiment with the NMT model on a set of 236k pairs of code components before and after the implementation of the changes provided in the pull requests. We show that, when applied in a narrow enough context (i.e., small/mediumsized pairs of methods before/after the pull request changes), NMT can automatically replicate the changes implemented by developers during pull requests in up to 36% of the cases. Moreover, our qualitative analysis shows that the model is capable of learning and replicating a wide variety of meaningful code changes, especially refactorings and bug-fixing activities. Our results pave the way for novel research in the area of DL on code, such as the automatic learning and applications of refactoring.\n\nAbstract-Recent years have seen the rise of Deep Learning (DL) techniques applied to source code. Researchers have exploited DL to automate several development and maintenance tasks, such as writing commit messages, generating comments and detecting vulnerabilities among others. One of the long lasting dreams of applying DL to source code is the possibility to automate non-trivial coding activities. While some steps in this direction have been taken (e.g., learning how to fix bugs), there is still a glaring lack of empirical evidence on the types of code changes that can be learned and automatically applied by DL.\n\nOur goal is to make this first important step by quantitatively and qualitatively investigating the ability of a Neural Machine Translation (NMT) model to learn how to automatically apply code changes implemented by developers during pull requests. We train and experiment with the NMT model on a set of 236k pairs of code components before and after the implementation of the changes provided in the pull requests. We show that, when applied in a narrow enough context (i.e., small/mediumsized pairs of methods before/after the pull request changes), NMT can automatically replicate the changes implemented by developers during pull requests in up to 36% of the cases. Moreover, our qualitative analysis shows that the model is capable of learning and replicating a wide variety of meaningful code changes, especially refactorings and bug-fixing activities. Our results pave the way for novel research in the area of DL on code, such as the automatic learning and applications of refactoring.\n\nIndex Terms-Neural-Machine Translation; Empirical Study\n\n\nI. INTRODUCTION\n\nSeveral works recently focused on the use of advanced machine learning techniques on source code with the goal of (semi)automating several non-trivial tasks, including code completion [65], generation of commit messages [47], method names [27], code comments [66], defect prediction [63], bug localization [49] and fixing [62], clone detection [64], code search [40], and learning API templates [41].\n\nThe rise of this research thread in the software engineering (SE) community is due to a combination of factors. The first is the vast availability of data, specifically source code, and its surrounding artifacts in open-source repositories. For instance, at the time of writing this paper, GitHub alone hosted 100M repositories, with over 200M merged pull requests (PRs) and 2B commits. Second, DL has become a useful tool due to its ability to learn categorization of data through the hidden layer architecture, making it especially proficient in feature detection [31]. Specifically, Neural Machine Translation (NMT) has become a premier method for the translation of different languages, surpassing that of human interpretation [67]. A similar principle applies to \"translating\" one piece of source code into another. Here, the ambiguity of translating makes this method extremely versatile: One can learn to translate buggy code into fixed code, English into Spanish, Java into C, etc. The third is the availability of (relatively) cheap hardware able to efficiently run DL infrastructures.\n\nDespite all the work, only a few approaches have been proposed to automate non-trivial coding activities. Tufano et al. [62] showed that DL can be used to automate bug-fixing activities. However, there is still a lack of empirical evidence about the types of code changes that can actually be learned and automatically applied by using DL. While most of the works applying DL in SE focus on quantitatively evaluating the performance of the devised technique (e.g., How many bugs is our approach able to fix?), little qualitative analysis has been done to deeply investigate the meaningfulness of the output produced by DL-based approaches. In this paper, we make the first empirical step towards extensively investigating the ability of an NMT model to learn how to automatically apply code changes just as developers do in PRs. We harness NMT to automatically \"translate\" a code component from its state before the implementation of the PR and after the PR has been merged, thereby, emulating the combination of code changes that would be implemented by developers in PRs.\n\nWe mine three large Gerrit [17] code review repositories, namely Android [14], Google Source [15], and Ovirt [16]. In total, these repositories host code reviews related to 339 subprojects. We collected from these projects 78,981 merged PRs that underwent code review. We only considered merged and reviewed PRs for three reasons. First, we wanted to ensure that an NMT model is learning meaningful changes, thus, justifying the choice of mining \"reviewed PRs\" as opposed to any change committed in the versioning system. Second, given the deep qualitative focus of our study, we wanted to analyze the discussions carried out in the code review process to better understand the types of changes learned by our approach. Indeed, while for commits we would only have commit notes accompanying them, with a reviewed PR we can count on a rich qualitative data explaining the rationale behind the implemented changes. Third, we only focus on merged PRs, since the code before and after (i.e., merged) the PR is available. This is not the case for abandoned PRs. We extract method-level AST edit operations from these PRs using fine-grained source code differencing [38]. This resulted in 239,522 method pairs, each of them representing the method before (PR not submitted) and after (PR merged) the PR process. An Encoder-Decoder Recurrent Neural Network (RNN) is then used to learn the code transformations performed by developers during PR activities.\n\nWe demonstrate a quantitative and qualitative evaluation of the NMT model. For the quantitative analysis, we assessed its ability in modifying the project's code exactly as done by developers during real PRs. This means that we compare, for the same code components, the output of the manually implemented changes and of the output of the NMT model. The qualitative analysis aims instead at distilling a taxonomy of meaningful code transformations that the model was able to automatically learn from the training data -see Fig. 1.\n\nThe achieved results indicate that, in its best configuration, the NMT model is able to inject the same code transformations that are implemented by developers in PRs in 16-36% of cases, depending on the number of possible solutions that it is required to produce using beam search [57]. Moreover, the extracted taxonomy shows that the model is able to learn a rich variety of meaningful code transformations, automatically fixing bugs and refactoring code as humans would do. As explained in Section III, these results have been achieved in a quite narrow context (i.e., we only considered pairs of small/medium methods before/after the implementation of the changes carried by the PR), and this is also one of the reasons why our infrastructure mostly learned bug-fixing and refactoring activities (as opposed to the implementation of new features). However, we believe that our results clearly show the potential of NMT for learning and automating non-trivial code changes and therefore can pave the way to more research targeting the automation of code changes (e.g., approaches designed to learn and apply refactorings). To foster research in this direction, we make publicly available the complete datasets, source code, tools, and raw data used in our experiments [21].\n\n\nII. APPROACH\n\nOur approach starts with mining PRs from three large Gerrit repositories (Sec. II-A). We extract the source code before and after the PRs are merged. We pair pre-PR and post-PR methods, where each pair serves as an example of a meaningful change (Sec. II-B). Method pairs are then abstracted, filtered, and organized in datasets (Sec. II-C). We train our model to translate the version of the code before the PR into the one after the PR, to emulate the code change (Sec. II-D). Finally, NMT's output model is concretized into real code (Sec. II-E).\n\n\nA. Code Reviews Mining\n\nWe built a Gerrit crawler to collect the PR data needed to train the NMT model. Given a Gerrit server, the crawler extracts the list of projects hosted on it. Then, for each project, the crawler retrieves the list of all PRs submitted for review and having \"merged\" as the final status. We then process each merged PR P using the following steps. First, let us define the set of Java files submitted in P as F S = {F 1 , F 2 , . . . , F n }.\n\nWe ignore non-Java files, since our NMT model only supports Java. For each file in F S , we use the Gerrit API to retrieve their version before the changes implemented in the PR. The crawler discards new files created in the PR (i.e., not existing before the PR) since we cannot learn any code transformation from them (we need the code before/after the PR to learn changes implemented by developers). Then, Gerrit API is used to retrieve the merged file versions impacted by the PR. The two (before/after) file sets might not be exactly the same, due to files created/deleted during the review process.\n\nThe output of the crawler is, for each PR, the version of the files impacted before (pre-PR) and after (post-PR, merged) the PR. At the end of the mining process we obtain three datasets of PRs: P R Ovirt , P R Android , and P R Google .\n\n\nB. Code Extraction\n\nEach mined PR is represented as pr\n= {(f 1 , . . . , f n ), (f 1 , . . . , f m )}, where f 1 , .\n. . , f n are the source code files before the PR, and f 1 , . . . , f m are code files after the PR. As previously explained, the two sets may or may not be the same size, since files could have been added or removed during the PR process. In the first step, we rely on GumTreeDiff [38] to establish the file-to-file mapping, performed using semantic anchors, between pre-and post-PR files and disregarding any file added/removed during the code review process. After this step, each PR is stored in the format pr = {(f 1 , . . . , f k ), (f 1 , . . . , f k )}, where f i is the file before and f i the corresponding version of the file after the PR. Next, each pair of files (f i , f i ) is again analyzed using GumTreeDiff, which establishes method-to-method mapping and identifies AST operations performed between two versions of the same method. We select only pairs of methods for which the code after the PR has been changed with respect to the code before the PR. Then We use the method-level granularity for several reasons: (i) methods implement a single functionality and provide enough context for a meaningful code transformation; (ii) file-level code changes are still possible by composing multiple methodlevel code transformations; (iii) files represent large corpus of text, with potentially many lines of untouched code during the PR, which would hinder our goal to train a NMT model.\n\nIn this paper we only study code changes which modify existing methods, disregarding code changes that involve the creation or deletion of entire methods/files (see Section V).\n\n\nC. Code Abstraction & Filtering\n\nNMT models generate sequences of tokens by computing probability distributions over words. They can become very slow or imprecise when dealing with a large vocabulary comprised of many possible output tokens. This problem has been addressed by artificially limiting the vocabulary size, considering only most common words, assigning special tokens (e.g., UNK) to rare words or by learning subword units and splitting the words into constituent tokens [53], [67]. The problem of large vocabularies (a.k.a. open vocabulary) is well known in the Natural Language Processing (NLP) field, where languages such as English or Chinese can have hundreds of thousands of words. This problem is even more pronounced for source code. As a matter of fact, developers are not limited to a finite dictionary of words to represent source code, rather, they can generate a potentially infinite amount of novel identifiers and literals. Table I shows the number of unique tokens identified in the source code of the three datasets. The vocabulary of the datasets ranges between 42k and 267k, while the combined vocabulary of the three datasets exceeds 370k unique tokens. In comparison, the Oxford English Dictionary contains entries for 171,476 words [55].\n\nIn order to allow the training of an NMT model, we need a way to reduce the vocabulary while still retaining semantic information of the source code. We employ an abstraction process which relies on the following observations regarding code changes: (i) several chunks of code might remain untouched; (ii) developers tend to reuse identifiers and literals already present in the code; (iii) frequent identifiers (i.e., common API calls and variable names) and literals (e.g., 0, 1, \"foo\") are likely to be introduced in code changes.\n\nWe start by computing the top-300 most frequent identifiers (i.e., type, method, and variable names) and literals (i.e., int, double, char, string values) used in the source code for each of the three datasets. This set contains frequent types, API calls, variable names and common literal values (e.g., 0, 1, \"\\n\") that we want to keep in our vocabulary.\n\nSubsequently, we abstract the source code of the method pairs by means of a process that replaces identifiers and literals with reusable IDs. The source code of a method is fed to a lexer, built on top of ANTLR [56], which tokenizes the raw code into a stream of tokens. This stream of tokens is then fed into a Java parser, which discerns the role of each identifier (i.e., whether it represents a variable, method, or type name) and the type of a literal. Each unique identifier and literal is mapped to an ID, having the form of CATEGORY_#, where CATEGORY represents the type of identifier or literal (i.e., TYPE, METHOD, VAR, INT, FLOAT, CHAR, STRING) and # is a numerical ID generated sequentially for each unique type of instance within that category (e.g., the first method will receive METHOD_0, the third integer value INT_2, etc.). These IDs are used in place of identifiers and literals in the abstracted code, while the mapping between IDs and actual identifier/literal values is saved in a map M , which allows us to map back the IDs in the code concretization phase (Section II-E). During the abstraction process, we replace all identifiers/literals with IDs, except for the list of 300 most frequent identifiers and literals, for which we keep the original token value in the corpus.\n\nGiven a method pair (m b , m a ), the method m b is abstracted first. Then, using the same mapping M generated during the abstraction of m b , the method m a is abstracted in such a way that identifiers/literals already available in M will use the same ID, while new identifiers/literals introduced in m a (and not available in m b ) will receive a new ID. At the end of this process, from the original method pair (m b , m a ) we obtain the abstracted method pair (am b , am a ).\n\nWe allow IDs to be reused across different method pairs (e.g., the first method name will always receive the ID METHOD_0), therefore leading to an overall reduction of the vocabulary size. The third column of Table I reports the vocabulary size after the abstraction process, which shows a significant reduction in the number of unique tokens in the corpus. In particular, after the abstraction process, the vocabulary contains: (i) Java keywords; (ii) top-300 identifiers/literals; (iii) reusable IDs. It is worth noting that the last row in Table I (i.e., All) does not represent the cumulative sum, but rather the count of unique tokens when the three dataset corpora are merged.\n\nHaving a relatively small vocabulary allows the NMT model to focus on learning patterns of code transformations that are common in different contexts. Moreover, the use of frequent identifiers and literals allows the NMT model to learn typical changes (e.g., if(i>1) to if(i>0)) and introduce API calls based on other API calls already available in the code.\n\nAfter the abstraction process, we filter out method pairs from which the NMT model would not be able to learn code transformations that will result in actual source code. To understand the reasoning behind this filtering, it is important to understand the real use case scenarios. When the NMT model receives the source code of the method am b , it can only perform code transformations that involve: (i) Java keywords; (ii) frequent identifiers/literals; (iii) identifiers and literals already available in m b . Therefore, we disregard method pairs where m a contains tokens not listed in the three aforementioned categories, since the model would have to synthesize new identifies or literals not previously seen.\n\nIn the future, we plan to increase the number of frequent identifiers and literals used in the vocabulary with the aim of learning code transformations from as many method pairs as possible. We also filter out those method pairs such that am b = am a , meaning the abstracted code before and after the PR appear the same. We remove these instances since the NMT model would not learn any code transformation.\n\nNext, we partition the method pairs in small and medium pairs, based on their size measured in the number of tokens.\n\nIn particular, small method pairs are those no longer than 50 tokens, while we consider medium pairs those having a length between 50-100 tokens. In this stage, we disregard longer method pairs. We discuss this limitation in Section V. Table II shows the number of method pairs, after the abstraction and filtering process, for each dataset and the combined one (i.e., All). Each of the four datasets is then randomly partitioned into training (80%), validation (10%), and test (10%) sets. Before doing so, we make sure to remove any duplicate method pairs, to ensure that none of the method pairs in the test set have been seen during the training phase.\n\n\nD. Learning Code Transformations\n\nIn this section, we describe the NMT models we use to learn code transformations. In particular, we train these models to translate the abstracted code am b in am a , effectively simulating the code change performed in the PR by developers.\n\n1) RNN Encoder-Decoder: To build such models, we rely on an RNN Encoder-Decoder architecture with attention mechanism [30], [52], [32], commonly adopted in NMT tasks [48], [60], [33]. As the name suggests, this model consists of two major components: an RNN Encoder, which encodes a sequence of tokens x into a vector representation, and an RNN Decoder, which decodes the representation into another sequence of tokens y. During training, the model learns a conditional distribution over a (output) sequence conditioned on another (input) sequence of terms: P (y 1 , .., y m |x 1 , .., x n ), where the lengths n and m may differ. In our setting, given the sequence representing the abstract code before the PR x = am b = (x 1 , .., x n ) and a corresponding target sequence representing the abstract code after the PR y = am a = (y 1 , .., y m ), the model is trained to learn the conditional distribution: P (am a |am b ) = P (y 1 , .., y m |x 1 , .., x n ), where x i and y j are abstracted source tokens: Java keywords, separators, IDs, and frequent identifiers and literals. The Encoder takes as input a sequence x = (x 1 , .., x n ) and produces a sequence of states h = (h 1 , .., h n ). In particular, we adopt a bi-directional RNN Encoder [30], which is formed by a backward and a forward RNN. The RNNs process the sentence both from left-to-right and right-to-left, and are able to create sentence representations taking into account both past and future inputs [32]. The RNN Decoder predicts the probability of a target sequence y = (y 1 , .., y m ) given h. Specifically, the probability of each output token y i is computed based on: (i) the recurrent state s i in the Decoder; (ii) the previous i \u2212 1 tokens (y 1 , .., y i\u22121 ); and (iii) a context vector c i . This vector c i , also called attention vector, is computed as a weighted average of the states in h: c i = n t=1 a it h t where the weights a it allow the model to pay more attention to different parts of the input sequence, when predicting the token y i . Encoder and Decoder are trained jointly by minimizing the negative log likelihood of the target tokens, using stochastic gradient descent.\n\n2) Beam Search Decoding: For each method pair (am b , am a ) the model is trained to translate am b solely into the corresponding am a . However, during testing, we would like to obtain multiple possible translations. Precisely, given a piece of source code m as input to the model, we would like to obtain k possible translations of m. To this aim, we employ a decoding strategy called a Beam Search used in previous applications of DL [57]. The major intuition behind a Beam Search decoding is that rather than predicting at each time step the token with the best probability, the decoding process keeps track of k hypotheses (with k being the beam size). Formally, let H t be the set of k hypotheses decoded until time step t:\nH t = {(\u1ef9 1 1 , . . . ,\u1ef9 1 t ), (\u1ef9 2 1 , . . . ,\u1ef9 2 t ), . . . , (\u1ef9 k 1 , .\n. . ,\u1ef9 k t )} At the next time step t + 1, for each hypothesis there will be |V | possible y t+1 terms (V being the vocabulary), for a total of k \u00b7 |V | possible hypotheses:\nC t+1 = k i=1 {(\u1ef9 i 1 , . . . ,\u1ef9 i t , v 1 ), . . . , (\u1ef9 i 1 , . . . ,\u1ef9 i t , v |V | )}\nFrom these candidate sets, the decoding process keeps the k sequences with the highest probability. The process continues until each hypothesis reaches the special token representing the end of a sequence. We consider these k final sentences as candidate patches for the buggy code.\n\n3) Hyperparameter Search: We tested ten configurations of the encoder-decoder architecture with different combinations of RNN Cells (LSTM [45] and GRU [33]), number of layers (1, 2, 4) and units (256, 512) for the encoder/decoder, and the embedding size (256, 512). Bucketing and padding was used to deal with the variable length of the sequences. We trained the models for a maximum of 60k epochs, and selected the model's checkpoint before over-fitting the training data. To guide the selection of the best configuration, we used the loss function computed on the validation set (not on the test set), while the results are computed on the test set.\n\n\nE. Code Concretization\n\nIn this final phase, the abstracted code generated as output by the NMT model is concretized by mapping back all the identifiers and literal IDs to their actual values. The process simply replaces each ID found in the abstracted code to the real identifier/literal associated with the ID and saved in the mapping M , for each method pair. The code is automatically indented and additional code style rules can be enforced during this stage. While we do not deal with comments, they could be reintroduced in this stage as well.\n\n\nIII. STUDY DESIGN\n\nThe goal of this study is to empirically assess whether NMT can be used to learn a diverse and meaningful set of code changes. The context consists of a dataset of PRs and aims at answering two research questions (RQs).\n\nA. RQ1: Can Neural Machine Translation be employed to learn meaningful code changes?\n\nWe aim to empirically assess whether NMT is a viable approach to learn transformations of the code, as performed by developers in PRs. To this end, we use the eight datasets of method pairs listed in Table II. Given a dataset, we train different configurations of the Encoder-Decoder models on the training set, then use the validation set to select the best performing configuration of the model. We then evaluate the validity of the model with the unseen instances of the test set. In total, we experiment with eight different models, one for each dataset in Table II (i.e., one model trained, configured, and evaluated on the Google dataset of small methods, one on the Google dataset of medium methods, etc.).\n\nThe evaluation is performed by the following methodology. Let M be a trained model and T be the test set of dataset D, we evaluate the model M for each (am b , am a ) \u2208 T . Specifically, we feed the pre-PR abstract code am b to the model M , performing inference with Beam Search Decoding for a given beam size k. The model will generate k different potential code transformations CT = {ct 1 , . . . , ct k }. We say that the model successfully predicted a code transformation if there exists a ct i \u2208 CT such that ct i = am a (i.e., the abstract code generated by developers after the merging of the PR). We report the raw count and percentage of successfully predicted code changes in the test set, with k = 1, 5, 10. In other words, given a source code method that the model has never seen before, we evaluate the model's ability to correctly predict the code transformation that a developer performed by allowing the model to generate its best guess (i.e., k = 1) or the top-5 and top-10 best guesses. It should be noted that while we count only perfect predictions, there are many other (slightly different) transformations that can still be viable and useful for developers. However, we discount these less-than-perfect predictions since it is not possible to automatically categorize those as viable and non-viable.\n\nB. RQ2: What types of meaningful code changes can be performed by the model?\n\nIn this RQ we aim to qualitatively assess the types of code changes that the NMT model is able to generate. To this goal, we focus only on the successfully predicted code transformations generated by the model trained on the All dataset, considering both small and medium sized methods.\n\nOne of the authors manually investigated all the successfully predicted code transformations and described the code changes. Subsequently, a second author discussed and validated the described code changes. Finally, the five authors together defined -and iteratively refined -a taxonomy of code transformations successfully performed by the NMT model.\n\n\nIV. STUDY RESULTS\n\nA. RQ1: Can Neural Machine Translation be employed to learn meaningful code changes? Table III reports the perfect predictions (i.e., successfully predicted code transformations) by the NMT models, in terms of raw numbers and percentages of the test sets. When we allow the models to generate only a single translation (i.e., beam = 1), they are able to predict the same code transformation performed by the developers in 3% up to 21% of the cases. It is worth noting how the model trained on the combined datasets (i.e., All) is able to outperform all the other single-dataset model, achieving impressive results even with a single guess (21.16% Moreover, this also provides preliminary evidence that transfer learning would be possible for such models.\n\nOn the other end of the spectrum, the poor performance of the models trained on Google's dataset could be explained by the limited amount of training data (see Table II) with respect to the other datasets.\n\nWhen we allow the same models to generate multiple translations of the code (i.e., 5 and 10), we observe a significant increase in perfect predictions across all models. On average, 1 out of 3 code transformations can be generated and perfectly predicted by the NMT model trained on the combined dataset. The model can generate 10 transformations in less than one second on a consumer-level GPU.\n\nSummary for RQ 1 . NMT models are able to learn meaningful code changes and perfectly predict code transformations in up to 21% of the cases when only one translation is generated, and up to 36% when 10 possible guesses are generated.\n\nB. RQ2: What types of meaningful code changes can be performed by the model?\n\nHere we focus on the 722 (388+334) perfect predictions generated by the model trained on the whole dataset, i.e., All, with beam size equals 10. These perfect predictions were the results of 216 unique types of AST operations, as detected by GumTreeDiff, that the model was able to emulate. The complete list is available in our replication package [21]. Fig. 1 shows the taxonomy of code transformations that we derived by manually analyzing the 722 perfect predictions. Note that a single perfect prediction can include multiple types of changes falling into different categories of our taxonomy (e.g., a refactoring and a bug fix implemented in the same code transformation). For this reason, the sum of the classified changes in Fig. 1 is 793. The taxonomy is composed of three sub-trees, grouping code transformations related to bug fixing, refactoring, and \"other\" types of changes. The latter includes code transformations that the model correctly performed (i.e., those replicating what was actually done by developers during the reviewed PRs) but for which we were unable to understand the rationale behind the code transformation (i.e., why it was . We preferred to adopt a conservative approach and categorize transformations into \"refactoring\" and \"bug-fix\" sub-trees only when we can confidently link to these types of activities. Also, for 27 transformations, the authors did not agree on the type of code change and, hence, we excluded them from our taxonomy (related to 695 perfect predictions).\n\nHere, we qualitatively discuss interesting examples (indicated using the icon) of code transformations belonging to our taxonomy. We do not report examples for all possible categories of changes learned by the model due to lack of space. Yet, the complete set of perfect predictions and their classification is available in our replication package [21].\n\n\nC. Refactoring\n\nWe grouped in the refactoring sub-tree, all code transformations that modify the internal structure of the system by improving one or more of its non-functional attributes (e.g., readability) without changing the system's external behavior. We categorized transformations into five sub-categories.\n\n1) Inheritance: Refactorings that impact how the inheritance mechanism is used in the code. We found three types of refactorings related to inheritance: (i) forbid method overriding by adding the final keyword to the method declaration; (ii) invoke overriding method instead of overridden by removing the super keyword to the method invocation; and (iii) making a method abstract through the abstract keyword and deleting the method body.\n\nExisting method declared as final [3]. In the DirectByteBuffer class of Android, the NMT model added to the signature of the getLong(int) method the final keyword. As stated by the developer implementing the PR: \"DirectByteBuffer cannot be final, but we can declare most methods final to make it easier to reason about\".\n\nRemoved unnecessary \"super\" specifier [24]. A PR in the Ovirt core subsystem was performed to clean up the class RandomUtil, that extends Java class java.util.Random. The nextShort() method implemented in the refactored class was invoking nextInt() of the base class through the use of the super java specifier. However, such a specifier was redundant because nextInt() was not overridden in RandomUtil. Thus, it was removed by the developer: \"Using this modifier has no meaning in the context that was removed\".\n\nExisting method converted to abstract [1]. The above code listing shows the code taken as input by the NMT model (top part, pre-PR) and produced as output (bottom, post-PR). The code transformation replicates the changes implemented by a developer in a PR, converting the getFloatUnchecked method into an abstract method, deleting its body. The rationale for this change is explained by the developer who implemented this change: The method getFloatUnchecked is overridden in all child classes of the abstract class implementing it and, thus, \"there is no need for the abstract base class to carry an implementation that throws UnsupportedOperationException\". The developer also mentions alternative solutions, such as moving this and similar methods into an interface, but concludes saying that the effort would be much higher. This case is interesting for at least two reasons. First, our model was able to learn a combination of code transformations needed to replicate the PR implemented by the developer (i.e., add the abstract keyword and delete the method body). Second, it shows the rich availability of information about the \"rationale\" for the implemented changes available in code review repositories. This could be exploited in the future to not only learn the code transformation, but also to justify it by automatically deriving the rationale from the developers' discussion.\n\n2) Methods Interaction: These refactorings impact the way in which methods of the system interact, and include (i) add parameter refactoring (i.e., a value previously computed in the method body is now passed as parameter to it), and (ii) broadening the return type of a method by using the Java wildcard (?) symbol. The code listing shows a change implemented in a PR done on the \"Google\" Gerrit repository and correctly replicated by the NMT model. The post method declaration was refactored to return a broader type and improve the usage of generics. As explained by the developer, this also allows to avoid the 'unchecked' warnings from the five implementations of the post method present in the system, thus simplifying the code.\n\n\nMethod returns a broader generic type [18].\n\n3) Naming: This category groups refactorings related to the renaming of methods, parameters, and variables. This is usually done to improve the expressiveness of identifiers and to better adhere to the coding style guidelines. Indeed, good identifiers improve readability, understandability and maintainability of source code [27], [46].\n\nRename method [25]. One example of correctly learned rename method, is the one fixing a typo from the OnSucess method in the Ovirt system [25]. In this case, the developer (and the NMT model) both suggested to rename the method in OnSuccess.\n\nRename parameter [12]. A second example of renaming, is the renamed parameter proposed for the endTrace(JMethod type) method in a PR impacting the AbstractTracerBrush class in the Android repository [12]. The developer here renamed several parameters \"for clarity\" and, in this case, renamed the type parameter into method, to make it more descriptive and better reflect its aim.\n\n\n4) Encapsulation:\n\nWe found refactorings aimed at broadening and narrowing the visibility of methods (see Fig. 1). This can be done by modifying the access modifiers (e.g., changing a public method to a private one).\n\nBroadening [5] and narrowing [19] method visibility. An example of a method, for which our model recommended to broaden its visibility from private to public, is the of method from the Key Android class [5]. This change was done in a PR to allow the usage of the method from outside the class, since the developer needed it to implement a new feature.\n\nThe visibility was instead narrowed from public to private in the context of a refactoring performed by a developer to make \"more methods private\" [19]. This change impacted the CurrentUser.getUser() method from the Google repository, and the rationale for this change correctly replicated by the NMT model was that the getUser() method was only used in one location in the system outside of its class. However, in that location the value of \"the user is already known\", thus do not really requiring the invocation of getUser(). 5) Readability: Readable code is easier to understand and maintain [59]. We found several types of code transformations learned by the model and targeting the improvement of code readability. This includes: (i) braces added to if statements with the only goal of clearly delimiting their scope; (ii) the merging of two statements defining (e.g., String address;) and initializing (e.g., address = getAddess();) a variable into a single statement doing both (e.g., String address = getAddess();); (iii) the addition/removal of the this qualifier, to match the project's coding standards; (iv) reducing the verbosity of a generic declaration by using the Java diamond operator (e.g., Map < String, List < String >> mapping = new HashMap < String, List < String >> () becomes Map < String, List < String >> mapping = new HashMap <>); (v) remove redundant else keywords from if statements (i.e., when the code delimited by the else statement would be executed in any case); (vi) refactoring anonymous classes implementing one method to lambda expressions, to make the code more readable [22]; (vii) simplifying boolean expressions (e.g., if(x == true) becomes if(x), where x is a boolean variable); and (viii) merging two catch blocks capturing different exceptions into one catch block capturing both exceptions using the or operator [7].\n\nAnonymous class replaced with lambda expression [22]. Merging catch blocks capturing different exceptions [7]. As part of a PR implementing several changes, the two catch blocks of the getInteger method were merged by the developer into a single catch block (see the code above). The NMT model was able to replicate such a code transformation that is only meaningful when an exception is caught and the resulting code that is executed is the same for both instances of the exception (as in this case). This code change, while simple from a developer's perspective, is not trivial to learn due to the several transformations to implement (i.e., removal of the two catch blocks and implementation of a new catch block using the | or operator) and to the \"pre-condition\" to check (i.e., the same behavior implemented in the catch blocks).\n\n\nD. Bug Fix\n\nChanges in the \"bug fix\" subtree (see Fig. 1) include changes implemented with the goal of fixing a specific bug which has been introduced in the past. The learned code transformations are organized here into five sub-categories, grouping changes related to bug fixes that deal with (i) exception handling, (ii) the addition/modification of conditional statements, (iii) changes in the value returned by a method, (iv) the handling of lock mechanisms, and (v) wrong method invocations.\n\n1) Exception: This category of changes is further specialized into several subcategories (see Fig. 1) including (i) the addition/delation of thrown exceptions; (ii) the addition of try \u2212 catch/finally blocks [2]; (iii) narrowing or broadening the scope of the try block by moving the existing statements inside/outside the block [9]; (iv) changing the exception type in the catch clause to a narrower type (e.g., replacing Throwable with RuntimeException).\n\nAdd try-catch block [2]. The above code from the Android repository, shows the change implemented in a PR aimed at fixing \"resource leakages in tests\". The transformation performed by the NMT model wrapped the creation and usage of a DatagramSocket object into a try \u2212 with \u2212 resources block. This way theSocket.close() will be automatically invoked (or an exception will be thrown), thus avoiding resource leakage.\n\nNarrowed the scope of try block [9]. Another change replicated by the NMT model and impacting the Andorid test suite is the code transformation depicted above and moving the ConcurrentHashMap object instantiation outside of the try block. The reason for this change is the following. The involved test method is supposed to throw a NullPointerException in case c.get(null) is invoked. Yet, the test method would have also passed if the exception was thrown during the c instantiation. For this reason, the developer moved the object creation out of the try block.\n\n2) Conditional statements: Several bugs can be fixed in conditional statements verifying that certain preconditions are met before specific actions are performed (e.g., verifying that an object is not null before invoking one of its methods).\n\nAdded null check [4]. \n\n\n.] } }\n\nA second example of a bug successfully fixed by the NMT model working on the conditional statements, impacted the API of the FieldPacker class. As explained by the developer, the PR contributed \"a fix to the FieldPacker.reset() API, which was not allowing the FieldPacker to ever point to the final entry in its buffer\". This was done by changing the >= operand to > as shown in the code reported above.\n\n\n3) Values:\n\nThe only type of change we observed in this category is the change of methods' return value to fix a bug. This includes simple cases in which a boolean return value was changes from false to true (see e.g., [13]), as well as less obvious code transformations in which a constant return value was replaced with a field storing the current return value, e.g., return \"refs/my/config\"; converted into return ref;, where ref is a variable initialized in the constructor [20]. 4) Lock mechanism: These code changes are all related to the usage of the synchronized Java keyword in different parts of the code. These include its removal from a code block [11], from a method signature [10], and moving the keyword from the method signature to a code block or vice versa [8]. We do not discuss these transformations due to lack of space. 5) Methods invocation: These category groups code transformations fixing bugs by changing the order or value of parameters in method invocations.\n\nFlipped parameters in assertEquals [23]. In this example the developer fixed a bug in the test suite by flipping the order in which the parameters are passed to the assertEquals method. In particular, while the assert method was expecting the pairs of parameters (long expected, long actual), test was passing the actual value first, thus invalidating the test. The fix, automatically applied by the NMT model, swaps the arguments of the assertEquals.\n\n\nE. Other\n\nAs previously said, we assigned to the 'Other' subtree those code transformations for which we were unable to clearly identify the motivation/reason. This subtree includes changes related to: (i) the method signature (added/removed/changed parameter or return type); (ii) types (removed type casting in method body or its signature, changed variable type); (iii) variable initialization; (iv) replaced statement/invoked method; (v) added code (condition, statement, invoked method, parameter); (vi) deleted code (if condition, finally block, try \u2212 catch block, invoked method, statement); (vii) changes triggered by the other changes (e.g., static method call replaced with an instance method call or vice versa -see Fig. 1). Note that, while we did not assign a specific \"meaning\" to these changes, due to a lack of domain knowledge of the involved systems, these are still perfect predictions that the NMT model performed. This means the code changes are identical to the ones implemented by developers in the PR.\n\nSummary for RQ 2 . Our results show the great potential of NMT for learning meaningful code changes. Indeed, the NMT model was able to learn and automatically apply a wide variety of code changes, mostly related to refactoring and bugfixing activities. The fact that we did not find other types of changes, such as new feature implementation, might be due to the narrow context in which we applied our models (i.e., methods of limited size), as well as to the fact that new features implemented in different classes and systems rarely exhibit recurring patterns (i.e., recurring types of code changes) that the model can learn. More research is needed to make this further step ahead.\n\nV. THREATS TO VALIDITY Construct validity. We collected code components before and after pull requests through a crawler relying on the Gerrit API. The crawler has been extensively tested, and the manual analysis of the extracted pairs performed to define the taxonomy in Fig. 1 confirmed the correctness of the collected data.\n\nInternal validity. The performance of the NMT model might be influenced by the hyperparameter configuration we adopted. To ensure replicability, we explain in Section II how hyperparameter search has been performed.\n\nWe identified through the manual analysis the types of code transformations learned by the model. To mitigate subjectivity bias in such a process, the taxonomy definition has been done by one of the authors, double checked by a second author, and finally, the resulting taxonomy has been discussed among all authors to spot possible issues. Moreover, in case of doubts, the code transformation was categorized in the \"other\" subtree, in which we only observed the type of code change implemented, without conjecturing about the goal of the transformation. However, as in any manual process, errors are possible, and we cannot exclude the presence of misclassified code transformations in our taxonomy.\n\nExternal validity. We experimented with the NMT model on data related to Java programs only. However, the learning process is language-independent and the whole infrastructure can be instantiated for different programming languages by replacing the lexer, parser and AST differencing tools.\n\nWe only focused on methods having no more than 100 tokens. This is justified by the fact that we observe a higher density of method pairs with sizes less than 100 tokens in our dataset. The distribution also shows a long tail of large methods, which could be problematic when training a NMT model. Distribution and data can be accessed in our replication package [21]. Also, we only focus on learning code transformations of existing methods rather than the creation of new methods since these latter are (i) complex code changes that involve a higher level of understanding of the software system in its entirety; and (ii) not well-suited for NMT models since the translation would go from/to empty methods.\n\nFinally, pull request data from three Gerrit repositories were used. While these repositories include hundreds of individual projects (thus ensuring a good external validity of our findings) our results might not generalize to other projects/languages.\n\n\nVI. RELATED WORK\n\nDeep Learning (DL) has recently become a useful tool to study different facets of software engineering. The unique representations allow for features to be discovered by the model rather than manual derivation. Due to the power of these representations, many works have applied these models to solve SE problems [39] [43]. However, to the best of our knowledge, this is the first work that uses DL techniques to learn and create a taxonomy from a variety of code transformations taken from developers' PRs.\n\nWhite et al. uses representation learning via a recursive autoencoder for the task of clone detection [64]. Each piece of code is represented as a stream of identifiers and literals, which they use as input to their DL model. Using a similar encoding, Tufano et al. encodes methods into four different representations, then the DL model evaluates how similar two pieces of code are based on their multiple representations [61]. Another recent work by Tufano et al. applies NMT to bug-fixing patches the wild [62]. This work applies a similar approach, but rather than learning code transformations they attempt to learn bug-fixing commits to generate patches. These works are related to ours, since we use a similar code representation as input to the DL model, yet, we apply this methodology to learn as many code transformations as possible.\n\nWhite et al. also compare DL models with natural language processing models for the task of code suggestion. They show that DL models make code suggestions based upon contextual features learned by the model rather than the predictive power of the past n tokens [65]. Further expanding upon the powerful, predictive capabilities of these models, Dam et al. presents DeepSoft, which is a DL-based architecture used for modeling software, code generation and software risk prediction [36].\n\nDL has also been applied to the areas of bug triaging and localization. Lam et al. makes use of DL models and information retrieval to localize buggy files after a bug report is submitted. They use a revised Vector Space Model to create a representation the DL model can use to relate terms in a bug report to source code tokens [49]. Likewise, to reduce the effort of bug triaging, Lee et al. applies a CNN to industrial software in order to properly triage bugs. This approach uses word2vec to embed a summary and a description which the CNN then assigns to a developer [50]. Related to software bugs, Wang et al. uses a Deep Belief Network (DBN) to learn semantic features from token vectors taken from a programs' ASTs. The network then predicts if the commit will be defective [63].\n\nMany DL usages aim to help developers with tasks outside of writing code. Choetkiertikul et al. proposes a DL architecture of long short-term memory and recurring highway network that aims to predict the effort estimation of a coding task [34]. Another aid for developers is the ability to summarize a given segment of source code. To this point Allamanis et al. uses an Attentional Neural Network (ANN) with a convoluation layer in order to summarize pieces of source code into short, functional descriptions [29]. Guo et al. develops a DL approach using RNNs and word embeddings to learn the sentence semantics of requirement artifacts, which helps to create traceability links in software projects [42]. The last example of DL implementations that aid developers in the software development process is an approach developed by Gu et al. that helps to locate source code. This implementation uses NNs and natural language to embed code snippets with natural language descriptions into a high-dimensional vector space, helping developers locate source code based on natural language queries [40].\n\nDL-based approaches have also been applied to more coding related tasks, one such task is accurate method and class naming. Allamanis et al. uses a log-bilinear neural network to understand the context of a method or class and recommends a representative name that has not appeared in the training corpus [28]. Also helping with correct coding practices, Gu et al. uses an RNN encoder-decoder model to generate a series of correct API usages in source code based upon natural language queries. The learned semantics allow the model to associate natural language queries with a sequence of API usages [41].\n\nRecently we have seen DL infiltrate the mobile SE realm. Moran et al. uses a DL-based approach to automatically generate GUIs for mobile apps. In this approach, a deep CNN is used to help classify GUI components which can later be used to generate a mock GUI for a specific app [54].\n\nAlthough DL approaches are prevalent in SE, this work is the first to apply DL to empirically evaluate the capability to learn code changes from developer PRs. The previous work has shown that DL approaches can yield meaningful results given enough quality training data. Thus, we specifically apply NMT to automatically learn a variety of code transformations, from real pull requests, and create a meaningful taxonomy.\n\n\nVII. CONCLUSION\n\nWe investigated the ability of NMT models to learn how to automatically apply code transformations. We first mine a dataset of complete and meaningful code changes performed by developers in merged pull requests, extracted from three Gerrit repositories. Then, we train NMT models to translate pre-PR code into post-PR code, effectively learning code transformations as performed by developers.\n\nOur empirical analysis shows that NMT models are capable to learn code changes and perfectly predict code transformations in up to 21% of the cases when only a single translation is generated, and up to 36% when 10 possible guesses are generated. The results also highlight the ability of the models to learn from a heterogeneous set of PRs belonging to different datasets, indicating the possibility of transfer learning across projects and domains. The performed qualitative analysis also highlighted the ability of the NMT models to learn a wide variety of code transformations, paving the way to further research in this field targeting the automatic learning and application of non-trivial code changes, such as refactoring operations. In that sense, we hope that the public availability of the source code of our infrastructure and of the data and tools we used [21], can help in fostering research in this field.\n\n\nVIII. ACKNOWLEDGMENT\n\nThis work is supported in part by the NSF CCF-1525902 and CCF-1815186 grants. Pantiuchina and Bavota thank the Swiss National Science foundation for the financial support through SNF Project JITRA, No. 172479. Any opinions, findings, and conclusions expressed herein are the authors' and do not necessarily reflect those of the sponsors.\n\n\n, each PR is represented as a list of paired methods pr = {(m b , m a ) 1 , . . . , (m b , m a ) n }, where each pair (m b , m a ) i contains the method before the PR (m b ) and the method after the PR (m a ). These are examples of changes used to train an NMT model to translate m b in m a .\n\n\nfloat getFloatUnchecked(int index) { throw new UnsupportedOperationException(); } abstract float getFloatUnchecked(int index);\n\n<I>\nRestModifyView<P,I> post(P parent) throws [...]; RestModifyView<P,?> post(P parent) throws [...];\n\n\npublic boolean isDiskExist([...]) { return execute(new java.util.concurrent.Callable<java. lang.Boolean>() { @java.lang.Override public java.lang.Boolean call() { try {[...]} } }); } public boolean isDiskExist([...]) { return execute(() -> { try {[...]} }); } In the above code listing, the NMT model automatically replaces an anonymous class (top part, pre-PR) with a lambda expression (bottom part, post-PR), replicating changes made by Ovirt's developers during the transitions of the code through Java 8. The new syntax is more compact and readable.\n\n\npublic void test_getPort() throws IOException { DatagramSocket theSocket = new DatagramSocket(); [...] } public void test_getPort() throws IOException { try (DatagramSocket theSocket = new DatagramSocket()) { [...] } }\n\n\npublic void run() { mCallback.onConnectionStateChange(BluetoothGatt.this, GATT_FAILURE, BluetoothProfile.STATE_DISCONNECTED); } public void run() { if (mCallback != null) { mCallback.onConnectionStateChange(BluetoothGatt.this, GATT_FAILURE, BluetoothProfile.STATE_DISCONNECTED); } } The code listing shows the changes implemented in an Android PR to \"fix a NullPointerException when accessing mCallback in BluetoothGatt\". The addition of the if statement implementing the null check allows the NMT model to fix the bug exactly as the developer did. Change comparison operand [6]. public void reset(int i) { if ((i < 0) || (i >= mLen)) { [...] } } public void reset(int i) { if ((i < 0) || (i > mLen)) { [..\n\nTABLE I VOCABULARIES\nIDataset \nVocabulary \nAbstracted Vocabulary \n\nGoogle \n42,430 \n373 \nAndroid \n266,663 \n429 \nOvirt \n81,627 \n351 \n\nAll \n370,519 \n740 \n\n\n\nTABLE II DATASETS\nIIDataset \nM small \nM medium \n\nGoogle \n2,165 \n2,286 \nAndroid \n4,162 \n3,617 \nOvirt \n4,456 \n5,088 \n\nAll \n10,783 \n10,991 \n\n\n\nTABLE III\nIIIPERFECT PREDICTIONS \n\nDataset \nBeam \nM small \nM medium \n\nGoogle \n\n1 \n10 (4.62%) \n7 (3.07%) \n5 \n17 (7.87%) \n13 (5.70%) \n10 \n20 (9.25%) \n17 (7.45%) \n\nAndroid \n\n1 \n40 (9.61%) \n51 (14.12%) \n5 \n71 (17.06%) \n73 (20.22%) \n10 \n79 (18.99%) \n76 (21.05%) \n\nOvirt \n\n1 \n55 (12.35%) \n60 (11.78%) \n5 \n93 (20.89%) \n90 (17.68%) \n10 \n113 (25.39%) \n102 (20.03%) \n\nAll \n\n1 \n228 (21.16%) \n178 (16.21%) \n5 \n349 (32.40%) \n306 (27.86%) \n10 \n388 (36.02%) \n334 (30.41%) \n\nfor small and 16.21% for medium methods). This result shows \nthat NMT models are able to learn code transformations from \na heterogeneous set of examples belonging to different datasets. \n\n\n\nFig. 1. Taxonomy of code transformations learned by the NMT model performed)Refactoring \n\nInheritance \n\nForbid overriding: \nadd final to \nmethod \n\nMethods \nInteraction \n\nAdd parameter & \nremove variable \nfrom method body \n\nEncapsulation \n\nBroad method \nvisibility \n\nNarrow method \nvisibility \n\nNaming \n\nRename parameter Rename method \nRename variable \n\nReadability \n\nAdd braces to if \nstatement \n\nAdd/Remove \n\"this\" qualifier \n\nReplace generic \nspecification with \ndiamond operator \n\nRemove redundant \n\"else\" keyword \n\nReplace \nanonymous class \nwith lambda \nexpression \n\nMerge 2 catch \nblocks capturing \nboth exceptions in \n1 catch expression \n\nMerge variable \ndefinition & \ninitialization \n\nRemove redundant \ninitialization \n\nUse ? in generics \nas return type \n\nSimplify if \ncondition \n\nInvoke overridden \nmethod instead of \ninherited one \n\nAbstract an \nexisting method \nusing the \n\"abstract\" keyword \n\nBug fix \n\nMethods \ninvocation \n\nChange parameters \norder in method \ninvocation \n\nChange parameter \nvalue of invoked \nmethod \n\nExceptions \n\nAdd try block \n\nMove existing \nstatements in try \nblock \n\nMove existing \nstatements out of \ntry block \n\nConditional \nstatements \n\nAdd/Remove \noperand from \ncondition \n\nAdd null check \n\nChange \ncomparison \noperator (e.g., >) in \ncondition \n\nModify \nif condition \n\nChange operands \norder in if \ncondition \n\nValues \n\nChange method \nreturn value \n\nLock \nmechanism \n\nRemove \nsynchronized \nkeyword from \nmethod \n\nRemove \nsynchronized \nblock \n\nRemove thrown \nexception \n\nChange exception \ntype in catch \nclause \n\nReplace if \nstatement with \nassert statement \n\nMove synchronized \nkeyword from \nsignature to code \nblock or vice versa \n\nOther \n\nType \n\nRemove type \ncasting in method \nbody \n\nTriggered by \nother changes \nInitialization \n\nForbid multiple \nassignments: \nadd final to \nvariable \n\nRemove type \ncasting in method \nsignature \n\nMethod \nsignature \n\nAdd/Remove \nparameter \n\nDelete code \n\nChange qualified \nname in response \nto a move class \nrefactoring \n\nRemove \"finally\" \nfrom try/catch \nRemove try/catch \nRemove if \ncondition \nRemove statement \n\nChange parameter \ntype \nChange return type \nChange type of a \nvariable \n\nClass is not static \nanymore. Add \nobject instance to \ninvoke its methods \n\nClass becomes \nstatic. Delete \nobject instance to \ninvoke its methods \n\nChange method \ninvocation as \nresult of a move \nmethod \n\nAdd code \n\nAdd condition \n\nAdd parameter in \nmethod/ \nconstructor \ninvocation \n\nReplace code \n\nReplace invoked \nmethod \nReplace statement \nAdd statement \nAdd invoked \nmethod \n\nRemove parameter \nfrom the method \ninvocation \n\nRemove invoked \nmethod \n\n104 \n\n171 \n\n518 \n\n22 \n17 \n6 \n5 \n54 \n\n10 \n3 \n81 \n44 \n33 \n\n97 \n21 \n49 \n79 \n1 \n56 \n215 \n\n\n\n\n[26][37][35][51][44][58]\n\n. Android: Abstract Method. \"Android: Abstract Method. https://android-review.googlesource.com/c/ platform/libcore/+/675863.\"\n\nAndroid: Add Catch Block. \"Android: Add Catch Block. https://android-review.googlesource.com/c/ platform/libcore/+/283122.\"\n\nAndroid: Add Final. \"Android: Add Final. https://android-review.googlesource.com/c/ platform/libcore/+/321410/1/.\"\n\nAndroid: Added Null Check. \"Android: Added Null Check. https://android-review.googlesource.com/ c/platform/frameworks/base/+/382232.\"\n\nAndroid: Broadening Visibility. \"Android: Broadening Visibility. https://android-review.googlesource. com/c/platform/tools/base/+/110627/6/.\"\n\nAndroid: Merging Catch Blocks. \"Android: Merging Catch Blocks. https://android-review.googlesource. com/c/platform/libcore/+/244295/4/.\"\n\nAndroid: Move Synchronization. \"Android: Move Synchronization. https://android-review.googlesource. com/c/platform/libcore/+/40261/2/.\"\n\nAndroid: Narrow Catch Block. \"Android: Narrow Catch Block. https://android-review.googlesource.com/ c/platform/libcore/+/148551.\"\n\nAndroid: Remove Synchronized From Signature. \"Android: Remove Synchronized From Signature. https://android-review. googlesource.com/c/platform/frameworks/base/+/114871/2/.\"\n\nAndroid: Remove Synchronized. \"Android: Remove Synchronized. https://android-review.googlesource. com/c/platform/frameworks/base/+/143346.\"\n\nAndroid: Rename Parameter. \"Android: Rename Parameter. https://android-review.googlesource.com/ c/toolchain/jack/+/264513/2/.\"\n\nAndroid: Return Value. \"Android: Return Value. https://android-review.googlesource.com/c/ platform/tools/base/+/155460/6/.\"\n\n. Gerrit -Google Source. \"Gerrit -Google Source. https://gerrit-review.googlesource.com/ (last access: 18/08/2018).\"\n\n. &quot; Gerrit -Ovirt, \"Gerrit -Ovirt. https://gerrit.ovirt.org/ (last access: 18/08/2018).\"\n\nGoogle: Broader Generic Type. last access: 11/08/2018).\" [18\"Gerrit. https://www.gerritcodereview.com (last access: 11/08/2018).\" [18] \"Google: Broader Generic Type. https://gerrit-review.googlesource.com/ c/gerrit/+/127039.\"\n\nGoogle: Narrowing Visibility. \"Google: Narrowing Visibility. https://gerrit-review.googlesource.com/c/ gerrit/+/99660/4/.\"\n\nGoogle: Return Value. \"Google: Return Value. https://gerrit-review.googlesource.com/c/gerrit/+/ 139770.\"\n\nOn learning meaningful code changes via neural machine translation Replication Package. Ovirt: Flipped Parameters. 22Ovirt: Rename Method\"On learning meaningful code changes via neural machine translation Replication Package https://sites.google.com/view/learning-codechanges.\" [22] \"Ovirt: Anonymous Class To Lambda. https://gerrit.ovirt.org/#/c/50859/.\" [23] \"Ovirt: Flipped Parameters. https://gerrit.ovirt.org/#/c/63570/.\" [24] \"Ovirt: Redundant Super. https://gerrit.ovirt.org/#/c/45678/.\" [25] \"Ovirt: Rename Method. https://gerrit.ovirt.org/#/c/14147/.\"\n\nGuided code synthesis using deep neural networks. C V Alexandru, http:/doi.acm.org/10.1145/2950290.2983951Proceedings of the 2016 24th ACM SIGSOFT International Symposium on Foundations of Software Engineering, ser. FSE 2016. the 2016 24th ACM SIGSOFT International Symposium on Foundations of Software Engineering, ser. FSE 2016New York, NY, USAACMC. V. Alexandru, \"Guided code synthesis using deep neural networks,\" in Proceedings of the 2016 24th ACM SIGSOFT International Symposium on Foundations of Software Engineering, ser. FSE 2016. New York, NY, USA: ACM, 2016, pp. 1068-1070. [Online]. Available: http://doi.acm.org/10.1145/2950290.2983951\n\nSuggesting accurate method and class names. M Allamanis, E T Barr, C Bird, C Sutton, http:/doi.acm.org/10.1145/2786805.2786849Proceedings of the 2015 10th Joint Meeting on Foundations of Software Engineering, ser. ESEC/FSE 2015. the 2015 10th Joint Meeting on Foundations of Software Engineering, ser. ESEC/FSE 2015New York, NY, USAACMM. Allamanis, E. T. Barr, C. Bird, and C. Sutton, \"Suggesting accurate method and class names,\" in Proceedings of the 2015 10th Joint Meeting on Foundations of Software Engineering, ser. ESEC/FSE 2015. New York, NY, USA: ACM, 2015, pp. 38-49. [Online]. Available: http://doi.acm.org/10.1145/2786805.2786849\n\nSuggesting accurate method and class names. http:/doi.acm.org/10.1145/2786805.2786849Proceedings of the 2015 10th Joint Meeting on Foundations of Software Engineering, ser. ESEC/FSE 2015. the 2015 10th Joint Meeting on Foundations of Software Engineering, ser. ESEC/FSE 2015New York, NY, USAACM--, \"Suggesting accurate method and class names,\" in Proceedings of the 2015 10th Joint Meeting on Foundations of Software Engineering, ser. ESEC/FSE 2015. New York, NY, USA: ACM, 2015, pp. 38-49. [Online]. Available: http://doi.acm.org/10.1145/2786805.2786849\n\nA convolutional attention network for extreme summarization of source code. M Allamanis, H Peng, C A Sutton, abs/1602.03001CoRR. M. Allamanis, H. Peng, and C. A. Sutton, \"A convolutional attention network for extreme summarization of source code,\" CoRR, vol. abs/1602.03001, 2016. [Online]. Available: http://arxiv.org/abs/1602. 03001\n\nNeural machine translation by jointly learning to align and translate. D Bahdanau, K Cho, Y Bengio, abs/1409.0473CoRR. D. Bahdanau, K. Cho, and Y. Bengio, \"Neural machine translation by jointly learning to align and translate,\" CoRR, vol. abs/1409.0473, 2014. [Online]. Available: http://arxiv.org/abs/1409.0473\n\nMachine learning vs. deep learning. J Berkman, 22J. Berkman, \"Machine learning vs. deep learning,\" August 2018, [Online; posted 22-August-2017]. [Online]. Available: https://www.datascience. com/blog/machine-learning-and-deep-learning-what-is-the-difference\n\nMassive exploration of neural machine translation architectures. D Britz, A Goldie, M Luong, Q V Le, CoRR. D. Britz, A. Goldie, M. Luong, and Q. V. Le, \"Massive exploration of neural machine translation architectures,\" CoRR, vol. abs/1703.03906, 2017. [Online]. Available: http://arxiv.org/abs/1703.03906\n\nLearning phrase representations using RNN encoder-decoder for statistical machine translation. K Cho, B Van Merrienboer, \u00c7 G\u00fcl\u00e7ehre, F Bougares, H Schwenk, Y Bengio, abs/1406.1078CoRR. K. Cho, B. van Merrienboer, \u00c7. G\u00fcl\u00e7ehre, F. Bougares, H. Schwenk, and Y. Bengio, \"Learning phrase representations using RNN encoder-decoder for statistical machine translation,\" CoRR, vol. abs/1406.1078, 2014. [Online]. Available: http://arxiv.org/abs/1406.1078\n\nA deep learning model for estimating story points. M Choetkiertikul, H K Dam, T Tran, T T M Pham, A Ghose, T Menzies, IEEE Transactions on Software Engineering. M. Choetkiertikul, H. K. Dam, T. Tran, T. T. M. Pham, A. Ghose, and T. Menzies, \"A deep learning model for estimating story points,\" IEEE Transactions on Software Engineering, pp. 1-1, 2018.\n\nExploring the use of deep learning for feature location. C S Corley, K Damevski, N A Kraft, 2015 IEEE International Conference on Software Maintenance and Evolution (ICSME). C. S. Corley, K. Damevski, and N. A. Kraft, \"Exploring the use of deep learning for feature location,\" in 2015 IEEE International Conference on Software Maintenance and Evolution (ICSME), Sept 2015, pp. 556-560.\n\nDeepsoft: A vision for a deep model of software. H K Dam, T Tran, J Grundy, A Ghose, Proceedings of the 2016 24th ACM SIGSOFT International Symposium on Foundations of Software Engineering, ser. FSE 2016. the 2016 24th ACM SIGSOFT International Symposium on Foundations of Software Engineering, ser. FSE 2016New York, NY, USAACMH. K. Dam, T. Tran, J. Grundy, and A. Ghose, \"Deepsoft: A vision for a deep model of software,\" in Proceedings of the 2016 24th ACM SIGSOFT International Symposium on Foundations of Software Engineering, ser. FSE 2016. New York, NY, USA: ACM, 2016, pp. 944-947. [Online].\n\n. http:/doi.acm.org/10.1145/2950290.2983985Available: http://doi.acm.org/10.1145/2950290.2983985\n\nTowards accurate duplicate bug retrieval using deep learning techniques. J Deshmukh, A K M , S Podder, S Sengupta, N Dubash, 2017 IEEE International Conference on Software Maintenance and Evolution (ICSME). J. Deshmukh, A. K. M, S. Podder, S. Sengupta, and N. Dubash, \"Towards accurate duplicate bug retrieval using deep learning techniques,\" in 2017 IEEE International Conference on Software Maintenance and Evolution (ICSME), Sept 2017, pp. 115-124.\n\nFine-grained and accurate source code differencing. J Falleri, F Morandat, X Blanc, M Martinez, M Monperrus, ACM/IEEE International Conference on Automated Software Engineering, ASE '14. J. Falleri, F. Morandat, X. Blanc, M. Martinez, and M. Monperrus, \"Fine-grained and accurate source code differencing,\" in ACM/IEEE International Conference on Automated Software Engineering, ASE '14, 2014, pp. 313-324.\n\nLearn&fuzz: Machine learning for input fuzzing. P Godefroid, H Peleg, R Singh, abs/1701.07232CoRR. P. Godefroid, H. Peleg, and R. Singh, \"Learn&fuzz: Machine learning for input fuzzing,\" CoRR, vol. abs/1701.07232, 2017. [Online]. Available: http://arxiv.org/abs/1701.07232\n\nDeep code search. X Gu, H Zhang, S Kim, Proceedings of the 40th International Conference on Software Engineering, ser. ICSE '18. the 40th International Conference on Software Engineering, ser. ICSE '18New York, NY, USAACMX. Gu, H. Zhang, and S. Kim, \"Deep code search,\" in Proceedings of the 40th International Conference on Software Engineering, ser. ICSE '18. New York, NY, USA: ACM, 2018, pp. 933-944. [Online].\n\n. http:/doi.acm.org/10.1145/3180155.3180167Available: http://doi.acm.org/10.1145/3180155.3180167\n\nDeep api learning. X Gu, H Zhang, D Zhang, S Kim, http:/doi.acm.org/10.1145/2950290.2950334Proceedings of the 2016 24th ACM SIGSOFT International Symposium on Foundations of Software Engineering, ser. FSE 2016. the 2016 24th ACM SIGSOFT International Symposium on Foundations of Software Engineering, ser. FSE 2016New York, NY, USAACMX. Gu, H. Zhang, D. Zhang, and S. Kim, \"Deep api learning,\" in Proceedings of the 2016 24th ACM SIGSOFT International Symposium on Foundations of Software Engineering, ser. FSE 2016. New York, NY, USA: ACM, 2016, pp. 631-642. [Online]. Available: http://doi.acm.org/10.1145/2950290.2950334\n\nSemantically enhanced software traceability using deep learning techniques. J Guo, J Cheng, J Cleland-Huang, Proceedings of the 39th International Conference on Software Engineering, ser. ICSE '17. the 39th International Conference on Software Engineering, ser. ICSE '17Piscataway, NJ, USAIEEE PressJ. Guo, J. Cheng, and J. Cleland-Huang, \"Semantically enhanced software traceability using deep learning techniques,\" in Proceedings of the 39th International Conference on Software Engineering, ser. ICSE '17. Piscataway, NJ, USA: IEEE Press, 2017, pp. 3-14. [Online].\n\n. 10.1109/ICSE.2017.9Available: https://doi.org/10.1109/ICSE.2017.9\n\nDeepfix: Fixing common c language errors by deep learning. R Gupta, S Pal, A Kanade, S K Shevade, AAAIR. Gupta, S. Pal, A. Kanade, and S. K. Shevade, \"Deepfix: Fixing common c language errors by deep learning,\" in AAAI, 2017.\n\nLearning to predict severity of software vulnerability using only vulnerability description. Z Han, X Li, Z Xing, H Liu, Z Feng, 2017 IEEE International Conference on Software Maintenance and Evolution (ICSME). Z. Han, X. Li, Z. Xing, H. Liu, and Z. Feng, \"Learning to predict severity of software vulnerability using only vulnerability description,\" in 2017 IEEE International Conference on Software Maintenance and Evolution (ICSME), Sept 2017, pp. 125-136.\n\nLong short-term memory. S Hochreiter, J Schmidhuber, 10.1162/neco.1997.9.8.1735Neural Comput. 98S. Hochreiter and J. Schmidhuber, \"Long short-term memory,\" Neural Comput., vol. 9, no. 8, pp. 1735-1780, Nov. 1997. [Online]. Available: http://dx.doi.org/10.1162/neco.1997.9.8.1735\n\nDebugging method names. E W H\u00f8st, B M \u00d8stvold, ECOOP 2009 -Object-Oriented Programming. S. DrossopoulouBerlin, Heidelberg; Berlin HeidelbergSpringerE. W. H\u00f8st and B. M. \u00d8stvold, \"Debugging method names,\" in ECOOP 2009 -Object-Oriented Programming, S. Drossopoulou, Ed. Berlin, Heidelberg: Springer Berlin Heidelberg, 2009, pp. 294-317.\n\nAutomatically generating commit messages from diffs using neural machine translation. S Jiang, A Armaly, C Mcmillan, 2017 32nd IEEE/ACM International Conference on Automated Software Engineering (ASE). S. Jiang, A. Armaly, and C. McMillan, \"Automatically generating commit messages from diffs using neural machine translation,\" in 2017 32nd IEEE/ACM International Conference on Automated Software Engineering (ASE), Oct 2017, pp. 135-146.\n\nRecurrent continuous translation models. N Kalchbrenner, P Blunsom, Proceedings of the 2013 Conference on Empirical Methods in Natural Language Processing. the 2013 Conference on Empirical Methods in Natural Language ProcessingSeattle, Washington, USAAssociation for Computational LinguisticsN. Kalchbrenner and P. Blunsom, \"Recurrent continuous translation models,\" in Proceedings of the 2013 Conference on Empirical Methods in Natural Language Processing. Seattle, Washington, USA: Association for Computational Linguistics, October 2013, pp. 1700-1709. [Online].\n\nCombining deep learning with information retrieval to localize buggy files for bug reports (n). A N Lam, A T Nguyen, H A Nguyen, T N Nguyen, 2015 30th IEEE/ACM International Conference on Automated Software Engineering (ASE). A. N. Lam, A. T. Nguyen, H. A. Nguyen, and T. N. Nguyen, \"Combining deep learning with information retrieval to localize buggy files for bug reports (n),\" in 2015 30th IEEE/ACM International Conference on Automated Software Engineering (ASE), Nov 2015, pp. 476-481.\n\nApplying deep learning based automatic bug triager to industrial projects. S.-R Lee, M.-J Heo, C.-G Lee, M Kim, G Jeong, http:/doi.acm.org/10.1145/3106237.3117776Proceedings of the 2017 11th Joint Meeting on Foundations of Software Engineering, ser. ESEC/FSE 2017. the 2017 11th Joint Meeting on Foundations of Software Engineering, ser. ESEC/FSE 2017New York, NY, USAACMS.-R. Lee, M.-J. Heo, C.-G. Lee, M. Kim, and G. Jeong, \"Applying deep learning based automatic bug triager to industrial projects,\" in Proceedings of the 2017 11th Joint Meeting on Foundations of Software Engineering, ser. ESEC/FSE 2017. New York, NY, USA: ACM, 2017, pp. 926-931. [Online]. Available: http://doi.acm.org/10.1145/3106237.3117776\n\nCclearner: A deep learning-based clone detection approach. L Li, H Feng, W Zhuang, N Meng, B Ryder, 2017 IEEE International Conference on Software Maintenance and Evolution (ICSME). L. Li, H. Feng, W. Zhuang, N. Meng, and B. Ryder, \"Cclearner: A deep learning-based clone detection approach,\" in 2017 IEEE International Conference on Software Maintenance and Evolution (ICSME), Sept 2017, pp. 249-260.\n\nEffective approaches to attention-based neural machine translation. M Luong, H Pham, C D Manning, abs/1508.04025CoRR. M. Luong, H. Pham, and C. D. Manning, \"Effective approaches to attention-based neural machine translation,\" CoRR, vol. abs/1508.04025, 2015. [Online]. Available: http://arxiv.org/abs/1508.04025\n\nVocabulary manipulation for neural machine translation. H Mi, Z Wang, A Ittycheriah, abs/1605.03209CoRR. H. Mi, Z. Wang, and A. Ittycheriah, \"Vocabulary manipulation for neural machine translation,\" CoRR, vol. abs/1605.03209, 2016. [Online]. Available: http://arxiv.org/abs/1605.03209\n\nMachine learning-based prototyping of graphical user interfaces for mobile apps. K Moran, C Bernal-C\u00e1rdenas, M Curcio, R Bonett, D Poshyvanyk, abs/1802.02312CoRR. K. Moran, C. Bernal-C\u00e1rdenas, M. Curcio, R. Bonett, and D. Poshyvanyk, \"Machine learning-based prototyping of graphical user interfaces for mobile apps,\" CoRR, vol. abs/1802.02312, 2018. [Online]. Available: http://arxiv.org/abs/1802.02312\n\nHow many words are there in the english language. Oxford, Oxford, \"How many words are there in the english language?\" August 2018. [Online]. Available: https://en.oxforddictionaries.com/explore/ how-many-words-are-there-in-the-english-language/\n\nT Parr, The Definitive ANTLR 4 Reference. 2nd ed. Pragmatic BookshelfT. Parr, The Definitive ANTLR 4 Reference, 2nd ed. Pragmatic Bookshelf, 2013.\n\nCode completion with statistical language models. V Raychev, M Vechev, E Yahav, Proceedings of the 35th ACM SIGPLAN Conference on Programming Language Design and Implementation, ser. PLDI '14. the 35th ACM SIGPLAN Conference on Programming Language Design and Implementation, ser. PLDI '14New York, NY, USAACMV. Raychev, M. Vechev, and E. Yahav, \"Code completion with statistical language models,\" in Proceedings of the 35th ACM SIGPLAN Conference on Programming Language Design and Implementation, ser. PLDI '14. New York, NY, USA: ACM, 2014, pp. 419-428. [Online].\n\n. http:/doi.acm.org/10.1145/2594291.2594321Available: http://doi.acm.org/10.1145/2594291.2594321\n\nDeep green: Modelling time-series of software energy consumption. S Romansky, N C Borle, S Chowdhury, A Hindle, R Greiner, 2017 IEEE International Conference on Software Maintenance and Evolution (ICSME). S. Romansky, N. C. Borle, S. Chowdhury, A. Hindle, and R. Greiner, \"Deep green: Modelling time-series of software energy consumption,\" in 2017 IEEE International Conference on Software Maintenance and Evolution (ICSME), Sept 2017, pp. 273-283.\n\nImproving code readability models with textual features. S Scalabrino, M Linares-V\u00e1squez, D Poshyvanyk, R Oliveto, 2016 IEEE 24th International Conference on Program Comprehension (ICPC). S. Scalabrino, M. Linares-V\u00e1squez, D. Poshyvanyk, and R. Oliveto, \"Improving code readability models with textual features,\" in 2016 IEEE 24th International Conference on Program Comprehension (ICPC), May 2016.\n\nSequence to sequence learning with neural networks. I Sutskever, O Vinyals, Q V Le, abs/1409.3215CoRR. I. Sutskever, O. Vinyals, and Q. V. Le, \"Sequence to sequence learning with neural networks,\" CoRR, vol. abs/1409.3215, 2014. [Online].\n\nDeep learning similarities from different representations of source code. M Tufano, C Watson, G Bavota, M Di Penta, M White, D Poshyvanyk, http:/doi.acm.org/10.1145/3196398.3196431Proceedings of the 15th International Conference on Mining Software Repositories, ser. MSR '18. the 15th International Conference on Mining Software Repositories, ser. MSR '18New York, NY, USAACMM. Tufano, C. Watson, G. Bavota, M. Di Penta, M. White, and D. Poshyvanyk, \"Deep learning similarities from different representations of source code,\" in Proceedings of the 15th International Conference on Mining Software Repositories, ser. MSR '18. New York, NY, USA: ACM, 2018, pp. 542-553. [Online]. Available: http://doi.acm.org/10.1145/3196398.3196431\n\nAn empirical investigation into learning bug-fixing patches in the wild via neural machine translation. Proceedings of the 33rd. the 33rd--, \"An empirical investigation into learning bug-fixing patches in the wild via neural machine translation,\" in Proceedings of the 33rd\n\nhttp:/doi.acm.org/10.1145/3238147.3240732ACM/IEEE International Conference on Automated Software Engineering, ser. ASE 2018. New York, NY, USAACMACM/IEEE International Conference on Automated Software Engineering, ser. ASE 2018. New York, NY, USA: ACM, 2018, pp. 832-837. [Online]. Available: http://doi.acm.org/10.1145/3238147.3240732\n\nAutomatically learning semantic features for defect prediction. S Wang, T Liu, L Tan, http:/doi.acm.org/10.1145/2884781.2884804Proceedings of the 38th International Conference on Software Engineering, ser. ICSE '16. the 38th International Conference on Software Engineering, ser. ICSE '16New York, NY, USAACMS. Wang, T. Liu, and L. Tan, \"Automatically learning semantic features for defect prediction,\" in Proceedings of the 38th International Conference on Software Engineering, ser. ICSE '16. New York, NY, USA: ACM, 2016, pp. 297-308. [Online]. Available: http: //doi.acm.org/10.1145/2884781.2884804\n\nDeep learning code fragments for code clone detection. M White, M Tufano, C Vendome, D Poshyvanyk, http:/doi.acm.org/10.1145/2970276.2970326Proceedings of the 31st IEEE/ACM International Conference on Automated Software Engineering, ser. ASE 2016. the 31st IEEE/ACM International Conference on Automated Software Engineering, ser. ASE 2016New York, NY, USAACMM. White, M. Tufano, C. Vendome, and D. Poshyvanyk, \"Deep learning code fragments for code clone detection,\" in Proceedings of the 31st IEEE/ACM International Conference on Automated Software Engineering, ser. ASE 2016. New York, NY, USA: ACM, 2016, pp. 87-98. [Online]. Available: http://doi.acm.org/10.1145/2970276.2970326\n\nToward deep learning software repositories. M White, C Vendome, M Linares-V\u00e1squez, D Poshyvanyk, Proceedings of the 12th Working Conference on Mining Software Repositories, ser. MSR '15. the 12th Working Conference on Mining Software Repositories, ser. MSR '15Piscataway, NJ, USAIEEE PressM. White, C. Vendome, M. Linares-V\u00e1squez, and D. Poshyvanyk, \"Toward deep learning software repositories,\" in Proceedings of the 12th Working Conference on Mining Software Repositories, ser. MSR '15. Piscataway, NJ, USA: IEEE Press, 2015, pp. 334-345. [Online].\n\nAutocomment: Mining question and answer sites for automatic comment generation. E Wong, J Yang, L Tan, 2013 28th IEEE/ACM International Conference on Automated Software Engineering (ASE). E. Wong, J. Yang, and L. Tan, \"Autocomment: Mining question and answer sites for automatic comment generation,\" in 2013 28th IEEE/ACM International Conference on Automated Software Engineering (ASE), Nov 2013, pp. 562-567.\n\nGoogle's neural machine translation system: Bridging the gap between human and machine translation. Y Wu, M Schuster, Z Chen, Q V Le, M Norouzi, W Macherey, M Krikun, Y Cao, Q Gao, K Macherey, J Klingner, A Shah, M Johnson, X Liu, L Kaiser, S Gouws, Y Kato, T Kudo, H Kazawa, K Stevens, G Kurian, N Patil, W Wang, C Young, J Smith, J Riesa, A Rudnick, O Vinyals, G Corrado, M Hughes, J Dean, abs/1609.08144CoRR. Y. Wu, M. Schuster, Z. Chen, Q. V. Le, M. Norouzi, W. Macherey, M. Krikun, Y. Cao, Q. Gao, K. Macherey, J. Klingner, A. Shah, M. Johnson, X. Liu, L. Kaiser, S. Gouws, Y. Kato, T. Kudo, H. Kazawa, K. Stevens, G. Kurian, N. Patil, W. Wang, C. Young, J. Smith, J. Riesa, A. Rudnick, O. Vinyals, G. Corrado, M. Hughes, and J. Dean, \"Google's neural machine translation system: Bridging the gap between human and machine translation,\" CoRR, vol. abs/1609.08144, 2016. [Online].\n", "annotations": {"author": "[{\"end\":156,\"start\":70},{\"end\":268,\"start\":157},{\"end\":353,\"start\":269},{\"end\":453,\"start\":354},{\"end\":524,\"start\":454}]", "publisher": null, "author_last_name": "[{\"end\":84,\"start\":78},{\"end\":178,\"start\":167},{\"end\":280,\"start\":274},{\"end\":369,\"start\":363},{\"end\":470,\"start\":460}]", "author_first_name": "[{\"end\":77,\"start\":70},{\"end\":166,\"start\":157},{\"end\":273,\"start\":269},{\"end\":362,\"start\":354},{\"end\":459,\"start\":454}]", "author_affiliation": "[{\"end\":155,\"start\":104},{\"end\":267,\"start\":209},{\"end\":352,\"start\":301},{\"end\":452,\"start\":394},{\"end\":523,\"start\":472}]", "title": "[{\"end\":67,\"start\":1},{\"end\":591,\"start\":525}]", "venue": null, "abstract": "[{\"end\":2253,\"start\":648}]", "bib_ref": "[{\"attributes\":{\"ref_id\":\"b62\"},\"end\":4136,\"start\":4132},{\"attributes\":{\"ref_id\":\"b42\"},\"end\":4172,\"start\":4168},{\"attributes\":{\"ref_id\":\"b19\"},\"end\":4191,\"start\":4187},{\"attributes\":{\"ref_id\":\"b63\"},\"end\":4211,\"start\":4207},{\"attributes\":{\"ref_id\":\"b60\"},\"end\":4235,\"start\":4231},{\"attributes\":{\"ref_id\":\"b44\"},\"end\":4258,\"start\":4254},{\"attributes\":{\"ref_id\":\"b58\"},\"end\":4274,\"start\":4270},{\"attributes\":{\"ref_id\":\"b61\"},\"end\":4296,\"start\":4292},{\"attributes\":{\"ref_id\":\"b33\"},\"end\":4314,\"start\":4310},{\"attributes\":{\"ref_id\":\"b35\"},\"end\":4347,\"start\":4343},{\"attributes\":{\"ref_id\":\"b23\"},\"end\":4920,\"start\":4916},{\"attributes\":{\"ref_id\":\"b64\"},\"end\":5085,\"start\":5081},{\"attributes\":{\"ref_id\":\"b58\"},\"end\":5570,\"start\":5566},{\"attributes\":{\"ref_id\":\"b14\"},\"end\":6552,\"start\":6548},{\"end\":6598,\"start\":6594},{\"attributes\":{\"ref_id\":\"b12\"},\"end\":6618,\"start\":6614},{\"attributes\":{\"ref_id\":\"b13\"},\"end\":6634,\"start\":6630},{\"attributes\":{\"ref_id\":\"b31\"},\"end\":7685,\"start\":7681},{\"attributes\":{\"ref_id\":\"b52\"},\"end\":8789,\"start\":8785},{\"attributes\":{\"ref_id\":\"b17\"},\"end\":9778,\"start\":9774},{\"attributes\":{\"ref_id\":\"b31\"},\"end\":12064,\"start\":12060},{\"attributes\":{\"ref_id\":\"b48\"},\"end\":13848,\"start\":13844},{\"attributes\":{\"ref_id\":\"b64\"},\"end\":13854,\"start\":13850},{\"attributes\":{\"ref_id\":\"b50\"},\"end\":14631,\"start\":14627},{\"attributes\":{\"ref_id\":\"b51\"},\"end\":15741,\"start\":15737},{\"attributes\":{\"ref_id\":\"b22\"},\"end\":20654,\"start\":20650},{\"attributes\":{\"ref_id\":\"b47\"},\"end\":20660,\"start\":20656},{\"attributes\":{\"ref_id\":\"b24\"},\"end\":20666,\"start\":20662},{\"attributes\":{\"ref_id\":\"b43\"},\"end\":20702,\"start\":20698},{\"attributes\":{\"ref_id\":\"b56\"},\"end\":20708,\"start\":20704},{\"attributes\":{\"ref_id\":\"b25\"},\"end\":20714,\"start\":20710},{\"attributes\":{\"ref_id\":\"b22\"},\"end\":21784,\"start\":21780},{\"attributes\":{\"ref_id\":\"b24\"},\"end\":22008,\"start\":22004},{\"attributes\":{\"ref_id\":\"b52\"},\"end\":23146,\"start\":23142},{\"attributes\":{\"ref_id\":\"b40\"},\"end\":24199,\"start\":24195},{\"attributes\":{\"ref_id\":\"b25\"},\"end\":24212,\"start\":24208},{\"attributes\":{\"ref_id\":\"b17\"},\"end\":30395,\"start\":30391},{\"attributes\":{\"ref_id\":\"b17\"},\"end\":31907,\"start\":31903},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":32703,\"start\":32700},{\"end\":33030,\"start\":33026},{\"attributes\":{\"ref_id\":\"b0\"},\"end\":33543,\"start\":33540},{\"attributes\":{\"ref_id\":\"b19\"},\"end\":36005,\"start\":36001},{\"attributes\":{\"ref_id\":\"b41\"},\"end\":36011,\"start\":36007},{\"end\":36032,\"start\":36028},{\"end\":36156,\"start\":36152},{\"attributes\":{\"ref_id\":\"b10\"},\"end\":36278,\"start\":36274},{\"attributes\":{\"ref_id\":\"b10\"},\"end\":36460,\"start\":36456},{\"attributes\":{\"ref_id\":\"b4\"},\"end\":36871,\"start\":36868},{\"attributes\":{\"ref_id\":\"b15\"},\"end\":36890,\"start\":36886},{\"attributes\":{\"ref_id\":\"b4\"},\"end\":37063,\"start\":37060},{\"attributes\":{\"ref_id\":\"b15\"},\"end\":37361,\"start\":37357},{\"attributes\":{\"ref_id\":\"b55\"},\"end\":37810,\"start\":37806},{\"attributes\":{\"ref_id\":\"b5\"},\"end\":39073,\"start\":39070},{\"end\":39128,\"start\":39124},{\"attributes\":{\"ref_id\":\"b5\"},\"end\":39185,\"start\":39182},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":40624,\"start\":40621},{\"attributes\":{\"ref_id\":\"b7\"},\"end\":40745,\"start\":40742},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":40894,\"start\":40891},{\"attributes\":{\"ref_id\":\"b7\"},\"end\":41323,\"start\":41320},{\"attributes\":{\"ref_id\":\"b3\"},\"end\":42117,\"start\":42114},{\"attributes\":{\"ref_id\":\"b11\"},\"end\":42759,\"start\":42755},{\"attributes\":{\"ref_id\":\"b16\"},\"end\":43018,\"start\":43014},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":43200,\"start\":43196},{\"attributes\":{\"ref_id\":\"b8\"},\"end\":43230,\"start\":43226},{\"attributes\":{\"ref_id\":\"b6\"},\"end\":43314,\"start\":43311},{\"attributes\":{\"ref_id\":\"b17\"},\"end\":47600,\"start\":47596},{\"attributes\":{\"ref_id\":\"b32\"},\"end\":48532,\"start\":48528},{\"attributes\":{\"ref_id\":\"b38\"},\"end\":48537,\"start\":48533},{\"attributes\":{\"ref_id\":\"b61\"},\"end\":48830,\"start\":48826},{\"attributes\":{\"ref_id\":\"b57\"},\"end\":49150,\"start\":49146},{\"attributes\":{\"ref_id\":\"b58\"},\"end\":49236,\"start\":49232},{\"attributes\":{\"ref_id\":\"b62\"},\"end\":49835,\"start\":49831},{\"end\":49934,\"start\":49915},{\"attributes\":{\"ref_id\":\"b28\"},\"end\":50055,\"start\":50051},{\"attributes\":{\"ref_id\":\"b44\"},\"end\":50391,\"start\":50387},{\"attributes\":{\"ref_id\":\"b45\"},\"end\":50634,\"start\":50630},{\"attributes\":{\"ref_id\":\"b60\"},\"end\":50844,\"start\":50840},{\"attributes\":{\"ref_id\":\"b26\"},\"end\":51090,\"start\":51086},{\"attributes\":{\"ref_id\":\"b21\"},\"end\":51361,\"start\":51357},{\"attributes\":{\"ref_id\":\"b36\"},\"end\":51552,\"start\":51548},{\"attributes\":{\"ref_id\":\"b33\"},\"end\":51943,\"start\":51939},{\"attributes\":{\"ref_id\":\"b20\"},\"end\":52255,\"start\":52251},{\"attributes\":{\"ref_id\":\"b35\"},\"end\":52550,\"start\":52546},{\"attributes\":{\"ref_id\":\"b49\"},\"end\":52835,\"start\":52831},{\"attributes\":{\"ref_id\":\"b17\"},\"end\":54546,\"start\":54542},{\"attributes\":{\"ref_id\":\"b18\"},\"end\":60622,\"start\":60618},{\"attributes\":{\"ref_id\":\"b27\"},\"end\":60630,\"start\":60626},{\"attributes\":{\"ref_id\":\"b39\"},\"end\":60638,\"start\":60634},{\"attributes\":{\"ref_id\":\"b54\"},\"end\":60642,\"start\":60638}]", "figure": "[{\"attributes\":{\"id\":\"fig_0\"},\"end\":55250,\"start\":54956},{\"attributes\":{\"id\":\"fig_1\"},\"end\":55379,\"start\":55251},{\"attributes\":{\"id\":\"fig_2\"},\"end\":55482,\"start\":55380},{\"attributes\":{\"id\":\"fig_3\"},\"end\":56038,\"start\":55483},{\"attributes\":{\"id\":\"fig_4\"},\"end\":56259,\"start\":56039},{\"attributes\":{\"id\":\"fig_5\"},\"end\":56968,\"start\":56260},{\"attributes\":{\"id\":\"tab_0\",\"type\":\"table\"},\"end\":57122,\"start\":56969},{\"attributes\":{\"id\":\"tab_1\",\"type\":\"table\"},\"end\":57262,\"start\":57123},{\"attributes\":{\"id\":\"tab_2\",\"type\":\"table\"},\"end\":57911,\"start\":57263},{\"attributes\":{\"id\":\"tab_3\",\"type\":\"table\"},\"end\":60615,\"start\":57912},{\"attributes\":{\"id\":\"tab_7\",\"type\":\"table\"},\"end\":60642,\"start\":60616}]", "paragraph": "[{\"end\":2876,\"start\":2255},{\"end\":3871,\"start\":2878},{\"end\":3928,\"start\":3873},{\"end\":4348,\"start\":3948},{\"end\":5444,\"start\":4350},{\"end\":6519,\"start\":5446},{\"end\":7969,\"start\":6521},{\"end\":8501,\"start\":7971},{\"end\":9779,\"start\":8503},{\"end\":10345,\"start\":9796},{\"end\":10813,\"start\":10372},{\"end\":11418,\"start\":10815},{\"end\":11657,\"start\":11420},{\"end\":11714,\"start\":11680},{\"end\":13179,\"start\":11777},{\"end\":13357,\"start\":13181},{\"end\":14632,\"start\":13393},{\"end\":15167,\"start\":14634},{\"end\":15524,\"start\":15169},{\"end\":16824,\"start\":15526},{\"end\":17306,\"start\":16826},{\"end\":17990,\"start\":17308},{\"end\":18350,\"start\":17992},{\"end\":19068,\"start\":18352},{\"end\":19478,\"start\":19070},{\"end\":19596,\"start\":19480},{\"end\":20253,\"start\":19598},{\"end\":20530,\"start\":20290},{\"end\":22703,\"start\":20532},{\"end\":23434,\"start\":22705},{\"end\":23684,\"start\":23511},{\"end\":24055,\"start\":23773},{\"end\":24708,\"start\":24057},{\"end\":25261,\"start\":24735},{\"end\":25502,\"start\":25283},{\"end\":25588,\"start\":25504},{\"end\":26303,\"start\":25590},{\"end\":27627,\"start\":26305},{\"end\":27705,\"start\":27629},{\"end\":27993,\"start\":27707},{\"end\":28346,\"start\":27995},{\"end\":29122,\"start\":28368},{\"end\":29329,\"start\":29124},{\"end\":29726,\"start\":29331},{\"end\":29962,\"start\":29728},{\"end\":30040,\"start\":29964},{\"end\":31553,\"start\":30042},{\"end\":31908,\"start\":31555},{\"end\":32224,\"start\":31927},{\"end\":32664,\"start\":32226},{\"end\":32986,\"start\":32666},{\"end\":33500,\"start\":32988},{\"end\":34891,\"start\":33502},{\"end\":35627,\"start\":34893},{\"end\":36012,\"start\":35675},{\"end\":36255,\"start\":36014},{\"end\":36636,\"start\":36257},{\"end\":36855,\"start\":36658},{\"end\":37208,\"start\":36857},{\"end\":39074,\"start\":37210},{\"end\":39911,\"start\":39076},{\"end\":40411,\"start\":39926},{\"end\":40869,\"start\":40413},{\"end\":41286,\"start\":40871},{\"end\":41851,\"start\":41288},{\"end\":42095,\"start\":41853},{\"end\":42119,\"start\":42097},{\"end\":42533,\"start\":42130},{\"end\":43523,\"start\":42548},{\"end\":43976,\"start\":43525},{\"end\":45004,\"start\":43989},{\"end\":45690,\"start\":45006},{\"end\":46019,\"start\":45692},{\"end\":46236,\"start\":46021},{\"end\":46939,\"start\":46238},{\"end\":47231,\"start\":46941},{\"end\":47941,\"start\":47233},{\"end\":48195,\"start\":47943},{\"end\":48722,\"start\":48216},{\"end\":49567,\"start\":48724},{\"end\":50056,\"start\":49569},{\"end\":50845,\"start\":50058},{\"end\":51944,\"start\":50847},{\"end\":52551,\"start\":51946},{\"end\":52836,\"start\":52553},{\"end\":53258,\"start\":52838},{\"end\":53672,\"start\":53278},{\"end\":54593,\"start\":53674},{\"end\":54955,\"start\":54618}]", "formula": "[{\"attributes\":{\"id\":\"formula_0\"},\"end\":11776,\"start\":11715},{\"attributes\":{\"id\":\"formula_1\"},\"end\":23510,\"start\":23435},{\"attributes\":{\"id\":\"formula_2\"},\"end\":23772,\"start\":23685}]", "table_ref": "[{\"attributes\":{\"ref_id\":\"tab_0\"},\"end\":14319,\"start\":14312},{\"attributes\":{\"ref_id\":\"tab_0\"},\"end\":17524,\"start\":17517},{\"attributes\":{\"ref_id\":\"tab_0\"},\"end\":17858,\"start\":17851},{\"attributes\":{\"ref_id\":\"tab_0\"},\"end\":19842,\"start\":19834},{\"attributes\":{\"ref_id\":\"tab_0\"},\"end\":25798,\"start\":25790},{\"attributes\":{\"ref_id\":\"tab_0\"},\"end\":26159,\"start\":26151},{\"attributes\":{\"ref_id\":\"tab_0\"},\"end\":28462,\"start\":28453},{\"attributes\":{\"ref_id\":\"tab_0\"},\"end\":29292,\"start\":29284}]", "section_header": "[{\"end\":3946,\"start\":3931},{\"end\":9794,\"start\":9782},{\"end\":10370,\"start\":10348},{\"end\":11678,\"start\":11660},{\"end\":13391,\"start\":13360},{\"end\":20288,\"start\":20256},{\"end\":24733,\"start\":24711},{\"end\":25281,\"start\":25264},{\"end\":28366,\"start\":28349},{\"end\":31925,\"start\":31911},{\"end\":35673,\"start\":35630},{\"end\":36656,\"start\":36639},{\"end\":39924,\"start\":39914},{\"end\":42128,\"start\":42122},{\"end\":42546,\"start\":42536},{\"end\":43987,\"start\":43979},{\"end\":48214,\"start\":48198},{\"end\":53276,\"start\":53261},{\"end\":54616,\"start\":54596},{\"end\":55384,\"start\":55381},{\"end\":56990,\"start\":56970},{\"end\":57141,\"start\":57124},{\"end\":57273,\"start\":57264}]", "table": "[{\"end\":57122,\"start\":56992},{\"end\":57262,\"start\":57144},{\"end\":57911,\"start\":57277},{\"end\":60615,\"start\":57990}]", "figure_caption": "[{\"end\":55250,\"start\":54958},{\"end\":55379,\"start\":55253},{\"end\":55482,\"start\":55385},{\"end\":56038,\"start\":55485},{\"end\":56259,\"start\":56041},{\"end\":56968,\"start\":56262},{\"end\":57990,\"start\":57914},{\"end\":60642,\"start\":60618}]", "figure_ref": "[{\"end\":8500,\"start\":8494},{\"end\":30403,\"start\":30397},{\"end\":30788,\"start\":30775},{\"end\":36751,\"start\":36745},{\"end\":39970,\"start\":39964},{\"end\":40513,\"start\":40507},{\"end\":44712,\"start\":44706},{\"end\":45970,\"start\":45964}]", "bib_author_first_name": "[{\"end\":62390,\"start\":62384},{\"end\":63547,\"start\":63546},{\"end\":63549,\"start\":63548},{\"end\":64192,\"start\":64191},{\"end\":64205,\"start\":64204},{\"end\":64207,\"start\":64206},{\"end\":64215,\"start\":64214},{\"end\":64223,\"start\":64222},{\"end\":65423,\"start\":65422},{\"end\":65436,\"start\":65435},{\"end\":65444,\"start\":65443},{\"end\":65446,\"start\":65445},{\"end\":65754,\"start\":65753},{\"end\":65766,\"start\":65765},{\"end\":65773,\"start\":65772},{\"end\":66032,\"start\":66031},{\"end\":66320,\"start\":66319},{\"end\":66329,\"start\":66328},{\"end\":66339,\"start\":66338},{\"end\":66348,\"start\":66347},{\"end\":66350,\"start\":66349},{\"end\":66656,\"start\":66655},{\"end\":66663,\"start\":66662},{\"end\":66682,\"start\":66681},{\"end\":66694,\"start\":66693},{\"end\":66706,\"start\":66705},{\"end\":66717,\"start\":66716},{\"end\":67060,\"start\":67059},{\"end\":67078,\"start\":67077},{\"end\":67080,\"start\":67079},{\"end\":67087,\"start\":67086},{\"end\":67095,\"start\":67094},{\"end\":67099,\"start\":67096},{\"end\":67107,\"start\":67106},{\"end\":67116,\"start\":67115},{\"end\":67419,\"start\":67418},{\"end\":67421,\"start\":67420},{\"end\":67431,\"start\":67430},{\"end\":67443,\"start\":67442},{\"end\":67445,\"start\":67444},{\"end\":67798,\"start\":67797},{\"end\":67800,\"start\":67799},{\"end\":67807,\"start\":67806},{\"end\":67815,\"start\":67814},{\"end\":67825,\"start\":67824},{\"end\":68521,\"start\":68520},{\"end\":68533,\"start\":68532},{\"end\":68537,\"start\":68534},{\"end\":68541,\"start\":68540},{\"end\":68551,\"start\":68550},{\"end\":68563,\"start\":68562},{\"end\":68953,\"start\":68952},{\"end\":68964,\"start\":68963},{\"end\":68976,\"start\":68975},{\"end\":68985,\"start\":68984},{\"end\":68997,\"start\":68996},{\"end\":69357,\"start\":69356},{\"end\":69370,\"start\":69369},{\"end\":69379,\"start\":69378},{\"end\":69601,\"start\":69600},{\"end\":69607,\"start\":69606},{\"end\":69616,\"start\":69615},{\"end\":70116,\"start\":70115},{\"end\":70122,\"start\":70121},{\"end\":70131,\"start\":70130},{\"end\":70140,\"start\":70139},{\"end\":70798,\"start\":70797},{\"end\":70805,\"start\":70804},{\"end\":70814,\"start\":70813},{\"end\":71419,\"start\":71418},{\"end\":71428,\"start\":71427},{\"end\":71435,\"start\":71434},{\"end\":71445,\"start\":71444},{\"end\":71447,\"start\":71446},{\"end\":71680,\"start\":71679},{\"end\":71687,\"start\":71686},{\"end\":71693,\"start\":71692},{\"end\":71701,\"start\":71700},{\"end\":71708,\"start\":71707},{\"end\":72072,\"start\":72071},{\"end\":72086,\"start\":72085},{\"end\":72352,\"start\":72351},{\"end\":72354,\"start\":72353},{\"end\":72362,\"start\":72361},{\"end\":72364,\"start\":72363},{\"end\":72751,\"start\":72750},{\"end\":72760,\"start\":72759},{\"end\":72770,\"start\":72769},{\"end\":73146,\"start\":73145},{\"end\":73162,\"start\":73161},{\"end\":73768,\"start\":73767},{\"end\":73770,\"start\":73769},{\"end\":73777,\"start\":73776},{\"end\":73779,\"start\":73778},{\"end\":73789,\"start\":73788},{\"end\":73791,\"start\":73790},{\"end\":73801,\"start\":73800},{\"end\":73803,\"start\":73802},{\"end\":74243,\"start\":74239},{\"end\":74253,\"start\":74249},{\"end\":74263,\"start\":74259},{\"end\":74270,\"start\":74269},{\"end\":74277,\"start\":74276},{\"end\":74941,\"start\":74940},{\"end\":74947,\"start\":74946},{\"end\":74955,\"start\":74954},{\"end\":74965,\"start\":74964},{\"end\":74973,\"start\":74972},{\"end\":75353,\"start\":75352},{\"end\":75362,\"start\":75361},{\"end\":75370,\"start\":75369},{\"end\":75372,\"start\":75371},{\"end\":75654,\"start\":75653},{\"end\":75660,\"start\":75659},{\"end\":75668,\"start\":75667},{\"end\":75965,\"start\":75964},{\"end\":75974,\"start\":75973},{\"end\":75993,\"start\":75992},{\"end\":76003,\"start\":76002},{\"end\":76013,\"start\":76012},{\"end\":76534,\"start\":76533},{\"end\":76732,\"start\":76731},{\"end\":76743,\"start\":76742},{\"end\":76753,\"start\":76752},{\"end\":77414,\"start\":77413},{\"end\":77426,\"start\":77425},{\"end\":77428,\"start\":77427},{\"end\":77437,\"start\":77436},{\"end\":77450,\"start\":77449},{\"end\":77460,\"start\":77459},{\"end\":77855,\"start\":77854},{\"end\":77869,\"start\":77868},{\"end\":77888,\"start\":77887},{\"end\":77902,\"start\":77901},{\"end\":78250,\"start\":78249},{\"end\":78263,\"start\":78262},{\"end\":78274,\"start\":78273},{\"end\":78276,\"start\":78275},{\"end\":78512,\"start\":78511},{\"end\":78522,\"start\":78521},{\"end\":78532,\"start\":78531},{\"end\":78542,\"start\":78541},{\"end\":78545,\"start\":78543},{\"end\":78554,\"start\":78553},{\"end\":78563,\"start\":78562},{\"end\":79847,\"start\":79846},{\"end\":79855,\"start\":79854},{\"end\":79862,\"start\":79861},{\"end\":80442,\"start\":80441},{\"end\":80451,\"start\":80450},{\"end\":80461,\"start\":80460},{\"end\":80472,\"start\":80471},{\"end\":81116,\"start\":81115},{\"end\":81125,\"start\":81124},{\"end\":81136,\"start\":81135},{\"end\":81155,\"start\":81154},{\"end\":81704,\"start\":81703},{\"end\":81712,\"start\":81711},{\"end\":81720,\"start\":81719},{\"end\":82136,\"start\":82135},{\"end\":82142,\"start\":82141},{\"end\":82154,\"start\":82153},{\"end\":82162,\"start\":82161},{\"end\":82164,\"start\":82163},{\"end\":82170,\"start\":82169},{\"end\":82181,\"start\":82180},{\"end\":82193,\"start\":82192},{\"end\":82203,\"start\":82202},{\"end\":82210,\"start\":82209},{\"end\":82217,\"start\":82216},{\"end\":82229,\"start\":82228},{\"end\":82241,\"start\":82240},{\"end\":82249,\"start\":82248},{\"end\":82260,\"start\":82259},{\"end\":82267,\"start\":82266},{\"end\":82277,\"start\":82276},{\"end\":82286,\"start\":82285},{\"end\":82294,\"start\":82293},{\"end\":82302,\"start\":82301},{\"end\":82312,\"start\":82311},{\"end\":82323,\"start\":82322},{\"end\":82333,\"start\":82332},{\"end\":82342,\"start\":82341},{\"end\":82350,\"start\":82349},{\"end\":82359,\"start\":82358},{\"end\":82368,\"start\":82367},{\"end\":82377,\"start\":82376},{\"end\":82388,\"start\":82387},{\"end\":82399,\"start\":82398},{\"end\":82410,\"start\":82409},{\"end\":82420,\"start\":82419}]", "bib_author_last_name": "[{\"end\":62404,\"start\":62391},{\"end\":63559,\"start\":63550},{\"end\":64202,\"start\":64193},{\"end\":64212,\"start\":64208},{\"end\":64220,\"start\":64216},{\"end\":64230,\"start\":64224},{\"end\":65433,\"start\":65424},{\"end\":65441,\"start\":65437},{\"end\":65453,\"start\":65447},{\"end\":65763,\"start\":65755},{\"end\":65770,\"start\":65767},{\"end\":65780,\"start\":65774},{\"end\":66040,\"start\":66033},{\"end\":66326,\"start\":66321},{\"end\":66336,\"start\":66330},{\"end\":66345,\"start\":66340},{\"end\":66353,\"start\":66351},{\"end\":66660,\"start\":66657},{\"end\":66679,\"start\":66664},{\"end\":66691,\"start\":66683},{\"end\":66703,\"start\":66695},{\"end\":66714,\"start\":66707},{\"end\":66724,\"start\":66718},{\"end\":67075,\"start\":67061},{\"end\":67084,\"start\":67081},{\"end\":67092,\"start\":67088},{\"end\":67104,\"start\":67100},{\"end\":67113,\"start\":67108},{\"end\":67124,\"start\":67117},{\"end\":67428,\"start\":67422},{\"end\":67440,\"start\":67432},{\"end\":67451,\"start\":67446},{\"end\":67804,\"start\":67801},{\"end\":67812,\"start\":67808},{\"end\":67822,\"start\":67816},{\"end\":67831,\"start\":67826},{\"end\":68530,\"start\":68522},{\"end\":68548,\"start\":68542},{\"end\":68560,\"start\":68552},{\"end\":68570,\"start\":68564},{\"end\":68961,\"start\":68954},{\"end\":68973,\"start\":68965},{\"end\":68982,\"start\":68977},{\"end\":68994,\"start\":68986},{\"end\":69007,\"start\":68998},{\"end\":69367,\"start\":69358},{\"end\":69376,\"start\":69371},{\"end\":69385,\"start\":69380},{\"end\":69604,\"start\":69602},{\"end\":69613,\"start\":69608},{\"end\":69620,\"start\":69617},{\"end\":70119,\"start\":70117},{\"end\":70128,\"start\":70123},{\"end\":70137,\"start\":70132},{\"end\":70144,\"start\":70141},{\"end\":70802,\"start\":70799},{\"end\":70811,\"start\":70806},{\"end\":70828,\"start\":70815},{\"end\":71425,\"start\":71420},{\"end\":71432,\"start\":71429},{\"end\":71442,\"start\":71436},{\"end\":71455,\"start\":71448},{\"end\":71684,\"start\":71681},{\"end\":71690,\"start\":71688},{\"end\":71698,\"start\":71694},{\"end\":71705,\"start\":71702},{\"end\":71713,\"start\":71709},{\"end\":72083,\"start\":72073},{\"end\":72098,\"start\":72087},{\"end\":72359,\"start\":72355},{\"end\":72372,\"start\":72365},{\"end\":72757,\"start\":72752},{\"end\":72767,\"start\":72761},{\"end\":72779,\"start\":72771},{\"end\":73159,\"start\":73147},{\"end\":73170,\"start\":73163},{\"end\":73774,\"start\":73771},{\"end\":73786,\"start\":73780},{\"end\":73798,\"start\":73792},{\"end\":73810,\"start\":73804},{\"end\":74247,\"start\":74244},{\"end\":74257,\"start\":74254},{\"end\":74267,\"start\":74264},{\"end\":74274,\"start\":74271},{\"end\":74283,\"start\":74278},{\"end\":74944,\"start\":74942},{\"end\":74952,\"start\":74948},{\"end\":74962,\"start\":74956},{\"end\":74970,\"start\":74966},{\"end\":74979,\"start\":74974},{\"end\":75359,\"start\":75354},{\"end\":75367,\"start\":75363},{\"end\":75380,\"start\":75373},{\"end\":75657,\"start\":75655},{\"end\":75665,\"start\":75661},{\"end\":75680,\"start\":75669},{\"end\":75971,\"start\":75966},{\"end\":75990,\"start\":75975},{\"end\":76000,\"start\":75994},{\"end\":76010,\"start\":76004},{\"end\":76024,\"start\":76014},{\"end\":76343,\"start\":76337},{\"end\":76539,\"start\":76535},{\"end\":76740,\"start\":76733},{\"end\":76750,\"start\":76744},{\"end\":76759,\"start\":76754},{\"end\":77423,\"start\":77415},{\"end\":77434,\"start\":77429},{\"end\":77447,\"start\":77438},{\"end\":77457,\"start\":77451},{\"end\":77468,\"start\":77461},{\"end\":77866,\"start\":77856},{\"end\":77885,\"start\":77870},{\"end\":77899,\"start\":77889},{\"end\":77910,\"start\":77903},{\"end\":78260,\"start\":78251},{\"end\":78271,\"start\":78264},{\"end\":78279,\"start\":78277},{\"end\":78519,\"start\":78513},{\"end\":78529,\"start\":78523},{\"end\":78539,\"start\":78533},{\"end\":78551,\"start\":78546},{\"end\":78560,\"start\":78555},{\"end\":78574,\"start\":78564},{\"end\":79852,\"start\":79848},{\"end\":79859,\"start\":79856},{\"end\":79866,\"start\":79863},{\"end\":80448,\"start\":80443},{\"end\":80458,\"start\":80452},{\"end\":80469,\"start\":80462},{\"end\":80483,\"start\":80473},{\"end\":81122,\"start\":81117},{\"end\":81133,\"start\":81126},{\"end\":81152,\"start\":81137},{\"end\":81166,\"start\":81156},{\"end\":81709,\"start\":81705},{\"end\":81717,\"start\":81713},{\"end\":81724,\"start\":81721},{\"end\":82139,\"start\":82137},{\"end\":82151,\"start\":82143},{\"end\":82159,\"start\":82155},{\"end\":82167,\"start\":82165},{\"end\":82178,\"start\":82171},{\"end\":82190,\"start\":82182},{\"end\":82200,\"start\":82194},{\"end\":82207,\"start\":82204},{\"end\":82214,\"start\":82211},{\"end\":82226,\"start\":82218},{\"end\":82238,\"start\":82230},{\"end\":82246,\"start\":82242},{\"end\":82257,\"start\":82250},{\"end\":82264,\"start\":82261},{\"end\":82274,\"start\":82268},{\"end\":82283,\"start\":82278},{\"end\":82291,\"start\":82287},{\"end\":82299,\"start\":82295},{\"end\":82309,\"start\":82303},{\"end\":82320,\"start\":82313},{\"end\":82330,\"start\":82324},{\"end\":82339,\"start\":82334},{\"end\":82347,\"start\":82343},{\"end\":82356,\"start\":82351},{\"end\":82365,\"start\":82360},{\"end\":82374,\"start\":82369},{\"end\":82385,\"start\":82378},{\"end\":82396,\"start\":82389},{\"end\":82407,\"start\":82400},{\"end\":82417,\"start\":82411},{\"end\":82425,\"start\":82421}]", "bib_entry": "[{\"attributes\":{\"id\":\"b0\"},\"end\":60769,\"start\":60644},{\"attributes\":{\"id\":\"b1\"},\"end\":60894,\"start\":60771},{\"attributes\":{\"id\":\"b2\"},\"end\":61010,\"start\":60896},{\"attributes\":{\"id\":\"b3\"},\"end\":61145,\"start\":61012},{\"attributes\":{\"id\":\"b4\"},\"end\":61288,\"start\":61147},{\"attributes\":{\"id\":\"b5\"},\"end\":61426,\"start\":61290},{\"attributes\":{\"id\":\"b6\"},\"end\":61563,\"start\":61428},{\"attributes\":{\"id\":\"b7\"},\"end\":61694,\"start\":61565},{\"attributes\":{\"id\":\"b8\"},\"end\":61868,\"start\":61696},{\"attributes\":{\"id\":\"b9\"},\"end\":62009,\"start\":61870},{\"attributes\":{\"id\":\"b10\"},\"end\":62137,\"start\":62011},{\"attributes\":{\"id\":\"b11\"},\"end\":62262,\"start\":62139},{\"attributes\":{\"id\":\"b12\"},\"end\":62380,\"start\":62264},{\"attributes\":{\"id\":\"b13\"},\"end\":62475,\"start\":62382},{\"attributes\":{\"id\":\"b14\"},\"end\":62702,\"start\":62477},{\"attributes\":{\"id\":\"b15\"},\"end\":62826,\"start\":62704},{\"attributes\":{\"id\":\"b16\"},\"end\":62932,\"start\":62828},{\"attributes\":{\"id\":\"b17\",\"matched_paper_id\":59316445},\"end\":63494,\"start\":62934},{\"attributes\":{\"doi\":\"http:/doi.acm.org/10.1145/2950290.2983951\",\"id\":\"b18\",\"matched_paper_id\":387671},\"end\":64145,\"start\":63496},{\"attributes\":{\"doi\":\"http:/doi.acm.org/10.1145/2786805.2786849\",\"id\":\"b19\",\"matched_paper_id\":9279336},\"end\":64788,\"start\":64147},{\"attributes\":{\"doi\":\"http:/doi.acm.org/10.1145/2786805.2786849\",\"id\":\"b20\",\"matched_paper_id\":9279336},\"end\":65344,\"start\":64790},{\"attributes\":{\"doi\":\"abs/1602.03001\",\"id\":\"b21\",\"matched_paper_id\":2723946},\"end\":65680,\"start\":65346},{\"attributes\":{\"doi\":\"abs/1409.0473\",\"id\":\"b22\",\"matched_paper_id\":11212020},\"end\":65993,\"start\":65682},{\"attributes\":{\"id\":\"b23\"},\"end\":66252,\"start\":65995},{\"attributes\":{\"id\":\"b24\",\"matched_paper_id\":2201909},\"end\":66558,\"start\":66254},{\"attributes\":{\"doi\":\"abs/1406.1078\",\"id\":\"b25\",\"matched_paper_id\":5590763},\"end\":67006,\"start\":66560},{\"attributes\":{\"id\":\"b26\",\"matched_paper_id\":15300052},\"end\":67359,\"start\":67008},{\"attributes\":{\"id\":\"b27\",\"matched_paper_id\":15764135},\"end\":67746,\"start\":67361},{\"attributes\":{\"id\":\"b28\",\"matched_paper_id\":9498207},\"end\":68347,\"start\":67748},{\"attributes\":{\"doi\":\"http:/doi.acm.org/10.1145/2950290.2983985\",\"id\":\"b29\"},\"end\":68445,\"start\":68349},{\"attributes\":{\"id\":\"b30\",\"matched_paper_id\":19056247},\"end\":68898,\"start\":68447},{\"attributes\":{\"id\":\"b31\",\"matched_paper_id\":218737160},\"end\":69306,\"start\":68900},{\"attributes\":{\"doi\":\"abs/1701.07232\",\"id\":\"b32\",\"matched_paper_id\":1568498},\"end\":69580,\"start\":69308},{\"attributes\":{\"id\":\"b33\",\"matched_paper_id\":47021242},\"end\":69996,\"start\":69582},{\"attributes\":{\"doi\":\"http:/doi.acm.org/10.1145/3180155.3180167\",\"id\":\"b34\"},\"end\":70094,\"start\":69998},{\"attributes\":{\"doi\":\"http:/doi.acm.org/10.1145/2950290.2950334\",\"id\":\"b35\",\"matched_paper_id\":11540100},\"end\":70719,\"start\":70096},{\"attributes\":{\"id\":\"b36\",\"matched_paper_id\":4708148},\"end\":71288,\"start\":70721},{\"attributes\":{\"doi\":\"10.1109/ICSE.2017.9\",\"id\":\"b37\"},\"end\":71357,\"start\":71290},{\"attributes\":{\"id\":\"b38\"},\"end\":71584,\"start\":71359},{\"attributes\":{\"id\":\"b39\",\"matched_paper_id\":33064240},\"end\":72045,\"start\":71586},{\"attributes\":{\"doi\":\"10.1162/neco.1997.9.8.1735\",\"id\":\"b40\",\"matched_paper_id\":1915014},\"end\":72325,\"start\":72047},{\"attributes\":{\"id\":\"b41\",\"matched_paper_id\":4698136},\"end\":72662,\"start\":72327},{\"attributes\":{\"id\":\"b42\",\"matched_paper_id\":9237290},\"end\":73102,\"start\":72664},{\"attributes\":{\"id\":\"b43\",\"matched_paper_id\":12639289},\"end\":73669,\"start\":73104},{\"attributes\":{\"id\":\"b44\",\"matched_paper_id\":206511804},\"end\":74162,\"start\":73671},{\"attributes\":{\"doi\":\"http:/doi.acm.org/10.1145/3106237.3117776\",\"id\":\"b45\",\"matched_paper_id\":10249133},\"end\":74879,\"start\":74164},{\"attributes\":{\"id\":\"b46\",\"matched_paper_id\":1474148},\"end\":75282,\"start\":74881},{\"attributes\":{\"doi\":\"abs/1508.04025\",\"id\":\"b47\",\"matched_paper_id\":1998416},\"end\":75595,\"start\":75284},{\"attributes\":{\"doi\":\"abs/1605.03209\",\"id\":\"b48\",\"matched_paper_id\":1371374},\"end\":75881,\"start\":75597},{\"attributes\":{\"doi\":\"abs/1802.02312\",\"id\":\"b49\",\"matched_paper_id\":3629347},\"end\":76285,\"start\":75883},{\"attributes\":{\"id\":\"b50\"},\"end\":76531,\"start\":76287},{\"attributes\":{\"id\":\"b51\"},\"end\":76679,\"start\":76533},{\"attributes\":{\"id\":\"b52\",\"matched_paper_id\":13040187},\"end\":77247,\"start\":76681},{\"attributes\":{\"doi\":\"http:/doi.acm.org/10.1145/2594291.2594321\",\"id\":\"b53\"},\"end\":77345,\"start\":77249},{\"attributes\":{\"id\":\"b54\",\"matched_paper_id\":11315392},\"end\":77795,\"start\":77347},{\"attributes\":{\"id\":\"b55\",\"matched_paper_id\":1489233},\"end\":78195,\"start\":77797},{\"attributes\":{\"doi\":\"abs/1409.3215\",\"id\":\"b56\",\"matched_paper_id\":7961699},\"end\":78435,\"start\":78197},{\"attributes\":{\"doi\":\"http:/doi.acm.org/10.1145/3196398.3196431\",\"id\":\"b57\",\"matched_paper_id\":46902434},\"end\":79168,\"start\":78437},{\"attributes\":{\"id\":\"b58\",\"matched_paper_id\":51991430},\"end\":79443,\"start\":79170},{\"attributes\":{\"doi\":\"http:/doi.acm.org/10.1145/3238147.3240732\",\"id\":\"b59\"},\"end\":79780,\"start\":79445},{\"attributes\":{\"doi\":\"http:/doi.acm.org/10.1145/2884781.2884804\",\"id\":\"b60\",\"matched_paper_id\":10769502},\"end\":80384,\"start\":79782},{\"attributes\":{\"doi\":\"http:/doi.acm.org/10.1145/2970276.2970326\",\"id\":\"b61\",\"matched_paper_id\":14867364},\"end\":81069,\"start\":80386},{\"attributes\":{\"id\":\"b62\",\"matched_paper_id\":367166},\"end\":81621,\"start\":81071},{\"attributes\":{\"id\":\"b63\",\"matched_paper_id\":10506832},\"end\":82033,\"start\":81623},{\"attributes\":{\"doi\":\"abs/1609.08144\",\"id\":\"b64\",\"matched_paper_id\":3603249},\"end\":82919,\"start\":82035}]", "bib_title": "[{\"end\":63020,\"start\":62934},{\"end\":63544,\"start\":63496},{\"end\":64189,\"start\":64147},{\"end\":64832,\"start\":64790},{\"end\":65420,\"start\":65346},{\"end\":65751,\"start\":65682},{\"end\":66317,\"start\":66254},{\"end\":66653,\"start\":66560},{\"end\":67057,\"start\":67008},{\"end\":67416,\"start\":67361},{\"end\":67795,\"start\":67748},{\"end\":68518,\"start\":68447},{\"end\":68950,\"start\":68900},{\"end\":69354,\"start\":69308},{\"end\":69598,\"start\":69582},{\"end\":70113,\"start\":70096},{\"end\":70795,\"start\":70721},{\"end\":71677,\"start\":71586},{\"end\":72069,\"start\":72047},{\"end\":72349,\"start\":72327},{\"end\":72748,\"start\":72664},{\"end\":73143,\"start\":73104},{\"end\":73765,\"start\":73671},{\"end\":74237,\"start\":74164},{\"end\":74938,\"start\":74881},{\"end\":75350,\"start\":75284},{\"end\":75651,\"start\":75597},{\"end\":75962,\"start\":75883},{\"end\":76729,\"start\":76681},{\"end\":77411,\"start\":77347},{\"end\":77852,\"start\":77797},{\"end\":78247,\"start\":78197},{\"end\":78509,\"start\":78437},{\"end\":79272,\"start\":79170},{\"end\":79844,\"start\":79782},{\"end\":80439,\"start\":80386},{\"end\":81113,\"start\":81071},{\"end\":81701,\"start\":81623},{\"end\":82133,\"start\":82035}]", "bib_author": "[{\"end\":62406,\"start\":62384},{\"end\":63561,\"start\":63546},{\"end\":64204,\"start\":64191},{\"end\":64214,\"start\":64204},{\"end\":64222,\"start\":64214},{\"end\":64232,\"start\":64222},{\"end\":65435,\"start\":65422},{\"end\":65443,\"start\":65435},{\"end\":65455,\"start\":65443},{\"end\":65765,\"start\":65753},{\"end\":65772,\"start\":65765},{\"end\":65782,\"start\":65772},{\"end\":66042,\"start\":66031},{\"end\":66328,\"start\":66319},{\"end\":66338,\"start\":66328},{\"end\":66347,\"start\":66338},{\"end\":66355,\"start\":66347},{\"end\":66662,\"start\":66655},{\"end\":66681,\"start\":66662},{\"end\":66693,\"start\":66681},{\"end\":66705,\"start\":66693},{\"end\":66716,\"start\":66705},{\"end\":66726,\"start\":66716},{\"end\":67077,\"start\":67059},{\"end\":67086,\"start\":67077},{\"end\":67094,\"start\":67086},{\"end\":67106,\"start\":67094},{\"end\":67115,\"start\":67106},{\"end\":67126,\"start\":67115},{\"end\":67430,\"start\":67418},{\"end\":67442,\"start\":67430},{\"end\":67453,\"start\":67442},{\"end\":67806,\"start\":67797},{\"end\":67814,\"start\":67806},{\"end\":67824,\"start\":67814},{\"end\":67833,\"start\":67824},{\"end\":68532,\"start\":68520},{\"end\":68540,\"start\":68532},{\"end\":68550,\"start\":68540},{\"end\":68562,\"start\":68550},{\"end\":68572,\"start\":68562},{\"end\":68963,\"start\":68952},{\"end\":68975,\"start\":68963},{\"end\":68984,\"start\":68975},{\"end\":68996,\"start\":68984},{\"end\":69009,\"start\":68996},{\"end\":69369,\"start\":69356},{\"end\":69378,\"start\":69369},{\"end\":69387,\"start\":69378},{\"end\":69606,\"start\":69600},{\"end\":69615,\"start\":69606},{\"end\":69622,\"start\":69615},{\"end\":70121,\"start\":70115},{\"end\":70130,\"start\":70121},{\"end\":70139,\"start\":70130},{\"end\":70146,\"start\":70139},{\"end\":70804,\"start\":70797},{\"end\":70813,\"start\":70804},{\"end\":70830,\"start\":70813},{\"end\":71427,\"start\":71418},{\"end\":71434,\"start\":71427},{\"end\":71444,\"start\":71434},{\"end\":71457,\"start\":71444},{\"end\":71686,\"start\":71679},{\"end\":71692,\"start\":71686},{\"end\":71700,\"start\":71692},{\"end\":71707,\"start\":71700},{\"end\":71715,\"start\":71707},{\"end\":72085,\"start\":72071},{\"end\":72100,\"start\":72085},{\"end\":72361,\"start\":72351},{\"end\":72374,\"start\":72361},{\"end\":72759,\"start\":72750},{\"end\":72769,\"start\":72759},{\"end\":72781,\"start\":72769},{\"end\":73161,\"start\":73145},{\"end\":73172,\"start\":73161},{\"end\":73776,\"start\":73767},{\"end\":73788,\"start\":73776},{\"end\":73800,\"start\":73788},{\"end\":73812,\"start\":73800},{\"end\":74249,\"start\":74239},{\"end\":74259,\"start\":74249},{\"end\":74269,\"start\":74259},{\"end\":74276,\"start\":74269},{\"end\":74285,\"start\":74276},{\"end\":74946,\"start\":74940},{\"end\":74954,\"start\":74946},{\"end\":74964,\"start\":74954},{\"end\":74972,\"start\":74964},{\"end\":74981,\"start\":74972},{\"end\":75361,\"start\":75352},{\"end\":75369,\"start\":75361},{\"end\":75382,\"start\":75369},{\"end\":75659,\"start\":75653},{\"end\":75667,\"start\":75659},{\"end\":75682,\"start\":75667},{\"end\":75973,\"start\":75964},{\"end\":75992,\"start\":75973},{\"end\":76002,\"start\":75992},{\"end\":76012,\"start\":76002},{\"end\":76026,\"start\":76012},{\"end\":76345,\"start\":76337},{\"end\":76541,\"start\":76533},{\"end\":76742,\"start\":76731},{\"end\":76752,\"start\":76742},{\"end\":76761,\"start\":76752},{\"end\":77425,\"start\":77413},{\"end\":77436,\"start\":77425},{\"end\":77449,\"start\":77436},{\"end\":77459,\"start\":77449},{\"end\":77470,\"start\":77459},{\"end\":77868,\"start\":77854},{\"end\":77887,\"start\":77868},{\"end\":77901,\"start\":77887},{\"end\":77912,\"start\":77901},{\"end\":78262,\"start\":78249},{\"end\":78273,\"start\":78262},{\"end\":78281,\"start\":78273},{\"end\":78521,\"start\":78511},{\"end\":78531,\"start\":78521},{\"end\":78541,\"start\":78531},{\"end\":78553,\"start\":78541},{\"end\":78562,\"start\":78553},{\"end\":78576,\"start\":78562},{\"end\":79854,\"start\":79846},{\"end\":79861,\"start\":79854},{\"end\":79868,\"start\":79861},{\"end\":80450,\"start\":80441},{\"end\":80460,\"start\":80450},{\"end\":80471,\"start\":80460},{\"end\":80485,\"start\":80471},{\"end\":81124,\"start\":81115},{\"end\":81135,\"start\":81124},{\"end\":81154,\"start\":81135},{\"end\":81168,\"start\":81154},{\"end\":81711,\"start\":81703},{\"end\":81719,\"start\":81711},{\"end\":81726,\"start\":81719},{\"end\":82141,\"start\":82135},{\"end\":82153,\"start\":82141},{\"end\":82161,\"start\":82153},{\"end\":82169,\"start\":82161},{\"end\":82180,\"start\":82169},{\"end\":82192,\"start\":82180},{\"end\":82202,\"start\":82192},{\"end\":82209,\"start\":82202},{\"end\":82216,\"start\":82209},{\"end\":82228,\"start\":82216},{\"end\":82240,\"start\":82228},{\"end\":82248,\"start\":82240},{\"end\":82259,\"start\":82248},{\"end\":82266,\"start\":82259},{\"end\":82276,\"start\":82266},{\"end\":82285,\"start\":82276},{\"end\":82293,\"start\":82285},{\"end\":82301,\"start\":82293},{\"end\":82311,\"start\":82301},{\"end\":82322,\"start\":82311},{\"end\":82332,\"start\":82322},{\"end\":82341,\"start\":82332},{\"end\":82349,\"start\":82341},{\"end\":82358,\"start\":82349},{\"end\":82367,\"start\":82358},{\"end\":82376,\"start\":82367},{\"end\":82387,\"start\":82376},{\"end\":82398,\"start\":82387},{\"end\":82409,\"start\":82398},{\"end\":82419,\"start\":82409},{\"end\":82427,\"start\":82419}]", "bib_venue": "[{\"end\":60670,\"start\":60646},{\"end\":60795,\"start\":60771},{\"end\":60914,\"start\":60896},{\"end\":61037,\"start\":61012},{\"end\":61177,\"start\":61147},{\"end\":61319,\"start\":61290},{\"end\":61457,\"start\":61428},{\"end\":61592,\"start\":61565},{\"end\":61739,\"start\":61696},{\"end\":61898,\"start\":61870},{\"end\":62036,\"start\":62011},{\"end\":62160,\"start\":62139},{\"end\":62287,\"start\":62266},{\"end\":62505,\"start\":62477},{\"end\":62732,\"start\":62704},{\"end\":62848,\"start\":62828},{\"end\":63047,\"start\":63022},{\"end\":63720,\"start\":63602},{\"end\":64374,\"start\":64273},{\"end\":64976,\"start\":64875},{\"end\":65473,\"start\":65469},{\"end\":65799,\"start\":65795},{\"end\":66029,\"start\":65995},{\"end\":66359,\"start\":66355},{\"end\":66743,\"start\":66739},{\"end\":67167,\"start\":67126},{\"end\":67533,\"start\":67453},{\"end\":67951,\"start\":67833},{\"end\":68652,\"start\":68572},{\"end\":69085,\"start\":69009},{\"end\":69405,\"start\":69401},{\"end\":69709,\"start\":69622},{\"end\":70305,\"start\":70187},{\"end\":70917,\"start\":70830},{\"end\":71416,\"start\":71359},{\"end\":71795,\"start\":71715},{\"end\":72139,\"start\":72126},{\"end\":72413,\"start\":72374},{\"end\":72864,\"start\":72781},{\"end\":73258,\"start\":73172},{\"end\":73895,\"start\":73812},{\"end\":74427,\"start\":74326},{\"end\":75061,\"start\":74981},{\"end\":75400,\"start\":75396},{\"end\":75700,\"start\":75696},{\"end\":76044,\"start\":76040},{\"end\":76335,\"start\":76287},{\"end\":76573,\"start\":76541},{\"end\":76872,\"start\":76761},{\"end\":77550,\"start\":77470},{\"end\":77983,\"start\":77912},{\"end\":78298,\"start\":78294},{\"end\":78711,\"start\":78617},{\"end\":79297,\"start\":79274},{\"end\":79568,\"start\":79486},{\"end\":79996,\"start\":79909},{\"end\":80632,\"start\":80526},{\"end\":81256,\"start\":81168},{\"end\":81809,\"start\":81726},{\"end\":82445,\"start\":82441},{\"end\":63842,\"start\":63722},{\"end\":64479,\"start\":64376},{\"end\":65081,\"start\":64978},{\"end\":68073,\"start\":67953},{\"end\":69800,\"start\":69711},{\"end\":70427,\"start\":70307},{\"end\":71010,\"start\":70919},{\"end\":72467,\"start\":72430},{\"end\":73355,\"start\":73260},{\"end\":74532,\"start\":74429},{\"end\":76987,\"start\":76874},{\"end\":78809,\"start\":78713},{\"end\":79307,\"start\":79299},{\"end\":79587,\"start\":79570},{\"end\":80087,\"start\":79998},{\"end\":80742,\"start\":80634},{\"end\":81350,\"start\":81258}]"}}}, "year": 2023, "month": 12, "day": 17}