{"id": 54193823, "updated": "2023-10-06 08:42:02.407", "metadata": {"title": "Inviwo - A Visualization System with Usage Abstraction Levels", "authors": "[{\"first\":\"Daniel\",\"last\":\"Jonsson\",\"middle\":[]},{\"first\":\"Peter\",\"last\":\"Steneteg\",\"middle\":[]},{\"first\":\"Erik\",\"last\":\"Sund'en\",\"middle\":[]},{\"first\":\"Rickard\",\"last\":\"Englund\",\"middle\":[]},{\"first\":\"Sathish\",\"last\":\"Kottravel\",\"middle\":[]},{\"first\":\"Martin\",\"last\":\"Falk\",\"middle\":[]},{\"first\":\"Anders\",\"last\":\"Ynnerman\",\"middle\":[]},{\"first\":\"Ingrid\",\"last\":\"Hotz\",\"middle\":[]},{\"first\":\"Timo\",\"last\":\"Ropinski\",\"middle\":[]}]", "venue": "ArXiv", "journal": "ArXiv", "publication_date": {"year": 2018, "month": 11, "day": 29}, "abstract": "The complexity of today's visualization applications demands specific visualization systems tailored for the development of these applications. Frequently, such systems utilize levels of abstraction to improve the application development process, for instance by providing a data flow network editor. Unfortunately, these abstractions result in several issues, which need to be circumvented through an abstraction-centered system design. Often, a high level of abstraction hides low level details, which makes it difficult to directly access the underlying computing platform, which would be important to achieve an optimal performance. Therefore, we propose a layer structure developed for modern and sustainable visualization systems allowing developers to interact with all contained abstraction levels. We refer to this interaction capabilities as usage abstraction levels, since we target application developers with various levels of experience. We formulate the requirements for such a system, derive the desired architecture, and present how the concepts have been exemplary realized within the Inviwo visualization system. Furthermore, we address several specific challenges that arise during the realization of such a layered architecture, such as communication between different computing platforms, performance centered encapsulation, as well as layer-independent development by supporting cross layer documentation and debugging capabilities.", "fields_of_study": "[\"Computer Science\"]", "external_ids": {"arxiv": "1811.12517", "mag": "2963955312", "acl": null, "pubmed": "31180858", "pubmedcentral": null, "dblp": "journals/tvcg/JonssonSSEKFYHR20", "doi": "10.1109/tvcg.2019.2920639"}}, "content": {"source": {"pdf_hash": "f883d091e60e810ed69b3cf91ae17a8b6ef2ef57", "pdf_src": "Arxiv", "pdf_uri": "[\"https://arxiv.org/pdf/1811.12517v1.pdf\"]", "oa_url_match": false, "oa_info": {"license": null, "open_access_url": "http://liu.diva-portal.org/smash/get/diva2:1360056/FULLTEXT01", "status": "GREEN"}}, "grobid": {"id": "5a9bea65d6f6a45686898ae6cfe455681a2784a1", "type": "plain-text", "url": "s3://ai2-s2-pdf-extraction-prod/parse-results/s2orc_worker/f883d091e60e810ed69b3cf91ae17a8b6ef2ef57.txt", "contents": "\nInviwo -A Visualization System with Usage Abstraction Levels\n\n\nDaniel J\u00f6nsson \nPeter Steneteg \nErik Sund\u00e9n \nRickard Englund \nSathish Kottravel \nMartin Falk \nAnders Ynnerman \nIngrid Hotz \nTimo Ropinski \nInviwo -A Visualization System with Usage Abstraction Levels\nIndex Terms-Visualization systems\nThe complexity of todays visualization applications demands specific visualization systems tailored for the development of these applications. Frequently, such systems utilize levels of abstraction to improve the application development process, for instance by providing a data flow network editor. Unfortunately, these abstractions result in several issues, which need to be circumvented through an abstraction-centered system design. Often, a high level of abstraction hides low level details, which makes it difficult to directly access the underlying computing platform, which would be important to achieve an optimal performance. Therefore, we propose a layer structure developed for modern and sustainable visualization systems allowing developers to interact with all contained abstraction levels. We refer to this interaction capabilities as usage abstraction levels, since we target application developers with various levels of experience. We formulate the requirements for such a system, derive the desired architecture, and present how the concepts have been exemplary realized within the Inviwo visualization system. Furthermore, we address several specific challenges that arise during the realization of such a layered architecture, such as communication between different computing platforms, performance centered encapsulation, as well as layer-independent development by supporting cross layer documentation and debugging capabilities.\n\nINTRODUCTION\n\nThe field of visualization is maturing, and a shift can be observed from algorithm-centric research to application-centric research. While in previous years research has focused on novel visualization methods and algorithms for a particular data type, e.g., volume rendering [29], line integral convolution [9], or tensor glyphs [31], today visualization research also puts emphasis on the solution of specific applicationoriented visualization problems in a wide range of domains, e.g., in medical visualization [46], engineering sciences [10], biological visualization [36], or astronomy [6]. Visualization researchers are confronted with new challenges, as in most applications the interplay between different visualization algorithms and the integration of multiple data sources must be considered. Furthermore, data is typically large and heterogeneous. All these aspects make it challenging to develop interactive visualization applications that are applicable to real-world problems. Over the years, several efforts have been made to provide systems designed to ease the development of visualization applications. VTK [43] was one of the foundational frameworks for this purpose, enabling visualization application developers to load the data to be visualized and combine several building blocks into a visualization pipeline. Following the success of VTK, many visualization systems have been released to enable application-centric visualization research, e.g., VisTrails [3], VolumeShop [7], MeVisLab [37], VisIt [11], VA-POR [12], Voreen [38] and Amira [48]. While the capabilities of these systems vary, most of them make use of the popular separation of concerns design principle [42] by employing different layers of abstraction. Since the visualization pipeline can readily be modeled through data flow networks [39], many modern visualization systems expose the highest layer of abstraction as a data flow network editor to the application developer, e.g., VisTrails [3], MeVisLab [37] or Voreen [38]. This layered architecture approach has been proven successful, but it also comes with a few downsides, which could potentially hamper the \u2022 D. J\u00f6nsson visualization application development process. It can first be observed that visualization application developers have varying needs. Exposing the highest layer of abstraction is often not enough to facilitate the development of complex visualization applications, as in many scenarios it becomes necessary to modify functionality rooted at different levels of abstraction. For instance, besides modifying the data flow network a developer might also want to change the C++ or computing platform specific code for a particular building block. As data flow network editors support rapid development, i.e., the influence of made changes can be directly seen in the visualization, such a development paradigm is also desired at the lower levels of abstraction. Furthermore, as a consequence of such changes, it also becomes necessary to debug and document at these levels. We refer to the possibility to change, debug, test and document functionality at different abstraction layers to cross-layer development, We regard our realization of this concept as one of the two main contributions of this system paper.\n\nA fundamental problem in the layer abstraction used by modern visualization systems is related to the underlying hardware used. While it is undisputed that modern visualization applications should be interactive [51], the size and complexity of data often makes it challenging to maintain interactive frame rates. To deal with this challenge, the ever increasing capabilities of graphics processing units (GPUs) is exploited [52], and consequently most current visualization systems, e.g., VisTrails [3], VolumeShop [7], MeVisLab [37], VAPOR [12], Voreen [38] and Amira [48], rely on the GPU for both data processing and rendering. This is often done by interfacing with computing platforms, such as OpenCL, CUDA or OpenGL, from within the lowest level of abstraction. While this allows for leveraging the power of modern GPUs, it also comes with the drawback that algorithms cannot be combined with new computing platforms, e.g., an algorithm developed for OpenCL cannot directly be used with an algorithm developed for OpenGL. This is especially problematic when considering the fact that new computing platforms are released rather frequently In this paper, we propose concepts enabling algorithms implemented for different computing platforms to be used together seamlessly. This computing platform interoperability is the second main contribution of this system paper.\n\nIn this paper we propose design principles, and their technical realizations, which support cross-layer development and computing platform interoperability in modern visualization systems. The proposed design principles have been developed and integrated into the Inviwo visualization system, which has been used to implement a range of visualization applications, e.g., volume data exploration [28], molecular Table 1. Comparison of major visualizations systems with respect to seamless combination of algorithms implemented on different computing platforms and the support for cross-layer development.\n\nInviwo MeVisLab [37] Amira [48] ParaView [2] VisIt [11] VisTrails [3] License  BSD  Commercial  Commercial  BSD  BSD  GNU GPL v2  Integrated computing platform interoperability  \u2022  -----C++  \u2022  \u2022  ---NA  Interactive development  Shaders  \u2022  \u2022  \u2022  ---Visual debugging  \u2022  \u2022  ----Integrated documentation  \u2022  ----\u2022  Visualization pipeline testing  \u2022  \u2022  \u2022  \u2022  \u2022  \u2022 visualization [32], and material science [34]. The proposed concepts are in themselves a contribution beyond the Inviwo system. As visualization systems with cross-layer development and integrated computing platform interoperability will make it possible to use the same system during the entire visualization application development process and gracefully adapt to the introduction of new computing platforms, we foresee that other system developers will find our principles and realization approaches useful.\n\n\nRELATED WORK\n\nHere, we provide a comprehensive comparison between visualization systems and game engines with respect to their computing platform interoperability capabilities and usage abstraction layers for visualization application development. Visualization systems. The Visualization Toolkit (VTK) by Schroeder et al. [43] is a C++ framework for creating visualizations and therefore requires several usage abstraction levels to be built on top of the framework for it to be accessible to visualization practitioners. More recently, VTK-m [40] has been developed to better support parallel architectures. Unlike the approach taken in this work, VTK-m provide an abstraction preventing access to the underlying computing platforms. Since VTK and VTK-m are lower abstraction level frameworks, they can be integrated into Inviwo and thereby benefit from its usage abstraction levels.\n\nExamples of systems providing usage abstraction levels are Par-aView [2], VisTrails [3], VisIt [11] and tomviz [24]. Since VTK does not have integrated computing platform interoperability, the systems building on this API do not have this property either. Similar to Inviwo, ParaView and VisTrails are general platforms that do not target a specific domain or type of data. Out of these, ParaView uses a tree-view to represent the visualization pipeline while Inviwo and many others, e.g., MevisLab [37], Amira [48], VistTrails [3], and Voreen [38], uses an acyclic graph representation. VisIt [11] primarily targets parallel systems and streaming of data defined on 2D and 3D meshes, while tomviz [24] focuses on transmission electron microscope data.\n\nThere are also many general systems that are not based on VTK. Amira [48] and MeVisLab [37] are commercial systems targeting life sciences. Another commercial system is AVS Express [1], but it does not target a specific domain. Voreen [38] was designed for volume rendering and has OpenGL built into its core, which currently prevent it from integrating computing platform interoperability. Forbes et al. [21] introduced a Java-based framework designed for dynamic data by explicitly separating processing into three interconnected graphs. Their graphs involve scene graph logics, data processing and timing operations for interaction and animation. The work by Forbes et al. [21] can be seen as orthogonal to the concepts presented here since they could be used together as an additional usage abstraction level with respect to scene graph logics and timing operations. A range of systems are more specialized, such as FAnToM [8], focusing on topological analysis, VAPOR [12], focusing on data from earth and space sciences and VolumeShop [7], focusing on illustrative visualization of volume data. While most of these systems support multiple computing platforms, none of them allow algorithms implemented for different computing platforms to be seamlessly combined.\n\nVisualization systems comparison. In the following, we will compare several major visualization systems with respect to their computing platform interoperability support and cross-layer development capabilities. The ones selected for comparison, seen in Table 1, are actively developed and support the whole visualization design process. Four concepts were considered when it comes to cross-layer development, being able to develop multiple layers of abstraction at runtime, visual debugging of the data flow network, co-locating code and documentation for higher abstraction layers and testing at functional and visualization pipeline levels, i.e., unit and visualization integration and regression testing.\n\nAs seen in Table 1, many systems have support for multiple computing platforms but only Inviwo has a concept for seamlessly combining algorithms written for different computing platforms. Multiple systems have support for interactive shader editing (Amira, Inviwo, MeVisLab), i.e., changing them at runtime, while only a few provide means for interactively developing algorithms (Inviwo, MeVisLab).\n\nIn the software development process, debugging involves locating, identifying, and correcting a defect [22]. Debugging therefore involves everything from printing variables to the console to stepping through code to see where logical errors are made. In the field of information visualization, Hoffswell et al. [25] presented techniques for debugging reactive data visualizations. Hoffswell et al. focus on showing the state and interaction logic over time as the user interacts with a visualization. Their techniques can be seen as orthogonal to the ones presented in this work, where the focus is on the debugging process of algorithms and not the the interaction logic. Debugging of visualization pipelines is supported by Inviwo and MeVisLab. However, the approach in MeVis-Lab is slightly different. While Inviwo uses visualization pipelines to provide information co-located with the port location, MeVisLab displays the information in a separate pane.\n\nWhen it comes to documentation of higher abstraction level components, i.e., processors and modules, it is most common to provide it in separate files. For example, MeVisLab requires a .mhelp file for describing fields in their modules. Here, Inviwo and VisTrails stand out. VisTrails allows developers to specify documentation in code for their modules (their equivalent to processor) and ports separately, while Inviwo co-locates this documentation for multiple usage abstraction levels. All of the systems in the comparison provide testing capabilities for both individual functions as well as on visualization pipeline level. The main difference is on how easy it is to add the tests. Here, we believe that the minimal requirement in Inviwo for adding regression tests, e.g., a workspace with its resulting image(s), can lower the threshold for providing such tests. A final note is that all visualization systems included in the comparison supports use of scripting languages, such as Python or Tcl.\n\nGame engines, such as Unity [50] and Unreal Engine [18], have lately become viable options for building visualization systems. They provide support for multiple computing platforms but do not allow developers to access to them. Sicat et al. [44] presented a toolkit based on Unity for creating immersive visualizations. However, compared to Inviwo their toolkit do not provide usage abstraction levels for editing visualization pipelines. In general, the visual debugging support of game engines is more focused on the needs of game developers and not on visualization pipelines. Furthermore, the game engines' focus on game developers can limit their use for practical visualization problems. For example, Unity pre-processes meshes to optimize them for rendering, which might not be desirable for scientific visualization purposes.\n\n\nSYSTEM REQUIREMENTS\n\nVisualization systems commonly use multiple layers of abstraction to realize an abstraction-centered design. As illustrated in Fig. 1, the top abstraction layer is the visualization pipeline, which act as a layer of abstraction for processor composites, i.e., a group of functional units processing data flowing in the visualization pipeline. Each processor is in turn acting as an abstraction layer for C++ code. The lowest abstraction layer provides computing platform level access. Having multiple layers of abstraction poses several challenges that we address in this paper. Foremost, how can a cross-layer development process be provided, where the developer can use concepts from low abstraction layers, i.e., debugging and testing, on the higher abstraction layers. Also, which parts of the lower abstraction layers should be exposed on higher levels. Critical aspects that we consider here are performance and development speed, it must be ensured that the access across abstraction layers does not hamper performance and that it helps in creating tailored visualization applications. Another challenge is communication within the computing platform layer, for example how to deal with the number computing platform combinations possible.\n\nApplication oriented research requires a new level of engineering and our aim is to supply a sustainable system that aids researchers in all stages of the visualization application design process. We first describe the requirements for the usage abstraction levels and then the computing platform interoperability.\n\nA requirement for visualization systems with usage abstraction levels is that they support rapid development at all levels ranging from application tailoring to computing platform coding. From a developer's perspective, this process involves coding, debugging, documenting and testing. Thus, the system should support interactive C++ coding, shader editing and debugging of data flow networks. Documentation of algorithms is read by other developers and visualization composers, meaning that both groups must have access to it on the level they are using the system. Testing must be supported on both algorithm and visualization pipeline levels. From a visualization composer's perspective, the system must support visual creation and editing of visualization pipelines as well as the possibility to create a tailored visualization application.\n\nInteraction is key in visualization systems. A computing platform interoperable visualization system must therefore provide access to native computing platform capabilities to allow processing of large and complex data at interactive frame rates. In addition, research is commonly at the forefront of technology usage, which means that a visualization system used for research cannot abstract away access to computing platforms. Thus, such a system must instead provide access to the lowest technical layer. For algorithms to remain portable across computing platforms, the system must provide ways of seamlessly converting data between computing platforms, i.e., transfer data between memory locations. While it is possible to manually convert data from one computing platform to another one, it requires knowledge about both computing platforms, and thus does not scale when later introducing new computing platforms. Furthermore, since this is a traveling salesman problem where the highest performance path from one computing platform to another one must be found, it is not feasible to solve this combinatorial problem manually even for a small number of computing platforms. To make things more complicated, different computing platforms also have support for different types of specialized data, such as buffers or textures. Mapping between different types of data occurring in different computing platforms is therefore an additional challenge that needs to be considered.\n\nConcepts addressing the requirements above are presented in the following two sections.\n\n\nUSAGE ABSTRACTION LEVELS\n\nSupporting interactive coding, shader editing and debugging requires a system allowing development to be performed across layers of abstraction. This section will define key concepts for such a system meeting the previously presented requirements. First, we describe ways of achieving interactive development. This is followed by three concepts enabling cross-layer development in terms of debugging, documenting and testing.\n\n\nInteractive Development\n\nHigh level development means using a visual representation for creating and changing visualization pipelines. In order to allow simultaneous high level editing and low-level C++ coding, the system must recompile and reload the changed parts while the visual editor is running. This concept must be realized through a modular system design, i.e., a plugin system where dynamic libraries can be unloaded and loaded again to reflect the changes made. Medium usage abstraction level editing, i.e., modifying shaders used by computing platforms, or scripting, can be performed at runtime without unloading or loading dynamic libraries. Thus, interactive development at this level can be realized through either providing a user interface for recompiling the source code or observing the sources of origin, e.g., text files, and automatically recompile the source code when it changes. While the presented interactive development concept is seemingly simple, it allows the user to access multiple layers of abstraction at the same time and thus address the rapid development requirements of the system.\n\n\nVisual Data Flow Debugging\n\nDebugging parallel operations is difficult since there are many outputs occurring at the same time. Readily available debugging tools can help developers by allowing the execution of a given thread to be inspected. Inspecting one thread at a time can be tedious and is most effective when the error has been narrowed down to a specific part in the code. Visually inspecting output of parallel operations can help the developer to quickly obtain an overview and thereby identify the source of an error. This can be seen as debugging on a higher level of abstraction, giving quick access to information at lower abstraction layers.\n\nThis cross-layer debugging is provided by a concept we refer to as port inspection. A port inspector allows the contents of a processor's port to be viewed. By applying this concept in the visualization pipeline editor, it allows for step-by-step debugging of the data-flow network. For example, hovering or clicking on ports, or their connections, shows debug information about data originating from their associated outport. We can not only inspect data on a higher abstraction level, we can also create the debugging information on a high level. For this purpose, we propose to use a visualization pipeline to provide the debugging information for a particular port type. For example, a volume data port, containing a stack of images, can use a predefined visualization pipeline for slice-based inspection. Thus, the presented concept enables cross-layer visual debugging of data flow networks.\n\n\nDocumentation\n\nAPI documentation is more or less standardized nowadays using for example the Doxygen system. However, this documentation is intended for developers and is not readily available for visualization pipeline editors. Providing documentation at the visualization pipeline editor level can be done in a wide variety of ways. For example, by presenting documentation written in separate files, such as xml, or html. While this makes it possible to use tools suited for text and layout, it also makes it harder to maintain and follow from a developer's perspective. For systems where low maintenance overhead and ease of use is important, we suggest to integrate this documentation procedure into the API documentation. This allows developers to write documentation once but show it in both API-documentation and to visualization pipeline editor users.\n\nWhile developers are used to textual documentation, pipeline editors often desire richer information. Thus, the documentation must be presented appropriately at the different usage abstraction levels. In practice, our concept involves extracting the documentation of processors from the source code and augmenting it with the visual representation used in the higher abstraction layer. The augmented visual representation of the processor contextualizes the documentation and can be generated automatically since they are already used in the higher abstraction layer.\n\nThe documentation concept described above not only makes it easy to maintain, due to its co-location with the actual code, but also provides information on how to use a processor at multiple usage abstraction levels and thereby address the system requirements.\n\n\nTesting\n\nUnit testing is commonly used for testing low abstraction level code, but can also be used for testing an entire visualization pipeline. However, unit testing requires programming skills and therefore cannot be created in the higher usage level abstraction.\n\nOur testing concept allows tests of visualization pipelines to be created on a high usage abstraction level, i.e., through the visualization pipeline GUI editor. Once the visualization pipeline to be tested has been defined its results before and after a change can be compared. However, comparing results of a visualization pipeline presents challenges that our concept takes into account. Here, one approach is to generate reference results on demand, i.e., never store them, and compare the new results with the generated references each time a test is run. We have found this approach to be problematic due to two reasons. First, the results can vary between different hardware, but this, possibly incorrect behavior, will never be detected since the same hardware is used for generating reference and comparison images. Second, it can be resource demanding since it requires having, or building, multiple versions for generating the reference data. Thus, reference results should instead be generated once when the test is defined. To deal with the differences in results across hardwares we allow specification of an error threshold such that, in cases an investigation has found that this indeed is the cause of the error, the test can be allowed to pass.\n\nThe presented testing concept has addressed the challenge of exposing testing at a high usage abstraction level, and thus enables the system to support testing across layers of abstraction.\n\n\nCOMPUTING PLATFORM INTEROPERABILITY\n\nThe lowest abstraction layer in our system is data abstraction. This layer provides an interface for accessing data on a per computing platform basis without knowing about the other computing platforms, thus enabling developers to utilize platform specific features but still combine algorithms written for different computing platforms.\n\nDesigning a computing platform layer of abstraction requires considering both performance and sustainability. For example, the OpenGL computing platform has specialized data types for textures which must be taken into account to not loose performance. Therefore, we focus on creating a layer of abstraction for the data, not for all computing platforms. In other words, our concept allows developers to fully utilize the computing platforms on the premise that they request data for the computing platform they are utilizing. While this might seem like a too narrow abstraction, it is fitting to visualization pipelines since they operate on data flows and each processor is in this way isolated from the other ones. This abstraction layer must provide a common interface for data objects flowing in the visualization pipeline. One way of providing such an abstraction is to disallow direct usage of the underlying computing platform memory location and instead provide a wrapper exposing common functionality, similar to how for example the Java programming language operates. Clearly, this prevents developers from using computing platform specific features. Another alternative is to provide an interface for requesting the data for the desired computing platform. Given that data can be transferred to the requested computing platform, it means that the developer only needs to know about the computing platform for which data is requested for. The downsides of this approach are a more complicated data interface for developers, due to the abstraction, and that data might need to be transferred when used by different algorithms.\n\nOur design consists of a general data interface exposing functions for requesting data for arbitrary computing platforms. Examples of data types utilizing this interface are buffers, images and volumes. Succinctly, the computing platform data representation is simply referred to as representation. The three most important objects of importance in our design are illustrated in Fig. 2 for volume data. In this figure the data interface provides an abstraction for data access, the representation manages the data, and the converter transfers data between different computing platforms. A representation is created lazily upon request. However, once requested it is cached in order to reduce the number of data transfers necessary. As the representations are typically not on the same device, i.e., RAM and video memory, caching is in general a good trade-off. A list of used representations by the data object must be stored. It is necessary to know which representations in the list that are up to date. For this purpose, a representation must be requested with either read or write access. Write access means that other representations must be updated from this representation when requested. The observant reader has identified two types of representation operations, one for creation and one for updating. It is desirable to separate these two operations since creation is generally slower than updating. Therefore, the only two tasks of a converter is to create or update a representation from another one.\n\nIn practice, computing platforms such as OpenGL and OpenCL have special data object types for which hardware accelerated operations are supported. These need to be considered to obtain interactive frame rates. Based on currently existing hardware we have identified three types of fundamental data objects. Buffers, which can store arbitrary data, 2D textures storing image data and 3D textures storing volume data. This separation ensures that hardware accelerated filtering operations can \n\n\nBase\n\nOpenGL Python\n\nVector Field Visualization (GL)\n\n\nBaseGL\n\nBrushing And Linking \u2026 \u2026 \u2026\n\nNetwork Editor Brain Visualization \u2026 \u2026 \u2026 Fig. 3. The Inviwo architecture is divided into three main components.\n\nThe core provides, for example, processor network functionality, saving/loading mechanisms, and interfaces for extending the framework. Modules bring in new functionality using the interfaces and factories provided in core, or by exposing external libraries. Applications expose the processor network in various ways, for example using graphical interfaces for editing the network or tailored design for brain activity visualization.\n\nbe utilized on GPU computing platforms. Moreover, while the computing platforms have evolved, these underlying types have remained the same and due to their ubiquitous usage it is not likely that they will be removed in the near future when new hardware is developed. Each of these fundamental types requires one converter per combination of computing platform. In order to form an optimal conversion path when requesting data, all combinations between the existing computing platforms must be considered. Thus, it quickly becomes unfeasible to manually implement all possible converter combinations. This challenge is addressed by algorithmically creating converter packages from the individual converters provided by the developers. One such package contains a path to transfer data from one representation to another. These packages can be sorted in order of performance and be selected at runtime. In practice, this algorithmic converter path creation means that a developer only has to implement one converter between the new and an existing representation for it to function. Specifying more data transfer combinations can increase performance, such as in the case of shared data. More complex data structures, such as meshes containing buffers of vertices and other attributes, can utilize the fundamental types provided as building blocks and thereby gain the same properties. The presented concept improves the sustainability of a visualization system while still allowing access to native computing platform capabilities. The presented usage abstraction levels and computing platform interoperability concepts have been implemented in Inviwo. Details of these implementations are provided in the following section.\n\n\nREALIZATION IN THE INVIWO FRAMEWORK\n\nThe previously described concepts have been implemented in the Inviwo system. We will first provide an overview of Inviwo and describe how its different parts relate to these concepts. Then, we will discuss how the usage level abstractions and computing platform interoperability are realized in Inviwo.\n\nInviwo can be divided into three main components illustrated in Fig. 3. First is the core, containing functionality for evaluating a dataflow network, fundamental data structures, such as images, volumes and meshes, as well as interfaces and factories for adding additional functionality. The core has no dependencies on any GPU platform but provides the foundation for computing platform communication.  Second is the module system, which is used to extend the core with new functionality at runtime in a plug-in based manner. A new module can, for example, add support for data readers, computing platforms or new visualization algorithms. Third is the visual editor in which visualization pipelines can be created, parameters can be tuned and scripting can be edited. The visual editor provides access across the layers of abstraction and supports interactive C++ coding, scripting and shader editing. It has two modes, developer and application modes. The developer mode allows data flow creation as well as parameter editing, while the application mode hides the data flow network and only shows a subset of parameters determined in the developer mode. Thus, a tailored visualization application can quickly be created.\n\nThe following sub sections will first provide a brief overview of Inviwo, then describe how the usage abstraction levels are implemented followed by the details on how algorithm interoperability is achieved.\n\n\nInviwo Overview\n\nInviwo is built around a central concept of a data flow graph where each node in the graph represents an functional unit. The edges in the graph represent data flowing into and out of the functional units. A functional unit, its input and output data and its parameters are encapsulated by a processor. A processor has inports, encapsulating the input data, outports, encapsulating the output data, and properties, encapsulating parameters. Guidelines for how to best encapsulate a functional unit into a processor are provided in the appendix of this paper. A group of processors can be combined in the form of a processor composite and thus provide an abstraction for a more complex task. The graph of connected processors and processor composites is referred as the processor network, which is equivalent to a visualization pipeline.\n\nData can be raw data in memory, geometries, volumes, images, data frames or any other arbitrary data structure. Note that while the types provided by Inviwo generally use the data interface presented in Section 5, there is no such requirement on the port data. This means that data types in external libraries can easily be integrated and benefit from the usage abstraction levels, even though they will not gain the computing platform interoperability of the data types provided by Inviwo. Figure 4 shows the visual representation used for a processor and its components. The processor itself is represented by a box, where input data is flowing from the top into the inports and the output data is exiting in the bottom through the outport. A processor is evaluated when all its inports, and at least one outport, are connected. The low abstraction layer concept of function overloading in programming is captured using optional inports, which do not need to be connected for the processor to evaluate.\n\n\nUsage Abstractions For Interactive Development\n\nThe implementations of interactive development in Inviwo can be categorized into three usage abstraction level categories. The high usage abstraction level is based on graphical interfaces, the medium usage abstraction level contains scripting and shader editing while the lowest usage abstraction level is based on C++ coding. Next, we describe   5. Screenshot of the Inviwo network editor for rapid visualization pipeline creation. The processor network in the center loads and visualizes the charge density of the chemical boron element. New processors can be dragged from the processor list and dropped into the processor network, where a visual representation of the processor and its components will be shown. Pipelines are created by connecting processor ports in the network. Properties exposed by the selected processor are automatically shown in the property list to the right.\n\nhow the developer can move between these categories and achieve interactive development in Inviwo.\n\n\nHigh Usage Abstraction Level Editing\n\nVisualization pipeline abstraction level editing is performed in the processor network editor (network editor), seen in Figure 5. The network editor is an application for visually building, editing, debugging and running processor networks. It is a key component as it provides means for cross-layer development by allowing the developer to seamlessly move between visually editing the visualization pipeline, scripting in Python and coding in C++.\n\nThe network editor uses the drag-and-drop metaphor to include processors in the network. Processors added by modules can be selected from a list and dropped into the processor network, whereby a graphical element, exemplified in Figure 4, is created to represent the selected processor in the network. Its inports and outports are displayed as colored squares laid out in rows at the top and the bottom of the element, respectively. The color of the ports reflect the type of data they manage. Images are blue, volumes are red and meshes are yellow.\n\nThe network is automatically evaluated while building the pipeline and the results can be inspected either in a canvas or through visual debugging (see Section 6.2). Selecting a processor in the network shows graphical user interfaces (GUIs) for editing all of its properties, see the Property List in Figure 5. The same property type can have different visual representations, which we refer to as property semantics. For example, four floating point values can be represented by four sliders or as a color. The property semantics can be set at different usage abstraction levels, i.e., in code or visually using the property's context menu. Multiple processors can be aggregated into one processor, which thereby enable high usage abstraction level access to the third layer of abstraction, processor composites.\n\nProperties in the network can be linked (synchronized) between processors in a similar, but orthogonal, way to connections between ports. A dotted line between link connectors of two processors indicate that one or more of their properties are linked.\n\nThis high usage abstraction level editing enables interactive development of a visualization pipeline. However, the network editor also integrates with the medium and low usage level abstractions as described next.\n\n\nMedium Usage Abstraction Level Editing\n\nInviwo has integrated support for the widely used Python scripting language. The Python integration in Inviwo can be used in several ways. Firstly, it is possible to perform batch processing using an integrated Python editor in the processor network editor. As an example, camera parameters can be scripted for performance benchmarking. The integrated Python editor thereby enables the developer to seamlessly move between the high and medium usage abstraction levels. Secondly, data can be transfered back and forth to Python for computations within a processor. This is particularly valuable due to the rich data processing capabilities in Python, but also means that algorithms available in Inviwo can be used in Python. The Python data transfer is typically used within a processor, but the script can be exposed through a property which thus enables high usage abstraction level editing. Third, a processor and its processing can be defined entirely in Python. This is advantageous for developers more comfortable with Python, and of course inherits the benefits of working with a scripting language while still taking advantage of the usage abstraction level concepts in Inviwo. Finally, we point out that Python is still integrated through a module, i.e., it is not included and Inviwo core, which demonstrates the modularity of Inviwo.\n\nInteractive shader editing in the network editor is also supported by observing all shader files. Saving a shader file will notify the network editor, which will invalidate the processor network, causing it to update the output. Similiar to Python scripting, some processors also expose shaders through properties. Changing a shader in this case invalidates the property, which also causes the processor network to update.\n\n\nLow Usage Abstraction Level Editing\n\nThe Inviwo system is based on a modular structure, which is the foundation for achieving interactive development. All modules depend on the core and, in addition, they can depend on other modules or external libraries, see Fig. 3. Dependencies on external libraries occur when integrating their functionality into Inviwo. The module system allows new functionality to be included without introducing any dependencies into the core system. For example, the OpenGL module adds OpenGL computing platform support to the Inviwo system. Other modules can depend on the OpenGL module to build on those capabilities. Inviwo takes care of managing the dependencies between the different modules. When possible, external library source code should be brought into the build system to ensure version compatibility in deployed applications.\n\nInteractive coding is enabled by allowing modules to be loaded at runtime when they change, also known as hot reloading. The network editor observes all module shared library files for change, meaning that the developer can recompile the module while the application is running and immediately see the effects of the change. The processor network is Fig. 6. Example of visual debugging of a visualization pipeline. In this instance, a port inspector shows the rendered color layer, the picking buffer, and the contents of the depth buffer. Details, such as data format and dimension are, displayed below the images. serialized, modules are reloaded, and the network is deserialized again. It should be noted that the developer has the responsibility to ensure that a module can be unloaded and loaded repeatedly, for example by not making breaking API changes, as the system cannot regulate this. A module version system ensures that modules of correct version are loaded at runtime. Modules are only loaded if they are linked to the correct Inviwo core version used by the application. Thus, it is only necessary to bump the module version if the module is released in between Inviwo core releases. This version dependency means that module developers rarely need to care about the module version.\n\nIn essence, the presented interactive development implementation allows developers to rapidly move between a low usage abstraction level, i.e., editing the code, and a high usage abstraction level, i.e., visually editing the visualization pipeline.\n\n\nVisual Debugging\n\nInviwo provides port inspectors based on processor networks for three types: meshes, images and volumes. Modules can add more port inspectors if desired. Events are forwarded to port inspectors meaning that interaction is possible. As an example, the volume port inspector, showing a series of slices, allows for changing the current slice using the scroll wheel of a mouse. Since the pipelines created for port inspection by design are computing platform interoperable, it is possible to use the port inspectors on data residing in another computing platform's memory.\n\nCreating an entire processor network for less commonly used port types can be to high of a threshold. Inviwo therefore also allows port debug information to be created using C++ template traits for the port type. The port template trait output debug text, expected in HTMLformat, will be displayed together with the results of the data flow port inspection, if existing. This enables visual debugging information to be created at both low and high usage abstraction levels. Figure 6 depicts the inspection of an image port as realized in the Inviwo system. It shows the output images generated or forwarded by the respective processor, including additional information such as image format and dimension. A default implementation for ports displays the name of the port, meaning that the port inspection can be applied to all ports and port connections without any efforts from a developer.\n\n\nTwo-Level Documentation\n\nInviwo implements the documentation concept combining low level API-documentation and high level documentation in the network editor using the Doxygen system. The Doxygen docpage command is used in the header file of the processor, thus co-locating the documentation for developers and visualization editor users. Each docpage provides descriptions of how to use the processor, its inports, outports and parameters. In practice, we use Markdown language for this purpose, since it is supported by Doxygen and thereby provides a rich way for describing the module. The documentation itself is generated at compile time using a separate compile target. The processor identifier, which is a unique identifier available in all processors, is used to provide a connection between the documentation and the processor. This makes it possible to also automatically generate images of the visual representation of each processor. These images provide a contextual overview of the processors in the documentation. An example of API and end user documentation based on the same comments can be seen in Figure 7. In order to reduce copy-paste errors, and to make it quick and easy to create as well as document a processor, boiler plate processor code can be generated through a python script.\n\n\nCross-Layer Testing\n\nThe Inviwo system tries to make it as easy as possible for developers to create tests across the layers of abstraction, i.e, code and entire processor networks. For example, the tests made for Inviwo can run on the developer's machine, they do not require a separate testing machine. The system currently provides two means for testing, unit tests, which focus on testing each element of the code, and regression tests, which focus on testing integration between processors, i.e., the top abstraction layer described in Section 4.4.\n\nModule developers can add tests by creating a folder called \"tests\" in their module directory and putting unit tests in sub-folder \"unittests\" and regression tests in sub-folder \"regression\". All tests organized according to this structure will automatically be added by the framework. Further details about the two types of testing is provided below.\n\n\nUnit Testing\n\nInviwo relies heavily on Google Test [53] for its unit testing and, instead of providing its own unit testing framework, tries to provide a smooth integration. The unit tests are performed on a per-module basis. As mentioned above, all files having cpp file-ending residing inside the unit testing folder of the module are automatically considered. Each test source file can include one or multiple tests. By default, unit testing of all modules is included in the build process of the system. This means that the tests are run after a successful build and output information about the tests is shown in the integrated developer environment (IDE). Unit tests can also be run individually if desired.\n\n\nRegression Testing\n\nWhile writing unit tests for each individual unit of code ensure correctness of the unit, it does not necessarily test its integration with other units. Regression tests in Inviwo execute a whole network and compare its output with a result deemed correct. Creating a regression test is therefore only a matter of saving the output in the processor network, commonly the canvas images, along with the workspace containing the network. Future changes producing a different output will fail the regression test. Thus, this is a quick and easy way of detecting if code changes have an undesirable effect on the output of existing algorithms. While this approach does not tell exactly which unit of code caused the failure, it does tell which code changes that did. From experience, we have found that GPU hardware might produce small numerical differences depending on driver version or manufacturer. To resolve this, the developer can configure the regression test error threshold per output. Note that allowing errors should be used with caution and only after thorough investigation.\n\nPython scripts can be used to simulate interaction or other runtime changes. All Python scripts in the folder of the regression test will be executed after loading the network, meaning that all functionality exposed through the Inviwo Python integration can be utilized in a regression test. The Inviwo regression testing environment itself is setup using Python scripts. The Python scripts manage the execution of the tests and also generate a report in HTML. An example of a regression test report is depicted in Fig. 8. Besides details about the outcome of the tests, the report allows developers to see the difference between the result image and the reference image as well as analyzing performance measurements over time.\n\nRegression tests need to be executed on demand since they are too time-consuming to run as a build-step. Correctness and stability of the public repository code is ensured by utilizing a continuous integration server, which runs all tests before merging code changes.\n\n\nAlgorithm Interoperability\n\nInviwo has implemented the data interface described in Section 5 using template functions for retrieving representations. The returned representations are therefore strongly typed, which aids in the development process. Currently, CPU, OpenGL and OpenCL computing platforms are supported. We foresee that future heterogeneous computing platforms may integrate CPUs and GPUs into the same hardware. The data location will in this case be be shared among the different computing platforms. Inviwo system takes this scenario into account by allowing the underlying data to the shared among different computing platforms. Currently, Inviwo supports shared OpenGL and OpenCL buffers and textures. No data transfer is in this case necessary, since they reside at the same video memory location. There are a range of implementation aspects that need to be considered when using shared OpenCL representations. First, it requires that data has first been allocated in OpenGL. Thus, if data is located on RAM it must first be transfered to OpenGL before a shared OpenCL representation can be created. The algorithmically created converter packages described in Section 5 substantially reduces the implementation effort in this case. Second, OpenCL supports a limited subset of data formats compared to OpenGL. Lower versions of OpenCL do for example not support depth textures. Therefore, Inviwo currently throws errors when these unsupported formats are used. Ideally, they should be converted without errors even though performance might suffer, which can be seen as a future improvement for the system. The implemented computing platform converters makes Inviwo computing platform interoperable and allows current and future computing platforms to be used without changing existing implementations as required in Section 3.\n\n\nAPPLICATION EXAMPLES\n\nInviwo has successfully been used in numerous scientific publications within different application areas, commercial products, and universitylevel courses. The scientific contributions include work on advanced volumetric illumination [27,30,47], medical visualization [20,35], transfer function design for volume rendering [19,28], crowd-sourcingbased user studies [13,15,16], topological analysis [5,33], as well as multi-variate data and flow visualization [14,17,26]. In addition, Inviwo is to the best of our knowledge currently used by four different universities and two commercial companies.\n\nWe have selected four examples demonstrating usage of Inviwo at different usage abstraction levels as well as its computing platform interoperable capabilities. Admittedly, some of these concepts are hard to demonstrate since they are integrated in the development process. We start by demonstrating the core concepts in a fictitious example starting from importing data over adding additional functionality in shaders and processors to creating regression tests. Afterward, we continue with real-world examples including large scale pathology imaging, public brain visualization exhibition, and education.\n\n\nUsage Abstraction Level Work-Flow\n\nThis example demonstrates how the presented concepts are used in the process of creating a visualization. It starts on a high usage abstraction level, goes into medium and low usage abstraction levels before finishing with creating a visualization pipeline test. The reader is strongly encouraged to have a look at the video in the supplementary material which complements this textual description.\n\nIn order to create a volume rendering pipeline, the user starts by dragging and dropping a volume source processor set into the network editor and referring to a CT scan of a salmon. Next, three more processors are added to the pipeline; one for providing the bounding box geometry for the volume, one for generating entry and exit points for each pixel, and a volume raycaster. This processor renders the volume by considering the output of the other processors including the volume source. Finally, a canvas processor is added to show the resulting image. The volume data is then further explored by adjusting the transfer function. To quickly get an understanding of the data flow in the pipeline, the user hovers over the outports of each processor and thereby sees their content by means of the port inspector concept.\n\nIn the next step, the user wants clip the volume programmatically in the shader, which we refer to as medium usage abstraction level. The raycasting shader is extended accordingly and the changes are immediately propagated to the network after saving. The necessary parameters, i.e. a boolean flag and the spatial position of the clipping, are exposed via shader uniforms. On the low usage abstraction level, the user can now add matching properties to the C++ source of the volume raycaster processor. These properties are then used to set the uniforms in the shader. A recompilation of the code causes the network editor to reload the network, which demonstrates the interactive development possibilities even at the low usage abstraction levels. Moving back to high level editing in the network editor, the newly added properties are accessible in the property list and can be used to interactively adjust the clipped region.\n\nHigh and medium usage abstraction levels are exposed by the Python scripting integration. Here, the user decides to export each xy slice of the volume dataset individually which requires a script looping over all slices in the volume and writing the respective contents of the canvas to disk. To ensure that the results remain consistent despite future changes, a regression test is created by selecting create regression test in the menu. This demonstrates the ability to quickly create tests at high usage abstraction levels. The regression test is run locally and the resulting regression report is inspected.\n\n\nApplied Research Usage Example\n\nIn recent years, hospitals have started to digitize tissue samples on glass slides using scanners to obtain digital high-resolution color images of the samples [49]. Multiple digitized slide images of the same sample can be co-registered and combined into a single volume, thereby closely resembling the original block of tissue. The challenges associated with this kind of data include dealing with large amounts of image data, ways of interacting with this data, and the ability to look at the inside of the volume, i.e., the image stack.\n\nThe visualization of the image stack is based on brick-based volume raycasting [4], thus enabling large scale data handling of volumetric data within Inviwo. Inviwo provides a thread pool, which is used for on demand asynchronous loading of bricked image data. Image tiles are first loaded using the OpenSlide image library [23] and then uploaded into a 3D texture atlas. A volume, indicating the brick indices, is forwarded to the raycasting along with the texture atlas. The existing raycasting processor was extended in order to account for RGB image data instead of scalar values. A 2D transfer function based on color similarity [19] enables the user to adjust opacity as well as replacement colors, which could, e.g., be used for highlighting features. Fig. 9 shows an interactive rendering of 100 slide images as well as domain specific navigation. The TIFF jpeg compressed image data consumes about 100 GiB on disk and features details like individual nuclei. In order to address the challenges related to interacting with the stack of slide images, Inviwo provides a user interface, a minimap, and navigation widgets. The result is a tailored application that is used by a number of pathologists located at several hospitals and was evaluted in a user study with practising pathologists [20]. This scenario has demonstrated the ability to develop at both low and high abstraction layers in Inviwo as well as its capabilities in tailoring an application to domain scientists.\n\n\nPublic Dissemination Usage Example\n\nTaking research into public display, such as science centers and museums, poses different demands on a system compared to prototyping ideas for research. Stability, in case the application will be running all day, seven days a week, is a an even more important requirement. In addition, the application must be responsive and the user interface should be tailored to suit visitors without prior experience regarding the underlying algorithms [28].  10. Public exhibition of human brain activity depicting where active areas are located in the brain when performing different tasks. Fig. 10 depicts a brain visualization application where the entire user interface has been tailored for public use. The application visualizes where active areas in the brain are located while performing different tasks, such as wiggling toes or listening to music. It uses volume visualization techniques to fuse data from magnetic resonance imaging (MRI) and functional MRI, inspired by Nguyen et al. [41]. The graphical user interface communicates with the processor network driving the brain visualization. It uses the built-in processor network evaluation, touch interaction, and data management, while extending Inviwo with new modules for multi-modal volume visualization.\n\nIn this scenario, the work-flow for creating the application was as follows. In a first step, the visualization pipeline was set up in the network editor using readily available processors for loading MRI and fMRI neuroimaging data, data processing, and interaction. A new volume visualization processor was created for fusing the MRI and fMRI signals. Finally, Inviwo was used as an API in an application with a custom user interface, where the GUI elements were connected to the corresponding properties in the processor network using their identifiers.\n\nThe application has been running every day during opening hours since 2015 at one museum and one science center. A big advantage of this setup has been that the actual data processing, rendering, and interaction could be fully created and adjusted on a higher level of abstraction within the Inviwo network editor. This application scenario demonstrates the use of Inviwo at a low level, as an API, at a high level through the visual network editor, as well as its stability, responsiveness, and user interface flexibility.\n\n\nEducational Usage Example\n\nInviwo has been used as the underlying platform for a number of master thesis' and is currently being used in, to our knowledge, four courses on visualization. In these courses, the students are primarily using the system to get an in-depth understanding of visualization algorithms by implementing them, but also to explore how common visualization algorithms work in practice. VTK [43], Paraview [2] and VisTrails [3] have previously been used for two of these courses. From this experience, it was found that use of pure VTK imposed a steep learning curve and that the tree-view of data-flow in Paraview was hard for the students to understand with respect to how data is flowing in the visualization pipeline. VisTrails has succesfully been used for education [45] and provides a similar setup as Inviwo with respect to the visualization pipeline. However, VisTrails tends to expose many inports and outports per node/processor, which was confusing to the students. In Inviwo, the number of ports of processors are reduced by applying the processor creation guidelines presented in the appendix, which make it easier for new users of the system. The visual debugging concepts further help the students to understand the data flows and find errors in their implementations.\n\nAs a contrast to the courses targeting visualization, Inviwo is also used in a course for physics students on Bachelor level. The physics students design visualizations of electron structure simulation data for common tasks involving analysis of charge densities, molecular dynamics and crystal structures. They use both the Python scripting in Inviwo as well as the high level network editor to accomplish their goals.\n\nTo summarize, Inviwo has been used by hundreds of students to both get in-depth understanding of visualization algorithms and how to use them to understand data. The students use the system at all levels of abstraction.\n\n\nDISCUSSION AND CONCLUSIONS\n\nIn this paper we have described how to design a computing platform interoperable visualization system with usage abstraction levels through a layered architecture. The proposed computing platform interoperable solution allows algorithms developed for different computing platforms to be used together while still allowing developers to access the underlying computing platforms.\n\nWe presented several concepts for interactive development, debugging, documentation and testing across layers of abstraction. More specifically, the concepts allow tasks commonly performed by a developer at lower levels, i.e., debugging in IDEs, to be performed on a visualization pipeline level. While some of these concepts are found in other systems, we have formalized them and brought them together in one system. It is the combination of the presented concepts that enable tailored visualization applications to be rapidly developed. For example, since the system is computing platform interoperable, it is possible to design a port inspector using OpenGL and apply it to data residing in OpenCL. This also demonstrates the crucial success factor in view of the amount of work that goes into creating and maintaining advanced visualization systems.\n\nThe concepts were demonstrated in the Inviwo system along with accounts for implementation choices and technical details, such as use of shared computing platforms, that need to be considered when realizing the concepts. Naturally, not all details can be provided in a systems paper but a comprehensive account for technical aspects is available on the Inviwo website (www.inviwo.org), where the source code is also distributed freely under the BSD license.\n\nSeveral application examples, implemented using the Inviwo system, demonstrated the wide usage levels made available through the described concepts. It was shown that Inviwo meets the requirements and can be used throughout the whole visualization application design process, from writing functional units, through visualization pipeline editing, to tailored application creation.\n\nWhile the presented computing platform interoperable solution allows for high performance and novel utilization of each computing platform, it can also be seen as one of the limitations since algorithms will be designed for a specific computing platform and will have to be ported to devices not supporting them. For example, algorithms using OpenCL cannot run on mobile phones. The presented concepts have been designed and demonstrated for single-computer usage. An interesting direction for future work would be to take the demonstrated out-of-core concepts and extend them to distributed computing.\n\n( 2004 :\n2004OpenGL 2.0, 2006:DirectX 10, 2007:CUDA, 2008:OpenGL 3.0, 2009:OpenCL/DirectX 11, 2015:DirectX 12, 2016:Vulkan).\n\nFig. 1 .\n1Illustration of the layers of abstraction in our visualization system. The different layers of abstraction allow access to functionality for different usage levels and parts of the visualization application design process. As an example, our Python integration allows interactive development across layers through editing of the visualization pipeline or definition of new processors.\n\nFig. 2 .\n2Illustration of the computing platform communication in the C++ usage abstraction level for a volume data object. The Developer requests representations of the object but data transfer is performed on a layer of abstraction underneath data objects, thus never visible to the developer. Representations are mapped to types supported by hardware, i.e., buffers and textures, for performance reasons.\n\n\nNetwork, Processor, Property, Serialization, Factories, ...\n\nFig. 4 .\n4Visual representation of a processor, the encapsulation of an algorithm in Inviwo. Data is flowing from the top into the inports of the processor. The resulting output data continuous its flow through the outport. Synchronization of properties between processors are represented through property links.\n\nFig.\nFig. 5. Screenshot of the Inviwo network editor for rapid visualization pipeline creation. The processor network in the center loads and visualizes the charge density of the chemical boron element. New processors can be dragged from the processor list and dropped into the processor network, where a visual representation of the processor and its components will be shown. Pipelines are created by connecting processor ports in the network. Properties exposed by the selected processor are automatically shown in the property list to the right.\n\nFig. 7 .\n7Inviwo processor documentation, based on Markdown and doxygen, serves as both API (left) and end user documentation (right). The visual processor representation seen at the top in the right image is automatically generated by the Inviwo documentation system.\n\nFig. 8 .\n8Depiction of a regression test report. The plot in the top provides an overview of the regression test history. Test details show the new output, the reference, magnified difference between them and a binary mask of where error is above the error threshold. Additional details include the runtime log and explanation of the error causing the failure.\n\nFig. 9 .\n9Digital pathology: Visualizing a stack of 100 colored microscopic slides, each with a resolution of 63,000\u00d735,000 pixels and totaling in 110 GiB of compressed TIFF image data.\n\nFig.\nFig. 10. Public exhibition of human brain activity depicting where active areas are located in the brain when performing different tasks.\n\n\n, P. Steneteg, E. Sund\u00e9n, R. Englund, S. Kottravel, M. Falk, J. Jankowai, A. Ynnerman, and I. Hotz are with Link\u00f6ing University, Sweden. E-mail: {daniel.jonsson, peter.steneteg, erik.sunden, rickard.englund, sathish.kottravel, martin.falk, jochen.jankowai, anders.ynnerman, ingrid.hotz}@liu.se. \u2022 T. Ropinski is with Ulm University, Germany E-mail: timo.ropinski@uni-ulm.de.Manuscript received xx xxx. 201x; accepted xx xxx. 201x. Date of Publication \nxx xxx. 201x; date of current version xx xxx. 201x. For information on \nobtaining reprints of this article, please send e-mail to: reprints@ieee.org. \nDigital Object Identifier: xx.xxxx/TVCG.201x.xxxxxxx \n\n\nACKNOWLEDGMENTSThis work was supported through grants from the Swedish e-Science Research Centre (SeRC), the Excellence Center at Link\u00f6ping and Lund in Information Technology (ELLIIT), and the Knut and Alice Wallenberg Foundation (KAW) grant 2013-0076.APPENDIX -PROCESSOR CREATION GUIDELINESThe concept of encapsulating an functional unit into a processor is quite straight forward, but it can sometimes be difficult to differentiate between ports and properties. All algorithm parameters could potentially be exposed as inports. However, including many ports on each processor makes the system difficult to use and understand, especially if they are of the same type since they will only differ by the name the developer gave them.The Inviwo system uses different colors for each data types and also separate visual representations for optional and mandatory ports to alleviate this problem, seeFigure 4. Still, there must be a balance between what is exposed through ports and what is exposed as properties. Based on years of development and usage, we have come up with a set of guidelines for this purpose. In general, we have experienced that simplicity outweighs flexibility since it lowers the difficulty level for using the system, reduces cluttering and thus provides better overview, and also makes it faster to use overall since fewer connections are necessary. More flexible solutions are mostly only required by more experienced users, who already have deeper knowledge on how to use the system and therefore can create specialized solutions for their specific needs. The following recommended principles thus favor simplicity and ease of use in the network over flexibility:-Use inports for mandatory parameters. Processing will not take place until inports are connected. Thus, a good design uses ports for mandatory parameters. Properties require default values and generally do not put restrictions on evaluation of the processor so they should not be used for mandatory parameters.An exception to this rule is for example file path parameters. While they are mandatory for loading files they are not suitable to use as ports since they need to be specified by the user. Properties can easily be exposed to the user and are therefore appropriate for file path parameters.-Minimize the number of inports (less than five). Processors with many inports are hard to reuse for other purposes since they rely on many different types of inputs. We therefore classify processors with more than five inports as a sign of bad design of the underlying algorithm and encourage them to be broken down to smaller elements. This also affect the higher usage abstraction levels of the system. Each port requires a connection to another port and it quickly becomes difficult to immediately know which port to connect to. Furthermore, each connection adds clutter to the network and therefore reduces the users' ability to overview the pipeline.-Use properties when there is need for tuning by the user. The Inviwo network editor exposes properties through a rich set of widgets, which makes it easy for users to tune parameters. Different semantics can be used for the same type of property, i.e., four floating point values can be edited through sliders, a color widget, or spin boxes. Port data, on the other hand, must be come from memory or files, which is not suitable for tuning by a user.-Use properties for parameters with low memory transfer overhead. Linking (synchronizing) two properties involve a copy operation each time one of them changes. Thus, the memory transfer overhead could become noticeable when multiple processors require a parameter to be the same and it changes often. This memory transfer overhead is in many cases not a problem since the computation time in the pipeline widely exceeds parameter copy operation time. We have therefore favored properties instead of ports to reduce the number of inports in the case of for example cameras and transfer functions. A transfer function/color map can use many control points for mapping values to colors, and might cache a lookup table, but it still does not outweigh the added simplicity of including it as a property.If performance is crucial we recommend to use an (optional) inport instead of a property for the parameter. In practice, this means that one first creates a new processor having the parameter as both a property and outport. Then, instead of linking the properties between multiple processors, connect the parameter through ports. This solution avoids copy operations and enables the parameter to be tweaked using the property GUI. Note that this approach should still be avoided since, as pointed out before, it makes the processor more difficult to use.\nAdvanced Visual Systems Inc. Avs express. Advanced Visual Systems Inc. Avs express. www.avs.com/solutions/ express. Accessed: 2018-10-31.\n\nThe ParaView Guide: A Parallel Visualization Application. U Ayachit, Kitware, USAU. Ayachit. The ParaView Guide: A Parallel Visualization Application. Kitware, USA, 2015.\n\nVistrails: Enabling interactive multiple-view visualizations. L Bavoil, S P Callahan, P J Crossno, J Freire, C E Scheidegger, C T Silva, H T Vo, VIS 05. IEEE Visualization. IEEEL. Bavoil, S. P. Callahan, P. J. Crossno, J. Freire, C. E. Scheidegger, C. T. Silva, and H. T. Vo. Vistrails: Enabling interactive multiple-view visualizations. In VIS 05. IEEE Visualization, 2005., pp. 135-142. IEEE, 2005.\n\nState-of-the-art in gpu-based largescale volume visualization. J Beyer, M Hadwiger, H Pfister, 10.1111/cgf.12605Computer Graphics Forum. 348J. Beyer, M. Hadwiger, and H. Pfister. State-of-the-art in gpu-based large- scale volume visualization. Computer Graphics Forum, 34(8):13-37, 2015. doi: 10.1111/cgf.12605\n\nTopoangler: Interactive topology-based extraction of fishes. A Bock, H Doraiswamy, A Summers, C Silva, doi: 10. 1109/TVCG.2017.2743980IEEE Transactions on Visualization and Computer Graphics. 241A. Bock, H. Doraiswamy, A. Summers, and C. Silva. Topoangler: In- teractive topology-based extraction of fishes. IEEE Transactions on Vi- sualization and Computer Graphics, 24(1):812-821, Jan 2018. doi: 10. 1109/TVCG.2017.2743980\n\nVisual Verification of Space Weather Ensemble Simulations. A Bock, A Pembroke, M L Mays, L Rastaetter, A Ynnerman, T Ropinski, Proceedings of the IEEE Vis. the IEEE VisA. Bock, A. Pembroke, M. L. Mays, L. Rastaetter, A. Ynnerman, and T. Ropinski. Visual Verification of Space Weather Ensemble Simulations. In Proceedings of the IEEE Vis, 2015.\n\nVolumeshop: An interactive system for direct volume illustration. S Bruckner, M E Gr\u00f6ller, IEEES. Bruckner and M. E. Gr\u00f6ller. Volumeshop: An interactive system for direct volume illustration. IEEE, 2005.\n\nFAnToM -Field Analysis using Topological Methods. R Bujack, J M Hlawitschka, M H\u00fctter, J Kasten, S Koch, W Reich, S Schlegel, S Volke, R. Bujack, J. M. Hlawitschka, M. H\u00fctter, J. Kasten, S. Koch, W. Reich, S. Schlegel, and S. Volke. FAnToM -Field Analysis using Topological Methods. www.informatik.uni-leipzig.de/fantom/. Accessed: 2018-10-31.\n\nImaging vector fields using line integral convolution. B Cabral, L C Leedom, Proceedings of the 20th annual conference on Computer graphics and interactive techniques. the 20th annual conference on Computer graphics and interactive techniquesACMB. Cabral and L. C. Leedom. Imaging vector fields using line integral convolution. In Proceedings of the 20th annual conference on Computer graphics and interactive techniques, pp. 263-270. ACM, 1993.\n\nVisualization and analysis of rotating stall for transonic jet engine simulation. C.-M Chen, S Dutta, X Liu, G Heinlein, H.-W Shen, J.-P Chen, IEEE transactions on visualization and computer graphics. 221C.-M. Chen, S. Dutta, X. Liu, G. Heinlein, H.-W. Shen, and J.-P. Chen. Vi- sualization and analysis of rotating stall for transonic jet engine simulation. IEEE transactions on visualization and computer graphics, 22(1):847-856, 2016.\n\nVisIt: An End-User Tool For Visualizing and Analyzing Very Large Data. H Childs, E Brugger, B Whitlock, J Meredith, S Ahern, D Pugmire, K Biagas, M Miller, C Harrison, G H Weber, H Krishnan, T Fogal, A Sanderson, C Garth, E W Bethel, D Camp, O R\u00fcbel, M Durant, J M Favre, P Navr\u00e1til, High Performance Visualization-Enabling Extreme-Scale Scientific Insight. H. Childs, E. Brugger, B. Whitlock, J. Meredith, S. Ahern, D. Pugmire, K. Biagas, M. Miller, C. Harrison, G. H. Weber, H. Krishnan, T. Fogal, A. Sanderson, C. Garth, E. W. Bethel, D. Camp, O. R\u00fcbel, M. Durant, J. M. Favre, and P. Navr\u00e1til. VisIt: An End-User Tool For Visualizing and Analyzing Very Large Data. In High Performance Visualization-Enabling Extreme-Scale Scientific Insight, pp. 357-372. Oct 2012.\n\nInteractive desktop analysis of high resolution simulations: application to turbulent plume dynamics and current sheet formation. J Clyne, P Mininni, A Norton, M Rast, New Journal of Physics. 98301J. Clyne, P. Mininni, A. Norton, and M. Rast. Interactive desktop analysis of high resolution simulations: application to turbulent plume dynamics and current sheet formation. New Journal of Physics, 9(8):301, 2007.\n\nA Crowdsourcing System for Integrated and Reproducible Evaluation in Scientific Visualization. R Englund, S Kottravel, T Ropinski, Proceedings of the 2016 IEEE Pacific Visualization Symposium. the 2016 IEEE Pacific Visualization SymposiumR. Englund, S. Kottravel, and T. Ropinski. A Crowdsourcing System for Integrated and Reproducible Evaluation in Scientific Visualization. In Proceedings of the 2016 IEEE Pacific Visualization Symposium, 2016.\n\nTouching Data: Enhancing Visual Exploration of Flow Data with Haptics. R Englund, K Palmerius, I Hotz, A Ynnerman, IEEE Computing in Science & Engineering. 203R. Englund, K. Lundin Palmerius, I. Hotz, and A. Ynnerman. Touching Data: Enhancing Visual Exploration of Flow Data with Haptics. IEEE Computing in Science & Engineering, 20(3):89-100, 2018.\n\nEvaluating the perception of semi-transparent structures in direct volume rendering techniques. R Englund, T Ropinski, SIGGRAPH ASIA 2016 Symposium on Visualization. ACMR. Englund and T. Ropinski. Evaluating the perception of semi-transparent structures in direct volume rendering techniques. In SIGGRAPH ASIA 2016 Symposium on Visualization. ACM, 2016.\n\nQuantitative and Qualitative Analysis of the Perception of Semi-Transparent Structures in Direct Volume Rendering. R Englund, T Ropinski, 10.1111/cgf.13320Computer Graphics Forum. R. Englund and T. Ropinski. Quantitative and Qualitative Analysis of the Perception of Semi-Transparent Structures in Direct Volume Rendering. Computer Graphics Forum, 2018. DOI: 10.1111/cgf.13320.\n\nCoherence Maps for Blood Flow Exploration. R Englund, T Ropinski, I Hotz, Eurographics Workshop on Visual Computing for Biology and Medicine. Eurographics Association. Bergen, NorwayR. Englund, T. Ropinski, and I. Hotz. Coherence Maps for Blood Flow Exploration. In Eurographics Workshop on Visual Computing for Biology and Medicine. Eurographics Association, Bergen, Norway, 2016.\n\n. Epic Games. Unreal engine. www.unrealengine.com. Accessed. Epic Games. Unreal engine. www.unrealengine.com. Accessed: 2018- 10-31.\n\nTransfer function design toolbox for full-color volume datasets. M Falk, I Hotz, P Ljung, D Treanor, A Ynnerman, C Lundstr\u00f6m, IEEE Pacific Visualization Symposium. M. Falk, I. Hotz, P. Ljung, D. Treanor, A. Ynnerman, and C. Lundstr\u00f6m. Transfer function design toolbox for full-color volume datasets. In IEEE Pacific Visualization Symposium (PacificVis 2017), 2017.\n\nInteractive visualization of 3D histopathology in native resolution. M Falk, A Ynnerman, D Treanor, C Lundstr\u00f6m, 10.1109/TVCG.2018.2864816IEEE TVCG (SciVis Proceedings). 29M. Falk, A. Ynnerman, D. Treanor, and C. Lundstr\u00f6m. Interactive visu- alization of 3D histopathology in native resolution. IEEE TVCG (SciVis Proceedings), 29(1), 2019. doi: 10.1109/TVCG.2018.2864816\n\nBehaviorism: A framework for dynamic data visualization. A Forbes, T H\u00f6llerer, G Legrady, IEEE Transactions on Visualization and Computer Graphics. 166A. Forbes, T. H\u00f6llerer, and G. Legrady. Behaviorism: A framework for dynamic data visualization. IEEE Transactions on Visualization and Computer Graphics, 16(6):1164-1171, 2010.\n\nD Gelperin, B Hetzel, The growth of software testing. Communications of the ACM. 31D. Gelperin and B. Hetzel. The growth of software testing. Communica- tions of the ACM, 31(6):687-695, 1988.\n\nOpenSlide: A vendor-neutral software foundation for digital pathology. A Goode, B Gilbert, J Harkes, D Jukic, M Satyanarayanan, Journal of Pathology Informatics. 427A. Goode, B. Gilbert, J. Harkes, D. Jukic, and M. Satyanarayanan. OpenSlide: A vendor-neutral software foundation for digital pathology. Journal of Pathology Informatics, 4(27), 2013.\n\n. M D Hanwell, U Ayachit, D A Muller, R Hovden, Tomviz. www.tomviz.org. Accessed. M. D. Hanwell, U. Ayachit, D. A. Muller, and R. Hovden. Tomviz. www.tomviz.org. Accessed: 2018-10-31.\n\nVisual Debugging Techniques for Reactive Data Visualization. J Hoffswell, A Satyanarayan, J Heer, S Kairam, J Kaye, J Guerra-Gomez, D A Shamma, Y.-S Kim, J Hullman, M Agrawala, Computer Graphics Forum (Proc. EuroVis). 343J. Hoffswell, A. Satyanarayan, J. Heer, S. Kairam, J. Kaye, J. Guerra- Gomez, D. A. Shamma, Y.-S. Kim, J. Hullman, M. Agrawala, et al. Visual Debugging Techniques for Reactive Data Visualization. In Computer Graphics Forum (Proc. EuroVis), vol. 34, p. 3, 2015.\n\nFeature level-sets: Generalizing iso-surfaces to multi-variate data. J Jankowai, I Hotz, 10.1109/TVCG.2018.2867488IEEE Transactions on Visualization and Computer Graphics. J. Jankowai and I. Hotz. Feature level-sets: Generalizing iso-surfaces to multi-variate data. IEEE Transactions on Visualization and Computer Graphics, pp. 1-1, 2018. doi: 10.1109/TVCG.2018.2867488\n\nEnhancing Salient Features in Volumetric Data Using Illumination and Transfer Functions. D J\u00f6nsson, Link\u00f6ping UniversityPhD thesisD. J\u00f6nsson. Enhancing Salient Features in Volumetric Data Using Il- lumination and Transfer Functions. PhD thesis, Link\u00f6ping University, 2016.\n\nIntuitive Exploration of. D J\u00f6nsson, M Falk, A Ynnerman, 2016.10.1109/TVCG.2015.2467294umetric Data Using Dynamic Galleries. IEEE Transactions on Visualization and Computer Graphics (TVCG). 22D. J\u00f6nsson, M. Falk, and A. Ynnerman. Intuitive Exploration of Vol- umetric Data Using Dynamic Galleries. IEEE Transactions on Vi- sualization and Computer Graphics (TVCG), 22(1):896 -905, 2016. 10.1109/TVCG.2015.2467294.\n\nA Survey of Volumetric Illumination Techniques for Interactive Volume Rendering. D J\u00f6nsson, E Sund\u00e9n, A Ynnerman, T Ropinski, Computer Graphics Forum. 331D. J\u00f6nsson, E. Sund\u00e9n, A. Ynnerman, and T. Ropinski. A Survey of Volumetric Illumination Techniques for Interactive Volume Rendering. Computer Graphics Forum, 33(1):27-51, 2014.\n\nCorrelated Photon Mapping for Interactive Global Illumination of Time-Varying Volumetric Data. D J\u00f6nsson, A Ynnerman, IEEE Transactions on Visualization and Computer Graphics (TVCG). 231D. J\u00f6nsson and A. Ynnerman. Correlated Photon Mapping for Interactive Global Illumination of Time-Varying Volumetric Data. IEEE Transactions on Visualization and Computer Graphics (TVCG), 23(1):901-910, 2017.\n\nSuperquadric tensor glyphs. G Kindlmann, Proceedings of the Sixth Joint Eurographics-IEEE TCVG conference on Visualization. the Sixth Joint Eurographics-IEEE TCVG conference on VisualizationG. Kindlmann. Superquadric tensor glyphs. In Proceedings of the Sixth Joint Eurographics-IEEE TCVG conference on Visualization, pp. 147-154. Eurographics Association, 2004.\n\nBinding sites for luminescent amyloid biomarkers from non-biased molecular dynamics simulations. C Konig, R Sk\u00e5nberg, I Hotz, A Ynnerman, P Norman, M Linares, 10.1039/C8CC00105GChem. Commun. 54C. Konig, R. Sk\u00e5nberg, I. Hotz, A. Ynnerman, P. Norman, and M. Linares. Binding sites for luminescent amyloid biomarkers from non-biased molec- ular dynamics simulations. Chem. Commun., 54:3030-3033, 2018. doi: 10.1039/C8CC00105G\n\nTemporal treemaps: Static visualization of evolving trees. W K\u00f6pp, T Weinkauf, IEEE Transactions on Visualization and Computer Graphics (Proc. IEEE VIS). 25W. K\u00f6pp and T. Weinkauf. Temporal treemaps: Static visualization of evolving trees. IEEE Transactions on Visualization and Computer Graph- ics (Proc. IEEE VIS), 25(1), Jan. 2019.\n\nVisual analysis of stochastic trajectory ensembles in organic solar cell design. S Kottravel, R Volpi, M Linares, T Ropinski, I Hotz, In Informatics. 425Multidisciplinary Digital Publishing InstituteS. Kottravel, R. Volpi, M. Linares, T. Ropinski, and I. Hotz. Visual analysis of stochastic trajectory ensembles in organic solar cell design. In Informatics, vol. 4, p. 25. Multidisciplinary Digital Publishing Institute, 2017.\n\nVisually supporting multiple needle placement in irreversible electroporation interventions. J Kreiser, J Freedman, T Ropinski, Computer Graphics Forum. Wiley Online Library37J. Kreiser, J. Freedman, and T. Ropinski. Visually supporting multiple nee- dle placement in irreversible electroporation interventions. In Computer Graphics Forum, vol. 37, pp. 59-71. Wiley Online Library, 2018.\n\ncellview: a tool for illustrative and multi-scale rendering of large biomolecular datasets. M Le Muzic, L Autin, J Parulek, I Viola, Eurographics Workshop on Visual Computing for Biomedicine. NIH Public Access201561M. Le Muzic, L. Autin, J. Parulek, and I. Viola. cellview: a tool for illustrative and multi-scale rendering of large biomolecular datasets. In Eurographics Workshop on Visual Computing for Biomedicine, vol. 2015, p. 61. NIH Public Access, 2015.\n\n. MeVis Medical Solutions AG. Mevislab. www.mevislab.de. Accessed. MeVis Medical Solutions AG. Mevislab. www.mevislab.de. Accessed: 2018-10-31.\n\nVoreen: A Rapid-Prototyping Environment for Ray-Casting-Based Volume Visualizations. J Meyer-Spradow, T Ropinski, J Mensmann, K Hinrichs, IEEE Computer Graphics and Applications. 296J. Meyer-Spradow, T. Ropinski, J. Mensmann, and K. Hinrichs. Voreen: A Rapid-Prototyping Environment for Ray-Casting-Based Volume Vi- sualizations. IEEE Computer Graphics and Applications, 29(6):6-13, 2009.\n\nA survey of visualization pipelines. K Moreland, 10.1109/TVCG.2012.133IEEE Transactions on Visualization and Computer Graphics. 193K. Moreland. A survey of visualization pipelines. IEEE Transactions on Visualization and Computer Graphics, 19(3):367-378, March 2013. doi: 10.1109/TVCG.2012.133\n\nVtk-m: Accelerating the visualization toolkit for massively threaded architectures. K Moreland, C Sewell, W Usher, L Lo, J Meredith, D Pugmire, J Kress, H Schroots, K.-L Ma, H Childs, IEEE computer graphics and applications. 363K. Moreland, C. Sewell, W. Usher, L.-t. Lo, J. Meredith, D. Pugmire, J. Kress, H. Schroots, K.-L. Ma, H. Childs, et al. Vtk-m: Accelerating the visualization toolkit for massively threaded architectures. IEEE computer graphics and applications, 36(3):48-58, 2016.\n\nConcurrent Volume Visualization of Real-Time fMRI. K T Nguyen, A Eklund, H Ohlsson, F Hernell, P Ljung, C Forsell, M T Andersson, H Knutsson, A Ynnerman, IEEE/EG Volume Graphics. K. T. Nguyen, A. Eklund, H. Ohlsson, F. Hernell, P. Ljung, C. Forsell, M. T. Andersson, H. Knutsson, and A. Ynnerman. Concurrent Volume Visualization of Real-Time fMRI. In IEEE/EG Volume Graphics, pp. 53-60, 2010.\n\nElements of functional programming. C Reade, Addison-WesleyC. Reade. Elements of functional programming. Addison-Wesley, 1989.\n\nW Schroeder, K Martin, B Lorensen, The visualization toolkit. Kitware. 4 ed.W. Schroeder, K. Martin, and B. Lorensen. The visualization toolkit. Kitware, 4 ed., 2006.\n\nDxr: A toolkit for building immersive data visualizations. R Sicat, J Li, J Choi, M Cordeil, W.-K Jeong, B Bach, H Pfister, IEEE transactions on visualization and computer graphics. R. Sicat, J. Li, J. Choi, M. Cordeil, W.-K. Jeong, B. Bach, and H. Pfis- ter. Dxr: A toolkit for building immersive data visualizations. IEEE transactions on visualization and computer graphics, 2018.\n\nUsing VisTrails and Provenance for Teaching Scientific Visualization. C T Silva, E Anderson, E Santos, J Freire, 10.1111/j.1467-8659.2010.01830.xComputer Graphics Forum. 301C. T. Silva, E. Anderson, E. Santos, and J. Freire. Using VisTrails and Provenance for Teaching Scientific Visualization. Computer Graphics Forum, 30(1):75-84, 2011. doi: 10.1111/j.1467-8659.2010.01830.x\n\nPelvis: Atlas-based surgical planning for oncological pelvic surgery. N Smit, K Lawonn, A Kraima, M Deruiter, H Sokooti, S Bruckner, E Eisemann, A Vilanova, 10.1109/TVCG.2016.2598826IEEE Transactions on Visualization and Computer Graphics. 231N. Smit, K. Lawonn, A. Kraima, M. DeRuiter, H. Sokooti, S. Bruckner, E. Eisemann, and A. Vilanova. Pelvis: Atlas-based surgical planning for oncological pelvic surgery. IEEE Transactions on Visualization and Computer Graphics, 23(1):741-750, Jan 2017. doi: 10.1109/TVCG.2016. 2598826\n\nEfficient Volume Illumination with Multiple Light Sources through Selective Light Updates. E Sund\u00e9n, T Ropinski, Proceedings of the 2015 IEEE Pacific Visualization Symposium. the 2015 IEEE Pacific Visualization SymposiumE. Sund\u00e9n and T. Ropinski. Efficient Volume Illumination with Multiple Light Sources through Selective Light Updates. In Proceedings of the 2015 IEEE Pacific Visualization Symposium, pp. 231-238, 2015.\n\n. Thermo Fisher Scientific. Amira. www.fei.com. Accessed. Thermo Fisher Scientific. Amira. www.fei.com. Accessed: 2018-10-31.\n\nImplementation of largescale routine diagnostics using whole slide imaging in sweden: Digital pathology experiences 2006-2013. S Thorstenson, J Molin, C Lundstr\u00f6m, 10.4103/2153-3539.129452Journal of Pathology Informatics. 514S. Thorstenson, J. Molin, and C. Lundstr\u00f6m. Implementation of large- scale routine diagnostics using whole slide imaging in sweden: Digital pathology experiences 2006-2013. Journal of Pathology Informatics, 5(14), 2014. doi: 10.4103/2153-3539.129452\n\n. Unity Technologies. Unity. www.unity3d.com.com. Accessed. Unity Technologies. Unity. www.unity3d.com.com. Accessed: 2018- 10-31.\n\nThe value of visualization. J J Van Wijk, Visualization, 2005. VIS 05. IEEE. IEEEJ. J. Van Wijk. The value of visualization. In Visualization, 2005. VIS 05. IEEE, pp. 79-86. IEEE, 2005.\n\nEfficiently using graphics hardware in volume rendering applications. R Westermann, T Ertl, ACM SIGGRAPH 1998. R. Westermann and T. Ertl. Efficiently using graphics hardware in volume rendering applications. In ACM SIGGRAPH 1998, 1998.\n\nHow Google tests software. J A Whittaker, J Arbon, J Carollo, Addison-WesleyJ. A. Whittaker, J. Arbon, and J. Carollo. How Google tests software. Addison-Wesley, 2012.\n", "annotations": {"author": "[{\"end\":79,\"start\":64},{\"end\":95,\"start\":80},{\"end\":108,\"start\":96},{\"end\":125,\"start\":109},{\"end\":144,\"start\":126},{\"end\":157,\"start\":145},{\"end\":174,\"start\":158},{\"end\":187,\"start\":175},{\"end\":202,\"start\":188}]", "publisher": null, "author_last_name": "[{\"end\":78,\"start\":71},{\"end\":94,\"start\":86},{\"end\":107,\"start\":101},{\"end\":124,\"start\":117},{\"end\":143,\"start\":134},{\"end\":156,\"start\":152},{\"end\":173,\"start\":165},{\"end\":186,\"start\":182},{\"end\":201,\"start\":193}]", "author_first_name": "[{\"end\":70,\"start\":64},{\"end\":85,\"start\":80},{\"end\":100,\"start\":96},{\"end\":116,\"start\":109},{\"end\":133,\"start\":126},{\"end\":151,\"start\":145},{\"end\":164,\"start\":158},{\"end\":181,\"start\":175},{\"end\":192,\"start\":188}]", "author_affiliation": null, "title": "[{\"end\":61,\"start\":1},{\"end\":263,\"start\":203}]", "venue": null, "abstract": "[{\"end\":1752,\"start\":298}]", "bib_ref": "[{\"attributes\":{\"ref_id\":\"b28\"},\"end\":2047,\"start\":2043},{\"attributes\":{\"ref_id\":\"b8\"},\"end\":2078,\"start\":2075},{\"attributes\":{\"ref_id\":\"b30\"},\"end\":2101,\"start\":2097},{\"attributes\":{\"ref_id\":\"b45\"},\"end\":2285,\"start\":2281},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":2312,\"start\":2308},{\"attributes\":{\"ref_id\":\"b35\"},\"end\":2343,\"start\":2339},{\"attributes\":{\"ref_id\":\"b5\"},\"end\":2361,\"start\":2358},{\"attributes\":{\"ref_id\":\"b42\"},\"end\":2897,\"start\":2893},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":3251,\"start\":3248},{\"attributes\":{\"ref_id\":\"b6\"},\"end\":3267,\"start\":3264},{\"attributes\":{\"ref_id\":\"b36\"},\"end\":3282,\"start\":3278},{\"attributes\":{\"ref_id\":\"b10\"},\"end\":3294,\"start\":3290},{\"attributes\":{\"ref_id\":\"b11\"},\"end\":3307,\"start\":3303},{\"attributes\":{\"ref_id\":\"b37\"},\"end\":3320,\"start\":3316},{\"attributes\":{\"ref_id\":\"b47\"},\"end\":3335,\"start\":3331},{\"attributes\":{\"ref_id\":\"b41\"},\"end\":3464,\"start\":3460},{\"attributes\":{\"ref_id\":\"b38\"},\"end\":3598,\"start\":3594},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":3753,\"start\":3750},{\"attributes\":{\"ref_id\":\"b36\"},\"end\":3768,\"start\":3764},{\"attributes\":{\"ref_id\":\"b37\"},\"end\":3783,\"start\":3779},{\"end\":3935,\"start\":3928},{\"attributes\":{\"ref_id\":\"b50\"},\"end\":5262,\"start\":5258},{\"attributes\":{\"ref_id\":\"b51\"},\"end\":5475,\"start\":5471},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":5549,\"start\":5546},{\"attributes\":{\"ref_id\":\"b6\"},\"end\":5565,\"start\":5562},{\"attributes\":{\"ref_id\":\"b36\"},\"end\":5580,\"start\":5576},{\"attributes\":{\"ref_id\":\"b11\"},\"end\":5592,\"start\":5588},{\"attributes\":{\"ref_id\":\"b37\"},\"end\":5605,\"start\":5601},{\"attributes\":{\"ref_id\":\"b47\"},\"end\":5620,\"start\":5616},{\"attributes\":{\"ref_id\":\"b27\"},\"end\":6820,\"start\":6816},{\"attributes\":{\"ref_id\":\"b36\"},\"end\":7046,\"start\":7042},{\"attributes\":{\"ref_id\":\"b47\"},\"end\":7057,\"start\":7053},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":7070,\"start\":7067},{\"attributes\":{\"ref_id\":\"b10\"},\"end\":7081,\"start\":7077},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":7095,\"start\":7092},{\"attributes\":{\"ref_id\":\"b31\"},\"end\":7407,\"start\":7403},{\"attributes\":{\"ref_id\":\"b33\"},\"end\":7434,\"start\":7430},{\"attributes\":{\"ref_id\":\"b42\"},\"end\":8229,\"start\":8225},{\"attributes\":{\"ref_id\":\"b39\"},\"end\":8450,\"start\":8446},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":8861,\"start\":8858},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":8876,\"start\":8873},{\"attributes\":{\"ref_id\":\"b10\"},\"end\":8888,\"start\":8884},{\"attributes\":{\"ref_id\":\"b23\"},\"end\":8904,\"start\":8900},{\"attributes\":{\"ref_id\":\"b36\"},\"end\":9292,\"start\":9288},{\"attributes\":{\"ref_id\":\"b47\"},\"end\":9304,\"start\":9300},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":9320,\"start\":9317},{\"attributes\":{\"ref_id\":\"b37\"},\"end\":9337,\"start\":9333},{\"attributes\":{\"ref_id\":\"b10\"},\"end\":9387,\"start\":9383},{\"attributes\":{\"ref_id\":\"b23\"},\"end\":9491,\"start\":9487},{\"attributes\":{\"ref_id\":\"b47\"},\"end\":9616,\"start\":9612},{\"attributes\":{\"ref_id\":\"b36\"},\"end\":9634,\"start\":9630},{\"attributes\":{\"ref_id\":\"b0\"},\"end\":9727,\"start\":9724},{\"attributes\":{\"ref_id\":\"b37\"},\"end\":9782,\"start\":9778},{\"attributes\":{\"ref_id\":\"b20\"},\"end\":9952,\"start\":9948},{\"attributes\":{\"ref_id\":\"b20\"},\"end\":10223,\"start\":10219},{\"attributes\":{\"ref_id\":\"b7\"},\"end\":10473,\"start\":10470},{\"attributes\":{\"ref_id\":\"b11\"},\"end\":10519,\"start\":10515},{\"attributes\":{\"ref_id\":\"b6\"},\"end\":10586,\"start\":10583},{\"attributes\":{\"ref_id\":\"b21\"},\"end\":12030,\"start\":12026},{\"attributes\":{\"ref_id\":\"b24\"},\"end\":12238,\"start\":12234},{\"attributes\":{\"ref_id\":\"b49\"},\"end\":13921,\"start\":13917},{\"attributes\":{\"ref_id\":\"b17\"},\"end\":13944,\"start\":13940},{\"attributes\":{\"ref_id\":\"b43\"},\"end\":14134,\"start\":14130},{\"attributes\":{\"ref_id\":\"b52\"},\"end\":46656,\"start\":46652},{\"attributes\":{\"ref_id\":\"b26\"},\"end\":51528,\"start\":51524},{\"attributes\":{\"ref_id\":\"b29\"},\"end\":51531,\"start\":51528},{\"attributes\":{\"ref_id\":\"b46\"},\"end\":51534,\"start\":51531},{\"attributes\":{\"ref_id\":\"b19\"},\"end\":51562,\"start\":51558},{\"attributes\":{\"ref_id\":\"b34\"},\"end\":51565,\"start\":51562},{\"attributes\":{\"ref_id\":\"b18\"},\"end\":51617,\"start\":51613},{\"attributes\":{\"ref_id\":\"b27\"},\"end\":51620,\"start\":51617},{\"attributes\":{\"ref_id\":\"b12\"},\"end\":51659,\"start\":51655},{\"attributes\":{\"ref_id\":\"b14\"},\"end\":51662,\"start\":51659},{\"attributes\":{\"ref_id\":\"b15\"},\"end\":51665,\"start\":51662},{\"attributes\":{\"ref_id\":\"b4\"},\"end\":51691,\"start\":51688},{\"attributes\":{\"ref_id\":\"b32\"},\"end\":51694,\"start\":51691},{\"attributes\":{\"ref_id\":\"b13\"},\"end\":51753,\"start\":51749},{\"attributes\":{\"ref_id\":\"b16\"},\"end\":51756,\"start\":51753},{\"attributes\":{\"ref_id\":\"b25\"},\"end\":51759,\"start\":51756},{\"attributes\":{\"ref_id\":\"b48\"},\"end\":55500,\"start\":55496},{\"attributes\":{\"ref_id\":\"b3\"},\"end\":55960,\"start\":55957},{\"attributes\":{\"ref_id\":\"b22\"},\"end\":56206,\"start\":56202},{\"attributes\":{\"ref_id\":\"b18\"},\"end\":56516,\"start\":56512},{\"attributes\":{\"ref_id\":\"b19\"},\"end\":57178,\"start\":57174},{\"attributes\":{\"ref_id\":\"b27\"},\"end\":57846,\"start\":57842},{\"attributes\":{\"ref_id\":\"b40\"},\"end\":58389,\"start\":58385},{\"attributes\":{\"ref_id\":\"b42\"},\"end\":60160,\"start\":60156},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":60174,\"start\":60171},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":60192,\"start\":60189},{\"attributes\":{\"ref_id\":\"b44\"},\"end\":60541,\"start\":60537}]", "figure": "[{\"attributes\":{\"id\":\"fig_0\"},\"end\":64527,\"start\":64402},{\"attributes\":{\"id\":\"fig_1\"},\"end\":64923,\"start\":64528},{\"attributes\":{\"id\":\"fig_2\"},\"end\":65332,\"start\":64924},{\"attributes\":{\"id\":\"fig_3\"},\"end\":65394,\"start\":65333},{\"attributes\":{\"id\":\"fig_5\"},\"end\":65708,\"start\":65395},{\"attributes\":{\"id\":\"fig_7\"},\"end\":66259,\"start\":65709},{\"attributes\":{\"id\":\"fig_8\"},\"end\":66529,\"start\":66260},{\"attributes\":{\"id\":\"fig_9\"},\"end\":66891,\"start\":66530},{\"attributes\":{\"id\":\"fig_10\"},\"end\":67078,\"start\":66892},{\"attributes\":{\"id\":\"fig_11\"},\"end\":67222,\"start\":67079},{\"attributes\":{\"id\":\"tab_0\",\"type\":\"table\"},\"end\":67883,\"start\":67223}]", "paragraph": "[{\"end\":5044,\"start\":1768},{\"end\":6419,\"start\":5046},{\"end\":7024,\"start\":6421},{\"end\":7899,\"start\":7026},{\"end\":8787,\"start\":7916},{\"end\":9541,\"start\":8789},{\"end\":10811,\"start\":9543},{\"end\":11521,\"start\":10813},{\"end\":11921,\"start\":11523},{\"end\":12881,\"start\":11923},{\"end\":13887,\"start\":12883},{\"end\":14722,\"start\":13889},{\"end\":15992,\"start\":14746},{\"end\":16308,\"start\":15994},{\"end\":17154,\"start\":16310},{\"end\":18636,\"start\":17156},{\"end\":18725,\"start\":18638},{\"end\":19179,\"start\":18754},{\"end\":20303,\"start\":19207},{\"end\":20963,\"start\":20334},{\"end\":21862,\"start\":20965},{\"end\":22725,\"start\":21880},{\"end\":23294,\"start\":22727},{\"end\":23556,\"start\":23296},{\"end\":23825,\"start\":23568},{\"end\":25089,\"start\":23827},{\"end\":25280,\"start\":25091},{\"end\":25657,\"start\":25320},{\"end\":27294,\"start\":25659},{\"end\":28808,\"start\":27296},{\"end\":29301,\"start\":28810},{\"end\":29323,\"start\":29310},{\"end\":29356,\"start\":29325},{\"end\":29393,\"start\":29367},{\"end\":29506,\"start\":29395},{\"end\":29941,\"start\":29508},{\"end\":31667,\"start\":29943},{\"end\":32010,\"start\":31707},{\"end\":33236,\"start\":32012},{\"end\":33445,\"start\":33238},{\"end\":34301,\"start\":33465},{\"end\":35307,\"start\":34303},{\"end\":36245,\"start\":35358},{\"end\":36345,\"start\":36247},{\"end\":36834,\"start\":36386},{\"end\":37385,\"start\":36836},{\"end\":38201,\"start\":37387},{\"end\":38454,\"start\":38203},{\"end\":38670,\"start\":38456},{\"end\":40056,\"start\":38713},{\"end\":40480,\"start\":40058},{\"end\":41348,\"start\":40520},{\"end\":42648,\"start\":41350},{\"end\":42898,\"start\":42650},{\"end\":43488,\"start\":42919},{\"end\":44380,\"start\":43490},{\"end\":45689,\"start\":44408},{\"end\":46245,\"start\":45713},{\"end\":46598,\"start\":46247},{\"end\":47314,\"start\":46615},{\"end\":48420,\"start\":47337},{\"end\":49149,\"start\":48422},{\"end\":49418,\"start\":49151},{\"end\":51265,\"start\":49449},{\"end\":51888,\"start\":51290},{\"end\":52496,\"start\":51890},{\"end\":52932,\"start\":52534},{\"end\":53757,\"start\":52934},{\"end\":54687,\"start\":53759},{\"end\":55301,\"start\":54689},{\"end\":55876,\"start\":55336},{\"end\":57361,\"start\":55878},{\"end\":58661,\"start\":57400},{\"end\":59218,\"start\":58663},{\"end\":59743,\"start\":59220},{\"end\":61049,\"start\":59773},{\"end\":61470,\"start\":61051},{\"end\":61691,\"start\":61472},{\"end\":62100,\"start\":61722},{\"end\":62956,\"start\":62102},{\"end\":63415,\"start\":62958},{\"end\":63797,\"start\":63417},{\"end\":64401,\"start\":63799}]", "formula": null, "table_ref": "[{\"end\":6839,\"start\":6832},{\"end\":7388,\"start\":7096},{\"end\":11074,\"start\":11067},{\"end\":11541,\"start\":11534}]", "section_header": "[{\"attributes\":{\"n\":\"1\"},\"end\":1766,\"start\":1754},{\"attributes\":{\"n\":\"2\"},\"end\":7914,\"start\":7902},{\"attributes\":{\"n\":\"3\"},\"end\":14744,\"start\":14725},{\"attributes\":{\"n\":\"4\"},\"end\":18752,\"start\":18728},{\"attributes\":{\"n\":\"4.1\"},\"end\":19205,\"start\":19182},{\"attributes\":{\"n\":\"4.2\"},\"end\":20332,\"start\":20306},{\"attributes\":{\"n\":\"4.3\"},\"end\":21878,\"start\":21865},{\"attributes\":{\"n\":\"4.4\"},\"end\":23566,\"start\":23559},{\"attributes\":{\"n\":\"5\"},\"end\":25318,\"start\":25283},{\"end\":29308,\"start\":29304},{\"end\":29365,\"start\":29359},{\"attributes\":{\"n\":\"6\"},\"end\":31705,\"start\":31670},{\"end\":33463,\"start\":33448},{\"attributes\":{\"n\":\"6.1\"},\"end\":35356,\"start\":35310},{\"attributes\":{\"n\":\"6.1.1\"},\"end\":36384,\"start\":36348},{\"attributes\":{\"n\":\"6.1.2\"},\"end\":38711,\"start\":38673},{\"attributes\":{\"n\":\"6.1.3\"},\"end\":40518,\"start\":40483},{\"attributes\":{\"n\":\"6.2\"},\"end\":42917,\"start\":42901},{\"attributes\":{\"n\":\"6.3\"},\"end\":44406,\"start\":44383},{\"attributes\":{\"n\":\"6.4\"},\"end\":45711,\"start\":45692},{\"attributes\":{\"n\":\"6.4.1\"},\"end\":46613,\"start\":46601},{\"attributes\":{\"n\":\"6.4.2\"},\"end\":47335,\"start\":47317},{\"attributes\":{\"n\":\"6.5\"},\"end\":49447,\"start\":49421},{\"attributes\":{\"n\":\"7\"},\"end\":51288,\"start\":51268},{\"attributes\":{\"n\":\"7.1\"},\"end\":52532,\"start\":52499},{\"attributes\":{\"n\":\"7.2\"},\"end\":55334,\"start\":55304},{\"attributes\":{\"n\":\"7.3\"},\"end\":57398,\"start\":57364},{\"attributes\":{\"n\":\"7.4\"},\"end\":59771,\"start\":59746},{\"attributes\":{\"n\":\"8\"},\"end\":61720,\"start\":61694},{\"end\":64411,\"start\":64403},{\"end\":64537,\"start\":64529},{\"end\":64933,\"start\":64925},{\"end\":65404,\"start\":65396},{\"end\":65714,\"start\":65710},{\"end\":66269,\"start\":66261},{\"end\":66539,\"start\":66531},{\"end\":66901,\"start\":66893},{\"end\":67084,\"start\":67080}]", "table": "[{\"end\":67883,\"start\":67599}]", "figure_caption": "[{\"end\":64527,\"start\":64416},{\"end\":64923,\"start\":64539},{\"end\":65332,\"start\":64935},{\"end\":65394,\"start\":65335},{\"end\":65708,\"start\":65406},{\"end\":66259,\"start\":65715},{\"end\":66529,\"start\":66271},{\"end\":66891,\"start\":66541},{\"end\":67078,\"start\":66903},{\"end\":67222,\"start\":67085},{\"end\":67599,\"start\":67225}]", "figure_ref": "[{\"attributes\":{\"ref_id\":\"fig_1\"},\"end\":14879,\"start\":14873},{\"attributes\":{\"ref_id\":\"fig_2\"},\"end\":27681,\"start\":27675},{\"end\":29442,\"start\":29436},{\"end\":32082,\"start\":32076},{\"attributes\":{\"ref_id\":\"fig_5\"},\"end\":34802,\"start\":34794},{\"end\":35707,\"start\":35706},{\"end\":36514,\"start\":36506},{\"attributes\":{\"ref_id\":\"fig_5\"},\"end\":37073,\"start\":37065},{\"end\":37697,\"start\":37689},{\"end\":40749,\"start\":40743},{\"end\":41706,\"start\":41700},{\"end\":43972,\"start\":43964},{\"attributes\":{\"ref_id\":\"fig_8\"},\"end\":45507,\"start\":45499},{\"attributes\":{\"ref_id\":\"fig_9\"},\"end\":48943,\"start\":48937},{\"attributes\":{\"ref_id\":\"fig_10\"},\"end\":56643,\"start\":56637},{\"attributes\":{\"ref_id\":\"fig_1\"},\"end\":57851,\"start\":57849},{\"attributes\":{\"ref_id\":\"fig_1\"},\"end\":57989,\"start\":57982}]", "bib_author_first_name": "[{\"end\":72830,\"start\":72829},{\"end\":73006,\"start\":73005},{\"end\":73016,\"start\":73015},{\"end\":73018,\"start\":73017},{\"end\":73030,\"start\":73029},{\"end\":73032,\"start\":73031},{\"end\":73043,\"start\":73042},{\"end\":73053,\"start\":73052},{\"end\":73055,\"start\":73054},{\"end\":73070,\"start\":73069},{\"end\":73072,\"start\":73071},{\"end\":73081,\"start\":73080},{\"end\":73083,\"start\":73082},{\"end\":73409,\"start\":73408},{\"end\":73418,\"start\":73417},{\"end\":73430,\"start\":73429},{\"end\":73719,\"start\":73718},{\"end\":73727,\"start\":73726},{\"end\":73741,\"start\":73740},{\"end\":73752,\"start\":73751},{\"end\":74143,\"start\":74142},{\"end\":74151,\"start\":74150},{\"end\":74163,\"start\":74162},{\"end\":74165,\"start\":74164},{\"end\":74173,\"start\":74172},{\"end\":74187,\"start\":74186},{\"end\":74199,\"start\":74198},{\"end\":74495,\"start\":74494},{\"end\":74507,\"start\":74506},{\"end\":74509,\"start\":74508},{\"end\":74684,\"start\":74683},{\"end\":74694,\"start\":74693},{\"end\":74696,\"start\":74695},{\"end\":74711,\"start\":74710},{\"end\":74721,\"start\":74720},{\"end\":74731,\"start\":74730},{\"end\":74739,\"start\":74738},{\"end\":74748,\"start\":74747},{\"end\":74760,\"start\":74759},{\"end\":75034,\"start\":75033},{\"end\":75044,\"start\":75043},{\"end\":75046,\"start\":75045},{\"end\":75511,\"start\":75507},{\"end\":75519,\"start\":75518},{\"end\":75528,\"start\":75527},{\"end\":75535,\"start\":75534},{\"end\":75550,\"start\":75546},{\"end\":75561,\"start\":75557},{\"end\":75936,\"start\":75935},{\"end\":75946,\"start\":75945},{\"end\":75957,\"start\":75956},{\"end\":75969,\"start\":75968},{\"end\":75981,\"start\":75980},{\"end\":75990,\"start\":75989},{\"end\":76001,\"start\":76000},{\"end\":76011,\"start\":76010},{\"end\":76021,\"start\":76020},{\"end\":76033,\"start\":76032},{\"end\":76035,\"start\":76034},{\"end\":76044,\"start\":76043},{\"end\":76056,\"start\":76055},{\"end\":76065,\"start\":76064},{\"end\":76078,\"start\":76077},{\"end\":76087,\"start\":76086},{\"end\":76089,\"start\":76088},{\"end\":76099,\"start\":76098},{\"end\":76107,\"start\":76106},{\"end\":76116,\"start\":76115},{\"end\":76126,\"start\":76125},{\"end\":76128,\"start\":76127},{\"end\":76137,\"start\":76136},{\"end\":76765,\"start\":76764},{\"end\":76774,\"start\":76773},{\"end\":76785,\"start\":76784},{\"end\":76795,\"start\":76794},{\"end\":77144,\"start\":77143},{\"end\":77155,\"start\":77154},{\"end\":77168,\"start\":77167},{\"end\":77568,\"start\":77567},{\"end\":77579,\"start\":77578},{\"end\":77592,\"start\":77591},{\"end\":77600,\"start\":77599},{\"end\":77944,\"start\":77943},{\"end\":77955,\"start\":77954},{\"end\":78318,\"start\":78317},{\"end\":78329,\"start\":78328},{\"end\":78625,\"start\":78624},{\"end\":78636,\"start\":78635},{\"end\":78648,\"start\":78647},{\"end\":79164,\"start\":79163},{\"end\":79172,\"start\":79171},{\"end\":79180,\"start\":79179},{\"end\":79189,\"start\":79188},{\"end\":79200,\"start\":79199},{\"end\":79212,\"start\":79211},{\"end\":79534,\"start\":79533},{\"end\":79542,\"start\":79541},{\"end\":79554,\"start\":79553},{\"end\":79565,\"start\":79564},{\"end\":79894,\"start\":79893},{\"end\":79904,\"start\":79903},{\"end\":79916,\"start\":79915},{\"end\":80167,\"start\":80166},{\"end\":80179,\"start\":80178},{\"end\":80431,\"start\":80430},{\"end\":80440,\"start\":80439},{\"end\":80451,\"start\":80450},{\"end\":80461,\"start\":80460},{\"end\":80470,\"start\":80469},{\"end\":80712,\"start\":80711},{\"end\":80714,\"start\":80713},{\"end\":80725,\"start\":80724},{\"end\":80736,\"start\":80735},{\"end\":80738,\"start\":80737},{\"end\":80748,\"start\":80747},{\"end\":80956,\"start\":80955},{\"end\":80969,\"start\":80968},{\"end\":80985,\"start\":80984},{\"end\":80993,\"start\":80992},{\"end\":81003,\"start\":81002},{\"end\":81011,\"start\":81010},{\"end\":81027,\"start\":81026},{\"end\":81029,\"start\":81028},{\"end\":81042,\"start\":81038},{\"end\":81049,\"start\":81048},{\"end\":81060,\"start\":81059},{\"end\":81447,\"start\":81446},{\"end\":81459,\"start\":81458},{\"end\":81838,\"start\":81837},{\"end\":82049,\"start\":82048},{\"end\":82060,\"start\":82059},{\"end\":82068,\"start\":82067},{\"end\":82519,\"start\":82518},{\"end\":82530,\"start\":82529},{\"end\":82540,\"start\":82539},{\"end\":82552,\"start\":82551},{\"end\":82866,\"start\":82865},{\"end\":82877,\"start\":82876},{\"end\":83195,\"start\":83194},{\"end\":83628,\"start\":83627},{\"end\":83637,\"start\":83636},{\"end\":83649,\"start\":83648},{\"end\":83657,\"start\":83656},{\"end\":83669,\"start\":83668},{\"end\":83679,\"start\":83678},{\"end\":84014,\"start\":84013},{\"end\":84022,\"start\":84021},{\"end\":84372,\"start\":84371},{\"end\":84385,\"start\":84384},{\"end\":84394,\"start\":84393},{\"end\":84405,\"start\":84404},{\"end\":84417,\"start\":84416},{\"end\":84812,\"start\":84811},{\"end\":84823,\"start\":84822},{\"end\":84835,\"start\":84834},{\"end\":85200,\"start\":85199},{\"end\":85203,\"start\":85201},{\"end\":85212,\"start\":85211},{\"end\":85221,\"start\":85220},{\"end\":85232,\"start\":85231},{\"end\":85800,\"start\":85799},{\"end\":85817,\"start\":85816},{\"end\":85829,\"start\":85828},{\"end\":85841,\"start\":85840},{\"end\":86142,\"start\":86141},{\"end\":86483,\"start\":86482},{\"end\":86495,\"start\":86494},{\"end\":86505,\"start\":86504},{\"end\":86514,\"start\":86513},{\"end\":86520,\"start\":86519},{\"end\":86532,\"start\":86531},{\"end\":86543,\"start\":86542},{\"end\":86552,\"start\":86551},{\"end\":86567,\"start\":86563},{\"end\":86573,\"start\":86572},{\"end\":86943,\"start\":86942},{\"end\":86945,\"start\":86944},{\"end\":86955,\"start\":86954},{\"end\":86965,\"start\":86964},{\"end\":86976,\"start\":86975},{\"end\":86987,\"start\":86986},{\"end\":86996,\"start\":86995},{\"end\":87007,\"start\":87006},{\"end\":87009,\"start\":87008},{\"end\":87022,\"start\":87021},{\"end\":87034,\"start\":87033},{\"end\":87322,\"start\":87321},{\"end\":87414,\"start\":87413},{\"end\":87427,\"start\":87426},{\"end\":87437,\"start\":87436},{\"end\":87641,\"start\":87640},{\"end\":87650,\"start\":87649},{\"end\":87656,\"start\":87655},{\"end\":87664,\"start\":87663},{\"end\":87678,\"start\":87674},{\"end\":87687,\"start\":87686},{\"end\":87695,\"start\":87694},{\"end\":88036,\"start\":88035},{\"end\":88038,\"start\":88037},{\"end\":88047,\"start\":88046},{\"end\":88059,\"start\":88058},{\"end\":88069,\"start\":88068},{\"end\":88414,\"start\":88413},{\"end\":88422,\"start\":88421},{\"end\":88432,\"start\":88431},{\"end\":88442,\"start\":88441},{\"end\":88454,\"start\":88453},{\"end\":88465,\"start\":88464},{\"end\":88477,\"start\":88476},{\"end\":88489,\"start\":88488},{\"end\":88963,\"start\":88962},{\"end\":88973,\"start\":88972},{\"end\":89549,\"start\":89548},{\"end\":89564,\"start\":89563},{\"end\":89573,\"start\":89572},{\"end\":90058,\"start\":90057},{\"end\":90060,\"start\":90059},{\"end\":90287,\"start\":90286},{\"end\":90301,\"start\":90300},{\"end\":90481,\"start\":90480},{\"end\":90483,\"start\":90482},{\"end\":90496,\"start\":90495},{\"end\":90505,\"start\":90504}]", "bib_author_last_name": "[{\"end\":72838,\"start\":72831},{\"end\":73013,\"start\":73007},{\"end\":73027,\"start\":73019},{\"end\":73040,\"start\":73033},{\"end\":73050,\"start\":73044},{\"end\":73067,\"start\":73056},{\"end\":73078,\"start\":73073},{\"end\":73086,\"start\":73084},{\"end\":73415,\"start\":73410},{\"end\":73427,\"start\":73419},{\"end\":73438,\"start\":73431},{\"end\":73724,\"start\":73720},{\"end\":73738,\"start\":73728},{\"end\":73749,\"start\":73742},{\"end\":73758,\"start\":73753},{\"end\":74148,\"start\":74144},{\"end\":74160,\"start\":74152},{\"end\":74170,\"start\":74166},{\"end\":74184,\"start\":74174},{\"end\":74196,\"start\":74188},{\"end\":74208,\"start\":74200},{\"end\":74504,\"start\":74496},{\"end\":74517,\"start\":74510},{\"end\":74691,\"start\":74685},{\"end\":74708,\"start\":74697},{\"end\":74718,\"start\":74712},{\"end\":74728,\"start\":74722},{\"end\":74736,\"start\":74732},{\"end\":74745,\"start\":74740},{\"end\":74757,\"start\":74749},{\"end\":74766,\"start\":74761},{\"end\":75041,\"start\":75035},{\"end\":75053,\"start\":75047},{\"end\":75516,\"start\":75512},{\"end\":75525,\"start\":75520},{\"end\":75532,\"start\":75529},{\"end\":75544,\"start\":75536},{\"end\":75555,\"start\":75551},{\"end\":75566,\"start\":75562},{\"end\":75943,\"start\":75937},{\"end\":75954,\"start\":75947},{\"end\":75966,\"start\":75958},{\"end\":75978,\"start\":75970},{\"end\":75987,\"start\":75982},{\"end\":75998,\"start\":75991},{\"end\":76008,\"start\":76002},{\"end\":76018,\"start\":76012},{\"end\":76030,\"start\":76022},{\"end\":76041,\"start\":76036},{\"end\":76053,\"start\":76045},{\"end\":76062,\"start\":76057},{\"end\":76075,\"start\":76066},{\"end\":76084,\"start\":76079},{\"end\":76096,\"start\":76090},{\"end\":76104,\"start\":76100},{\"end\":76113,\"start\":76108},{\"end\":76123,\"start\":76117},{\"end\":76134,\"start\":76129},{\"end\":76146,\"start\":76138},{\"end\":76771,\"start\":76766},{\"end\":76782,\"start\":76775},{\"end\":76792,\"start\":76786},{\"end\":76800,\"start\":76796},{\"end\":77152,\"start\":77145},{\"end\":77165,\"start\":77156},{\"end\":77177,\"start\":77169},{\"end\":77576,\"start\":77569},{\"end\":77589,\"start\":77580},{\"end\":77597,\"start\":77593},{\"end\":77609,\"start\":77601},{\"end\":77952,\"start\":77945},{\"end\":77964,\"start\":77956},{\"end\":78326,\"start\":78319},{\"end\":78338,\"start\":78330},{\"end\":78633,\"start\":78626},{\"end\":78645,\"start\":78637},{\"end\":78653,\"start\":78649},{\"end\":79169,\"start\":79165},{\"end\":79177,\"start\":79173},{\"end\":79186,\"start\":79181},{\"end\":79197,\"start\":79190},{\"end\":79209,\"start\":79201},{\"end\":79222,\"start\":79213},{\"end\":79539,\"start\":79535},{\"end\":79551,\"start\":79543},{\"end\":79562,\"start\":79555},{\"end\":79575,\"start\":79566},{\"end\":79901,\"start\":79895},{\"end\":79913,\"start\":79905},{\"end\":79924,\"start\":79917},{\"end\":80176,\"start\":80168},{\"end\":80186,\"start\":80180},{\"end\":80437,\"start\":80432},{\"end\":80448,\"start\":80441},{\"end\":80458,\"start\":80452},{\"end\":80467,\"start\":80462},{\"end\":80485,\"start\":80471},{\"end\":80722,\"start\":80715},{\"end\":80733,\"start\":80726},{\"end\":80745,\"start\":80739},{\"end\":80755,\"start\":80749},{\"end\":80966,\"start\":80957},{\"end\":80982,\"start\":80970},{\"end\":80990,\"start\":80986},{\"end\":81000,\"start\":80994},{\"end\":81008,\"start\":81004},{\"end\":81024,\"start\":81012},{\"end\":81036,\"start\":81030},{\"end\":81046,\"start\":81043},{\"end\":81057,\"start\":81050},{\"end\":81069,\"start\":81061},{\"end\":81456,\"start\":81448},{\"end\":81464,\"start\":81460},{\"end\":81846,\"start\":81839},{\"end\":82057,\"start\":82050},{\"end\":82065,\"start\":82061},{\"end\":82077,\"start\":82069},{\"end\":82527,\"start\":82520},{\"end\":82537,\"start\":82531},{\"end\":82549,\"start\":82541},{\"end\":82561,\"start\":82553},{\"end\":82874,\"start\":82867},{\"end\":82886,\"start\":82878},{\"end\":83205,\"start\":83196},{\"end\":83634,\"start\":83629},{\"end\":83646,\"start\":83638},{\"end\":83654,\"start\":83650},{\"end\":83666,\"start\":83658},{\"end\":83676,\"start\":83670},{\"end\":83687,\"start\":83680},{\"end\":84019,\"start\":84015},{\"end\":84031,\"start\":84023},{\"end\":84382,\"start\":84373},{\"end\":84391,\"start\":84386},{\"end\":84402,\"start\":84395},{\"end\":84414,\"start\":84406},{\"end\":84422,\"start\":84418},{\"end\":84820,\"start\":84813},{\"end\":84832,\"start\":84824},{\"end\":84844,\"start\":84836},{\"end\":85209,\"start\":85204},{\"end\":85218,\"start\":85213},{\"end\":85229,\"start\":85222},{\"end\":85238,\"start\":85233},{\"end\":85814,\"start\":85801},{\"end\":85826,\"start\":85818},{\"end\":85838,\"start\":85830},{\"end\":85850,\"start\":85842},{\"end\":86151,\"start\":86143},{\"end\":86492,\"start\":86484},{\"end\":86502,\"start\":86496},{\"end\":86511,\"start\":86506},{\"end\":86517,\"start\":86515},{\"end\":86529,\"start\":86521},{\"end\":86540,\"start\":86533},{\"end\":86549,\"start\":86544},{\"end\":86561,\"start\":86553},{\"end\":86570,\"start\":86568},{\"end\":86580,\"start\":86574},{\"end\":86952,\"start\":86946},{\"end\":86962,\"start\":86956},{\"end\":86973,\"start\":86966},{\"end\":86984,\"start\":86977},{\"end\":86993,\"start\":86988},{\"end\":87004,\"start\":86997},{\"end\":87019,\"start\":87010},{\"end\":87031,\"start\":87023},{\"end\":87043,\"start\":87035},{\"end\":87328,\"start\":87323},{\"end\":87424,\"start\":87415},{\"end\":87434,\"start\":87428},{\"end\":87446,\"start\":87438},{\"end\":87647,\"start\":87642},{\"end\":87653,\"start\":87651},{\"end\":87661,\"start\":87657},{\"end\":87672,\"start\":87665},{\"end\":87684,\"start\":87679},{\"end\":87692,\"start\":87688},{\"end\":87703,\"start\":87696},{\"end\":88044,\"start\":88039},{\"end\":88056,\"start\":88048},{\"end\":88066,\"start\":88060},{\"end\":88076,\"start\":88070},{\"end\":88419,\"start\":88415},{\"end\":88429,\"start\":88423},{\"end\":88439,\"start\":88433},{\"end\":88451,\"start\":88443},{\"end\":88462,\"start\":88455},{\"end\":88474,\"start\":88466},{\"end\":88486,\"start\":88478},{\"end\":88498,\"start\":88490},{\"end\":88970,\"start\":88964},{\"end\":88982,\"start\":88974},{\"end\":89561,\"start\":89550},{\"end\":89570,\"start\":89565},{\"end\":89583,\"start\":89574},{\"end\":90069,\"start\":90061},{\"end\":90298,\"start\":90288},{\"end\":90306,\"start\":90302},{\"end\":90493,\"start\":90484},{\"end\":90502,\"start\":90497},{\"end\":90513,\"start\":90506}]", "bib_entry": "[{\"attributes\":{\"id\":\"b0\"},\"end\":72769,\"start\":72632},{\"attributes\":{\"id\":\"b1\"},\"end\":72941,\"start\":72771},{\"attributes\":{\"id\":\"b2\",\"matched_paper_id\":2889261},\"end\":73343,\"start\":72943},{\"attributes\":{\"doi\":\"10.1111/cgf.12605\",\"id\":\"b3\",\"matched_paper_id\":11492133},\"end\":73655,\"start\":73345},{\"attributes\":{\"doi\":\"doi: 10. 1109/TVCG.2017.2743980\",\"id\":\"b4\",\"matched_paper_id\":8517610},\"end\":74081,\"start\":73657},{\"attributes\":{\"id\":\"b5\",\"matched_paper_id\":2288154},\"end\":74426,\"start\":74083},{\"attributes\":{\"id\":\"b6\"},\"end\":74631,\"start\":74428},{\"attributes\":{\"id\":\"b7\"},\"end\":74976,\"start\":74633},{\"attributes\":{\"id\":\"b8\",\"matched_paper_id\":2820629},\"end\":75423,\"start\":74978},{\"attributes\":{\"id\":\"b9\",\"matched_paper_id\":10719683},\"end\":75862,\"start\":75425},{\"attributes\":{\"id\":\"b10\",\"matched_paper_id\":2339107},\"end\":76632,\"start\":75864},{\"attributes\":{\"id\":\"b11\",\"matched_paper_id\":16028174},\"end\":77046,\"start\":76634},{\"attributes\":{\"id\":\"b12\",\"matched_paper_id\":13633266},\"end\":77494,\"start\":77048},{\"attributes\":{\"id\":\"b13\",\"matched_paper_id\":21675132},\"end\":77845,\"start\":77496},{\"attributes\":{\"id\":\"b14\",\"matched_paper_id\":8200698},\"end\":78200,\"start\":77847},{\"attributes\":{\"doi\":\"10.1111/cgf.13320\",\"id\":\"b15\",\"matched_paper_id\":51875566},\"end\":78579,\"start\":78202},{\"attributes\":{\"id\":\"b16\",\"matched_paper_id\":12193176},\"end\":78962,\"start\":78581},{\"attributes\":{\"id\":\"b17\"},\"end\":79096,\"start\":78964},{\"attributes\":{\"id\":\"b18\",\"matched_paper_id\":1268022},\"end\":79462,\"start\":79098},{\"attributes\":{\"doi\":\"10.1109/TVCG.2018.2864816\",\"id\":\"b19\",\"matched_paper_id\":52057217},\"end\":79834,\"start\":79464},{\"attributes\":{\"id\":\"b20\",\"matched_paper_id\":14562378},\"end\":80164,\"start\":79836},{\"attributes\":{\"id\":\"b21\"},\"end\":80357,\"start\":80166},{\"attributes\":{\"id\":\"b22\",\"matched_paper_id\":5382788},\"end\":80707,\"start\":80359},{\"attributes\":{\"id\":\"b23\"},\"end\":80892,\"start\":80709},{\"attributes\":{\"id\":\"b24\",\"matched_paper_id\":12711874},\"end\":81375,\"start\":80894},{\"attributes\":{\"doi\":\"10.1109/TVCG.2018.2867488\",\"id\":\"b25\",\"matched_paper_id\":52159487},\"end\":81746,\"start\":81377},{\"attributes\":{\"id\":\"b26\"},\"end\":82020,\"start\":81748},{\"attributes\":{\"doi\":\"2016.10.1109/TVCG.2015.2467294\",\"id\":\"b27\"},\"end\":82435,\"start\":82022},{\"attributes\":{\"id\":\"b28\",\"matched_paper_id\":19127869},\"end\":82768,\"start\":82437},{\"attributes\":{\"id\":\"b29\",\"matched_paper_id\":520298},\"end\":83164,\"start\":82770},{\"attributes\":{\"id\":\"b30\",\"matched_paper_id\":2625454},\"end\":83528,\"start\":83166},{\"attributes\":{\"doi\":\"10.1039/C8CC00105G\",\"id\":\"b31\",\"matched_paper_id\":4060759},\"end\":83952,\"start\":83530},{\"attributes\":{\"id\":\"b32\",\"matched_paper_id\":52070543},\"end\":84288,\"start\":83954},{\"attributes\":{\"id\":\"b33\",\"matched_paper_id\":218178},\"end\":84716,\"start\":84290},{\"attributes\":{\"id\":\"b34\",\"matched_paper_id\":51877897},\"end\":85105,\"start\":84718},{\"attributes\":{\"id\":\"b35\",\"matched_paper_id\":7148009},\"end\":85567,\"start\":85107},{\"attributes\":{\"id\":\"b36\"},\"end\":85712,\"start\":85569},{\"attributes\":{\"id\":\"b37\",\"matched_paper_id\":8211514},\"end\":86102,\"start\":85714},{\"attributes\":{\"doi\":\"10.1109/TVCG.2012.133\",\"id\":\"b38\",\"matched_paper_id\":2277704},\"end\":86396,\"start\":86104},{\"attributes\":{\"id\":\"b39\",\"matched_paper_id\":741554},\"end\":86889,\"start\":86398},{\"attributes\":{\"id\":\"b40\",\"matched_paper_id\":9137678},\"end\":87283,\"start\":86891},{\"attributes\":{\"id\":\"b41\"},\"end\":87411,\"start\":87285},{\"attributes\":{\"id\":\"b42\"},\"end\":87579,\"start\":87413},{\"attributes\":{\"id\":\"b43\",\"matched_paper_id\":52067753},\"end\":87963,\"start\":87581},{\"attributes\":{\"doi\":\"10.1111/j.1467-8659.2010.01830.x\",\"id\":\"b44\",\"matched_paper_id\":12435815},\"end\":88341,\"start\":87965},{\"attributes\":{\"doi\":\"10.1109/TVCG.2016.2598826\",\"id\":\"b45\",\"matched_paper_id\":8678723},\"end\":88869,\"start\":88343},{\"attributes\":{\"id\":\"b46\",\"matched_paper_id\":8495297},\"end\":89292,\"start\":88871},{\"attributes\":{\"id\":\"b47\"},\"end\":89419,\"start\":89294},{\"attributes\":{\"doi\":\"10.4103/2153-3539.129452\",\"id\":\"b48\",\"matched_paper_id\":5987119},\"end\":89895,\"start\":89421},{\"attributes\":{\"id\":\"b49\"},\"end\":90027,\"start\":89897},{\"attributes\":{\"id\":\"b50\",\"matched_paper_id\":7039904},\"end\":90214,\"start\":90029},{\"attributes\":{\"id\":\"b51\",\"matched_paper_id\":18679897},\"end\":90451,\"start\":90216},{\"attributes\":{\"id\":\"b52\"},\"end\":90620,\"start\":90453}]", "bib_title": "[{\"end\":73003,\"start\":72943},{\"end\":73406,\"start\":73345},{\"end\":73716,\"start\":73657},{\"end\":74140,\"start\":74083},{\"end\":75031,\"start\":74978},{\"end\":75505,\"start\":75425},{\"end\":75933,\"start\":75864},{\"end\":76762,\"start\":76634},{\"end\":77141,\"start\":77048},{\"end\":77565,\"start\":77496},{\"end\":77941,\"start\":77847},{\"end\":78315,\"start\":78202},{\"end\":78622,\"start\":78581},{\"end\":79161,\"start\":79098},{\"end\":79531,\"start\":79464},{\"end\":79891,\"start\":79836},{\"end\":80428,\"start\":80359},{\"end\":80953,\"start\":80894},{\"end\":81444,\"start\":81377},{\"end\":82046,\"start\":82022},{\"end\":82516,\"start\":82437},{\"end\":82863,\"start\":82770},{\"end\":83192,\"start\":83166},{\"end\":83625,\"start\":83530},{\"end\":84011,\"start\":83954},{\"end\":84369,\"start\":84290},{\"end\":84809,\"start\":84718},{\"end\":85197,\"start\":85107},{\"end\":85797,\"start\":85714},{\"end\":86139,\"start\":86104},{\"end\":86480,\"start\":86398},{\"end\":86940,\"start\":86891},{\"end\":87638,\"start\":87581},{\"end\":88033,\"start\":87965},{\"end\":88411,\"start\":88343},{\"end\":88960,\"start\":88871},{\"end\":89546,\"start\":89421},{\"end\":90055,\"start\":90029},{\"end\":90284,\"start\":90216}]", "bib_author": "[{\"end\":72840,\"start\":72829},{\"end\":73015,\"start\":73005},{\"end\":73029,\"start\":73015},{\"end\":73042,\"start\":73029},{\"end\":73052,\"start\":73042},{\"end\":73069,\"start\":73052},{\"end\":73080,\"start\":73069},{\"end\":73088,\"start\":73080},{\"end\":73417,\"start\":73408},{\"end\":73429,\"start\":73417},{\"end\":73440,\"start\":73429},{\"end\":73726,\"start\":73718},{\"end\":73740,\"start\":73726},{\"end\":73751,\"start\":73740},{\"end\":73760,\"start\":73751},{\"end\":74150,\"start\":74142},{\"end\":74162,\"start\":74150},{\"end\":74172,\"start\":74162},{\"end\":74186,\"start\":74172},{\"end\":74198,\"start\":74186},{\"end\":74210,\"start\":74198},{\"end\":74506,\"start\":74494},{\"end\":74519,\"start\":74506},{\"end\":74693,\"start\":74683},{\"end\":74710,\"start\":74693},{\"end\":74720,\"start\":74710},{\"end\":74730,\"start\":74720},{\"end\":74738,\"start\":74730},{\"end\":74747,\"start\":74738},{\"end\":74759,\"start\":74747},{\"end\":74768,\"start\":74759},{\"end\":75043,\"start\":75033},{\"end\":75055,\"start\":75043},{\"end\":75518,\"start\":75507},{\"end\":75527,\"start\":75518},{\"end\":75534,\"start\":75527},{\"end\":75546,\"start\":75534},{\"end\":75557,\"start\":75546},{\"end\":75568,\"start\":75557},{\"end\":75945,\"start\":75935},{\"end\":75956,\"start\":75945},{\"end\":75968,\"start\":75956},{\"end\":75980,\"start\":75968},{\"end\":75989,\"start\":75980},{\"end\":76000,\"start\":75989},{\"end\":76010,\"start\":76000},{\"end\":76020,\"start\":76010},{\"end\":76032,\"start\":76020},{\"end\":76043,\"start\":76032},{\"end\":76055,\"start\":76043},{\"end\":76064,\"start\":76055},{\"end\":76077,\"start\":76064},{\"end\":76086,\"start\":76077},{\"end\":76098,\"start\":76086},{\"end\":76106,\"start\":76098},{\"end\":76115,\"start\":76106},{\"end\":76125,\"start\":76115},{\"end\":76136,\"start\":76125},{\"end\":76148,\"start\":76136},{\"end\":76773,\"start\":76764},{\"end\":76784,\"start\":76773},{\"end\":76794,\"start\":76784},{\"end\":76802,\"start\":76794},{\"end\":77154,\"start\":77143},{\"end\":77167,\"start\":77154},{\"end\":77179,\"start\":77167},{\"end\":77578,\"start\":77567},{\"end\":77591,\"start\":77578},{\"end\":77599,\"start\":77591},{\"end\":77611,\"start\":77599},{\"end\":77954,\"start\":77943},{\"end\":77966,\"start\":77954},{\"end\":78328,\"start\":78317},{\"end\":78340,\"start\":78328},{\"end\":78635,\"start\":78624},{\"end\":78647,\"start\":78635},{\"end\":78655,\"start\":78647},{\"end\":79171,\"start\":79163},{\"end\":79179,\"start\":79171},{\"end\":79188,\"start\":79179},{\"end\":79199,\"start\":79188},{\"end\":79211,\"start\":79199},{\"end\":79224,\"start\":79211},{\"end\":79541,\"start\":79533},{\"end\":79553,\"start\":79541},{\"end\":79564,\"start\":79553},{\"end\":79577,\"start\":79564},{\"end\":79903,\"start\":79893},{\"end\":79915,\"start\":79903},{\"end\":79926,\"start\":79915},{\"end\":80178,\"start\":80166},{\"end\":80188,\"start\":80178},{\"end\":80439,\"start\":80430},{\"end\":80450,\"start\":80439},{\"end\":80460,\"start\":80450},{\"end\":80469,\"start\":80460},{\"end\":80487,\"start\":80469},{\"end\":80724,\"start\":80711},{\"end\":80735,\"start\":80724},{\"end\":80747,\"start\":80735},{\"end\":80757,\"start\":80747},{\"end\":80968,\"start\":80955},{\"end\":80984,\"start\":80968},{\"end\":80992,\"start\":80984},{\"end\":81002,\"start\":80992},{\"end\":81010,\"start\":81002},{\"end\":81026,\"start\":81010},{\"end\":81038,\"start\":81026},{\"end\":81048,\"start\":81038},{\"end\":81059,\"start\":81048},{\"end\":81071,\"start\":81059},{\"end\":81458,\"start\":81446},{\"end\":81466,\"start\":81458},{\"end\":81848,\"start\":81837},{\"end\":82059,\"start\":82048},{\"end\":82067,\"start\":82059},{\"end\":82079,\"start\":82067},{\"end\":82529,\"start\":82518},{\"end\":82539,\"start\":82529},{\"end\":82551,\"start\":82539},{\"end\":82563,\"start\":82551},{\"end\":82876,\"start\":82865},{\"end\":82888,\"start\":82876},{\"end\":83207,\"start\":83194},{\"end\":83636,\"start\":83627},{\"end\":83648,\"start\":83636},{\"end\":83656,\"start\":83648},{\"end\":83668,\"start\":83656},{\"end\":83678,\"start\":83668},{\"end\":83689,\"start\":83678},{\"end\":84021,\"start\":84013},{\"end\":84033,\"start\":84021},{\"end\":84384,\"start\":84371},{\"end\":84393,\"start\":84384},{\"end\":84404,\"start\":84393},{\"end\":84416,\"start\":84404},{\"end\":84424,\"start\":84416},{\"end\":84822,\"start\":84811},{\"end\":84834,\"start\":84822},{\"end\":84846,\"start\":84834},{\"end\":85211,\"start\":85199},{\"end\":85220,\"start\":85211},{\"end\":85231,\"start\":85220},{\"end\":85240,\"start\":85231},{\"end\":85816,\"start\":85799},{\"end\":85828,\"start\":85816},{\"end\":85840,\"start\":85828},{\"end\":85852,\"start\":85840},{\"end\":86153,\"start\":86141},{\"end\":86494,\"start\":86482},{\"end\":86504,\"start\":86494},{\"end\":86513,\"start\":86504},{\"end\":86519,\"start\":86513},{\"end\":86531,\"start\":86519},{\"end\":86542,\"start\":86531},{\"end\":86551,\"start\":86542},{\"end\":86563,\"start\":86551},{\"end\":86572,\"start\":86563},{\"end\":86582,\"start\":86572},{\"end\":86954,\"start\":86942},{\"end\":86964,\"start\":86954},{\"end\":86975,\"start\":86964},{\"end\":86986,\"start\":86975},{\"end\":86995,\"start\":86986},{\"end\":87006,\"start\":86995},{\"end\":87021,\"start\":87006},{\"end\":87033,\"start\":87021},{\"end\":87045,\"start\":87033},{\"end\":87330,\"start\":87321},{\"end\":87426,\"start\":87413},{\"end\":87436,\"start\":87426},{\"end\":87448,\"start\":87436},{\"end\":87649,\"start\":87640},{\"end\":87655,\"start\":87649},{\"end\":87663,\"start\":87655},{\"end\":87674,\"start\":87663},{\"end\":87686,\"start\":87674},{\"end\":87694,\"start\":87686},{\"end\":87705,\"start\":87694},{\"end\":88046,\"start\":88035},{\"end\":88058,\"start\":88046},{\"end\":88068,\"start\":88058},{\"end\":88078,\"start\":88068},{\"end\":88421,\"start\":88413},{\"end\":88431,\"start\":88421},{\"end\":88441,\"start\":88431},{\"end\":88453,\"start\":88441},{\"end\":88464,\"start\":88453},{\"end\":88476,\"start\":88464},{\"end\":88488,\"start\":88476},{\"end\":88500,\"start\":88488},{\"end\":88972,\"start\":88962},{\"end\":88984,\"start\":88972},{\"end\":89563,\"start\":89548},{\"end\":89572,\"start\":89563},{\"end\":89585,\"start\":89572},{\"end\":90071,\"start\":90057},{\"end\":90300,\"start\":90286},{\"end\":90308,\"start\":90300},{\"end\":90495,\"start\":90480},{\"end\":90504,\"start\":90495},{\"end\":90515,\"start\":90504}]", "bib_venue": "[{\"end\":74251,\"start\":74239},{\"end\":75220,\"start\":75146},{\"end\":77286,\"start\":77241},{\"end\":78763,\"start\":78749},{\"end\":83356,\"start\":83290},{\"end\":89091,\"start\":89046},{\"end\":72672,\"start\":72632},{\"end\":72827,\"start\":72771},{\"end\":73114,\"start\":73088},{\"end\":73480,\"start\":73457},{\"end\":73847,\"start\":73791},{\"end\":74237,\"start\":74210},{\"end\":74492,\"start\":74428},{\"end\":74681,\"start\":74633},{\"end\":75144,\"start\":75055},{\"end\":75624,\"start\":75568},{\"end\":76220,\"start\":76148},{\"end\":76824,\"start\":76802},{\"end\":77239,\"start\":77179},{\"end\":77650,\"start\":77611},{\"end\":78011,\"start\":77966},{\"end\":78380,\"start\":78357},{\"end\":78747,\"start\":78655},{\"end\":79023,\"start\":78966},{\"end\":79260,\"start\":79224},{\"end\":79632,\"start\":79602},{\"end\":79982,\"start\":79926},{\"end\":80245,\"start\":80188},{\"end\":80519,\"start\":80487},{\"end\":80789,\"start\":80757},{\"end\":81110,\"start\":81071},{\"end\":81547,\"start\":81491},{\"end\":81835,\"start\":81748},{\"end\":82210,\"start\":82109},{\"end\":82586,\"start\":82563},{\"end\":82951,\"start\":82888},{\"end\":83288,\"start\":83207},{\"end\":83719,\"start\":83707},{\"end\":84106,\"start\":84033},{\"end\":84438,\"start\":84424},{\"end\":84869,\"start\":84846},{\"end\":85297,\"start\":85240},{\"end\":85634,\"start\":85571},{\"end\":85891,\"start\":85852},{\"end\":86230,\"start\":86174},{\"end\":86621,\"start\":86582},{\"end\":87068,\"start\":87045},{\"end\":87319,\"start\":87285},{\"end\":87482,\"start\":87448},{\"end\":87761,\"start\":87705},{\"end\":88133,\"start\":88110},{\"end\":88581,\"start\":88525},{\"end\":89044,\"start\":88984},{\"end\":89350,\"start\":89296},{\"end\":89641,\"start\":89609},{\"end\":89955,\"start\":89899},{\"end\":90104,\"start\":90071},{\"end\":90325,\"start\":90308},{\"end\":90478,\"start\":90453}]"}}}, "year": 2023, "month": 12, "day": 17}