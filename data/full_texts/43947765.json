{"id": 43947765, "updated": "2023-09-30 20:51:17.215", "metadata": {"title": "Towards Robust Evaluations of Continual Learning", "authors": "[{\"first\":\"Sebastian\",\"last\":\"Farquhar\",\"middle\":[]},{\"first\":\"Yarin\",\"last\":\"Gal\",\"middle\":[]}]", "venue": "ArXiv", "journal": "ArXiv", "publication_date": {"year": 2018, "month": 5, "day": 24}, "abstract": "The experiments used in current continual learning research do not faithfully assess fundamental challenges of learning continually. We examine standard evaluations and show why these evaluations make some types of continual learning approaches look better than they are. In particular, current evaluations are biased towards continual learning approaches that treat previous models as a prior (e.g., EWC, VCL). We introduce desiderata for continual learning evaluations and explain why their absence creates misleading comparisons. Our analysis calls for a reprioritization of research effort by the community.", "fields_of_study": "[\"Mathematics\",\"Computer Science\"]", "external_ids": {"arxiv": "1805.09733", "mag": "2804746922", "acl": null, "pubmed": null, "pubmedcentral": null, "dblp": "journals/corr/abs-1805-09733", "doi": null}}, "content": {"source": {"pdf_hash": "9d8bfd44e956ee483db60495ff84f70443728636", "pdf_src": "Arxiv", "pdf_uri": "[\"https://arxiv.org/pdf/1805.09733v2.pdf\"]", "oa_url_match": false, "oa_info": null}, "grobid": {"id": "8d81e14dbbfd70055783ae85bb62790dd972f491", "type": "plain-text", "url": "s3://ai2-s2-pdf-extraction-prod/parse-results/s2orc_worker/9d8bfd44e956ee483db60495ff84f70443728636.txt", "contents": "\nTowards Robust Evaluations of Continual Learning\n\n\nSebastian Farquhar \nOATML Group\nOATML Group\nUniversity of Oxford\nUniversity of Oxford\n\n\nYarin Gal \nOATML Group\nOATML Group\nUniversity of Oxford\nUniversity of Oxford\n\n\nTowards Robust Evaluations of Continual Learning\n\nThe experiments used in current continual learning research do not faithfully assess fundamental challenges of learning continually. We examine standard evaluations and show why these evaluations make some types of continual learning approaches look better than they are. In particular, current evaluations are biased towards continual learning approaches that treat previous models as a prior (e.g., EWC, VCL). We introduce desiderata for continual learning evaluations and explain why their absence creates misleading comparisons. Our analysis calls for a reprioritization of research effort by the community.\n\nINTRODUCTION\n\nCertain applications require continual learningsplitting training into a series of tasks and discarding the data after training each task. These settings vary tremendously. If data relate to individuals it may be unethical, illegal, or imprudent to retain old datasets: for example, a hospital might want to delete old patient data. In other applications, real-time systems could face distributional shifts with an underlying distribution which changes faster than the time it would take to retrain a new model with all the data. For example, a quad-copter might react to changes in wind patterns. Neural networks trained on such series of tasks tend to forget earlier tasks (often referred to as catastrophic forgetting).\n\nRecent works have shown promising advances towards continual learning by adding regularization terms to the loss function which preserve important parameters (Kirkpatrick et al., 2017;Zenke et al., 2017;Nguyen Preliminary work. et al., 2018;Chaudhry et al., 2018;Ritter et al., 2018). We call these approaches 'prior-focused' because they can be interpreted as treating intermediate models as priors when learning updated weights. However, experimental evaluations in these recent works have major blind-spots which mask weak-points of current approaches. The design of the evaluations does not reflect the core motivations for continual learning, regardless of the dataset used, including evaluations based on MNIST (LeCun et al., 1998), notMNIST (Bulatov, 2011), CIFAR10 (Krizhevsky, 2009) and others. But evaluations which obscure the shortcomings of suggested continual learning solutions impede developments in the field, since researchers are not made aware of limitations of past research.\n\nIn this paper, we offer both a theoretical analysis of the evaluations' shortcomings and empirical evidence showing their bias towards prior-focused architectures. We demonstrate, for example, that prior-focused approaches stop working when the experimental set-up becomes more representative of continual learning. These evaluations can therefore be misleading, because models which perform well according to them can perform very badly on similar, but more representative, continual learning evaluations. Applications of continual learning are very diverse, and authors consider a wide range of settings. To remedy this, rather than propose an overly-narrow shared benchmark, we propose minimal desiderata for experimental evaluations in continual learning to make them more representative of the challenges that motivate the field, regardless of the intended application. We illustrate how these desiderata may be applied to specific datasets to form a robust continual learning evaluation.\n\nSpecifically, our contributions are as follows:\n\n1. We analyse the shortcomings of existing widely used evaluations in continual learning.\n\n2. We show empirically that these evaluations are biased towards prior-focused approaches, masking their limitations.\n\n3. We suggest minimal desiderata for future evaluations, which can be applied regardless of dataset, arXiv:1805.09733v2 [stat.ML] 6 Nov 2018 and illustrate their application.\n\nWhen experiments better reflect the continual learning problem, recent leading approaches fail even on simple datasets like MNIST. Until we improve the experimental design, the field will only show illusory progress on increasingly complex tasks, without overcoming fundamental challenges inherent to continual learning itself.\n\n\nCONTINUAL LEARNING\n\nWe start by formalising the definition of continual learning. In a typical learning setting, we aim to learn parameters w using an independently and identically distributed (i.i.d.) labelled training dataset D \u2261 {(x (i) , y (i) )} to accurately predict p(y * |w, x * ) for an unseen (x * , y * ) pair.\n\nIn the continual learning setting, members of D are not i.i.d. Instead they may be split into disjoint sub-\nsets D t \u2261 {(x (i) t , y (i)\nt )}. These sets are assumed to be drawn from T distinct i.i.d. distributions each of which represents a task. We join many authors in assuming that the tasks are clearly separated, although in general that may not be the case. The challenge of continual learning is to learn a single model which is able to predict well on data from any task, despite training on each task in sequence without revisiting previous tasks. 1 In this paper, we will frequently consider a model after training on some, but not necessarily all T tasks. The t'th model is the state of the model after training on datasets {D 1 : D t }.\n\n\nEXISTING WORK\n\nIn this paper, we critically analyse common evaluations used by the majority of recent papers. In this section, we review existing work focusing first on the methods employed ( \u00a73.1) and second on the evaluations used ( \u00a73.2). Throughout, we provide a framing which anticipates our critical analysis.\n\n\nMethods\n\nApproaches to continual learning and catastrophic forgetting form three main families. First, prior-focused approaches use regularization to create 'elastic' parameters. These include: Elastic Weight Consolidation (EWC) (Kirkpatrick et al., 2017), Synaptic Intelligence (SI) (Zenke et al., 2017), Variational Continual Learning (VCL) (Nguyen et al., 2018), Kroneckerfactored approximated Laplace approximation (Ritter  (Chaudhry et al., 2018). In fact, all of these can be seen as setting a distribution over the parameters of the t \u2212 1'th model as the prior when training on the t'th dataset.\n\nVCL makes this most explicit. VCL is a variational inference (VI) method that uses Bayesian neural networks (MacKay, 1992;Neal, 1995;Blundell et al., 2015). VCL sets the posterior at the end of training a task to be the prior when beginning training for the next task. EWC and SI instead use ordinary neural networks with an L 2 regularization term added to the loss. This regularization reflects a Gaussian prior for each parameter. The means of these priors are the point estimates of the parameters of the t\u22121'th model. They use the approximate Fisher information as a way of estimating the Hessian to assess importance. This implicitly sets the covariance of the parameter prior (which is assumed to be diagonal). Chaudhry et al. (2018) provide a generalization of both SI and EWC. Ritter et al. (2018) extend EWC by relaxing the assumption that the covariance matrix of the parameter distributions is diagonal. Schematically, as the authors of these papers note, these approaches use a similar loss function:\nL t = i log p(y (i) t |w t , x (i) t ) \u2212 c 2 (w t \u2212 w t\u22121 ) T \u03a3 \u22121 t\u22121 (w t \u2212 w t\u22121 )(1)\nwhere \u03a3 is the covariance of the prior, which is estimated differently under each approach. The first term reflects model log-likelihood on the t'th task. The second reflects distance from the model prior. In general, prior-focused approaches rely on the prior term to capture everything learned on previous tasks and only use the newest data to estimate the likelihood term. However, in practice the prior term does not capture everything learned in previous tasks. Some authors boost the performance of prior-focused approaches by sampling data from past tasks when estimating the likeli-hood. Although it has not been presented in this way, we see this sampling as attempting to better estimate the likelihood term of the conjunction of all datasets, which is only necessary when the prior term is not sufficient to capture what has been learned before. For example, VCL is also presented using coresetsstoring very small representative samples of past data. VCL with coresets fine-tunes on the withheld coreset data just before testing. Similarly, RW presents results both with and without training on subsamples of previous datasets. EWC revisits each dataset multiple times.\n\nThese rehearsals begin to blend in the second major family of continual learning approaches. Dual-memory approaches store some summary of seen datasets and partially revisits them. This summary might use a generative model as in Deep Generative Replay (DGR) by Shin et al. (2017). Alternatively it might just be a coreset as in VCL or RW. This family builds on pseudorehearsal introduced by Robins (1995) following a neuroscientific motivation.\n\nThe last major family uses dynamic architectures. These change the structure of the networks in significant ways to incorporate learning from each task separately (e.g., Rusu et al. (2016); Li and Hoiem (2017)). These perform well, but their expanding use of memory creates practical problems. A more thorough survey of these as well as prior-and likelihood-focused approaches can be found in Appendix A.\n\nPrior-focused approaches have received considerable attention in part because the methods are sufficiently general to apply to many architectures and settings. We focus our examination on these methods, because they seem to represent the most exciting recent advances in continual learning, but the experiments used to support them may not be fairly evaluating their performance.\n\n\nExperimental Evaluations\n\nIn this section we give an in-depth review of key experimental evaluations as they are used in current research. We illustrate our critique using the most commonly performed experiments using variations of the MNIST dataset: Permuted MNIST and Split MNIST, most commonly in multi-headed form. Although we emphasise MNIST for explanatory purposes, our critique in \u00a74 applies to many other evaluations which share similar design choices.\n\n\nPermuted MNIST\n\nThe Permuted MNIST experiment was introduced in Goodfellow et al. (2013). In their experiment, a model is trained on MNIST as D 1 . Each later D t for 1 < t \u2264 10 is constructed from the MNIST data but with the pixels of each digit randomly permuted. A fresh permutation is drawn for each task and applied to all images in the same way for that task. After training on each dataset, one evaluates the model on each of the previous datasets as well as the current. Goodfellow et al. (2013) used this experiment to investigate feature extraction, but it has since become a mainstay for continual learning evaluation (Zenke et al., 2017;Shin et al., 2017;Kirkpatrick et al., 2017;Lee et al., 2017;Lopez-paz and Ranzato, 2017;Nguyen et al., 2018;Ritter et al., 2018). \n\n\nSplit MNIST\n\n\nCRITICAL ANALYSIS OF EXISTING EVALUATIONS\n\nPermuted MNIST and multi-headed Split MNIST are commonly used to compare continual learning algorithms. However, each of these makes continual learning easier for prior-focused approaches. Continual learning is at its hardest when new tasks resemble old ones, enough that the model makes confident but incorrect predictions on the new data. Prior-focused approaches fail in such cases, because the models used to represent the prior are insufficiently expressive, and existing evaluations do not capture these scenarios. In this section we will provide a theoretical critique of these experiments. In \u00a76, we evaluate these analyses empirically.\n\nAlthough we use MNIST as a case study here, our analysis is much more general. For example, all of our critiques of the way MNIST is used by Zenke et al.\n\n(2017) apply also to their use of the CIFAR100 dataset, the use of notMNIST, Fashion MNIST, SVHN and CI-FAR10 in Ritter et al. (2018), and the use of notM-NIST in (Nguyen et al., 2018). These critiques are about experimental design, not dataset choice.\n\n\nPermuted MNIST\n\nPermuted MNIST represents an unrealistic best case scenario for continual learning. The permutation means that most inputs from the new dataset D t resemble none of the classes from D t\u22121 . In practice, this means that during early training on D t the model is unrealistically unconfident. It's strongest predictions have low output probabilities compared with more realistic continual learning setups. Unconfident, small probability predictions lead to smaller gradients.\n\nBecause of the loss function used in prior-focused continual learning, shown in equation (1), these smaller gradients lead to less forgetting. This loss function can be separated into a prior term and a likelihood term. Crucially, the prior term is data-independent and therefore the same regardless of the t'th dataset for a given t \u2212 1'th model. The likelihood term, however, is data-dependent. In particular, the gradients of the final layer with respect to the likelihood term of the loss tend to be large when the model makes confident but incorrect predictions. The derivative of the likelihood term in the loss with respect to each output weight w k in the output layer of a model is \u2202L \u2202o k = p k \u2212 y k where y k is the k'th entry of a onehot vector of labels and p k is the probability predicted for class k. Assume the ground truth class for a certain input is c which was not present in previously seen data. A confident incorrect prediction of class c would mean large magnitude gradients for the desired unit c which we want to adapt, but also for output unit c , a class found in the previous task, which we do not wish to change. On the other hand, uniform output probabilities reduce the magnitude of the gradient for all units apart from c, resulting in lower average gradients corresponding to the likelihood term of the loss function. This tendency towards much larger gradients given confident, false, predictions is only true in general for the output layer. However, especially early in training, output layer gradients are several orders of magnitude larger than gradients further into the model. Moreover, it suffices, for our purposes, to show that the Permuted setting protects the prior-focused loss from systematic large mis-estimates for an important subset of its gradients.\n\nIf the prior term fully captures correct class of models, its size will change appropriately, even though the likelihood term might be very large. However, when the model family represented by the prior is insufficient, the prior term might not reflect the optimal Bayesian result. In realistic settings with confident incorrect predictions, the likelihood term of the loss in the final layer is many orders of magnitude larger than the prior term. This means that, early in training, the gradients broadly ignore the prior. In the misleading Permuted setting, however, the ratio between the two is much smaller. This means that prior-focused approaches can look good in the Permuted setting but not be robust on more representative challenges where there are resemblances between tasks. Permuted MNIST's randomly permuted tasks mask this 'forgetting scenario' which is common in many continual learning tasks (e.g., patient records in hospitals are similar to previously observed patients, but might be different enough to cause forgetting). The experiment can therefore be seen as 'biased' towards current prior-focused approaches: approaches that will otherwise fail when consecutive tasks resemble each other look good in the Permuted setting. We demonstrate these ideas empirically in \u00a76.1.\n\n\nSplit MNIST\n\nSplit MNIST is more challenging than Permuted MNIST insofar as it introduces more realistic differences between tasks. However, the multi-headed version, which is most often used, is not representative of real-world continual learning use-cases, as Chaudhry et al. (2018) point out. To implement multi-heading, one needs to identify which task each example belongs to. Otherwise one cannot pick a head to train and predict with. Usually, if that were possible, continual learning would be unnecessary, since one could use a separate classifier for each task. Unfortunately, a model which performs well when implemented in a multi-headed way might do very badly when faced with a single-headed scenario. To illustrate, suppose some model has already been trained on the first four tasks of Split MNIST and is then tested on the digit '1'. In the single-headed variant, when shown a '1' it may incorrectly predict the label is seven, which was seen more recently. In the multi-headed variant, we knowingly assume that the label comes from [0:1]. Because the model only needs to decide between 0 and 1 (and not even consider if the image is a 7), a multiheaded model could correctly predict the label is 1 even though the same approach will completely fail in a single-headed experiment setup. A multi-headed evaluation can therefore make it seem as if an approach has solved a continual learning problem when it has not. Single-headed Split MNIST -an evaluation not generally used in the field-would require a model to work well even when the parameters change significantly to adapt to more than two new and different tasks, and when there may be strong resemblances between classes present in new and old tasks.\n\n\nOther non-representative evaluations\n\nTwo-task transfer is not representative of realistic problems because continual learning use-cases often involve a long series of tasks, not just two. An algorithm might have elements that perform well with just one previous task but fail with more. 2 In other cases, experiments revisit each dataset multiple times (Kirkpatrick et al., 2017;Schwarz et al., 2018). This is similarly unreflective of the continual learning setting where old datasets are no longer accessible.\n\n\nDESIDERATA FOR CONTINUAL LEARNING EVALUATIONS\n\nContinual learning reflects many environments and use cases. Sometimes it is motivated by extremely large datasets that make full retraining impractical (e.g., (Nguyen et al., 2018)). Other times by agent control in multiple distinct environments (e.g., (Kirkpatrick et al., 2017;Schwarz et al., 2018)). Or it might be motivated by legal constraints requiring periodic data deletion. The setting, as well as the motivation, may vary enormously, from image segmentation to medical diagnostics to control. Specialized continual learning datasets like Core50 (Lomonaco and Maltoni, 2017) are therefore useful for subfields but cannot be seen as an overall benchmark for continual learning. A set of desiderata for future evaluations of continual learning is more useful. We propose the following minimal principles which ought either to be respected or to be explicitly mentioned as absent.\n\nCross-task resemblances Input data from later tasks must at least sometimes result in confident predictions of old classes, early in training. Otherwise the problems of Permuted MNIST resurface. Shared output head If each task is given a different output vector, it must be explicitly and prominently mentioned. This has a large effect on the difficulty of the challenge. No test-time assumed task labels If one knows the label of the task at test-time, one might in many cases be able to train multiple models, rather than continually learning. If the test-time algorithm must select outputs based on the task label, it will not be relevant to many applications of continual learning. No retraining on old tasks Many motivations of continual learning preclude being able to retrain on task 1 after having trained on task T . This includes retaining small amounts of data from old tasks, which might violate privacy laws, for example. More than two tasks Most use cases of continual learning demand more than two tasks to be learned. Two-task transfer ( \u00a73.2.3) is therefore interesting, but succeeding at two-task transfer does not guarantee good performance on three or more tasks.\n\nAs an example of how these desiderata might be applied, we consider a challenging implementation of single-headed Split MNIST, which is what we use in \u00a76. Each of the five tasks (classifying a series of pairs of handwritten digits) has some resemblances to previous ones. For example, a seven can look much like a one. A single output vector is shared by all tasks, and the class prediction is decided without knowledge of the current task label. Each task is visited only once, and not repeated. In a strict version, there no coresets are saved between tasks. There is a sequence of five tasks.\n\nThere are, of course, situations where the desiderata might be deliberately set aside. For example, Nguyen et al. (2018) explicitly concern themselves mainly with fast adaptation to new tasks. They are therefore happy to assume knowledge of task labels and store small amounts of old data. While the five listed desiderata may seem basic and will not always be applicable, it remains a surprising fact that there is no prior-focused approach that has been shown to perform well in an evaluation with all of the five main desiderata. We have argued above why this might be, and show in \u00a76 that at least some prior-focused approaches fail as these desiderata are enforced and that they fail because they are priorfocused.\n\nThese desiderata are a starting point for more difficult challenges including:\n\nUnclear task demarcation Task boundaries are generally assumed knowledge during training. Continuous tasks Current practice usually assumes that tasks are discretely different rather than varying continuously. Overlapping tasks Current practice tends to have task output spaces with minimal overlap. 3 Long task sequences Continual learning is most interesting over extremely long sequences of tasks. Time constraints Continual learning solutions that update quickly are more useful than ones that have large computational overheads.\n\n\nMemory constraints Continual learning solutions\n\nthat use a small fixed memory are more useful than those that consume a large and expanding amount of memory.\n\nTo illustrate how the single-headed Split MNIST evaluation might be made more challenging for continual learning without choosing a more complex dataset we consider possible extensions. One might keep the same set-up but not inform the learner that a new dataset has arrived. One might represent a continuous task by a probability distribution of certain classes appearing, rather than a binary inclusion of, e.g., zero and one in the first task. One might include the same digit in multiple tasks, at different frequencies, or of different types (e.g., different colors). One might use more characters (e.g., from another source) to allow a longer sequence of tasks. One might measure the wall-clock time taken for training on each new task, and its memory use.\n\nA very real risk for the field is to embrace more complex datasets before establishing robust experimental design. Until we have continual learning evaluations that test the core challenges of continual learning, moving from MNIST to more complex datasets does little to measure progress in continual learning itself.\n\n\nEMPIRICAL ANALYSIS OF EXISTING EVALUATIONS\n\nThe aim of this section is twofold. First, we demonstrate failure cases of existing experimental evaluations, supporting our analysis in \u00a74. Second, we demonstrate that the existing evaluations are biased towards prior-focused approaches.\n\n\nShortcomings of Permuted MNIST\n\nWe introduce two tests to show the shortcomings of the Permuted MNIST experiment discussed in \u00a74.1. For each test we consider both the Permuted and Split settings. In each case, we train a model on Task A before training on Task B. In the split setting, Task A is the first five digits of MNIST and Task B the last five digits. In the permuted setting, Task A is MNIST and Task B is a random permutation of the pixels of MNIST. Here, we are assessing the evaluation framework itself, not continual learning performance.\n\n\nVerifying Permuted Setting Under-Confidence\n\nWe first validate our hypothesis that predictions are much more uniform in the Permuted setting. We evaluate the entropy of the output probability vector. Low entropy indicates a confident prediction of a single class, whereas a high entropy indicates a 'uniform' prediction, spreading the mass across different classes. These are summarised in Table 2, supporting our claim that models in the Permuted setting are much less confident than in a more typical setting. : Early in training Task B, the ratio of the likelihood term of gradients the final layer against the prior term is much lower in the Permuted setting. This reduces forgetting because the prior has a larger impact on learning. Averaged over 100 runs, shading is one standard deviation.\n\n\nVerifying Unusually Large Gradients in the Permuted Setting\n\nNext, we test our hypothesis from \u00a74.1 that more uniform predictions lead to slower 'catastrophic forgetting'. To test this hypothesis, after training on Task A, we measured gradients for the final weight layer while training Task B in the two variants (figure 3). All results are averaged over 100 runs. Full experimental details are in Appendix B.1. We found that having digits resembling previously observed ones in the Split setting led to much larger likelihood-term gradients in the final layer than found in the Permuted setting for early batches. As a result, the ratio between the likelihood term and the prior term of the loss is much higher in the Split setting ( figure 4). This means that the prior has a smaller influence over the gradients, leading to more forgetting.\n\n\nUnderstanding Prior-focused Bias\n\nIn the experiments below we investigate three algorithms based on work by Nguyen et al. (2018). We select them as representatives of the pure prior-focused approach, an entirely dual-memory approach, and a hybrid approach. We use these to tease out which aspects of the architecture are challenged under different experimental design choices. We use VCL because it provides a clearer distinction than other similar architectures between the elements of a continual learning system that reflect a prior based on the t \u2212 1'th model and the parts that learn from the t'th.\n\nWe distinguish three variants. First, we use pure VCL, exactly as described by Nguyen et al. (2018). A meanfield variational inference Bayesian neural network is trained on each dataset in sequence. At the end of the t \u2212 1'th task, the weights become the prior for training the next model. In this variant, no coreset is used, reflecting a pure prior-focused approach.\n\nIn the second variant, a small coreset of 40 datapoints is extracted from each dataset (we use their k-center coreset approach, but this does not have a large effect). Everything is the same as pure VCL except that, at the end of training on each task, the model is trained on the coresets before testing, as described in their work. This reflects a hybrid approach.\n\nThe third variant, a 'coreset only' approach, is exactly like the second variant except that the prior used for variational inference is the initial prior each timeit is not updated after each task. This is a purely dual-memory approach, and is not the same as any algorithm used in Nguyen et al. (2018). 4\n\nWe also provide results for EWC because it has been widely discussed in the literature. The fact that our observations for VCL are mirrored for EWC supports our hypothesis, based on our analysis, that the problems discussed in this section affect prior-focused approaches in general, rather than any specific architecture. Note that because VCL and its variants use a Bayesian neural network and variational inference, and EWC does not, performance comparisons between these architectures should be interpreted carefully.\n\nPrevious authors have demonstrated the effectiveness of their methods on Permuted MNIST. These demonstrations are reproduced in Appendix B.2.\n\n\nSplit MNIST and Fashion MNIST\n\nSplit MNIST, described in \u00a74.2, has tasks that resemble each other, which we show here is more challenging under the right conditions. We begin by evaluating models with multi-heading. That is, each prediction is the most probable class out of the classes of the task being evaluated. In addition, similarly to Zenke et al.  2018), VCL is trained with five separate heads which make predictions over only two classes, which are trained separately but share hidden layers.\n\nAll four architectures (VCL, VCL with coresets, coresets alone, and EWC) perform roughly as well as each other in multi-headed Split MNIST (figure 5). VCL's performance without coresets begins to dip slightly by the last task, but this experiment is clearly unable to distinguish significant performance differences between the three architectures. Note the compressed y-axis. Because of multi-heading, this task is not yet more challenging than (the single-headed) Per-   Single-headed Split MNIST reveals blind-spots (figure 6). We perform exactly the same experiment as before, except that predictions are not constrained to be from the 'ground truth' task for either training or testing. If a network predicts with high output probability that any input is most likely to be from the most recent task, it will now have 0% accuracy on old tasks, even if it could still distinguish zeros and ones (having been told to choose one of the two). With this small modification, a large performance difference emerges between the three approaches. The coreset-only approach is successful and performs exactly the same as VCL with coresets. Pure VCL and EWC, meanwhile, forget old classes completely. This suggests that coresets are responsible for the performance of the hybrid model. In this setting the prior representation is not sufficient to provide effective continual learning.\n\nWe also demonstrate that these phenomena are not unique to MNIST. We perform a similar analysis using Fashion MNIST, a dataset containing ten classes of small images of different types of clothing. Although a more complex domain, we still see that all models  perform similarly in the multi-headed setting (figure 7) but that coresets explain all the performance of VCL with coresets in the single-headed setting and VCL and EWC fail without coresets (figure 8). See appendix B.5 for full experimental details.\n\n\nDISCUSSION\n\nExperimental design shapes the field by providing reproducible comparisons between architectures, and testing whether an architecture satisfies minimal objectives. Blindspots in existing evaluations have led to inadequate comparisons in recent research. We showed that existing evaluations are biased towards priorfocused approaches, which perform badly in modified evaluations that satisfy minimal desiderata. We argued for a list of minimal desiderata, as well as more ambitious ones. It is tempting to demonstrate progress by using increasingly complex test environments. But until proposed architectures can perform well on robust experimental designs in simple testbeds, which they currently fail to do, this progress does not reflect progress in continual learning.\n\nWe would like to thank for their advice and comments on drafts of this paper: Owain Evans, Gregory Farquhar, Andreas Kirsch, Yingzhen Li, Jelena Luketina, Cuong Viet Nguyen, and Richard Turner. This research was supported by The Alan Turing Institute and the EPSRC grant number EP/P00881X/1 at the Centre for Doctoral Training in Cyber Security at the University of Oxford. We gratefully acknowledge the support of NVIDIA Corporation with the donation of the Titan Xp GPU used for this research.\n\nReferences Blundell, C., Cornebise, J., Kavukcuoglu, K., and Wierstra, D. (2015).   \nF t \u221d Nt n=1 \u2207 \u03c9 logp(y (n) t |\u03c9, x (n) t ) 2 \u03c9=\u03c9t\nThis approximate Fisher information matrix is estimated at the end of each task. The authors state that in the multi-task case the regularization term for task T is the sum of separate regularization terms for each past dataset D t , 5\n\nKirkpatrick et al. (2017) show EWC works well on the Permuted MNIST task introduced by Goodfellow et al. (2013). They also show that EWC reduces forgetting on a succession of Atari games.\n\n\nA.2 Synaptic Intelligence\n\nPublished soon after EWC, SI has a similar loss but computes the contribution of each parameter to the gradient of the loss over the entire course of training. The authors explicitly acknowledge that the derivation of their regularization term only extends to the twotask case, but point out that the model performs well even in multi-task settings.\n\nZenke et al. (2017) show that SI works in a multiheaded version of the Split MNIST task which they introduce, and matches EWC on the Permuted MNIST task. They also show some transfer learning on a multi-headed split CIFAR task of their own design.\n\n\nA.3 Variational Continual Learning\n\nNguyen et al. (2018)  Net uses evolutionary selection to try to learn which patches of a larger network are helpful to each task rather than making a layer-by-layer assumption (Fernando et al., 2017). This broad family of approaches are especially useful in two-task transfer cases, but it can become impractical to introduce the many taskspecific weights in the more general continual learning case that we consider.\n\nOthers find that adjustments to learning dynamics can reduce catastrophic forgetting, presumably by encouraging networks to use their capacity fully. This family of approaches includes selecting activations and using dropout to reduce forgetting (Srivastava et al., 2013;Goodfellow et al., 2013). These are useful, but do not go far enough to solve forgetting fully. Lee et al. (2017) extend dropout by shifting the zero-point of each dropout parameter to the parameter value from training on the previous task.\n\n\nB EXPERIMENTAL DETAILS AND FURTHER FIGURES\n\n\nB.1 Shortcomings of Permuted MNIST Experimental Settings\n\nTo measure the gradients during training, we first trained on Task A for 120 epochs with batch size 256 and an Adam optimizer using Variational Continual Learning (VCL) with the same settings used in B.2. We then trained on Task B for 15 batches of 16 digits each, again using VCL. We measured the average absolute value of the gradients of the final layer of the model. We averaged over 100 training runs for each setting (with a different permutation each time in the Permuted setting), resetting the model to its initial position after each run. Graphs show the standard deviation of the average gradient of each batch. The ratio displayed in figure 4 is the log-likelihood term of the loss described in equation 1 divided by the prior term, using VCL. The ratio is calculated for each of the 100 runs on the averaged absolute gradients.\n\n\nB.2 Permuted MNIST as Baseline\n\nAs Nguyen et al. (2018) have shown, on Permuted MNIST, described in \u00a74.1, VCL performs well with or without a coreset. We also show that the coreset on its own performs badly (figure 9, results averaged over 10 runs). This is consistent with our analysis of the Permuted setting, which suggested that the small and evenly spread gradients due to the likelihood term of the loss helped the prior term to work, despite a prior that does not fully support the function space. Note that this version of VCL was previously shown to outperform EWC and SI (Nguyen et al., 2018). We train for 100 epochs using a batch size of 256 on all the data except the with-held coresets. We train the whole single head on coresets for 100 epochs and use 200 digits of each permutation as a coreset chosen using the same k-center coresets algorithm used by Nguyen et al. (2018). VCL without coresets is exactly the same, but without a final training step on coresets. The coresets only algorithm is exactly the same as VCL, except that the prior is always initialized as though it were the first task.\n\n\nB.3 Single-headed Split MNIST\n\nThe settings for Split MNIST follow Nguyen et al. For all Bayesian neural network architectures we train for 120 epochs. We use batch sizes equal to the training set size. We use coresets of digits per task selected using the same k-center coreset algorithm as Nguyen et al. (2018), which are withheld from the training. We train for 120 epochs on the concatenated coreset across all the heads together.\n\nFor EWC, we use a neural network with two hidden layers with 256 weights. We train using the variant of EWC suggested in Husz\u00e1r (2018). We estimate the Fisher information using 200 samples at the end of each task, train using SGD with learning rate 10 \u22122 for 20 epochs per task. The coefficient of the regularization term in the loss was set to 10 but was found not to be important to performance.\n\n\nB.4 Multi-headed Split MNIST\n\nMulti-headed Split MNIST has almost precisely the same settings as the Single-headed Split MNIST above. Following Nguyen et al. (2018), for VCL we have five heads in the final layer, each of which is trained separately. Coresets are used to train each head in turn. Batch size equal is to training set size. Results are shown averaged over 10 runs with fresh coreset selection each time. Standard errors are not shown as they are of the order of a tenth of a percent.\n\nEWC is configured in exactly the same way as in the single-headed setting.\n\n\nB.5 Split Fashion MNIST\n\nSingle-and multi-headed Split Fashion MNIST are performed mostly the same as our Split MNIST experiments. We use a larger network, with four hidden layers with 200 units for the BNN and 256 units for EWC. Fashion MNIST has a much more diverse membership of its classes, which makes performance lower even with these larger networks. We did not find that using larger coresets significantly improved performance.\n\n\nC UNIFYING PRIOR-FOCUSED AND LIKELIHOOD-FOCUSED CONTINUAL LEARNING\n\nAuthors' note: In a previous version of this paper, we introduced a unifying view of Bayesian continual learning and presented a partner approach to Variational Contoninal Learning (VCL): Variational Generative Replay (VGR). In the current version of this paper, we focus specifically on evaluation, and the unifying view and VGR are left for future work. However, for sake of consistent citation, we preserve an introduction of these topics in this appendix, which will be integrated into future work which more closely examines Bayesian continual learning.\n\nEach of VCL, EWC, and SI effectively set the param-eters at the end of the last task as a prior, which is explicit in the Variational Inference (VI) derivation supporting VCL (Nguyen et al., 2018). We approach the derivation of continual learning in VI differently. Instead of changing priors between tasks, we adapt the log-likelihood component of the loss to depend on past datasets. We view estimating the log-likelihood component as using Monte Carlo sampling from densities of past data, which can be modelled using generative models. This offers a principled derivation combining the likelihood-focused approach to continual learning together with the prior-focused ones. In the following we develop the unifying Bayesian framework, focusing on the VI case in order to match the current stateof-the-art algorithm-VCL. An analogous derivation in the maximum likelihood estimation setting would recover an algorithm resembling a more streamlined version of DGR proposed by Shin et al. (2017).\n\n\nC.1 A Likelihood-focused Approach using a Variational Free Energy Loss\n\nIn non-continual learning, we aim to learn parameters \u03c9 using labeled training data D = (x, y) to infer p(y|\u03c9, x). In the continual learning context, the data is not independently and identically distributed (i.i.d.), but instead may be split into separate tasks D t = (X t , Y t ) whose individual examples x (nt) t and y (nt) t are assumed to be i.i.d. We assume in this case that the tasks are clearly separated, although in general this splitting might be based on unsupervised learning.\n\nUnder the standard VI approach (Jordan et al., 1999), we want to find the posterior over the parameters, p(\u03c9|D 0:T ) which let us estimate a probability distribution for y. The posterior is generally intractable, so we introduce a tractable approximating distribution q \u03b8 (\u03c9) and minimize the Kullback-Leibler divergence between the approximating distribution and posterior:\nq * \u03b8 = argmin q \u03b8 \u2208Q KL q \u03b8 (\u03c9) p(\u03c9|D 0:T )(2)\nwhich, after applying Bayes' theorem and removing constant terms, becomes:\nq * \u03b8 = argmin q \u03b8 \u2208Q KL q \u03b8 (\u03c9) p(\u03c9) \u2212 E \u03c9\u223cq \u03b8 (\u03c9) logp(Y 0:T |\u03c9, X 0:T ) .(3)\nThis is equivalent to minimizing the variational free energy of the model. The first term can be interpreted as pushing q towards a prior about the distributions of the parameters. The second term is data-dependent and is the expected negative log-likelihood of the observed data given the parameters of the model. To extend this log-likelihood term to the continual learning setting, we observe that:\nlogp(Y 0:T |\u03c9, X 0:T ) = T t=1 logp(Y t |\u03c9, X t ) = T t=1 Nt n=1 logp(y (n) t |\u03c9, x (n) t ).(4)\nUsing 3 and 4 and rearranging gives an expression for the variational free energy F T that can be used to train on dataset D T and can be decomposed into a sum of separate terms for each dataset D 0:T :\nF T \u221d KL q \u03b8 T (\u03c9) p(\u03c9) \u2212 T t=1 L t \u221d T t=1 1 T KL q \u03b8 T (\u03c9) p(\u03c9) \u2212 L t(5)\nwhere L t is the expected log-likelihood over D t :\nL t = Nt n=1 E \u03c9\u223cq \u03b8 T (\u03c9) logp(y (n) t |\u03c9, x (n) t ) .(6)\nWe cannot estimate L t for t < T directly because we have discarded those datasets. Instead, we approximate the sum in (6) as an integral over a data distribution p t (x, y) which is in turn approximated by a generative model. That is, we can approximate equation (6) as:\nL t \u2248 1 N t log p(y|\u03c9, x) p t (x, y)q(\u03c9)dxdyd\u03c9. (7)\nIn order to approximate the distribution of past datasets p t (x, y), we train a GAN q t (x, y) (Goodfellow et al., 2014) to produce (x,\u0177) pairs for each class in each dataset as it arrives. After that dataset is used, the data are discarded and the generator is kept.\n\nData from the distributionsx,\u0177 \u223c q 1:T \u22121 (x, y) can supplement the actual data for task T to create (x,\u1ef9) = (x\u222ax,\u0177\u222ay). Because we were able to separate (5) as an sum of task-specific terms we can minimize it by minimizing:\nF = E \u03c9\u223cq \u03b8 T (\u03c9) logp(\u1ef9|\u03c9,x) \u2212 1 N T KL q \u03b8 T (\u03c9) p(\u03c9)(8)\nwhich we approximate by averaging over sampled mini-batches. We refer to this model as Variational\n\nGenerative Replay, VGR, given in Algorithm 1. This model can be seen as an exemplar of the family of likelihood-focused approaches. By setting the prior to be given as the posterior from the previous task, or objective can further be seen as merging such likelihoodfocused approaches together with prior-focused approaches.\n\n\nC.2 Comparison Between VGR and Other Likelihood-focused Approaches\n\nExisting works already use generative models to simulate past datasets as a tool for continual learning (Robins, 1995;Shin et al., 2017). Our derivation provides a unified view for these algorithms together with prior-focused approaches. Additionally, our suggested VGR is novel in its application of variational inference and, because it was derived from first principles, simpler in design compared to (Shin et al., 2017) for example. VGR is designed to be as analogous as possible to VCL-the current state-of-the-art-which makes it ideally suited for experimental comparison. Further, VGR's probabilistic nature allows us to identify new tasks by examining model uncertainty (see \u00a7C.8).\n\nMany alternative ways of estimating density models for use in generating data are possible. One could use conditional GANs using the training class label as an input. Or one might follow Shin et al. (2017) whose 'scholar' uses old classifiers to label unconditional GAN outputs. Coresets or randomly preserving a subset of examples are other ways to estimate the density model. Whether coresets or generative models are more computationally efficient, or even tractable, depends on the data-space. However, we find that VGR is not very sensitive to the length of training of the generative model and even poor generative models preserve classifications adequately (see figure 13). Generative models can find complex data-spaces dif-\n\n\nAlgorithm 1 VGR\n\nInput: Prior p(\u03c9), inputs to generate per class n. Output: Variational and predictive distributions q \u03b8t (\u03c9), p(\u0177|\u03c9 t ,x) for 0 \u2264 t < T .\n\nInitialize \u03c9 \u2190 N (0, 1). for t = 0 to T do Observe dataset D t and initialize G t \u2190 \u2205 and q \u03b80 (\u03c9) \u2190 p(\u03c9). for t = 0 to t do Sample n replay from Gen t as R t G t \u2190 G t \u22121 \u222a R t end for \u03c9 \u2190 argmin(F) from equation (8) on D t \u222a G t . Train and store Gen t on D t . end for 1 2 3 4 5 6 7 8 9 10\n\nModel after n tasks 0.5 0.6 0.7 0.8 0.9 1.0 Accuracy on seen tasks VGR VCL+core VCL Core only Figure 10: Permuted MNIST. VGR has marginally better performance than VCL with or without a coreset, which has been shown to outperform EWC and SI. Coresets without the VCL loss performs worse. Averaged over 10 runs.\n\nficult, though major advances have been made with complex environments. Moreover, generative models can be trained with differential privacy (Farquhar and Gal, 2018) whereas coresets cannot have the same differential privacy guarantees.\n\n\nC.3 Experimental Evaluations of VGR and VCL\n\nAuthors' note: In a previous version of this paper, which introduced VGR, we included a number of experimental evaluations, some of which are different in kind to those in the current work.\n\n\nC.4 Permuted MNIST\n\nTraining with VGR is performed identically to the description in B.2 with the following exceptions. We train VGR for 120 epochs using a GAN trained for 200 epochs on each MNIST digit. We use 6000 generated digits per class, sampled fresh for each task, and initialize network weights using the previous task. We use a batch size of 256 times the number of seen tasks, ensuring that the number of batches is held constant.\n\nThe GAN is trained with an Adam optimizer with learning rate 2 * 10 \u22124 and \u03b2 1 of 0.5. The network has four fully-connected hidden layers with 256, 512, 1024 and 784 weights respectively. It uses Leaky ReLu with \u03b1 of 0.2.\n\nWe can see that VGR performs marginally better than VCL on Permuted MNIST, although the performance gain is very slight.\n\n\nC.5 Single-headed Split MNIST\n\nMost settings are as described in B.3. For VGR, we use 6000 digits per class generated by a convolutional GAN. Unlike VCL, we cap batch sizes at 30,000 rather than having the batch size equal the training set size.  Figure 11: Single-headed Split MNIST. VGR outperforms VCL with coresets. Coresets seem to contribute much of VCL's performance, as coresets alone performs identically. VCL alone forgets old tasks completely. Likelihood-focused approaches seem better suited to the single-headed case. Averaged over 10 runs. This is because the examples generated by VGR result in larger training sets which exceeded the memory available on our GPU.The GAN is trained for 50 epochs on each MNIST class using the same optimizer as the non-convolutional GAN used for Permuted MNIST. It has a fully connected layer followed by two convolutional layers with 64 and 1 channel(s) and 5x5 convolutions. Each convolutional layer is preceded by a 2x2 up-sampling layer. The activations are Leaky ReLu's with \u03b1 of 0.2.\n\nIn the single-headed Split MNIST task we begin to see a large difference in performance between VGR and VCL. Likelihood-focused continual learning methods appear to adapt well in this setting, while priorfocused ones struggle.\n\n\nC.6 Multi-headed Split MNIST\n\nMost settings are as described in B.4. For VGR, unlike VCL, we only perform multi-heading as a way of selecting predictions, rather than using multiple heads during training as well, because each batch contains data from multiple tasks.\n\nWhen multi-headed, both VGR and VCL perform very well, as the task is quite simple (see figure 12).\n\n\nC.7 Timed Single-headed Split MNIST\n\nWe use Timed Split MNIST to evaluate the trade-off of training time against accuracy in continual learning. This experiment is important because much of the need for lifelong learning comes from situations where a system cannot feasibly retrain on all previous data due to constraints of cost and time. Continual learning systems generally have hyperparameters that affect both performance and speed. For example, in VGR, training on larger sampled datasets improves performance but takes more time. In figure 13  show the average accuracy of various models plotted against the wall-clock time taken to finish training for a wide range of such hyper-parameters. The objective is not to carry out an exhaustive hyper-parameter search, but to indicate different possibilities for performance/time trade-offs. None of the configurations of VCL provides good accuracy on the single-headed task. At the same time, none of the configurations of VGR is able to provide good time performance (see appendix C.7.1). We highlight these shortcomings for future research to address.\n\nWe perform the single-headed Split MNIST experiment with a range of different configurations. For VGR we allow between 10 and 50 epochs for training the convolutional GANs and between 1 and 120 epochs for training the main model. We use 2000, 4000, or 6000 generated images per class. We add GAN training time to the main figure, even though it is possible to do in parallel. For VCL, we use between 1 and 120 epochs for training and coresets. In all cases, we report elapsed wall-clock time from start to finish. We plot this against average accuracy over all tasks of the final model trained on all tasks. In all cases, the experiment was carried out on an NVIDIA Tesla K80. Here, we also show Timed Split MNIST performed as a multi-headed experiment in order to allow VCL to use multi-headed training (figure 14). Performance is better for all models than in the single-headed case, but for VCL it can get very good, and faster than VGR.\n\n\nC.7.1 Time and Memory efficiency of Priorand Likelihood-focused Approaches\n\nLikelihood-focused approaches must train generative models and train on extra data relative to priorfocused approaches. But prior-focused approaches tend have slightly more complicated losses or add extra training phases. We found that VCL with coreset was faster than VGR. For the single-headed Split MNIST task it took roughly 7 minutes. 6 Training VGR with each generated set the same size as the true data took roughly 18 minutes plus 34 minutes to train the GANs. But a quicker training regime took only 2 minutes plus 8 for training GANs and was still more accurate than VCL. 7 The prior-focused costs scale badly with model size, while VGR's costs scale badly with data-space complexity and very long series of datasets. VGR is also potentially less memory intensive. Generated data can be sampled on demand, it need not be the same each epoch.\n\n\nC.8 Model Uncertainty on Unseen Tasks\n\nModel uncertainty gives another tool for understanding forgetting. A model with well-calibrated uncertainty enables detection of new distributions or the escalation of anomalous examples to human oversight.\n\nA good lifelong learning model should tend to be more certain on tasks it has seen before than tasks it has not seen. We train VGR and VCL on the single-headed Split MNIST task as before. After training on each task, we measure the model's uncertainty when shown data from each task, both seen and unseen. We then use the uncertainty information to predict whether the model has seen the dataset before or not. If the uncertainty is higher than a certain threshold, we announce 'the model was not trained on this dataset!'. We evaluated this with different thresholds, generating an ROC plot. We compare the AUC of both these ROC plots and find that VGR's AUC is 1 while VCL's is 0.76. This means that VGR is able to correctly detect all tasks it has not seen before, whereas VCL fails on a considerable number of those.\n\nTo quantify the uncertainty quality in continual learning we introduce a simple decision-rule: Fix some 1 < \u03b8 < 10. Then test if the uncertainty is higher than \u03b8 times the uncertainty on the current task. If so, predict that the example comes from an unseen task. We then construct an ROC plot of true positives against false positives for all \u03b8 thresholds, and compute the area under the curve (see figures 17 18). To measure uncertainty, we use the mutual information between predictions on each task and the model posterior, following Gal (2016). The mutual information is high when evaluated on data points far away from the training data.\n\nFor VGR, the obtained area under the curve of the ROC plot is 1, i.e. there is a value \u03b8 which cleanly divides high-uncertainty unseen tasks from lower uncertainty seen tasks. For VCL, the obtained area under the curve is 0.76. This is because the model stops recognizing old tasks as familiar-more specifically, the uncertainty of a model trained up until the fourth task when shown data from the second task (seen) is as high as when it is shown the fifth task (unseen). See figures 15 and 16 for full comparison.\n\nIn more detail, to assess the uncertainty of our models we compute the mutual information between predictions made on data from each task and the model posterior. This is high when the model is uncertain about predictions overall, but makes confident predictions when sampled. It is lower when the model is consistently uncertain and unconfident, and when the model is confidently correct. We measure uncertainty using exactly the same set-up as single-headed Split MNIST.\n\nIn order to measure the false positive and true positive rates, we set a decision rule that if the uncertainty on a task exceeds the uncertainty on the current task by a large enough margin, we deduce that it is a previously Uncertainty is high for unseen tasks, and low for all previously seen tasks, showing good calibration. Models trained on 1-5 tasks are each evaluated against all five tasks. Uncertainty is assessed using the mutual information between predictions on each task and the model posterior. It is normalized to 1 for the most uncertain task for each model. Uncertainty is high for unseen tasks, but rises for seen tasks that were seen some time ago. The fourth model, for example, is nearly as uncertain about the second task, which it has seen, as it is about the fifth, which it has not. unseen task. We vary that margin from \u03b8 = 1 (if the uncertainty is at all larger, the data must be unseen) to \u03b8 = 10 (the uncertainty can be 10 times larger and we still conclude the task is one we have previously seen) with a step-size of 0.1. We then calculate the area under the curve of an ROC plot. 0.5 represents a completely worthless test, while 1 is optimal.\n\n\nC.8.1 Using Monte Carlo Dropout\n\nIn addition to Bayesian neural networks, we consider the use of Monte Carlo Dropout (Gal and Ghahramani, 2015). We found that this model produced exactly the same performance as a Bayesian neural network, shown in figure 19. However, it could scale effectively to larger images where the Bayesian neural network would struggle.In contrast, we could not perform VCL with MC Dropout because it was not possible to make the parameter-uncertainties specific enough.   Figure 19: We can achieve the same performance using a Monte Carlo Dropout implementation of VI as we get with a Bayesian neural network. Here we use a simple CNN with two convolutional layers, one pooling layer, and two dense layers, with dropout throughout trained for 25 epochs. 2x2 max pooling layer, and two fully connected layers with dropout. Dropout was 0.25 and an L2 regularization with weight 0.01 produced the KL divergence.\n\n\nC.8.2 Sensitivity Analysis for VGR Hyper-parameters\n\nWe tested VGR with a wide range of hyperparameters and found that it was not very sensitive to them. Training anywhere between 20 and the 120 epochs used by VCL seemed to produce very similar performance (figure 20. Similarly, using anywhere between 2000 and 6000 digits per class of MNIST (MNIST itself has roughly 6000 digits per class) gave similar performance. Below 1000, performance fell (figure 21). Model after n tasks Accuracy VGR 6k VGR 4k VGR 2k VGR 1k VGR 500\n\nFigure 21: We find that task accuracy is not strongly affected by the number of generated images used, and that using just 2000 is enough to produce good continual learning. But the model performs best when given data matching the original number of digits in the task. For smaller generated sets we train for fewer epochs to show that VGR performs adequately when optimized for speed.\n\nFigure 1 :\n1We contrast prior-focused with rehearsal based continual learning. By comparing these, and hybrid forms, we can see which evaluations pose a bigger challenge to different approaches.et al., 2018), and Riemanian Walk (RW)\n\nFigure 2 :Figure 3 :\n23Average entropy of predictions on Task B, early in training; Note the 2 orders of magnitude difference between the two settings. Entropy is much higher in the Permuted setting. Early in training Task B, the likelihood term of gradients on the final layer is unusually low in the Permuted setting because permuted digits do not resemble any digits from Task A. This makes continual learning unrealistically easy in this evaluation. Averaged over 100 runs, shading is one standard deviation.\n\nFigure 4\n4Figure 4: Early in training Task B, the ratio of the likelihood term of gradients the final layer against the prior term is much lower in the Permuted setting. This reduces forgetting because the prior has a larger impact on learning. Averaged over 100 runs, shading is one standard deviation.\n\n\n(2017), Ritter et al. (2018), and Nguyen et al. (\n\nFigure 5 :\n5Multi-headed Split MNIST. VCL and EWC appear effective. VCL works with or without coresets, and coresets work well on their own.\n\nFigure 6 :\n6Single-headed Split MNIST. Coresets seem to cause the hybrid model's good performance: coresets alone perform the same. VCL and EWC forget old tasks completely. The single-headed setting reveals blind-spots from the multi-headed setting. muted MNIST, despite having classes that resemble each other. Details of training hyperparameters can be found in Appendix B.4.\n\nFigure 7 :\n7Multi-headed Split Fashion MNIST.As with MNIST, all algorithms perform similarly, though VCL performs very slightly worse without coresets.\n\nFigure 8 :\n8Single-headed Split Fashion MNIST. When single-headed, VCL and EWC no longer prevent catastrophic forgetting. Coresets do, and seem to explain all of VCL with coreset's performance.\n\n\n17 Goodfellow, I., Pouget-Abadie, J., Mirza, M., Xu, B., Warde-Farley, D., Ozair, S., Courville, A., and Bengio, Y. (2014). Generative Adversarial Nets. A. (2011). Practical Variational Inference for Neural Networks. Neural Information Processing Systems. 12 Husz\u00e1r, F. (2018). Note on the quadratic penalties in elastic weight consolidation. PNAS, 115(11):E2496-E2497. 11, 13 Jordan, M. I., Ghahramani, Z., Jaakkola, T. S., and Saul, L. K. (1999). Introduction to variational methods for graphical models. Machine Learning, 37(2):183-233. 13 Jung, H., Ju, J., Jung, M., and Kim, J. (2016). Less-forgetting Learning in Deep Neural Networks. arXiv. 3, 11 Kingma, D. P., Salimans, T., and Welling, M. (2015). Variational Dropout and the Local Reparameterization Trick. Advances In Neural Information Processing Systems, pages 2575-2583. 12 Kirkpatrick, J., Pascanu, R., Rabinowitz, N., Veness, J., Desjardins, G., Rusu, A. A., Milan, K., Quan, J., Ramalho, T., Grabska-Barwinska, A., Hassabis, D., Clopath, C., Kumaran, D., and Hadsell, R. (2017). Overcoming catastrophic forgetting in neural networks. Neural Information Processing Systems, 114(13):3521-3526. 1, 2, 3, 5, 11 Krizhevsky, A. (2009). Learning Multiple Layers of Features from Tiny Images. Technical report. 1 LeCun, Y., Bottou, L., Bengio, Y., and Haffner, P. (1998). Gradient-based learning applied to document recognition. IEEE, 86(11):2278-2324. 1 Lee, S.-w., Kim, J.-h., Jun, J., Ha, J.-w., and Zhang, B.-t. (2017). Overcoming Catastrophic Forgetting by Incremental Moment Matching. Advances in Neural Information Processing Systems. 3, 12 Li, Z. and Hoiem, D. (2017\n\nFigure 9 :\n9Permuted MNIST. VCL with or without a coreset performs well and has been shown elsewhere to outperform EWC and SI. Coresets without the VCL loss performs worse. Averaged over 10 runs.For permuted MNIST, we follow Nguyen et al.(2018)where possible. We use a Bayesian neural network (Graves, 2011) with two hidden layers of 100 units with ReLu activations. The priors are initialized as a unit Gaussian and the parameters are initialized with the mean of a pre-trained maximum likelihood model and a small initial variance (10 \u22126 ). We use the Adam optimizer(Kingma et al., 2015)  with learning rate 10 \u22123 . We use a single head, again followingNguyen et al.  (2018). For all results we present the average over 10 runs, with a different permutation each time. Standard errors are not shown as they are under a tenth of a percent.\n\n\nwhere possible. For Bayesian neural network architectures, we use exactly the same settings as for Permuted MNIST, including the single head, except that each hidden layer has 256 weights, similarly to Nguyen et al. (2018) on their multi-headed Split MNIST. Results are shown averaged over 10 runs, with a different coreset selection each time. Standard errors are not shown as they are of the order of a tenth of a percent.\n\nFigure 15 :\n15Mutual Information MNIST VGR.\n\nFigure 16 :\n16Mutual Information MNIST VCL.\n\nFigure 17 :\n17For a simple demonstration, we train a network with two convolutional layers with dropout (3x3 kernels and 32 then 64 channels) (Gal and Ghahramani, 2016)For VGR, sensible cut-off points cleanly differentiate previously-seen tasks from unseen ones with no false positives. This results in perfect recognition of previously seen tasks.\n\nFigure 18 :\n18For VCL, false positives are a problem because the model is highly uncertain about many previously-seen tasks. This represents forgetting of old tasks.\n\nFigure 20 :\n20Task accuracy is not strongly affected by further training on single-headed Split MNIST after 20 epochs.\n\n\nFigure 12: Multi-headed Split MNIST. VGR performs similarly to VCL, which has been shown to outperform EWC and SI. VCL appears to work largely independently of coresets, and coresets work well on their own. Averaged over 10 runs.Figure 13: Timed Single-headed Split MNIST. Hyperparameter choice can lead to slower, more accurate, models for each architecture. Ideal performance is in the top left corner. VGR is accurate but slower than VCL.we \n1 \n2 \n3 \n4 \n5 \nModel after n tasks \n\n0.96 \n\n0.98 \n\n1.00 \nAccuracy \n\nVGR \nVCL+core \nVCL \nCore only \n\n0 500 1000 1500 2000 2500 3000 \nWall clock time (s) \n\n0.2 \n\n0.4 \n\n0.6 \n\n0.8 \n\n1.0 \n\nAccuracy \n\nVGR \nVCL/core \n\n\n\n\nFigure 14: Multi-headed Timed Split MNIST. Ideal performance is in the top left corner. VGR can reach good accuracy, but slower than VCL. Now that VCL can use multi-headed training as well as coresets, the accuracy is good in the multi-headed experiment.500 1000 1500 2000 2500 3000 \nWall clock time (s) \n\n0.8 \n\n0.9 \n\n1.0 \n\nAccuracy \n\nVGR \nVCL/core \n\n\nIn practice, authors will relax some of these assumptions. For example, Nguyen et al. (2018) retain a small coreset of data from old tasks. Kirkpatrick et al. (2017); Schwarz et al. (2018) revisit each task multiple times.\nFor example, the approximate Fisher information matrix used in EWC is estimated using a Taylor expansion which is only locally accurate in one part of parameterspace. If, after many tasks, the model reaches a very different part of parameter-space, the estimated Fisher information for old tasks will be inaccurate.\nSee Lomonaco and Maltoni (2017) for detailed discussion of this point.\n Nguyen et al. (2018)  compares VCL to a hypothetical model that only uses a coreset. However, in their work, the 'coresets-only' model performs much worse than VCL even on the first task, where no continual learning is happening. This suggests the model is seeing only coresets-much less data.\n Husz\u00e1r (2018)  suggests that one should only regularize relative to the most recent weights, because it incorporates the old information, but using all historic Fisher information matrices.\nTimes are reported for a Nvidia Tesla K80. 7 Average single-headed accuracy of the final model for this less-trained VGR was 90% rather than 96% for the fully trained model. Training used one third the generated data, only 20 epochs of training, and only a fifth the training for the GAN.\n", "annotations": {"author": "[{\"end\":139,\"start\":52},{\"end\":218,\"start\":140}]", "publisher": null, "author_last_name": "[{\"end\":70,\"start\":62},{\"end\":149,\"start\":146}]", "author_first_name": "[{\"end\":61,\"start\":52},{\"end\":145,\"start\":140}]", "author_affiliation": "[{\"end\":138,\"start\":72},{\"end\":217,\"start\":151}]", "title": "[{\"end\":49,\"start\":1},{\"end\":267,\"start\":219}]", "venue": null, "abstract": "[{\"end\":880,\"start\":269}]", "bib_ref": "[{\"end\":1804,\"start\":1778},{\"end\":1823,\"start\":1804},{\"end\":1861,\"start\":1823},{\"end\":1883,\"start\":1861},{\"end\":1903,\"start\":1883},{\"end\":2357,\"start\":2331},{\"end\":2382,\"start\":2368},{\"end\":2410,\"start\":2382},{\"end\":6026,\"start\":6000},{\"end\":6075,\"start\":6055},{\"end\":6135,\"start\":6114},{\"end\":6222,\"start\":6199},{\"end\":6497,\"start\":6483},{\"end\":6508,\"start\":6497},{\"end\":6530,\"start\":6508},{\"end\":7115,\"start\":7093},{\"end\":7181,\"start\":7161},{\"end\":8939,\"start\":8921},{\"end\":9294,\"start\":9276},{\"end\":10446,\"start\":10440},{\"end\":10861,\"start\":10837},{\"end\":11007,\"start\":10987},{\"end\":11025,\"start\":11007},{\"end\":11050,\"start\":11025},{\"end\":11067,\"start\":11050},{\"end\":11095,\"start\":11067},{\"end\":11115,\"start\":11095},{\"end\":11135,\"start\":11115},{\"end\":12131,\"start\":12090},{\"end\":12182,\"start\":12161},{\"end\":17954,\"start\":17928},{\"end\":17975,\"start\":17954},{\"end\":18317,\"start\":18296},{\"end\":18416,\"start\":18390},{\"end\":18437,\"start\":18416},{\"end\":26578,\"start\":26558},{\"end\":27520,\"start\":27500},{\"end\":31952,\"start\":31912},{\"end\":32356,\"start\":32350},{\"end\":33298,\"start\":33275},{\"end\":33789,\"start\":33764},{\"end\":33813,\"start\":33789},{\"end\":33902,\"start\":33885},{\"end\":35033,\"start\":35013},{\"end\":35867,\"start\":35847},{\"end\":38769,\"start\":38748},{\"end\":40189,\"start\":40168},{\"end\":42047,\"start\":42022},{\"end\":43091,\"start\":43077},{\"end\":43109,\"start\":43091},{\"end\":43396,\"start\":43377},{\"end\":45326,\"start\":45302},{\"end\":55072,\"start\":55055}]", "figure": "[{\"attributes\":{\"id\":\"fig_0\"},\"end\":57010,\"start\":56777},{\"attributes\":{\"id\":\"fig_1\"},\"end\":57524,\"start\":57011},{\"attributes\":{\"id\":\"fig_2\"},\"end\":57829,\"start\":57525},{\"attributes\":{\"id\":\"fig_3\"},\"end\":57881,\"start\":57830},{\"attributes\":{\"id\":\"fig_4\"},\"end\":58023,\"start\":57882},{\"attributes\":{\"id\":\"fig_5\"},\"end\":58402,\"start\":58024},{\"attributes\":{\"id\":\"fig_6\"},\"end\":58555,\"start\":58403},{\"attributes\":{\"id\":\"fig_7\"},\"end\":58750,\"start\":58556},{\"attributes\":{\"id\":\"fig_8\"},\"end\":60386,\"start\":58751},{\"attributes\":{\"id\":\"fig_9\"},\"end\":61228,\"start\":60387},{\"attributes\":{\"id\":\"fig_10\"},\"end\":61655,\"start\":61229},{\"attributes\":{\"id\":\"fig_11\"},\"end\":61700,\"start\":61656},{\"attributes\":{\"id\":\"fig_12\"},\"end\":61745,\"start\":61701},{\"attributes\":{\"id\":\"fig_13\"},\"end\":62095,\"start\":61746},{\"attributes\":{\"id\":\"fig_14\"},\"end\":62262,\"start\":62096},{\"attributes\":{\"id\":\"fig_15\"},\"end\":62382,\"start\":62263},{\"attributes\":{\"id\":\"tab_6\",\"type\":\"table\"},\"end\":63041,\"start\":62383},{\"attributes\":{\"id\":\"tab_7\",\"type\":\"table\"},\"end\":63395,\"start\":63042}]", "paragraph": "[{\"end\":1618,\"start\":896},{\"end\":2616,\"start\":1620},{\"end\":3611,\"start\":2618},{\"end\":3660,\"start\":3613},{\"end\":3751,\"start\":3662},{\"end\":3870,\"start\":3753},{\"end\":4046,\"start\":3872},{\"end\":4375,\"start\":4048},{\"end\":4699,\"start\":4398},{\"end\":4808,\"start\":4701},{\"end\":5450,\"start\":4838},{\"end\":5768,\"start\":5468},{\"end\":6373,\"start\":5780},{\"end\":7388,\"start\":6375},{\"end\":8658,\"start\":7478},{\"end\":9104,\"start\":8660},{\"end\":9510,\"start\":9106},{\"end\":9891,\"start\":9512},{\"end\":10355,\"start\":9920},{\"end\":11137,\"start\":10374},{\"end\":11841,\"start\":11197},{\"end\":11996,\"start\":11843},{\"end\":12250,\"start\":11998},{\"end\":12741,\"start\":12269},{\"end\":14547,\"start\":12743},{\"end\":15844,\"start\":14549},{\"end\":17571,\"start\":15860},{\"end\":18086,\"start\":17612},{\"end\":19023,\"start\":18136},{\"end\":20208,\"start\":19025},{\"end\":20805,\"start\":20210},{\"end\":21526,\"start\":20807},{\"end\":21606,\"start\":21528},{\"end\":22141,\"start\":21608},{\"end\":22302,\"start\":22193},{\"end\":23066,\"start\":22304},{\"end\":23385,\"start\":23068},{\"end\":23670,\"start\":23432},{\"end\":24224,\"start\":23705},{\"end\":25024,\"start\":24272},{\"end\":25871,\"start\":25088},{\"end\":26477,\"start\":25908},{\"end\":26847,\"start\":26479},{\"end\":27215,\"start\":26849},{\"end\":27523,\"start\":27217},{\"end\":28046,\"start\":27525},{\"end\":28189,\"start\":28048},{\"end\":28694,\"start\":28223},{\"end\":30075,\"start\":28696},{\"end\":30587,\"start\":30077},{\"end\":31373,\"start\":30602},{\"end\":31870,\"start\":31375},{\"end\":31956,\"start\":31872},{\"end\":32243,\"start\":32008},{\"end\":32432,\"start\":32245},{\"end\":32811,\"start\":32462},{\"end\":33060,\"start\":32813},{\"end\":33516,\"start\":33099},{\"end\":34029,\"start\":33518},{\"end\":34975,\"start\":34135},{\"end\":36091,\"start\":35010},{\"end\":36528,\"start\":36125},{\"end\":36927,\"start\":36530},{\"end\":37427,\"start\":36960},{\"end\":37503,\"start\":37429},{\"end\":37942,\"start\":37531},{\"end\":38571,\"start\":38013},{\"end\":39569,\"start\":38573},{\"end\":40135,\"start\":39644},{\"end\":40511,\"start\":40137},{\"end\":40634,\"start\":40560},{\"end\":41116,\"start\":40715},{\"end\":41415,\"start\":41213},{\"end\":41542,\"start\":41491},{\"end\":41873,\"start\":41602},{\"end\":42194,\"start\":41926},{\"end\":42419,\"start\":42196},{\"end\":42577,\"start\":42479},{\"end\":42902,\"start\":42579},{\"end\":43662,\"start\":42973},{\"end\":44396,\"start\":43664},{\"end\":44553,\"start\":44416},{\"end\":44847,\"start\":44555},{\"end\":45159,\"start\":44849},{\"end\":45397,\"start\":45161},{\"end\":45634,\"start\":45445},{\"end\":46078,\"start\":45657},{\"end\":46301,\"start\":46080},{\"end\":46423,\"start\":46303},{\"end\":47463,\"start\":46457},{\"end\":47691,\"start\":47465},{\"end\":47960,\"start\":47724},{\"end\":48061,\"start\":47962},{\"end\":49170,\"start\":48101},{\"end\":50112,\"start\":49172},{\"end\":51042,\"start\":50191},{\"end\":51290,\"start\":51084},{\"end\":52112,\"start\":51292},{\"end\":52757,\"start\":52114},{\"end\":53274,\"start\":52759},{\"end\":53748,\"start\":53276},{\"end\":54926,\"start\":53750},{\"end\":55862,\"start\":54962},{\"end\":56389,\"start\":55918},{\"end\":56776,\"start\":56391}]", "formula": "[{\"attributes\":{\"id\":\"formula_0\"},\"end\":4837,\"start\":4809},{\"attributes\":{\"id\":\"formula_1\"},\"end\":7477,\"start\":7389},{\"attributes\":{\"id\":\"formula_2\"},\"end\":32007,\"start\":31957},{\"attributes\":{\"id\":\"formula_4\"},\"end\":40559,\"start\":40512},{\"attributes\":{\"id\":\"formula_5\"},\"end\":40714,\"start\":40635},{\"attributes\":{\"id\":\"formula_6\"},\"end\":41212,\"start\":41117},{\"attributes\":{\"id\":\"formula_7\"},\"end\":41490,\"start\":41416},{\"attributes\":{\"id\":\"formula_8\"},\"end\":41601,\"start\":41543},{\"attributes\":{\"id\":\"formula_9\"},\"end\":41925,\"start\":41874},{\"attributes\":{\"id\":\"formula_10\"},\"end\":42478,\"start\":42420}]", "table_ref": "[{\"end\":24624,\"start\":24617}]", "section_header": "[{\"attributes\":{\"n\":\"1\"},\"end\":894,\"start\":882},{\"attributes\":{\"n\":\"2\"},\"end\":4396,\"start\":4378},{\"attributes\":{\"n\":\"3\"},\"end\":5466,\"start\":5453},{\"attributes\":{\"n\":\"3.1\"},\"end\":5778,\"start\":5771},{\"attributes\":{\"n\":\"3.2\"},\"end\":9918,\"start\":9894},{\"attributes\":{\"n\":\"3.2.1\"},\"end\":10372,\"start\":10358},{\"attributes\":{\"n\":\"3.2.2\"},\"end\":11151,\"start\":11140},{\"attributes\":{\"n\":\"4\"},\"end\":11195,\"start\":11154},{\"attributes\":{\"n\":\"4.1\"},\"end\":12267,\"start\":12253},{\"attributes\":{\"n\":\"4.2\"},\"end\":15858,\"start\":15847},{\"attributes\":{\"n\":\"4.3\"},\"end\":17610,\"start\":17574},{\"attributes\":{\"n\":\"5\"},\"end\":18134,\"start\":18089},{\"end\":22191,\"start\":22144},{\"attributes\":{\"n\":\"6\"},\"end\":23430,\"start\":23388},{\"attributes\":{\"n\":\"6.1\"},\"end\":23703,\"start\":23673},{\"attributes\":{\"n\":\"6.1.1\"},\"end\":24270,\"start\":24227},{\"attributes\":{\"n\":\"6.1.2\"},\"end\":25086,\"start\":25027},{\"attributes\":{\"n\":\"6.2\"},\"end\":25906,\"start\":25874},{\"attributes\":{\"n\":\"6.3\"},\"end\":28221,\"start\":28192},{\"attributes\":{\"n\":\"7\"},\"end\":30600,\"start\":30590},{\"end\":32460,\"start\":32435},{\"end\":33097,\"start\":33063},{\"end\":34074,\"start\":34032},{\"end\":34133,\"start\":34077},{\"end\":35008,\"start\":34978},{\"end\":36123,\"start\":36094},{\"end\":36958,\"start\":36930},{\"end\":37529,\"start\":37506},{\"end\":38011,\"start\":37945},{\"end\":39642,\"start\":39572},{\"end\":42971,\"start\":42905},{\"end\":44414,\"start\":44399},{\"end\":45443,\"start\":45400},{\"end\":45655,\"start\":45637},{\"end\":46455,\"start\":46426},{\"end\":47722,\"start\":47694},{\"end\":48099,\"start\":48064},{\"end\":50189,\"start\":50115},{\"end\":51082,\"start\":51045},{\"end\":54960,\"start\":54929},{\"end\":55916,\"start\":55865},{\"end\":56788,\"start\":56778},{\"end\":57032,\"start\":57012},{\"end\":57534,\"start\":57526},{\"end\":57893,\"start\":57883},{\"end\":58035,\"start\":58025},{\"end\":58414,\"start\":58404},{\"end\":58567,\"start\":58557},{\"end\":60398,\"start\":60388},{\"end\":61668,\"start\":61657},{\"end\":61713,\"start\":61702},{\"end\":61758,\"start\":61747},{\"end\":62108,\"start\":62097},{\"end\":62275,\"start\":62264}]", "table": "[{\"end\":63041,\"start\":62826},{\"end\":63395,\"start\":63298}]", "figure_caption": "[{\"end\":57010,\"start\":56790},{\"end\":57524,\"start\":57035},{\"end\":57829,\"start\":57536},{\"end\":57881,\"start\":57832},{\"end\":58023,\"start\":57895},{\"end\":58402,\"start\":58037},{\"end\":58555,\"start\":58416},{\"end\":58750,\"start\":58569},{\"end\":60386,\"start\":58753},{\"end\":61228,\"start\":60400},{\"end\":61655,\"start\":61231},{\"end\":61700,\"start\":61671},{\"end\":61745,\"start\":61716},{\"end\":62095,\"start\":61761},{\"end\":62262,\"start\":62111},{\"end\":62382,\"start\":62278},{\"end\":62826,\"start\":62385},{\"end\":63298,\"start\":63044}]", "figure_ref": "[{\"attributes\":{\"ref_id\":\"fig_2\"},\"end\":25771,\"start\":25763},{\"attributes\":{\"ref_id\":\"fig_2\"},\"end\":34789,\"start\":34781},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":44342,\"start\":44333},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":44952,\"start\":44943},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":46682,\"start\":46673},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":48059,\"start\":48050},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":48613,\"start\":48604},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":55185,\"start\":55176},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":55435,\"start\":55426}]", "bib_author_first_name": null, "bib_author_last_name": null, "bib_entry": null, "bib_title": null, "bib_author": null, "bib_venue": null}}}, "year": 2023, "month": 12, "day": 17}