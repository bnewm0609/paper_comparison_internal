{"id": 222331525, "updated": "2022-01-21 06:05:23.665", "metadata": {"title": "Hardware-based Always-On Heap Memory Safety", "authors": "[{\"middle\":[],\"last\":\"Kim\",\"first\":\"Yonghae\"},{\"middle\":[],\"last\":\"Lee\",\"first\":\"Jaekyu\"},{\"middle\":[],\"last\":\"Kim\",\"first\":\"Hyesoon\"}]", "venue": "2020 53rd Annual IEEE/ACM International Symposium on Microarchitecture (MICRO)", "journal": "2020 53rd Annual IEEE/ACM International Symposium on Microarchitecture (MICRO)", "publication_date": {"year": 2020, "month": null, "day": null}, "abstract": "Memory safety violations, caused by illegal use of pointers in unsafe programming languages such as C and C++, have been a major threat to modern computer systems. However, implementing a low-overhead yet robust runtime memory safety solution is still challenging. Various hardware-based mechanisms have been proposed, but their significant hardware requirements have limited their feasibility, and their performance overhead is too high to be an always-on solution.In this paper, we propose AOS, a low-overhead always-on heap memory safety solution that implements a novel bounds-checking mechanism. We identify that the major challenges of existing bounds-checking approaches are 1) the extra instruction overhead for memory checking and metadata propagation and 2) the complex metadata addressing. To address these challenges, using Arm PA primitives, we leverage unused upper bits of a pointer to store a key and have it propagated along with the pointer address, eliminating propagation overhead. Then, we use the embedded key to index a hashed bounds table to achieve efficient metadata management. We also introduce a micro-architectural unit to remove the need for memory checking instructions. We show that AOS overcomes all the aforementioned challenges and demonstrate its feasibility as an efficient runtime memory safety solution. Our evaluation for SPEC 2006 workloads shows an 8.4% performance overhead on average.", "fields_of_study": "[\"Computer Science\"]", "external_ids": {"arxiv": null, "mag": "3101333446", "acl": null, "pubmed": null, "pubmedcentral": null, "dblp": "conf/micro/KimLK20", "doi": "10.1109/micro50266.2020.00095"}}, "content": {"source": {"pdf_hash": "7bbc2122c136a9a94dd78244d3d5401e589672ea", "pdf_src": "IEEE", "pdf_uri": null, "oa_url_match": false, "oa_info": null}, "grobid": {"id": "8086d55d4f4421f39bc31c55b58bc71df3966679", "type": "plain-text", "url": "s3://ai2-s2-pdf-extraction-prod/parse-results/s2orc_worker/7bbc2122c136a9a94dd78244d3d5401e589672ea.txt", "contents": "\nHardware-based Always-On Heap Memory Safety\n\n\nYonghae Kim yonghae@gatech.edu \nArm Research\nGeorgia Institute of Technology\nGeorgia Institute of Technology\n\n\nJaekyu Lee jaekyu.lee@arm.com \nArm Research\nGeorgia Institute of Technology\nGeorgia Institute of Technology\n\n\nHyesoon Kim hyesoon@cc.gatech.edu \nArm Research\nGeorgia Institute of Technology\nGeorgia Institute of Technology\n\n\nHardware-based Always-On Heap Memory Safety\n10.1109/MICRO50266.2020.00095Index Terms-Securitysoftware and system safetypointer authentication\nMemory safety violations, caused by illegal use of pointers in unsafe programming languages such as C and C++, have been a major threat to modern computer systems. However, implementing a low-overhead yet robust runtime memory safety solution is still challenging. Various hardware-based mechanisms have been proposed, but their significant hardware requirements have limited their feasibility, and their performance overhead is too high to be an always-on solution.In this paper, we propose AOS, a low-overhead always-on heap memory safety solution that implements a novel boundschecking mechanism. We identify that the major challenges of existing bounds-checking approaches are 1) the extra instruction overhead for memory checking and metadata propagation and 2) the complex metadata addressing. To address these challenges, using Arm PA primitives, we leverage unused upper bits of a pointer to store a key and have it propagated along with the pointer address, eliminating propagation overhead. Then, we use the embedded key to index a hashed bounds table to achieve efficient metadata management. We also introduce a micro-architectural unit to remove the need for memory checking instructions. We show that AOS overcomes all the aforementioned challenges and demonstrate its feasibility as an efficient runtime memory safety solution. Our evaluation for SPEC 2006 workloads shows an 8.4% performance overhead on average.\n\nAbstract-Memory safety violations, caused by illegal use of pointers in unsafe programming languages such as C and C++, have been a major threat to modern computer systems. However, implementing a low-overhead yet robust runtime memory safety solution is still challenging. Various hardware-based mechanisms have been proposed, but their significant hardware requirements have limited their feasibility, and their performance overhead is too high to be an always-on solution.\n\nIn this paper, we propose AOS, a low-overhead always-on heap memory safety solution that implements a novel boundschecking mechanism. We identify that the major challenges of existing bounds-checking approaches are 1) the extra instruction overhead for memory checking and metadata propagation and 2) the complex metadata addressing. To address these challenges, using Arm PA primitives, we leverage unused upper bits of a pointer to store a key and have it propagated along with the pointer address, eliminating propagation overhead. Then, we use the embedded key to index a hashed bounds table to achieve efficient metadata management. We also introduce a micro-architectural unit to remove the need for memory checking instructions. We show that AOS overcomes all the aforementioned challenges and demonstrate its feasibility as an efficient runtime memory safety solution. Our evaluation for SPEC 2006 workloads shows an 8.4% performance overhead on average. Index Terms-Security; software and system safety; pointer authentication;\n\n\nI. INTRODUCTION\n\nMemory safety violations have been a conventional but persistent problem in computer systems. Memory safety issues have inherently existed in unsafe programming languages such as C and C++ because of the illicit use of pointers. Recent industry reports [1], [2] revealed that memory safety errors addressed in their products accounted for more than 70% of all security issues. This demonstrates that memory safety errors are still prevalent and exploitable by attackers.\n\nResearchers have proposed extensive amounts of softwareand hardware-based work to prevent such vulnerabilities. Software techniques [3]- [7] provide strong security guarantees, but they are not suitable runtime solutions because of their significant performance overhead. Instead, their primary purpose is for testing and debugging. For example, AddressSanitizer (ASan), one of the most popular memory error detectors, showed a 73% slowdown [3].\n\nHardware-based mechanisms typically achieve less performance overhead, but they do not attain desired properties altogether, such as broad security coverage, high performance, and low hardware overhead. Instead, they trade off one property for another. For example, hardware-based blacklisting mechanisms [8], [9] set the surrounding regions of memory objects as redzones and prohibit their access to prevent over/underflow attacks. Such an approach is efficient since monitoring could be performed in parallel with normal operations, as in REST [8]. However, they cannot prevent nonadjacent illegal accesses that jump over the redzones. Given the upward trend of non-adjacent spatial safety violations (over 60% since 2014) [2], we expect that their effectiveness will be increasingly limited.\n\nWhitelisting mechanisms enforce memory operations to only access allowed memory locations, providing stronger security capabilities. For example, bounds-checking mechanisms [10]- [13] associate bounds metadata with pointers to protect and perform address range checking. Despite more powerful security guarantees, they incur significant hardware changes and design complexity. Their performance overhead is also too high to be an always-on solution.\n\nWe observe that the major challenges of existing boundschecking approaches are 1) the extra instruction overhead for memory checking and metadata propagation and 2) the complex metadata addressing. For instance, Watchdog [11], a prior hardware-based bounds-checking mechanism, showed 44% more dynamic instruction counts, causing significant performance degradation. It also requires register extensions (up to 256-bit) to propagate the metadata and use it inside a CPU core, which significantly increases power consumption. Moreover, prior approaches often require a complex addressing scheme for metadata accesses. For example, Intel Memory Protection Extensions (MPX) [12] requires approximately three register-to-register moves, three shifts, and two memory loads to access its hierarchical bounds table.\n\nTo tackle these challenges, we propose AOS, a lowoverhead Always-On memory Safety solution for heap protection that implements a novel bounds-checking mechanism. We utilize Arm pointer authentication (PA) primitives [14] to store a pointer authentication code (PAC) into the unused highorder bits of a pointer for memory safety. By doing so, we allow the embedded PAC to be passed along with the pointer address, removing extra instructions for metadata propagation. Furthermore, we sign all data pointers returned by dynamic memory allocation, i.e., placing a PAC into the pointer, and use the PAC to index a hashed bounds table that stores bounds metadata. This scheme enables efficient metadata management since the addressing becomes simplified using the base address of the table and the PAC as an offset.\n\nTo remove additional instructions required by prior work [10]- [12] for bounds checking, we introduce a new micro-architectural structure, a memory check unit (MCU). In AOS, every memory instruction is enqueued in the MCU when it is issued to the load-store unit (LSU). If a pointer address is signed, i.e., has an embedded PAC, we perform bounds checking to validate the access, which enables an efficient selective memory safety checking mechanism.\n\nAOS achieves efficient yet complete spatial and temporal memory safety for a heap region. AOS prevents spatial safety violations (e.g., out-of-bounds access) by checking bounds for all signed memory accesses. Moreover, AOS can detect temporal errors, such as the use of a dangling pointer, useafter-free (UAF), and double free. When a signed data pointer is freed, AOS clears the associated bounds information while leaving the pointer as being signed. Because of the absence of its bounds metadata, subsequent use of the pointer will fail in bounds checking. With the prevalence of heap memory vulnerabilities, AOS provides robust protection against the most prevailing attack vectors.\n\nWe also discuss how AOS can be extended to support pointer integrity by utilizing Arm PA primitives and achieve practical defenses against runtime control-flow attacks, such as return-oriented programming (ROP) [15] and jump-oriented programming (JOP) [16], and data-oriented attacks by corrupted data pointers. AOS also provides precise exception handling by delaying architectural state updates until an instruction retires with a successful bounds checking. This enables AOS to prevent leakage of secret data by an illegal read and memory corruption by an illegal write.\n\nGiven the limited PAC size (11 to 32 bits) under typical virtual address schemes in a processor, some memory objects may have the same PAC value, causing PAC collisions. To address this issue, we develop a multi-way bounds-table structure with gradual resizing to accommodate multiple bounds  metadata for each PAC. A process begins its execution with  a modest-size table and increases the associativity of the  table upon an insertion failure due to insufficient capacity.  This approach enables efficient and scalable bounds-table  management. This paper claims the following contributions: \u2022 We propose AOS, which overcomes the main challenges of existing bounds-checking approaches and realizes a practical bounds-checking mechanism for heap protection. II. BACKGROUND\n\n\nA. Memory Safety Violations\n\nMemory safety violations are a substantial threat to modern computer systems since they can lead to system crashes and security vulnerabilities. Fig. 1     exploitation, House of Spirit, which is a data-oriented attack on glibc. The attack crafts a data pointer controlled by an attacker so it can bypass the security tests of free(). Once freed, the pointer is inserted into a fastbin, which is one of the linked lists holding free chunks. Then, the next malloc() returns the address 16 bytes ahead of the crafted data pointer and ends up allowing subsequent malicious operations on the attacker-controlled memory locations. Fig. 2 shows a root cause trend of memory safety vulnerabilities reported by Microsoft [2]. We observe that stack corruption errors show a downward trend thanks to software protection methods, including canaries, address space layout randomization (ASLR), and pointer authentication. It also shows that heap vulnerabilities, such as heap corruption, outof-bounds (OOB) read, and use-after-free, have been dominant in recent years. Since other vulnerabilities, such as type confusion and uninitialized use, can be detected and mitigated by static analysis tools [17]- [19], we recognize that heap memory vulnerabilities are the most problematic and challenging.  \n\n\nB. Arm Pointer Authentication\n\nArm PA is a security primitive added in the Armv8.3-A extension [14]. It is designed to prevent illicit pointer modification by adding new instructions for signing and authenticating pointer authentication codes (PACs). The PAC is calculated using a cryptographic algorithm such as the QARMA block cipher [20]. QARMA takes two inputs, a pointer, and a context. The truncated output from QARMA becomes the PAC. The effective virtual address space in 64-bit architectures is typically less than 64 bits. By leveraging this idea, Arm PA places a PAC into the unused high-order bits of a pointer to protect and verifies its integrity by authenticating the PAC before use. Depending on the virtual address scheme in a processor, the PAC size ranges from 11 to 32 bits. Fig. 3 shows a return address signing scheme using Arm PA. In the prologue, pacia (line 1) computes and embeds a PAC into the return address (lr) using a stack pointer (sp) as a modifier and key A. In the epilogue, autia (line 6) authenticates the return address using the same modifier and key pair. If a pointer is corrupted, the authentication fails, and any further use of the pointer leads to a translation fault. Prior work [21] has reported a negligible performance overhead (\u223c0.5%) by return address signing.\n\nDespite its low overhead, Arm PA does not provide spatial and temporal safety. It can detect neither out-of-bounds accesses nor temporal errors. The prevalence of such spatial (e.g., heap OOB read) and temporal (e.g., use-after-free) violations, shown in Fig. 2, demonstrates that the PA mechanism cannot be a sole security solution, and cooperation with a stricter defense is essential.\n\n\nIII. AOS: ALWAYS-ON MEMORY SAFETY\n\nIn this section, we describe challenges in implementing an efficient bounds-checking mechanism and how AOS overcomes such challenges. Then, we outline AOS and its operations.\n\nA. Challenges Challenge 1. Register extension. Many prior studies [10], [11], [22], [23] implement a fat pointer to hold metadata needed for memory checking by extending every register. For example, Watchdog [11] extends registers up to 256 bits for bounds and use-after-free checking. A fat pointer itself contains the metadata, as shown in Fig. 4a, and every pointer dereferencing is checked with its associated metadata. However, such an approach not only requires changes to almost the entire  pipeline stages but also increases power consumption because of the increased bit width of register read/write operations.\n\nChallenge 2. Bounds-checking operation. Bounds checking is typically performed by extra instructions [10]- [12]. For instance, Watchdog inserts a check \u00b5op before every memory access (z and { in Fig. 5a). The check \u00b5op uses its identifier (id) for use-after-free detection and bounds checking. Adding check \u00b5ops resulted in 29% more dynamic instructions in their evaluation.  pointer arithmetic (| and } in Fig. 5a). Challenge 4. High memory overhead. Bounds metadata often incurs significant memory overhead. In particular, shadow memory implementations mirror virtual address space to the shadow space [3], [10], as shown in Fig. 4b, which results in severe memory fragmentation caused by page-granularity allocation. For instance, ASan reserves one-eighth of the virtual address space for shadow space [3]. Challenge 5. Complex metadata addressing. To perform bounds checking, the associated metadata of each pointer needs to be loaded from memory. Intel MPX [12] implements a two-level address translation scheme to access bounds metadata, as shown in Fig. 4c. This multi-stage translation requires approximately three register-to-register moves, three shifts, and two memory loads, causing significant performance degradation for memory-intensive applications.\n\n\nB. How We Overcome Challenges\n\nTo tackle the above challenges, we use Arm PA as a vehicle. If we sign a data pointer as Arm PA does, which places a PAC into its upper bits, the PAC is passed through along with the pointer address without any hardware support or extra operations. This scheme allows us to avoid register extension (Challenge 1) and additional instructions for metadata propagation (Challenge 3).\n\nFurthermore, data-pointer signing leaves a mark in the pointer, indicating that the memory access by the pointer needs to be validated by bounds checking. Once we see a signed data pointer being dereferenced, we perform bounds checking and validate the access. Since the need for bounds checking is determined only by examining the pointer address, this approach removes the necessity of explicit extra instructions for bounds checking (Challenge 2).\n\nLast but not least, using a pointer's PAC to index a bounds table simplifies the addressing scheme, as shown in Fig. 4d. We can calculate the metadata address by adding a PAC to the base address of a bounds table, enabling efficient bounds metadata accesses. Moreover, it alleviates the memory overhead, as it neither mirrors memory pages into shadow space nor causes significant memory fragmentation. As a result, we tackle challenges 4 and 5.\n\n\nC. AOS Operations\n\nIn this section, we briefly describe the operations of AOS. Fig. 6 shows an overview of AOS.\n\n1) Pointer Signing: We sign data pointers returned by malloc() using extended Arm PA instruction set architectures (ISAs) ( \u00a7IV-A). We instrument all malloc and free calls to generate a PAC and bounds-table management instructions ( \u00a7IV-C) using our custom LLVM passes ( \u00a7IV-B).\n\n2) Bounds Checking: To enable bounds checking without explicit instructions, we add a memory check unit (MCU) ( \u00a7V-A) in the core pipeline. When a memory instruction is issued to the load-store unit (LSU), it is also sent to the MCU. Since we sign every data pointer returned by malloc(), the MCU can identify memory accesses that require validation and perform selective bounds checking. For bounds-checking failures, we develop a new class of exceptions handled by the operating system (OS) ( \u00a7IV-D).\n\n3) Metadata Management: We store the bounds information of all heap memory chunks in a hashed bounds table (HBT) ( \u00a7V-B), which is similar to a hash table. A key of the HBT is a PAC value embedded in a pointer. To handle hash collisions, i.e., too many bounds to store in a table row, we dynamically resize the HBT. For an efficient bounds-searching process, we keep track of recently used bounds in a tag buffer ( \u00a7V-C). To reduce memory overhead and traffic, we develop a bounds-compression scheme ( \u00a7V-D).\n\n\n4) Precise Exception:\n\nWe provide precise exception handling by preventing architectural state updates until an instruction requiring validation retires with successful boundschecking. This prevents illegal memory accesses from reading sensitive data or writing malicious data.\n\n\nD. Threat Model\n\nTo demonstrate the effectiveness of our defense mechanism, we follow the typical attacker capabilities consistent with prior work. Our threat model assumes a powerful attacker who can exploit one or more memory vulnerabilities that may exist in a user space process, reading or writing arbitrary memory locations. We do not limit the location of vulnerabilities and possible attack vectors enabled by the attacker capabilities. However, we assume that the attacker cannot infer PA keys, which are stored in special registers and must be invisible to user space. We also assume that hardware components are trustworthy and therefore leave out of scope any attacks that exploit hardware vulnerabilities, such as row-hammer attacks [24], side-channel attacks [25], [26], and speculative execution attacks [27], [28].\n\nWith the prevalence of heap vulnerabilities, our work focuses on heap protection. We believe that our approach can be applied to other data-pointer types (e.g., stack pointers) in a similar manner but leave this as future work.\n\n\nIV. SOFTWARE EXTENSIONS\n\n\nA. ISA Extension\n\nWe introduce the following new instructions in AOS:\n\n\u2022 pacma/pacmb <Xd>,<Xn|SP>,<Xm>: These are variants of pacda/pacdb in Arm PA that compute a PAC and insert it into a pointer <Xd> using a modifier <Xn|SP> and key A or B. pacma/pacmb take the additional third operand <Xm>, the size of a new memory chunk. This is used to calculate a 2-bit address hashing code (AHC), which is used to 1) indicate a signed (protected) pointer when the value is nonzero and 2) indicate a type of invariant bits in a pointer associated with a memory object. We detail how the AHC is created and used in Section V-C. \u2022 xpacm <Xd>: This instruction is a variant of xpacd. It strips both PAC and AHC from a pointer. \u2022 autm <Xd>: This is a variant of autda/autdb, Arm PA authentication instructions. autm authenticates a pointer <Xd> by checking whether the pointer was signed by AOS, i.e., has a nonzero AHC. However, it does not strip the AHC after authentication. If the AHC is zero, the pointer is considered corrupted, and the authentication fails. \u2022 bndstr <Xn>,<Xm>: This instruction encodes 8-byte bounds metadata using a pointer address <Xn> and a size <Xm>, and stores them in an entry of the HBT. \u2022 bndclr <Xn>: This instruction clears the bounds metadata associated with a pointer address <Xn> by writing an 8-byte zero value into its corresponding bounds in the HBT.\n\n\nB. Compiler Support\n\nTo instrument new instructions for bounds checking, we implement new passes to the optimizer and the AArch64 backend in LLVM [29]. The AOS-opt-pass optimizer pass is designed to detect memory allocation and deallocation calls and insert new intrinsic functions. For the allocation call, the aos_malloc intrinsic function is inserted with two operands after the call, the pointer address returned by malloc() and the size of a new memory chunk. Also, after the deallocation call, the aos_free intrinsic function is inserted with one operand, the signed pointer address to free. \n\n\nC. Program Instrumentation\n\nAssign bounds upon memory allocation. Fig. 7a shows datapointer signing and bounds storing. AOS inserts two new instructions following malloc(). pacma (line 2) signs the data pointer returned by malloc() using a stack pointer (sp) as a modifier, and bndstr (line 3) computes bounds and stores them in the HBT.\n\nRelease bounds upon memory deallocation. Fig. 7b shows data-pointer stripping and bounds clearing. First, we insert bndclr before free() (line 1). The bndclr instruction clears the bounds metadata associated with the data pointer to free. The initialized entry will be reused later by a newly allocated memory object that has the same PAC. We also place xpacm (line 2) because freeing a memory chunk inherently invokes out-of-bounds accesses by the data pointer to free. In many standard C libraries, such as glibc (GNU C library), the memory allocator accesses the metadata of the prior and next memory chunks and performs block coalescing to reduce memory fragmentation. Since these accesses are legitimate, we use xpacm to strip the pointer temporarily and avoid unnecessary bounds checking during free(). Finally, we place pacma after free() (line 4) to re-sign the pointer. Since the size does not matter, we pass the zero register, xzr, as a size operand. Re-signing a pointer here, i.e., leaving a freed pointer as being signed, effectively locks the pointer. Any subsequent use of the pointer would fail in bounds checking because of the absence of its corresponding bounds in the HBT. In this way, AOS detects temporal violations.\n\nUnlike prior studies [3], [8], our approach does not demand a quarantine pool to provide temporal safety. Given that the REST [8] software framework's use of a quarantine pool mostly contributed to its performance overhead, avoiding the use of a quarantine pool will be beneficial in terms of performance.\n\n\nD. OS Support\n\nThe OS handles bounds-table management (allocation and resizing) and bounds-checking failures. The OS creates an HBT when a process is initiated. AOS introduces a new class of exceptions, an AOS exception, to handle a new type of failure. If a CPU core detects an instruction faulted by a bounds operation, it triggers an AOS exception, and the OS handles it depending on the instruction type:\n\n\u2022 bndstr: This indicates a bounds-store failure due to insufficient capacity in a row of the HBT. We allocate a new, larger bounds table and copy entries of the old table into the new one.\n\n\u2022 bndclr: This indicates a bounds-clear failure due to double free or free() by an invalid address. \u2022 Load/store: This indicates a bounds-checking failure, which could occur by one of the memory safety violations. Upon a failure, the information will be signaled to a user. Developers can implement the exception handler to either 1) terminate the process or 2) report an error and resume.\n\n\nV. HARDWARE EXTENSIONS A. Memory Check Unit\n\nTo perform memory safety checking without extra instructions, AOS adds a functional unit, called an MCU, inside a core. The MCU comprises a memory check queue (MCQ) and a bounds way buffer (BWB). It is located next to the LSU and performs bounds-table management and bounds checking. As shown in Fig. 6, we issue the bounds-table management instructions, bndstr and bndclr, directly to the MCU. To validate memory accesses when a memory instruction is issued to the LSU, we also send the instruction to the MCU. Thus, an instruction can be issued when both the LSU and the MCU are not full.\n\nThen, we check the instruction enqueued in the MCU to see whether its pointer address has been signed by checking the AHC value. For signed pointers, AOS performs bounds checking, which may iterate over multiple entries in an HBT row until it finds valid bounds. To reduce the overhead of iterative bounds searching, we utilize 64-byte (a typical cacheline size in a core) load requests and perform parallel bounds checking using multiple bounds in the same cache line. Since each bounds metadata is compressed to 8 bytes ( \u00a7V-D), up to eight bounds can be stored in one way of an HBT row. Note that all the bounds-access operations in AOS conform to existing cache coherence protocols and memory consistency models.\n\n1) Memory Check Queue: The MCQ stores in-flight bounds store, clear, and checking operations. Each MCQ entry has the following fields:\n\n\u2022 Valid indicates the validity of an entry.\n\n\u2022 Type differentiates the instruction type between boundstable management (bndstr/bndclr) and load/store. \u2022 Addr stores a pointer address. During bounds checking, we compare the address against the lower and upper bounds. \u2022 BndData holds 8-byte bounds from a bndstr or bndclr instruction to store them in the HBT. \u2022 BndAddr stores the address of an HBT way.\n\n\u2022 Way indicates which way to access in a row of the HBT.\n\n\u2022 Count keeps the number of ways accessed so far for the given bounds-checking operation. Count will be incremented if valid bounds are not found at an attempt. \u2022 Committed indicates whether the instruction has been committed from the ROB. To maintain the store-store ordering enforced by memory consistency, bounds-store requests should be sent in program order. Hence, they can be sent to memory only after Committed is set. 2) Finite State Machines: Depending on the instruction type, each MCQ entry operates in one of the FSM modes: one for bndstr/bndclr (Fig. 8a) or another for load/store (Fig. 8b). We describe the states and the transitions among them as follows. Init. In this state, BndAddr and BndData are calculated for a bndstr or bndclr, and the current state transitions to the OccChk state. In the case of a signed load/store, BndAddr is calculated, and this state moves to the BndChk state. If the pointer is not signed, it moves to the Done state. OccChk. The multiple bounds addressed by BndAddr are loaded from memory, and occupancy checking is performed. bndstr looks for an empty (zero) bounds, and bndclr checks if the loaded lower bound is the same as its pointer address. If it succeeds, this state transitions to BndStr and IncCnt otherwise. BndChk. Parallel bounds checking is performed using the multiple bounds addressed by BndAddr in this state. If the valid bounds are found, this state moves to Done. Otherwise, it goes to the IncCnt state. BndStr. The instruction waits until Committed is set, i.e., waits until the instruction is retired from the ROB. Once set, it sends a bounds-store request and moves to the Done state. IncCnt. Upon entering this state, the instruction increases its Count by 1 and recalculates BndAddr to access the next way. If Count reaches the associativity of the HBT, a bounds failure occurs, and the state transitions to Fail. Otherwise, this state transitions back to the previous state, OccChk in the case of bndstr/bndclr or BndChk for a load or store. Fail. This state indicates that the instruction has faulted because of a bounds failure. When an entry retires from the MCQ after becoming the head, an AOS exception is raised and handled by the OS. Before becoming the head, this entry can be replayed by the store-load replay mechanism, which is explained in Section V-E. Done. The instruction in this state has completed its bounds operation and is ready to commit. The head entry in the Done state with Committed set, i.e., the instruction is retired from the ROB, can be deallocated from the MCQ.\n\n\nB. Bounds Table with Gradual Resizing\n\nWe store bounds metadata in a per-process bounds table, called an HBT, the design of which is inspired by Cuckoo hashing [30], which specializes in hash collision resolution. Our HBT design shares some similarities with the Cuckoo hash table, but there are notable differences. Whereas a hash value in Cuckoo hashing is newly calculated whenever a hash table is accessed, AOS calculates a PAC with the base address of a newly allocated memory chunk and keeps the same PAC for a pointer. Furthermore, as opposed to Cuckoo hashing, which maintains multiple hash tables indexed with different hash functions, AOS maintains one hash table indexed with PACs that are embedded in pointers.\n\nThe table has a fixed number of rows, which is the same as the range of PAC values. For example, we have 64K rows for the 16-bit PAC size. An HBT is a multi-way structure to accommodate multiple bounds of different heap memory chunks that have the same PAC. To handle overflow, AOS develops a gradual resizing scheme. The process begins with a modest-size bounds table and dynamically resizes the table when an insertion failure occurs. Upon resizing, we create a new table that is twice the size of the original table by doubling the associativity. To compute a bounds address, we add two registers: 1) BND_BASE to store the base address of the HBT and 2) BND_ASSOC 1 to store the current associativity of the HBT. The row offset is computed using a PAC and BND_ASSOC, as shown in Eq. 1. Then, BndAddr is calculated using Eq. 2, where W is the way to access. Note that BndAddr is always 64B aligned to bring a single cache line.\nRowO f f set = PAC << (log 2 BND ASSOC + 6)\n(1) BndAddr = BND BASE + RowO f f set + (W << 6)\n\n(2)\n\n\nC. Bounds Way Buffer\n\nAlthough we perform parallel bounds checking, bounds searching that incurs multiple cache line accesses may degrade performance since we prevent an instruction from being retired until it finishes its validation. Hence, minimizing the number of iterations is important to avoid performance loss. To optimize the searching process, we introduce a tag buffer, BWB, which keeps track of recent bounds-table accesses and gives the correct location of valid bounds for subsequent bounds checking. Each BWB entry stores a 32-bit tag and the last used way in the HBT. Using only PACs as tags is not enough, since all bounds in the same row have the same PAC. Thus, we concatenate PACs with partial memory addresses and AHCs and use as tags. However, native concatenation can result in different tags for pointer addresses that belong to a same memory chunk. This is because even the upper bits of pointer addresses can change depending on the memory sizes. To resolve this issue, we utilize an embedded AHC that indicates the invariant bits within the memory region.\n\nAlgorithm 1 describes how we determine the invariant bits and calculate the AHC. We categorize memory objects into three groups based on the size: 1) small: about 64B size, 2) medium: about 256B size, and 3) a large group. Note that these are the bin sizes used by typical memory allocators. 1 We consider only power-of-two associativities.\n\nAs explained in Section IV-A, pacma/pacmb embed an AHC along with a PAC in a pointer upon pointer signing. AHC := 3 // >\u2248 256-byte chunk 8: return AHC Algorithm 2 describes how a tag is calculated. It takes three inputs: 1) a pointer address, 2) an AHC, and 3) a PAC. Based on the AHC value, we derive different bits from the pointer. When checking bounds, we compute the tag and look up the BWB to find a matching entry. If found, the corresponding way is used to calculate the bounds address to access. Otherwise, a searching process starts from way-0. bndstr always retrieves way-0. When an instruction retires from the MCQ, the BWB is updated with its tag and the last accessed HBT way. \n\n\nD. Bounds Compression\n\nMalloc-intensive applications require a larger HBT. Since bounds are stored in the cache hierarchy, AOS incurs more cache insertions, causing cache pollution. To alleviate such side effects, AOS develops a bounds-compression scheme that takes advantages of the following two observations: 1) malloc() returns a 16-byte aligned address, and 2) malloc() takes a 32-bit size argument. Compared to 16-byte (lower and upper bounds) and 12-byte (base and size) bounds, we encode 8-byte bounds using a 29-bit partial address (bits 4 to 32) from the base address (lower bound) and a 32-bit memory size. Fig. 9a shows the bounds-compression format.    For bounds checking, we first calculate the truncated address (tAddr) from the current pointer address (Addr), as shown in Fig. 9b. Then, tAddr is compared against the lower bound (dLowBnd) and the upper bound (dUppBnd) decoded from the compressed bounds. Note that C-bit in tAddr is used to compensate for losing a carry bit, caused by partial address encoding (LowBnd [32:4] in Fig. 9a).\n\nWhile we preserve the lower 33 bits of the lower bound, losing upper bits may cause false positives across pointer addresses that share the same lower bits. However, we believe that this is hardly exploitable because colliding addresses should be at least 8GB apart in the virtual address layout. Moreover, they should have the same PAC to pass bounds checking, which is rare considering the high PAC entropy. We further discuss false positives in Section VII-E.\n\n\nE. Store-Load Replay\n\nModern micro-architectures are equipped with out-of-order execution to improve performance, and AOS implements a similar out-of-order MCQ execution. To conform to underlying cache coherence protocols and memory consistency models, we develop a store-load replay mechanism. To preserve storeload ordering, when sending a bounds store request to the cache, bndstr and bndclr check newer MCQ entries. All newer entries with the same PAC need to be replayed with an initialized Count unless an entry is in the Done state because it has completed its execution with valid bounds. Since an HBT is private to each process, AOS does not consider loadload replay or other inter-process memory consistency issues within a core or across multiple cores.\n\nF. Optimization 1) Bounds Cache: Even with our novel boundscompression scheme, bounds metadata may occupy a non-trivial portion of the L1 cache. To reduce the cache pollution, AOS optionally adds a bounds cache, L1 B-cache, which is similar to a lock location cache in Watchdog [11]. While the rest of the cache hierarchy remains the same, we store all bounds metadata in the L1 B-cache, instead of in the L1 D-cache. Since the size of bounds information is small and constant (8-byte), regardless of a memory chunk size, a modest-size cache (e.g., a few tens of KB) can be sufficient.\n\n2) Bounds Forwarding: AOS allows bounds forwarding from a store to a load. When sending a bounds-load request, if an older bounds store with the same PAC is found, its bounds are forwarded to the load, and bounds checking is performed using the forwarded bounds. This forwarding can improve performance by 1) reducing memory accesses for loading bounds and 2) examining bounds early without waiting for the bounds to arrive. Bounds forwarding can be effective, especially when a pointer is dereferenced right after the memory allocation.\n\n3) Bounds   Fig. 10 depicts the bounds-table access during the HBT resizing. HBT 1 and HBT 2 indicate the old and new tables, each of which has T 1 and T 2 (=T 1 *2) ways, respectively. W indicates the way of a row to access. During resizing, the manager maintains two base addresses of old and new tables. It also maintains a row pointer (RowPtr) pointing to a row in the old table, splitting the table into two regions: the migrated region and the live region. If accesses fall into out-of-way in the old table (W \u2265 T 1 ) or the migrated region (PAC < RowPtr), the new table will be accessed using the base address of the new table. Otherwise, it accesses the old table. After resizing is finished, the base address of the old HBT is cleared, and the old HBT is deallocated. \n\n\nG. Hardware Overhead\n\n\nVI. DISCUSSION ON PAC COLLISIONS\n\nIn AOS, PAC collisions affect both performance and security. With a high PAC collision rate, the average number of bounds-table accesses taken to find valid bounds could increase. It may also introduce false positives by data pointers with the same PAC. In this section, we study PAC collisions using QARMA [20]. We base our approach on two assumptions: 1) the block cipher algorithm used to calculate PACs does not suffer from severe hash collisions and 2) most applications rarely maintain a large number of active, i.e., allocated but not yet deallocated, memory chunks.\n\nTo study the first assumption, we run a microbenchmark that continuously calls malloc() 1 million times and   61  6523  6474  namd  1316  1328  1326  gobmk  1021  137369  137358  soplex  140  98955  34025  povray  11667  2461247  2461107  hmmer  1450  1474128  1474128  sjeng  6  6  2  libquantum  5  180  180  h264ref  13857  38275  38273  lbm  5  7  7  omnetpp  1993737  21244416  21244416  astar  190984  1116621  1116621  sphinx3  200686  14224690  14024020 generates 16-bit PAC values. To compute a PAC, we use a 64-bit context value (0x477d469dec0b8762), a 128-bit key (0x84be85ce9804e94bec2802d4e0a488e9), and the pointer address returned by malloc(). Fig. 11 shows that the PAC values are well distributed, demonstrating QARMA's usability as a hash function.\n\nFor the second assumption, we analyze memory management characteristics. Table II presents the memory usage profiles from full program execution of SPEC 2006 workloads [35] with reference input. To gather the information, we use Valgrind [6] with the --trace-malloc option enabled. Interestingly, most of the workloads are not malloc-intensive, i.e., memory allocations are not frequent. For example, mcf, sjeng, and lbm have fewer than 10 malloc calls. More importantly, for all the applications, we observe that the average number of active memory chunks is significantly smaller than the number of total allocation calls. povray and hmmer have more than 1 million allocation calls but have only a few thousand active chunks at most. This characteristic matches our expectation because typical applications allocate new memory chunks on demand and free them when they are no longer needed. The analysis of real-world benchmarks shown in Table III indicates a similar tendency. The number of allocation and deallocation calls is proportional to the size of the input (in pbzip2, pigz, axel) or the number of requests (in apache, mysql), but all of them have a modest number of maximum active memory chunks.  \n\n\nVII. SECURITY ANALYSIS\n\n\nA. How AOS Detects Memory Safety Errors\n\nIn Fig. 12, we provide an example of memory safety errors and describe how AOS can detect them. First, AOS signs the pointer returned by malloc() and stores its bounds in the HBT (lines 2-4). Any subsequent memory access by the pointer triggers bounds checking. Hence, spatial safety violations (heap OOB accesses in lines 6-7) are detected by bounds checking. Since a valid free() (lines 9-12) deallocates the memory chunk and clears the associated bounds, any ensuing use of the freed pointer will fail in bounds checking because of the absence of the valid bounds. This prevents temporal safety errors such as the use of a dangling pointer or use-after-free (line 14) and double free (lines [16][17][18][19].\n\nAOS can also prevent other various heap exploitation attacks. In the example shown in Fig. 1, free() with the crafted address (line 18) triggers the error. AOS prevents this attack by ensuring that only valid, signed data pointers can be freed. This is because any free() with a crafted or unsigned address will be prevented by bndclr inserted before free().\n\n\nB. Pointer Integrity\n\nIn many attack scenarios, corrupting pointers becomes a preferred attack vector. For instance, control-flow attacks, such as ROP and JOP, corrupt the return address of a function to hijack the control flow of a program. In addition, Chen et al. [36] demonstrated that non-control-data attacks can even forge user credentials or change security-critical configurations without compromising code pointers. This kind of data-1 ldr ptr, [SP,#0] ; load data pointer 2 autm ptr ; authenticate oriented attack exploits data pointers to corrupt variables that influence program behavior. By inheriting Arm PA's primitives, AOS can be extended to ensure pointer integrity, enabling effective protection against pointer corruption attacks. For instance, Liljestrand et al. [21] proposed a PA-based code-and data-pointer integrity, which signs and authenticates PACs to prevent illicit pointer modification. While their return address and code-pointer signing schemes can be easily deployed to AOS, we especially care about how to cooperate with data-pointer signing. For datapointer integrity, the authors implement on-load authentication, in which data pointers are signed immediately before they are stored in memory and authenticated immediately after being loaded from memory.\n\nSince the AOS data pointers would already have been signed, AOS does not re-sign them when they are stored in memory. Also, AOS does not authenticate them as in [21]. Because their PACs were calculated using the base address of each memory chunk, the authentication will fail if the current address differs from the base address. Instead, AOS authenticates them using autm ( \u00a7IV-A) by checking whether the AHC value of a pointer is nonzero, as shown in Fig. 13. To further enhance the security capabilities, we integrate AOS with this pointer integrity mechanism and evaluate performance overhead in Section IX.\n\n\nC. PAC/AHC Forging\n\nSince we store PAC and AHC in the upper bits of a pointer, an attacker can try to manipulate the values via stack corruption or integer overflow. Deploying the autm authentication ( \u00a7VII-B) enhances protection against AHC forging attacks that try to bypass the bounds-checking process. Regarding PAC forging attacks, our authentication method cannot detect arbitrary modification on a PAC. However, the attack surface exposed by such attacks would be limited for the following reasons. First, even if one can change the PAC of a pointer, knowing the PAC of the target memory region is difficult. Second, as long as we enforce bounds checking for memory accesses, all data pointers signed by AOS cannot be used to exploit common attack vectors outside the heap region, such as procedure linkage table (PLT), global offset table (GOT), virtual table (VTable), heap metadata, and kernel data.\n\n\nD. Heap Protection\n\nHeap vulnerabilities are typically exploited by data-pointer manipulations. For example, an attacker can inject a malicious offset to a data pointer and make it point to a target memory location. Then, subsequent read/write operations using the tainted pointer lead to illegal memory corruption errors or leakage of sensitive information. Furthermore, heap safety issues correlate with the continuous development of new libraries. For instance, in glibc 2.26, the new thread localcaching mechanism, tcache, exposed a new heap exploit, double free. AOS provides an effective defense against those attacks by ensuring inter-object isolation, heap metadata protection, and temporal safety.\n\n\nE. False Positives\n\nAs described in Section VI, PAC collisions may introduce false positives across data pointers with the same PAC. However, exploiting PAC collisions is difficult given the PAC entropy. For instance, with a 16-bit PAC under typical AArch64 Linux systems, an attacker would require 45425 attempts to achieve a 50% likelihood for a correct guess [21]. Since the OS exception handler can terminate a process upon a boundschecking failure or a PAC authentication failure, a brute-force attack would be infeasible.\n\n\nF. Bounds Narrowing\n\nSeveral bounds-checking mechanisms narrow bounds to detect intra-object overflows (i.e., overflowing one field into another field in the same struct), and they reported such type of errors in SPEC CPU 2006 workloads [7], [12]. For example, gcc and soplex use custom memory management that causes intentional intra-object overruns. In h264ref and perlbench, benign intra-object buffer overruns are reported. The current AOS implementation does not support the bounds narrowing. We leave this for future work.\n\n\nVIII. METHODOLOGY\n\nWe evaluate SPEC CPU 2006 workloads [35] on Arm AArch64 using the gem5 simulator [37]. We use reference input sets and run the first 3 billion instructions. We do not count instrumented instructions ( \u00a7IV-C) to run the same number of instructions. Table IV shows the simulation parameters. Note that we choose an initial 1-way HBT from an empirical study. A compiler-based profiling method can be used to find optimal associativity, but we leave this for future work.\n\nWe evaluate the following four system configurations: \u2022 Baseline: the baseline without security features.\n\n\u2022 Watchdog: prior work that features user-after-free and bounds checking [11]. \u2022 PA: a PA-based solution for code-and data-pointer integrity.\n\nWe use the implementation of Liljestrand et al. [21], [39]. \u2022 AOS: the AOS bounds-checking mechanism.\n\n\u2022 PA+AOS: AOS integrated with PA ( \u00a7VII-B). \n\n\nIX. PERFORMANCE EVALUATION\n\n\nA. Execution Time\n\nFig. 14 shows the performance evaluation of various mechanisms. First, Watchdog incurs a 19.4% performance overhead on average. Even with its in-core memory checking, many applications show non-trivial performance overhead (>10%). We identify that the overhead is due to the extra instructions for memory checking and metadata propagation. Also, Watchdog has larger metadata of 24 bytes, compared to 8 bytes in AOS, thus causing more cache pollution.\n\nPA incurs negligible performance overhead, as reported in [21]. Most applications show less than 1% overhead, except for hmmer and omnetpp (\u223c10%). We discover that their overhead is caused by frequent function calls that lead to a large number of stack frame creations. Since the signing and authentication instructions are inserted for every stack frame, the overhead is proportional to the number of function calls.\n\nAOS shows an 8.4% performance overhead, and supporting pointer integrity (PA+AOS) imposes a 1.5% additional overhead. PA+AOS incurs negligible overhead for most applications, showing its feasibility as an always-on memory safety solution. Applications such as milc, namd, gobmk, and astar show slightly better performance than the baseline. We identify that the back-pressure on the issue pipeline stage due to the MCQ being full prevented aggressive branch predictions, resulting in fewer branch mispredictions and thus better performance. To find the root cause of the performance overhead of other applications, we consider the following three factors: 1) cache pollution, 2) delayed retirement, and 3) heap memory de-/allocation.\n\nCache pollution. Cache pollution caused by bounds metadata can degrade performance, in particular for memoryintensive applications. For instance, gcc has a large memory footprint and exhibits the worst slowdown, 2.16x, because of the increased cache misses. To see the impact of cache pollution, we study the performance of AOS with and without the L1-B cache ( \u00a7V-F1) and bounds compression ( \u00a7V-F3). As shown in Fig. 15, both optimizations are effective, but bounds compression brings a higher performance gain since it reduces the L2 cache pollution as well. Compared to when no optimization is used, the L1-B cache reduces the overhead by 10%, and bounds compression further reduces it by 3% on average. In particular, gcc and omnetpp show 60% and 68% lower overhead, respectively, when using both optimizations. Delayed retirement. In AOS, the validation process may delay instruction retirement. Hence, the more memory accesses requiring bounds checking we have, the more likely the degradation caused by delayed retirement increases. Fig. 16 shows the statistics of instructions of interest. In bzip2, gcc, hmmer, and lbm, memory accesses by signed data pointers account for more than 80% of the total accesses. In particular, hmmer requires bounds checking for over 99% of all memory accesses, resulting in a 41% overhead by AOS. In contrast, although lbm requires bounds checking for most of its memory accesses, it does not suffer from a high overhead because it is not memory-intensive.\n\nFrequent heap memory de-/allocations. This negatively affects performance for two reasons: 1) Overhead from extra instructions and 2) the high PAC collision rate, which could increase the number of bounds-table accesses. For instance, gcc and omnetpp invoke more than 20 million malloc calls during program execution, as shown in Table II. In this case, the slowdown imposed by extra instructions may not be trivial. thanks to the high BWB hit rate. Most applications show a BWB hit rate higher than 80%. This demonstrates that the performance overhead caused by the way iteration in AOS is not significant. 1) HBT Resizing: As explained in Section V-F3, resizing an HBT can be costly. During our simulation, no resizing occurred except for sphinx3 (1) and omnetpp (2) since the initial 1-way HBT could cover up to 512K bounds. Also, we found that the performance impact from resizing was amortized at runtime because of non-blocking accesses to the old table.\n\n\nB. Network Traffic\n\nTo evaluate memory overhead from bounds-table accesses, we measure the number of bytes transferred between caches and between the last-level cache and DRAM. Fig. 18 shows 31% and 18% additional network traffic on average by Watchdog and PA+AOS, respectively. Although Watchdog keeps bounds in extended registers in a core, it requires more traffic because of its larger metadata size than that of AOS. While most applications have modest traffic overhead (<10%) in AOS, we observe relatively high overhead in gcc, povray, and omnetpp because of frequent bounds-table accesses.\n\n\nX. RELATED WORK\n\nTrip-wire. This class places blacklisted regions around all the objects to be protected. Any access to these regions is prohibited. REST [8] stores randomized secret tokens around sensitive data and detects any access to them using a valuematching unit in the cache hierarchy. Califorms [9] achieves memory safety at the granularity of individual objects. By leveraging unused padding bytes, they mitigate the performance overhead for fine-grained memory safety. Although such trip-wire-based approaches are low cost, they cannot prevent accesses from jumping over the blacklisted regions. Memory tagging. These mechanisms tag memory regions to enable the tracking of illegal memory operations. For instance, HDFI [40] tags 1 bit with sensitive data and enforces data flow isolation at the word granularity. SPARC Application Data Integrity (ADI) [41] and Arm Memory Tagging Extension (MTE) [14] place a 4-bit tag into the upper bits of a pointer and associate the tag with the corresponding memory region. These approaches impose moderate performance overhead, but their implementations require significant hardware changes to the entire memory hierarchy and interfaces, such as tag cache, tag checking logic, and additional cache metadata extensions. Also, the limited size of tags reduces security guarantees. Given the probability of bug detection, specifically 94% with 4-bit tags, an attacker may bypass the protection with a sufficient number of attempts. Increasing the tag size is not trivial because of the memory overhead and hardware cost. Compared to prior work, AOS utilizes more bits and has a high PAC entropy, which makes the attacks less feasible. Bounds checking. This class associates bounds metadata with pointers and enforces every memory operation to access memory regions within the bounds [10]- [13]. BOGO [13] extended Intel MPX to guarantee temporal safety on top of spatial safety supported by MPX. Despite its lightweight scheme, it has a high performance overhead (\u223c60%) caused by its underlying mechanism, Intel MPX. Capability model. Capability models extend existing ISAs and provide security guarantees at the entire system level. In particular, CHERI architectures [22], [23], [42], [43] use a fat pointer to fit metadata, such as bounds information and permission bits. Every memory access is checked with its embedded metadata. However, the implementation requires changes to the entire system, including the pipeline stages, compiler, language runtime, and the OS. Although explorations of system designs remain open to the research community, the performance overhead and design complexity are high.\n\n\nXI. CONCLUSION\n\nThis paper proposed AOS, a defense mechanism against memory safety violations, to ensure heap spatial and temporal safeties. By utilizing the Arm PA's primitives, AOS signed data pointers to protect and used PACs embedded in the pointers to index a hashed bounds table. AOS also introduced a micro-architectural unit to eliminate extra boundschecking instructions. Furthermore, this paper discussed how AOS cooperates with pointer integrity solutions to enhance security capabilities further. Our evaluations showed that AOS overcame the major challenges of existing bounds-checking mechanisms and achieved marginal performance overhead while providing strong security guarantees. We believe that AOS can serve as an effective runtime safety solution.\n\nFig. 1 .\n1Heap exploitation example: House of Spirit.\n\nFig. 3 .\n3Return address signing using Arm PA.\n\nFig. 5 .\n5Comparison of memory safety operations between Watchdog and AOS. Extra instructions are blue colored.\n\nChallenge 3 .\n3Metadata propagation. Since the destination register does not automatically inherit the metadata from the source register, additional instructions are necessary to propagate the metadata throughout program execution. For example, Watchdog requires the extra instructions for the\n\n\nThese intrinsics are detected by the new pass, AOS-backend-pass, in the AArch64 backend and replaced with new instructions, as shown in Fig. 7.\n\nAlgorithm 2\n2BWB tag calculation (Addr, AHC, PAC) 1: if AHC = 1 then 2: return concat(PAC[15:0], Addr[20:7], AHC[1:0]) 3: else if AHC = 2 then 4: return concat(PAC[15:0], Addr[23:10], AHC[1:0]) 5: else 6: return concat(PAC[15:0], Addr[25:12], AHC[1:0])\n\n\n= LowBnd[32] & !Addr[32] (b) Decompressed bounds and truncated address to be compared.\n\nFig. 9 .\n9Bounds compression and decompression format.\n\nFig. 11 .\n11PAC distributions by QARMA.\n\n\nallocation, T: typename, N: # elements 2 T * ptr = (T * )malloc(sizeof(T) * N); 3 pacma ptr, sp, size; //size=sizeof(T) * N 4 bndstr ptr, size 5 // Heap OOB access 6 T varA = ptr[N+1];// Bounds-checking failure 7 ptr[N+1] = 0; // Bounds-checking failure 8 // Valid free() 9 bndclr ptr; 10 xpacm ptr; 11 free(ptr); 12 pacma ptr, sp, xzr; 13 // Dangling pointer or UAF 14 T varB = ptr[0]; // Cannot find valid bounds 15 // Double free 16 bndclr ptr; // Cannot find bounds to clear 17 xpacm ptr; 18 free(ptr); 19 pacma ptr, sp, xzr; Fig. 12. Memory safety violations detected by AOS.\n\nFig. 13 .\n13On-load authentication for AOS data pointers.\n\nFig. 15 .\n15L1-B cache and bounds-compression results.\n\nFig. 17 .\n17Analysis on bounds-table accesses.\n\nFig. 18 .\n18Fig. 17shows the average number of bounds-table accesses per instruction and the BWB hit rate. omnetpp shows the highest average accesses, 1.17, and others show close to one access Normalized network traffic.\n\n\n\u2022 We implement the AOS design and present performance evaluation for SPEC 2006 workloads. Our results show a marginal 8.4% performance overhead on average. \u2022 We describe how AOS can cooperate with pointer integrity solutions, which demonstrates that the security capabilities of AOS can be extended with little overhead. \u2022 We present a security analysis and demonstrate the effectiveness of the AOS protection mechanism.\n\n\nshows an example of heap 1 struct fast_chunk { size_t prev_size, size; struct fast_chunk * fd, * bk; 10 // Craft chunks to pass security tests 11 fchunk[0].size = sizeof(struct fast_chunk); 12 fchunk[1].size = sizeof(struct fast_chunk);2 \n\n3 \n\n4 \n\nchar buf[0x20]; \n5 }; \n\n6 \n\n7 struct fast_chunk fchunk[2]; \n8 void * ptr, * victim; \n\n9 \n\n13 \n\n14 // Attacker overwrites a pointer \n15 ptr = (void * ) &fchunk[0].fd; \n\n16 \n\n17 // fchunk[0] gets inserted into fastbin \n18 free(ptr); \n\n19 \n\n20 // Returns 16 bytes ahead of fchunk[0] \n21 victim = malloc(0x30); \n\n\n\n\nLoad 14 check R2.id 15 ld R1.id <-ShadowMem[R2].id 16 ld R1 <-Mem[R2] 17 // { StorePointer address \n\n0 \n63 \n\nBase \n\nLength \n\nIdentifier or Permission \n\n256 \nbits \n\n(a) Fat pointer \n\nShadow Space \n\nOriginal \n\naddr \n\nf(addr) \n\n(b) Shadow memory \n\nBounds \nTable \n\nBounds \nDirectory \n\nPointer address \n\nbase of BD \n\nbase of BT \n\nUBound | LBound \n\n63 \n0 \n\n(c) Two-level scheme \n\nHashed Bounds \nTable \n\nHBT(PACA) \n\nMem Chunk A \n\nMem Chunk B \n\nHBT(PACB) \n\nPACA Pointer address \n\nPACB Pointer address \n\n63 \n0 \n\n(d) AOS \n\nFig. 4. Comparison of metadata management methods. \n\n1 // x Heap Allocation \n2 ptr = malloc(size) \n3 key = unique_id++ \n4 lock = new_lock() \n5 * (lock) = key \n6 id = (key, lock) \n7 q = setid(ptr, id) \n8 // y Heap Deallocation \n9 id = getid(ptr) \n10 * (id.lock) = INVALID \n11 add_free_list(id.lock) \n12 free(ptr) \n13 // z 18 check R2.id \n19 ShadowMem[R2].id <-R1.id \n20 Mem[R2].val <-R1 \n21 // | Add Immediate \n22 R1.id <-R2.id \n23 add R1 <-R2 + imm \n24 // } Add \n25 if (R2.id != NULL) \n\n26 \n\nR1.id <-R2.id \n27 else \n\n28 \n\nR1.id <-R3.id \n29 add R1 <-R2 + R3 \n\n(a) Watchdog \n\n1 // x Heap Allocation \n2 ptr = malloc(size) \n3 pacma ptr, sp, size \n4 bndstr ptr, size \n\n5 \n\n6 \n\n7 \n\n8 // y Heap Deallocation \n9 bndclr ptr \n10 xpacm ptr \n11 free(ptr) \n12 pacma ptr, sp \n13 // z Load \n14 ld R1 <-Mem[R2] \n\n15 \n\n16 \n\n17 // { Store \n18 Mem[R2].val <-R1 \n\n19 \n\n20 \n\n21 // | Add Immediate \n22 add R1 <-R2 + imm \n\n23 \n\n24 // } Add \n25 add R1 <-R2 + R3 \n\n\n\n\nFig. 6. AOS overview.Load-Store \nUnit (LSU) \n\nMemory \nCheck Unit \n(MCU) \n\nL1 Cache \n\nLoad/store \nbndstr/bndclr \n\nTag \nWay \n\nBounds Way \nBuffer (BWB) \n\nProg \n\nLLVM \n\nmalloc() \npacma \nbndstr \n... \nbndclr \nxpacm \nfree() \npacma \n\nValid \n\nType \n\nAddr \n\nBndAddr \n\nBndData \n\nState \n\nCommitted \n\nWay \n\nCount \n\nMemory Check \nQueue (MCQ) \n\nTail \nHead \n\nWay 0 \n... \nWayT-1 \n\n8 Bounds \n8 Bounds \n8 Bounds \n\nBndAddr \n\nBounds \nBounds \nChecking \n\nHashed Bounds Table (HBT) \n\nMemory \nCore \n\nInstrumentation \n\nBndData \n\nPAC \nPAC \nVA \n\n55 \nVA_SIZE-1 \n0 \n63 \n\nAHC \n\n!= 0? \n\nSigned. \nPerform bounds checking. \nUnsigned. \nNo bounds checking. \n\nAddr: \n\n\n\n\n\u2022 Finally, State stores the operation state of the current finite state machine (FSM) in the MCQ.!succeed \n\nIncCnt \nFail \n\nBndChk \nDone \n\nInit \n\nCount < \n# Ways \n\nCount == \n# Ways \n\nsucceed \n\nsigned & \nsrcRegReady \n!signed \n\n(a) Load/store \n\nsucceed \n\nInit \nDone \n\nIncCnt \nFail \n\nOccChk \nBndStr \n\n!succeed \n\ncommitted \n\nCount < \n# Ways \n\nCount == \n# Ways \n\nsrcRegReady \n\n(b) bndstr/bndclr \n\nFig. 8. Finite state machines in the MCQ. \n\n\n\nTable Access During\nAccessResizing: Resizing an HBT is expensive since we need to copy all the entries from the old table into a new one. Stalling a process until resizing is done would incur a non-trivial performance overhead. InspiredT 1 \nT 2 \n\nPAC < RowPtr \nW >= T 1 \n\nHBT 2 (PAC) \n\nT 1 \nT 2 \n\nPAC >= RowPtr \nW >= T 1 \n\nHBT 2 (PAC) \n\nT 1 \nT 2 \n\nPAC < RowPtr \nW < T 1 \n\nHBT 2 (PAC) \n\n\u2460 \n\nT 1 \nT 2 \n\nPAC >= RowPtr \nW < T 1 \n\nHBT 1 (PAC) \n\n\u2461 \n\u2462 \n\u2463 \n\n: Migrated Region \n\nFig. 10. Bounds-table access during HBT resizing. \n\n\n\nTABLE I\nIHARDWARE OVERHEAD \n\nMetric \nMCQ \nBWB \nL1-B \nCache \n\nL1-D Cache \n(for reference) \n\nSize \n1.3KB \n384B \n32KB \n64KB \nArea (mm2) \n0.0096 \n0.00285 0.1573 \n0.2628 \nAccess time (ns) \n0.1383 \n0.12755 0.2984 \n0.3217 \nDynamic access energy (pJ) \n0.0014 \n0.00077 0.0347 \n0.0436 \nLeakage power (mW) \n3.2269 \n1.10712 58.295 \n122.69 \n\nby a parallel hash table look-up in the Elastic Cuckoo Hash \nTable [31], we develop a similar non-blocking bounds-table \naccess scheme and introduce a micro-architecture-based table \nmanager in charge of row-by-row bounds migration. \n\n\nTable I\nIsummarizes the hardware overhead of AOS. To estimate the area, access time, dynamic access energy, and leakage power, we use CACTI-6.0[32] at 45nm technology. Overall, the AOS structures incur modest overhead.\n\nTABLE II MEMORY\nIIUSAGE PROFILES FOR SPEC 2006 WORKLOADSName \nMax Active # \nAllocation \nDeallocation \n\nbzip2 \n10 \n29 \n25 \ngcc \n81825 \n1846825 \n1829255 \nmcf \n6 \n8 \n8 \nmilc \n\n\nTABLE III MEMORY\nIIIUSAGE PROFILES FOR REAL-WORLD BENCHMARKSName \nDescription \nMax # \nAlloc. \nDealloc. \n\npbzip2 \nCompress 1.4GB file, 8 threads \n110 \n12425 \n12423 \npigz \nCompress 1.4GB file, 8 threads \n110 \n24511 \n24511 \naxel \nDownload 1.4GB file, 8 threads \n172 \n473 \n473 \nmd5sum \nCalculate MD5 hash, 1.4GB file \n32 \n34 \n34 \napache \nApache bench [33], 10K req. \n7592 \n13.36M \n13.36M \nmysql \nSysbench [34], 100K req. \n\n\nTABLE IV SIMULATION\nIVPARAMETERS FOR PERFORMANCE EVALUATIONParameter \nValue \n\nCore \n2GHz, 8-wide, out-of-order, L-TAGE [38], 32-entry load \nand store queues, 192 ROB entries, 48 MCQ entries \nPrivate L1-I cache \n32KB, 4-way, 1-cycle, 64B line \nPrivate L1-D cache \n64KB, 8-way, 1-cycle, 64B line \nPrivate L1-B cache \n32KB, 4-way, 1-cycle, 8B bounds \nShared L2 cache \n8MB, 16-way, 8-cycle local, 16-cycle remote, 64B line \nDRAM \n50ns access latency from L2, 12.8 GB/s \nArm PA \n16-bit PAC size, signing/authentication: 4-cycle, strip-\nping: 1-cycle \nHBT \nInitial 1 way, 4MB size \nBWB \n64 entries, 1-cycle, eviction policy: LRU \n\n\nptr = malloc (size); 2 pacma ptr, sp, size 3 bndstr ptr, size 4 empty line (a) AOS-malloc\nACKNOWLEDGMENTWe would like to thank Sharjeel Khan,Taesoo\nGoogle queue hardening. Google, Google, \"Google queue hardening,\" https://security.googleblog.com/ 2019/05/queue-hardening-enhancements.html, 2017.\n\nTrends, challenges, and strategic shifts in the software vulnerability mitigation landscape. M Miller, M. Miller, \"Trends, challenges, and strategic shifts in the software vulnerability mitigation landscape,\" https://github.com/ microsoft/MSRC-Security-Research/blob/master/presentations/2019\n\nBlueHatIL/2019 01%20-%20BlueHatIL%20-%20Trends% 2C%20challenge%2C%20and%20shifts%20in%20software% 20vulnerability%20mitigation.pdf. BlueHatIL/2019 01%20-%20BlueHatIL%20-%20Trends% 2C%20challenge%2C%20and%20shifts%20in%20software% 20vulnerability%20mitigation.pdf, 2019.\n\nAddress-Sanitizer: A fast address sanity checker. K Serebryany, D Bruening, A Potapenko, D Vyukov, Proceedings of the 2012 USENIX Conference on Annual Technical Conference (ATC). the 2012 USENIX Conference on Annual Technical Conference (ATC)K. Serebryany, D. Bruening, A. Potapenko, and D. Vyukov, \"Address- Sanitizer: A fast address sanity checker,\" in Proceedings of the 2012 USENIX Conference on Annual Technical Conference (ATC),\" USENIX, 2012, pp. 309-318.\n\nLight-weight bounds checking. N Hasabnis, A Misra, R Sekar, Proceedings of the 10th International Symposium on Code Generation and Optimization (CGO). the 10th International Symposium on Code Generation and Optimization (CGO)Association for Computing MachineryN. Hasabnis, A. Misra, and R. Sekar, \"Light-weight bounds checking,\" in Proceedings of the 10th International Symposium on Code Generation and Optimization (CGO),\" Association for Computing Machinery, 2012, pp. 135-144.\n\nPurify: Fast detection of memory leaks and access errors. R Hastings, B Joyce, Proceedings of the Winter 1992 USENIX Conference. the Winter 1992 USENIX ConferenceR. Hastings and B. Joyce, \"Purify: Fast detection of memory leaks and access errors,\" in Proceedings of the Winter 1992 USENIX Conference, 1992, pp. 125-138.\n\nValgrind: A framework for heavyweight dynamic binary instrumentation. N Nethercote, J Seward, Proceedings of the 28th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI). the 28th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI)Association for Computing MachineryN. Nethercote and J. Seward, \"Valgrind: A framework for heavyweight dynamic binary instrumentation,\" in Proceedings of the 28th ACM SIGPLAN Conference on Programming Language Design and Imple- mentation (PLDI),\" Association for Computing Machinery, 2007, pp. 89-100.\n\nEffectivesan: Type and memory error detection using dynamically typed c/c++. G J Duck, R H C Yap, Proceedings of the 39th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI). the 39th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI)Association for Computing MachineryG. J. Duck and R. H. C. Yap, \"Effectivesan: Type and memory error detection using dynamically typed c/c++,\" in Proceedings of the 39th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI),\" Association for Computing Machinery, 2018, pp. 181-195.\n\nPractical memory safety with REST. K Sinha, S Sethumadhavan, Proceedings of the 45th Annual International Symposium on Computer Architecture (ISCA). the 45th Annual International Symposium on Computer Architecture (ISCA)K. Sinha and S. Sethumadhavan, \"Practical memory safety with REST,\" in Proceedings of the 45th Annual International Symposium on Com- puter Architecture (ISCA), 2018, pp. 600-611.\n\nPractical byte-granular memory blacklisting using califorms. H Sasaki, M A Arroyo, M T I Ziad, K Bhat, K Sinha, S Sethumadhavan, Proceedings of the 52nd Annual IEEE/ACM International Symposium on Microarchitecture (MICRO). the 52nd Annual IEEE/ACM International Symposium on Microarchitecture (MICRO)H. Sasaki, M. A. Arroyo, M. T. I. Ziad, K. Bhat, K. Sinha, and S. Sethumadhavan, \"Practical byte-granular memory blacklisting using califorms,\" in Proceedings of the 52nd Annual IEEE/ACM International Symposium on Microarchitecture (MICRO), 2019, pp. 558-571.\n\nHardbound: Architectural support for spatial safety of the c programming language. J Devietti, C Blundell, M M K Martin, S Zdancewic, Proceedings of the 13th ACM International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS). the 13th ACM International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)J. Devietti, C. Blundell, M. M. K. Martin, and S. Zdancewic, \"Hard- bound: Architectural support for spatial safety of the c programming language,\" in Proceedings of the 13th ACM International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS), 2008, pp. 103-114.\n\nWatchdog: Hardware for safe and secure manual memory management and full memory safety. S Nagarakatte, M M K Martin, S Zdancewic, Proceedings of the 39st Annual International Symposium on Computer Architecture (ISCA). the 39st Annual International Symposium on Computer Architecture (ISCA)S. Nagarakatte, M. M. K. Martin, and S. Zdancewic, \"Watchdog: Hard- ware for safe and secure manual memory management and full memory safety,\" in Proceedings of the 39st Annual International Symposium on Computer Architecture (ISCA), 2012, pp. 189-200.\n\nIntel MPX explained: A cross-layer analysis of the Intel MPX system stack. O Oleksenko, D Kuvaiskii, P Bhatotia, P Felber, C Fetzer, Proceedings of the ACM Measurement and Analysis of Computing Systems (POMACS). the ACM Measurement and Analysis of Computing Systems (POMACS)2O. Oleksenko, D. Kuvaiskii, P. Bhatotia, P. Felber, and C. Fetzer, \"Intel MPX explained: A cross-layer analysis of the Intel MPX system stack,\" Proceedings of the ACM Measurement and Analysis of Computing Systems (POMACS), vol. 2, no. 2, Jun. 2018.\n\nBOGO: Buy spatial memory safety, get temporal memory safety (almost) free. T Zhang, D Lee, C Jung, Proceedings of the 24th ACM International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS). the 24th ACM International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)Association for Computing MachineryT. Zhang, D. Lee, and C. Jung, \"BOGO: Buy spatial memory safety, get temporal memory safety (almost) free,\" in Proceedings of the 24th ACM International Conference on Architectural Support for Program- ming Languages and Operating Systems (ASPLOS),\" Association for Computing Machinery, 2019, pp. 631-644.\n\nArm\u00aearchitecture reference manual Armv8, for Armv8-A architecture profile. Arm, Arm, \"Arm\u00aearchitecture reference manual Armv8, for Armv8- A architecture profile,\" https://developer.arm.com/docs/ddi0487/fb/ arm-architecture-reference-manual-armv8-for-armv8-a-architecture-profile, 2020.\n\nThe geometry of innocent flesh on the bone: Return-intolibc without function calls (on the x86). H Shacham, Proceedings of the 14th ACM SIGSAC Conference on Computer and Communications Security (CCS). the 14th ACM SIGSAC Conference on Computer and Communications Security (CCS)H. Shacham, \"The geometry of innocent flesh on the bone: Return-into- libc without function calls (on the x86),\" in Proceedings of the 14th ACM SIGSAC Conference on Computer and Communications Security (CCS), 2007, pp. 552-561.\n\nReturn-oriented programming without returns. S Checkoway, L Davi, A Dmitrienko, A.-R Sadeghi, H Shacham, M Winandy, Proceedings of the 17th ACM Conference on Computer and Communications Security (CCS). the 17th ACM Conference on Computer and Communications Security (CCS)S. Checkoway, L. Davi, A. Dmitrienko, A.-R. Sadeghi, H. Shacham, and M. Winandy, \"Return-oriented programming without returns,\" in Proceedings of the 17th ACM Conference on Computer and Communi- cations Security (CCS), 2010, pp. 559-572.\n\nUnisan: Proactive kernel memory initialization to eliminate data leakages. K Lu, C Song, T Kim, W Lee, Proceedings of the 23rd ACM SIGSAC Conference on Computer and Communications Security (CCS). the 23rd ACM SIGSAC Conference on Computer and Communications Security (CCS)Association for Computing MachineryK. Lu, C. Song, T. Kim, and W. Lee, \"Unisan: Proactive kernel memory initialization to eliminate data leakages,\" in Proceedings of the 23rd ACM SIGSAC Conference on Computer and Communications Security (CCS),\" Association for Computing Machinery, 2016, pp. 920-932.\n\nSafeInit: Comprehensive and Practical Mitigation of Uninitialized Read Vulnerabilities. A Milburn, H Bos, C Giuffrida, The Network and Distributed System Security Symposium (NDSS). A. Milburn, H. Bos, and C. Giuffrida, \"SafeInit: Comprehensive and Practical Mitigation of Uninitialized Read Vulnerabilities,\" in The Net- work and Distributed System Security Symposium (NDSS), Feb. 2017.\n\nTypesan: Practical type confusion detection. I Haller, Y Jeon, H Peng, M Payer, C Giuffrida, H Bos, E Van Der Kouwe, Proceedings of the 23rd ACM SIGSAC Conference on Computer and Communications Security (CCS). the 23rd ACM SIGSAC Conference on Computer and Communications Security (CCS)Association for Computing MachineryI. Haller, Y. Jeon, H. Peng, M. Payer, C. Giuffrida, H. Bos, and E. van der Kouwe, \"Typesan: Practical type confusion detection,\" in Proceedings of the 23rd ACM SIGSAC Conference on Computer and Communications Security (CCS),\" Association for Computing Machinery, 2016, pp. 517- 528.\n\nAlmost MDS matrices over rings with zero divisors, nearly symmetric even-mansour constructions with non-involutory central rounds, and search heuristics for lowlatency s-boxes. R Avanzi, IACR Transactions on Symmetric Cryptology (ToSC). 20171The QARMA block cipher familyR. Avanzi, \"The QARMA block cipher family. Almost MDS matrices over rings with zero divisors, nearly symmetric even-mansour construc- tions with non-involutory central rounds, and search heuristics for low- latency s-boxes,\" IACR Transactions on Symmetric Cryptology (ToSC), vol. 2017, no. 1, pp. 4-44, Mar. 2017.\n\nPAC it up: Towards pointer integrity using ARM pointer authentication. H Liljestrand, T Nyman, K Wang, C C Perez, J.-E Ekberg, N Asokan, Proceedings of the 27th USENIX Security Symposium (Security),\" USENIX Association. the 27th USENIX Security Symposium (Security),\" USENIX AssociationH. Liljestrand, T. Nyman, K. Wang, C. C. Perez, J.-E. Ekberg, and N. Asokan, \"PAC it up: Towards pointer integrity using ARM pointer authentication,\" in Proceedings of the 27th USENIX Security Symposium (Security),\" USENIX Association, 2019, pp. 177-194.\n\nThe CHERI capability model: Revisiting RISC in an age of risk. J Woodruff, R N Watson, D Chisnall, S W Moore, J Anderson, B Davis, B Laurie, P G Neumann, R Norton, M Roe, Proceedings of the 41st Annual International Symposium on Computer Architecture (ISCA). the 41st Annual International Symposium on Computer Architecture (ISCA)IEEE PressJ. Woodruff, R. N. Watson, D. Chisnall, S. W. Moore, J. Anderson, B. Davis, B. Laurie, P. G. Neumann, R. Norton, and M. Roe, \"The CHERI capability model: Revisiting RISC in an age of risk,\" in Proceedings of the 41st Annual International Symposium on Computer Architecture (ISCA),\" IEEE Press, 2014, pp. 457-468.\n\nCHERI concentrate: Practical compressed capabilities. J Woodruff, A Joannou, H Xia, A Fox, R M Norton, D Chisnall, B Davis, K Gudka, N W Filardo, A T Markettos, M Roe, P G Neumann, R N M Watson, S W Moore, IEEE Transactions on Computers (TC). 6810J. Woodruff, A. Joannou, H. Xia, A. Fox, R. M. Norton, D. Chisnall, B. Davis, K. Gudka, N. W. Filardo, A. T. Markettos, M. Roe, P. G. Neumann, R. N. M. Watson, and S. W. Moore, \"CHERI concentrate: Practical compressed capabilities,\" IEEE Transactions on Computers (TC), vol. 68, no. 10, pp. 1455-1469, 2019.\n\nFlipping bits in memory without accessing them: An experimental study of DRAM disturbance errors. Y Kim, R Daly, J Kim, C Fallin, J H Lee, D Lee, C Wilkerson, K Lai, O Mutlu, Proceedings of the 41st Annual International Symposium on Computer Architecture (ISCA). the 41st Annual International Symposium on Computer Architecture (ISCA)IEEE PressY. Kim, R. Daly, J. Kim, C. Fallin, J. H. Lee, D. Lee, C. Wilkerson, K. Lai, and O. Mutlu, \"Flipping bits in memory without accessing them: An experimental study of DRAM disturbance errors,\" in Proceedings of the 41st Annual International Symposium on Computer Architecture (ISCA),\" IEEE Press, 2014, pp. 361-372.\n\nCache attacks and countermeasures: The case of AES. D A Osvik, A Shamir, E Tromer, Proceedings of the 2006 Cryptographers' Track at the RSA Conference on Topics in Cryptology (CT-RSA). the 2006 Cryptographers' Track at the RSA Conference on Topics in Cryptology (CT-RSA)Springer-VerlagD. A. Osvik, A. Shamir, and E. Tromer, \"Cache attacks and countermea- sures: The case of AES,\" in Proceedings of the 2006 Cryptographers' Track at the RSA Conference on Topics in Cryptology (CT-RSA),\" Springer-Verlag, 2006, pp. 1-20.\n\nFLUSH+RELOAD: A high resolution, low noise, L3 cache side-channel attack. Y Yarom, K Falkner, Proceedings of the 23rd USENIX Security Symposium (Security),\" USENIX Association. the 23rd USENIX Security Symposium (Security),\" USENIX AssociationY. Yarom and K. Falkner, \"FLUSH+RELOAD: A high resolution, low noise, L3 cache side-channel attack,\" in Proceedings of the 23rd USENIX Security Symposium (Security),\" USENIX Association, 2014, pp. 719- 732.\n\nSpectre attacks: Exploiting speculative execution. P Kocher, J Horn, A Fogh, D Genkin, D Gruss, W Haas, M Hamburg, M Lipp, S Mangard, T Prescher, M Schwarz, Y Yarom, Proceedings of the 40th IEEE Symposium on Security and Privacy (S&P). the 40th IEEE Symposium on Security and Privacy (S&P)P. Kocher, J. Horn, A. Fogh, D. Genkin, D. Gruss, W. Haas, M. Ham- burg, M. Lipp, S. Mangard, T. Prescher, M. Schwarz, and Y. Yarom, \"Spectre attacks: Exploiting speculative execution,\" in Proceedings of the 40th IEEE Symposium on Security and Privacy (S&P), 2019, pp. 1-19.\n\nMeltdown: Reading kernel memory from user space. M Lipp, M Schwarz, D Gruss, T Prescher, W Haas, A Fogh, J Horn, S Mangard, P Kocher, D Genkin, Y Yarom, M Hamburg, Proceedings of the 27th USENIX Security Symposium (Security). the 27th USENIX Security Symposium (Security)M. Lipp, M. Schwarz, D. Gruss, T. Prescher, W. Haas, A. Fogh, J. Horn, S. Mangard, P. Kocher, D. Genkin, Y. Yarom, and M. Hamburg, \"Meltdown: Reading kernel memory from user space,\" in Proceedings of the 27th USENIX Security Symposium (Security), 2018, pp. 973-990.\n\nLLVM: A compilation framework for lifelong program analysis & transformation. C Lattner, V Adve, Proceedings of the International Symposium on Code Generation and Optimization (CGO): Feedback-Directed and Runtime Optimization. the International Symposium on Code Generation and Optimization (CGO): Feedback-Directed and Runtime OptimizationC. Lattner and V. Adve, \"LLVM: A compilation framework for lifelong program analysis & transformation,\" in Proceedings of the International Symposium on Code Generation and Optimization (CGO): Feedback- Directed and Runtime Optimization,\" IEEE Computer Society, 2004, pp. 75-86.\n\nCuckoo hashing. R Pagh, F F Rodler, Journal of Algorithms. 512R. Pagh and F. F. Rodler, \"Cuckoo hashing,\" Journal of Algorithms, vol. 51, no. 2, pp. 122-144, May 2004.\n\nElastic cuckoo page tables: Rethinking virtual memory translation for parallelism. D Skarlatos, A Kokolis, T Xu, J Torrellas, Proceedings of the 25th ACM International Conference on Architectural Support for Programming Languages and Operating Systems (ASP-LOS). the 25th ACM International Conference on Architectural Support for Programming Languages and Operating Systems (ASP-LOS)Association for Computing MachineryD. Skarlatos, A. Kokolis, T. Xu, and J. Torrellas, \"Elastic cuckoo page tables: Rethinking virtual memory translation for parallelism,\" in Proceedings of the 25th ACM International Conference on Architectural Support for Programming Languages and Operating Systems (ASP- LOS),\" Association for Computing Machinery, 2020, pp. 1093-1108.\n\nCACTI 6.0: A tool to model large caches. N P J Naveen Muralimanohar, Rajeev Balasubramonian, N. P. J. Naveen Muralimanohar, Rajeev Balasubramonian, \"CACTI 6.0: A tool to model large caches,\" https://www.hpl.hp.com/techreports/2009/ HPL-2009-85.pdf.\n\nab-apache http server benchmarking tool. \"ab-apache http server benchmarking tool.\" https://httpd.apache.org/ docs/2.4/programs/ab.html.\n\nScriptable database and system performance benchmark. \"Scriptable database and system performance benchmark.\" https://github. com/akopytov/sysbench.\n\nSPEC CPU2006 benchmark descriptions. J L Henning, SIGARCH Computer Architecture News. 344J. L. Henning, \"SPEC CPU2006 benchmark descriptions,\" SIGARCH Computer Architecture News, vol. 34, no. 4, pp. 1-17, Sep. 2006.\n\nNon-control-data attacks are realistic threats. S Chen, J Xu, E C Sezer, P Gauriar, R K Iyer, Proceedings of the 14th USENIX Security Symposium (Security),\" USENIX Association. the 14th USENIX Security Symposium (Security),\" USENIX AssociationS. Chen, J. Xu, E. C. Sezer, P. Gauriar, and R. K. Iyer, \"Non-control-data attacks are realistic threats,\" in Proceedings of the 14th USENIX Security Symposium (Security),\" USENIX Association, 2005, pp. 177-191.\n\nThe gem5 simulator. N Binkert, B Beckmann, G Black, S K Reinhardt, A Saidi, A Basu, J Hestness, D R Hower, T Krishna, S Sardashti, R Sen, K Sewell, M Shoaib, N Vaish, M D Hill, D A Wood, SIGARCH Computer Architecture News. 392N. Binkert, B. Beckmann, G. Black, S. K. Reinhardt, A. Saidi, A. Basu, J. Hestness, D. R. Hower, T. Krishna, S. Sardashti, R. Sen, K. Sewell, M. Shoaib, N. Vaish, M. D. Hill, and D. A. Wood, \"The gem5 simulator,\" SIGARCH Computer Architecture News, vol. 39, no. 2, pp. 1-7, Aug. 2011.\n\nThe L-TAGE branch predictor. A Seznec, Journal of Instruction-Level Parallelism. 9JILP)A. Seznec, \"The L-TAGE branch predictor,\" Journal of Instruction-Level Parallelism (JILP), vol. 9, pp. 1-13, 2007.\n\nParts-llvm. \"Parts-llvm,\" https://github.com/pointer-authentication.\n\nHDFI: Hardware-assisted data-flow isolation. C Song, H Moon, M Alam, I Yun, B Lee, T Kim, W Lee, Y Paek, Proceedings of the 37th IEEE Symposium on Security and Privacy (S&P). the 37th IEEE Symposium on Security and Privacy (S&P)C. Song, H. Moon, M. Alam, I. Yun, B. Lee, T. Kim, W. Lee, and Y. Paek, \"HDFI: Hardware-assisted data-flow isolation,\" in Proceedings of the 37th IEEE Symposium on Security and Privacy (S&P), 2016, pp. 1-17.\n\nHardware-assisted checking using Silicon Secured Memory (SSM). Oracle, Oracle, \"Hardware-assisted checking using Silicon Secured Memory (SSM),\" 2015. [Online]. Available: https://docs.oracle.com/cd/E37069 01/html/E37085/gphwb.html\n\nCHERIvoke: Characterising pointer revocation using CHERI capabilities for temporal memory safety. H Xia, J Woodruff, S Ainsworth, N W Filardo, M Roe, A Richardson, P Rugg, P G Neumann, S W Moore, R N M Watson, T M Jones, Proceedings of the 52nd Annual IEEE/ACM International Symposium on Microarchitecture (MICRO). the 52nd Annual IEEE/ACM International Symposium on Microarchitecture (MICRO)Association for Computing MachineryH. Xia, J. Woodruff, S. Ainsworth, N. W. Filardo, M. Roe, A. Richard- son, P. Rugg, P. G. Neumann, S. W. Moore, R. N. M. Watson, and T. M. Jones, \"CHERIvoke: Characterising pointer revocation using CHERI capabilities for temporal memory safety,\" in Proceedings of the 52nd Annual IEEE/ACM International Symposium on Microarchitecture (MICRO),\" Association for Computing Machinery, 2019, pp. 545-557.\n\nCHEx86: Context-sensitive enforcement of memory safety via microcode-enabled capabilities. R Sharifi, A Venkat, Proceedings of the 47th Annual International Symposium on Computer Architecture (ISCA). the 47th Annual International Symposium on Computer Architecture (ISCA)R. Sharifi and A. Venkat, \"CHEx86: Context-sensitive enforcement of memory safety via microcode-enabled capabilities,\" in Proceedings of the 47th Annual International Symposium on Computer Architecture (ISCA), 2020, pp. 762-775.\n", "annotations": {"author": "[{\"start\":\"47\",\"end\":\"157\"},{\"start\":\"158\",\"end\":\"267\"},{\"start\":\"268\",\"end\":\"381\"}]", "publisher": null, "author_last_name": "[{\"start\":\"55\",\"end\":\"58\"},{\"start\":\"165\",\"end\":\"168\"},{\"start\":\"276\",\"end\":\"279\"}]", "author_first_name": "[{\"start\":\"47\",\"end\":\"54\"},{\"start\":\"158\",\"end\":\"164\"},{\"start\":\"268\",\"end\":\"275\"}]", "author_affiliation": "[{\"start\":\"79\",\"end\":\"156\"},{\"start\":\"189\",\"end\":\"266\"},{\"start\":\"303\",\"end\":\"380\"}]", "title": "[{\"start\":\"1\",\"end\":\"44\"},{\"start\":\"382\",\"end\":\"425\"}]", "venue": null, "abstract": "[{\"start\":\"524\",\"end\":\"1952\"}]", "bib_ref": "[{\"start\":\"3740\",\"end\":\"3743\",\"attributes\":{\"ref_id\":\"b0\"}},{\"start\":\"3745\",\"end\":\"3748\",\"attributes\":{\"ref_id\":\"b1\"}},{\"start\":\"4091\",\"end\":\"4094\",\"attributes\":{\"ref_id\":\"b3\"}},{\"start\":\"4096\",\"end\":\"4099\",\"attributes\":{\"ref_id\":\"b7\"}},{\"start\":\"4400\",\"end\":\"4403\",\"attributes\":{\"ref_id\":\"b3\"}},{\"start\":\"4711\",\"end\":\"4714\",\"attributes\":{\"ref_id\":\"b8\"}},{\"start\":\"4716\",\"end\":\"4719\",\"attributes\":{\"ref_id\":\"b9\"}},{\"start\":\"4952\",\"end\":\"4955\",\"attributes\":{\"ref_id\":\"b8\"}},{\"start\":\"5131\",\"end\":\"5134\",\"attributes\":{\"ref_id\":\"b1\"}},{\"start\":\"5375\",\"end\":\"5379\",\"attributes\":{\"ref_id\":\"b10\"}},{\"start\":\"5381\",\"end\":\"5385\",\"attributes\":{\"ref_id\":\"b13\"}},{\"start\":\"5874\",\"end\":\"5878\",\"attributes\":{\"ref_id\":\"b11\"}},{\"start\":\"6323\",\"end\":\"6327\",\"attributes\":{\"ref_id\":\"b12\"}},{\"start\":\"6678\",\"end\":\"6682\",\"attributes\":{\"ref_id\":\"b14\"}},{\"start\":\"7331\",\"end\":\"7335\",\"attributes\":{\"ref_id\":\"b10\"}},{\"start\":\"7337\",\"end\":\"7341\",\"attributes\":{\"ref_id\":\"b12\"}},{\"start\":\"8625\",\"end\":\"8629\",\"attributes\":{\"ref_id\":\"b15\"}},{\"start\":\"8666\",\"end\":\"8670\",\"attributes\":{\"ref_id\":\"b16\"}},{\"start\":\"10507\",\"end\":\"10510\",\"attributes\":{\"ref_id\":\"b1\"}},{\"start\":\"10981\",\"end\":\"10985\",\"attributes\":{\"ref_id\":\"b17\"}},{\"start\":\"10987\",\"end\":\"10991\",\"attributes\":{\"ref_id\":\"b19\"}},{\"start\":\"11180\",\"end\":\"11184\",\"attributes\":{\"ref_id\":\"b14\"}},{\"start\":\"11421\",\"end\":\"11425\",\"attributes\":{\"ref_id\":\"b20\"}},{\"start\":\"12310\",\"end\":\"12314\",\"attributes\":{\"ref_id\":\"b21\"}},{\"start\":\"13065\",\"end\":\"13069\",\"attributes\":{\"ref_id\":\"b10\"}},{\"start\":\"13071\",\"end\":\"13075\",\"attributes\":{\"ref_id\":\"b11\"}},{\"start\":\"13077\",\"end\":\"13081\",\"attributes\":{\"ref_id\":\"b22\"}},{\"start\":\"13083\",\"end\":\"13087\",\"attributes\":{\"ref_id\":\"b23\"}},{\"start\":\"13207\",\"end\":\"13211\",\"attributes\":{\"ref_id\":\"b11\"}},{\"start\":\"13722\",\"end\":\"13726\",\"attributes\":{\"ref_id\":\"b10\"}},{\"start\":\"13728\",\"end\":\"13732\",\"attributes\":{\"ref_id\":\"b12\"}},{\"start\":\"14225\",\"end\":\"14228\",\"attributes\":{\"ref_id\":\"b3\"}},{\"start\":\"14230\",\"end\":\"14234\",\"attributes\":{\"ref_id\":\"b10\"}},{\"start\":\"14426\",\"end\":\"14429\",\"attributes\":{\"ref_id\":\"b3\"}},{\"start\":\"14583\",\"end\":\"14587\",\"attributes\":{\"ref_id\":\"b12\"}},{\"start\":\"18635\",\"end\":\"18639\",\"attributes\":{\"ref_id\":\"b24\"}},{\"start\":\"18662\",\"end\":\"18666\",\"attributes\":{\"ref_id\":\"b25\"}},{\"start\":\"18668\",\"end\":\"18672\",\"attributes\":{\"ref_id\":\"b26\"}},{\"start\":\"18708\",\"end\":\"18712\",\"attributes\":{\"ref_id\":\"b27\"}},{\"start\":\"18714\",\"end\":\"18718\",\"attributes\":{\"ref_id\":\"b28\"}},{\"start\":\"20502\",\"end\":\"20506\",\"attributes\":{\"ref_id\":\"b29\"}},{\"start\":\"22558\",\"end\":\"22561\",\"attributes\":{\"ref_id\":\"b3\"}},{\"start\":\"22563\",\"end\":\"22566\",\"attributes\":{\"ref_id\":\"b8\"}},{\"start\":\"22663\",\"end\":\"22666\",\"attributes\":{\"ref_id\":\"b8\"}},{\"start\":\"28520\",\"end\":\"28524\",\"attributes\":{\"ref_id\":\"b30\"}},{\"start\":\"31489\",\"end\":\"31490\",\"attributes\":{\"ref_id\":\"b0\"}},{\"start\":\"33269\",\"end\":\"33275\"},{\"start\":\"34799\",\"end\":\"34803\",\"attributes\":{\"ref_id\":\"b11\"}},{\"start\":\"36791\",\"end\":\"36795\",\"attributes\":{\"ref_id\":\"b20\"}},{\"start\":\"37995\",\"end\":\"37999\",\"attributes\":{\"ref_id\":\"b35\"}},{\"start\":\"38065\",\"end\":\"38068\",\"attributes\":{\"ref_id\":\"b6\"}},{\"start\":\"39799\",\"end\":\"39803\",\"attributes\":{\"ref_id\":\"b16\"}},{\"start\":\"39803\",\"end\":\"39807\",\"attributes\":{\"ref_id\":\"b17\"}},{\"start\":\"39807\",\"end\":\"39811\",\"attributes\":{\"ref_id\":\"b18\"}},{\"start\":\"39811\",\"end\":\"39815\",\"attributes\":{\"ref_id\":\"b19\"}},{\"start\":\"40446\",\"end\":\"40450\",\"attributes\":{\"ref_id\":\"b36\"}},{\"start\":\"40634\",\"end\":\"40638\"},{\"start\":\"40638\",\"end\":\"40641\"},{\"start\":\"40964\",\"end\":\"40968\",\"attributes\":{\"ref_id\":\"b21\"}},{\"start\":\"41634\",\"end\":\"41638\",\"attributes\":{\"ref_id\":\"b21\"}},{\"start\":\"44070\",\"end\":\"44074\",\"attributes\":{\"ref_id\":\"b21\"}},{\"start\":\"44475\",\"end\":\"44478\",\"attributes\":{\"ref_id\":\"b7\"}},{\"start\":\"44480\",\"end\":\"44484\",\"attributes\":{\"ref_id\":\"b12\"}},{\"start\":\"44824\",\"end\":\"44828\",\"attributes\":{\"ref_id\":\"b35\"}},{\"start\":\"44869\",\"end\":\"44873\",\"attributes\":{\"ref_id\":\"b37\"}},{\"start\":\"45437\",\"end\":\"45441\",\"attributes\":{\"ref_id\":\"b11\"}},{\"start\":\"45555\",\"end\":\"45559\",\"attributes\":{\"ref_id\":\"b21\"}},{\"start\":\"45561\",\"end\":\"45565\",\"attributes\":{\"ref_id\":\"b39\"}},{\"start\":\"46215\",\"end\":\"46219\",\"attributes\":{\"ref_id\":\"b21\"}},{\"start\":\"50526\",\"end\":\"50529\",\"attributes\":{\"ref_id\":\"b8\"}},{\"start\":\"50676\",\"end\":\"50679\",\"attributes\":{\"ref_id\":\"b9\"}},{\"start\":\"51103\",\"end\":\"51107\",\"attributes\":{\"ref_id\":\"b40\"}},{\"start\":\"51236\",\"end\":\"51240\",\"attributes\":{\"ref_id\":\"b41\"}},{\"start\":\"51280\",\"end\":\"51284\",\"attributes\":{\"ref_id\":\"b14\"}},{\"start\":\"52209\",\"end\":\"52213\",\"attributes\":{\"ref_id\":\"b13\"}},{\"start\":\"52220\",\"end\":\"52224\",\"attributes\":{\"ref_id\":\"b13\"}},{\"start\":\"52589\",\"end\":\"52593\",\"attributes\":{\"ref_id\":\"b22\"}},{\"start\":\"52595\",\"end\":\"52599\",\"attributes\":{\"ref_id\":\"b23\"}},{\"start\":\"52601\",\"end\":\"52605\",\"attributes\":{\"ref_id\":\"b42\"}},{\"start\":\"52607\",\"end\":\"52611\",\"attributes\":{\"ref_id\":\"b43\"}},{\"start\":\"54719\",\"end\":\"54723\",\"attributes\":{\"ref_id\":\"b32\"}},{\"start\":\"54731\",\"end\":\"54735\",\"attributes\":{\"ref_id\":\"b32\"}},{\"start\":\"60607\",\"end\":\"60611\",\"attributes\":{\"ref_id\":\"b32\"}}]", "figure": "[{\"start\":\"53798\",\"end\":\"53852\",\"attributes\":{\"id\":\"fig_0\"}},{\"start\":\"53853\",\"end\":\"53900\",\"attributes\":{\"id\":\"fig_2\"}},{\"start\":\"53901\",\"end\":\"54013\",\"attributes\":{\"id\":\"fig_3\"}},{\"start\":\"54014\",\"end\":\"54308\",\"attributes\":{\"id\":\"fig_4\"}},{\"start\":\"54309\",\"end\":\"54454\",\"attributes\":{\"id\":\"fig_5\"}},{\"start\":\"54455\",\"end\":\"54708\",\"attributes\":{\"id\":\"fig_7\"}},{\"start\":\"54709\",\"end\":\"54797\",\"attributes\":{\"id\":\"fig_10\"}},{\"start\":\"54798\",\"end\":\"54853\",\"attributes\":{\"id\":\"fig_11\"}},{\"start\":\"54854\",\"end\":\"54894\",\"attributes\":{\"id\":\"fig_12\"}},{\"start\":\"54895\",\"end\":\"55477\",\"attributes\":{\"id\":\"fig_13\"}},{\"start\":\"55478\",\"end\":\"55536\",\"attributes\":{\"id\":\"fig_14\"}},{\"start\":\"55537\",\"end\":\"55592\",\"attributes\":{\"id\":\"fig_15\"}},{\"start\":\"55593\",\"end\":\"55640\",\"attributes\":{\"id\":\"fig_16\"}},{\"start\":\"55641\",\"end\":\"55862\",\"attributes\":{\"id\":\"fig_17\"}},{\"start\":\"55863\",\"end\":\"56285\",\"attributes\":{\"id\":\"tab_0\",\"type\":\"table\"}},{\"start\":\"56286\",\"end\":\"56845\",\"attributes\":{\"id\":\"tab_1\",\"type\":\"table\"}},{\"start\":\"56846\",\"end\":\"58301\",\"attributes\":{\"id\":\"tab_4\",\"type\":\"table\"}},{\"start\":\"58302\",\"end\":\"58935\",\"attributes\":{\"id\":\"tab_5\",\"type\":\"table\"}},{\"start\":\"58936\",\"end\":\"59373\",\"attributes\":{\"id\":\"tab_6\",\"type\":\"table\"}},{\"start\":\"59374\",\"end\":\"59897\",\"attributes\":{\"id\":\"tab_7\",\"type\":\"table\"}},{\"start\":\"59898\",\"end\":\"60462\",\"attributes\":{\"id\":\"tab_8\",\"type\":\"table\"}},{\"start\":\"60463\",\"end\":\"60682\",\"attributes\":{\"id\":\"tab_9\",\"type\":\"table\"}},{\"start\":\"60683\",\"end\":\"60856\",\"attributes\":{\"id\":\"tab_10\",\"type\":\"table\"}},{\"start\":\"60857\",\"end\":\"61276\",\"attributes\":{\"id\":\"tab_11\",\"type\":\"table\"}},{\"start\":\"61277\",\"end\":\"61903\",\"attributes\":{\"id\":\"tab_12\",\"type\":\"table\"}}]", "paragraph": "[{\"start\":\"1954\",\"end\":\"2429\"},{\"start\":\"2431\",\"end\":\"3467\"},{\"start\":\"3487\",\"end\":\"3957\"},{\"start\":\"3959\",\"end\":\"4404\"},{\"start\":\"4406\",\"end\":\"5200\"},{\"start\":\"5202\",\"end\":\"5651\"},{\"start\":\"5653\",\"end\":\"6460\"},{\"start\":\"6462\",\"end\":\"7272\"},{\"start\":\"7274\",\"end\":\"7724\"},{\"start\":\"7726\",\"end\":\"8412\"},{\"start\":\"8414\",\"end\":\"8987\"},{\"start\":\"8989\",\"end\":\"9762\"},{\"start\":\"9794\",\"end\":\"11082\"},{\"start\":\"11116\",\"end\":\"12396\"},{\"start\":\"12398\",\"end\":\"12785\"},{\"start\":\"12823\",\"end\":\"12997\"},{\"start\":\"12999\",\"end\":\"13619\"},{\"start\":\"13621\",\"end\":\"14886\"},{\"start\":\"14920\",\"end\":\"15300\"},{\"start\":\"15302\",\"end\":\"15752\"},{\"start\":\"15754\",\"end\":\"16198\"},{\"start\":\"16220\",\"end\":\"16312\"},{\"start\":\"16314\",\"end\":\"16592\"},{\"start\":\"16594\",\"end\":\"17096\"},{\"start\":\"17098\",\"end\":\"17606\"},{\"start\":\"17632\",\"end\":\"17886\"},{\"start\":\"17906\",\"end\":\"18719\"},{\"start\":\"18721\",\"end\":\"18948\"},{\"start\":\"18995\",\"end\":\"19046\"},{\"start\":\"19048\",\"end\":\"20353\"},{\"start\":\"20377\",\"end\":\"20954\"},{\"start\":\"20985\",\"end\":\"21294\"},{\"start\":\"21296\",\"end\":\"22535\"},{\"start\":\"22537\",\"end\":\"22842\"},{\"start\":\"22860\",\"end\":\"23253\"},{\"start\":\"23255\",\"end\":\"23443\"},{\"start\":\"23445\",\"end\":\"23834\"},{\"start\":\"23882\",\"end\":\"24472\"},{\"start\":\"24474\",\"end\":\"25190\"},{\"start\":\"25192\",\"end\":\"25326\"},{\"start\":\"25328\",\"end\":\"25371\"},{\"start\":\"25373\",\"end\":\"25730\"},{\"start\":\"25732\",\"end\":\"25788\"},{\"start\":\"25790\",\"end\":\"28357\"},{\"start\":\"28399\",\"end\":\"29082\"},{\"start\":\"29084\",\"end\":\"30013\"},{\"start\":\"30058\",\"end\":\"30106\"},{\"start\":\"30108\",\"end\":\"30111\"},{\"start\":\"30136\",\"end\":\"31195\"},{\"start\":\"31197\",\"end\":\"31537\"},{\"start\":\"31539\",\"end\":\"32230\"},{\"start\":\"32256\",\"end\":\"33288\"},{\"start\":\"33290\",\"end\":\"33752\"},{\"start\":\"33777\",\"end\":\"34519\"},{\"start\":\"34521\",\"end\":\"35106\"},{\"start\":\"35108\",\"end\":\"35645\"},{\"start\":\"35647\",\"end\":\"36424\"},{\"start\":\"36484\",\"end\":\"37057\"},{\"start\":\"37059\",\"end\":\"37825\"},{\"start\":\"37827\",\"end\":\"39036\"},{\"start\":\"39105\",\"end\":\"39816\"},{\"start\":\"39818\",\"end\":\"40176\"},{\"start\":\"40201\",\"end\":\"41471\"},{\"start\":\"41473\",\"end\":\"42084\"},{\"start\":\"42107\",\"end\":\"42996\"},{\"start\":\"43019\",\"end\":\"43705\"},{\"start\":\"43728\",\"end\":\"44235\"},{\"start\":\"44259\",\"end\":\"44766\"},{\"start\":\"44788\",\"end\":\"45255\"},{\"start\":\"45257\",\"end\":\"45362\"},{\"start\":\"45364\",\"end\":\"45505\"},{\"start\":\"45507\",\"end\":\"45608\"},{\"start\":\"45610\",\"end\":\"45654\"},{\"start\":\"45705\",\"end\":\"46155\"},{\"start\":\"46157\",\"end\":\"46574\"},{\"start\":\"46576\",\"end\":\"47309\"},{\"start\":\"47311\",\"end\":\"48808\"},{\"start\":\"48810\",\"end\":\"49770\"},{\"start\":\"49793\",\"end\":\"50369\"},{\"start\":\"50389\",\"end\":\"53027\"},{\"start\":\"53046\",\"end\":\"53797\"}]", "formula": "[{\"start\":\"30014\",\"end\":\"30057\",\"attributes\":{\"id\":\"formula_0\"}}]", "table_ref": "[{\"start\":\"9205\",\"end\":\"9535\",\"attributes\":{\"ref_id\":\"tab_8\"}},{\"start\":\"37169\",\"end\":\"37520\",\"attributes\":{\"ref_id\":\"tab_8\"}},{\"start\":\"37900\",\"end\":\"37908\",\"attributes\":{\"ref_id\":\"tab_8\"}},{\"start\":\"38766\",\"end\":\"38775\",\"attributes\":{\"ref_id\":\"tab_8\"}},{\"start\":\"45036\",\"end\":\"45044\",\"attributes\":{\"ref_id\":\"tab_8\"}},{\"start\":\"49140\",\"end\":\"49148\",\"attributes\":{\"ref_id\":\"tab_8\"}}]", "section_header": "[{\"start\":\"3470\",\"end\":\"3485\"},{\"start\":\"9765\",\"end\":\"9792\"},{\"start\":\"11085\",\"end\":\"11114\"},{\"start\":\"12788\",\"end\":\"12821\"},{\"start\":\"14889\",\"end\":\"14918\"},{\"start\":\"16201\",\"end\":\"16218\"},{\"start\":\"17609\",\"end\":\"17630\"},{\"start\":\"17889\",\"end\":\"17904\"},{\"start\":\"18951\",\"end\":\"18974\"},{\"start\":\"18977\",\"end\":\"18993\"},{\"start\":\"20356\",\"end\":\"20375\"},{\"start\":\"20957\",\"end\":\"20983\"},{\"start\":\"22845\",\"end\":\"22858\"},{\"start\":\"23837\",\"end\":\"23880\"},{\"start\":\"28360\",\"end\":\"28397\"},{\"start\":\"30114\",\"end\":\"30134\"},{\"start\":\"32233\",\"end\":\"32254\"},{\"start\":\"33755\",\"end\":\"33775\"},{\"start\":\"36427\",\"end\":\"36447\"},{\"start\":\"36450\",\"end\":\"36482\"},{\"start\":\"39039\",\"end\":\"39061\"},{\"start\":\"39064\",\"end\":\"39103\"},{\"start\":\"40179\",\"end\":\"40199\"},{\"start\":\"42087\",\"end\":\"42105\"},{\"start\":\"42999\",\"end\":\"43017\"},{\"start\":\"43708\",\"end\":\"43726\"},{\"start\":\"44238\",\"end\":\"44257\"},{\"start\":\"44769\",\"end\":\"44786\"},{\"start\":\"45657\",\"end\":\"45683\"},{\"start\":\"45686\",\"end\":\"45703\"},{\"start\":\"49773\",\"end\":\"49791\"},{\"start\":\"50372\",\"end\":\"50387\"},{\"start\":\"53030\",\"end\":\"53044\"},{\"start\":\"53799\",\"end\":\"53807\"},{\"start\":\"53854\",\"end\":\"53862\"},{\"start\":\"53902\",\"end\":\"53910\"},{\"start\":\"54015\",\"end\":\"54028\"},{\"start\":\"54456\",\"end\":\"54467\"},{\"start\":\"54799\",\"end\":\"54807\"},{\"start\":\"54855\",\"end\":\"54864\"},{\"start\":\"55479\",\"end\":\"55488\"},{\"start\":\"55538\",\"end\":\"55547\"},{\"start\":\"55594\",\"end\":\"55603\"},{\"start\":\"55642\",\"end\":\"55651\"},{\"start\":\"59375\",\"end\":\"59394\"},{\"start\":\"59899\",\"end\":\"59906\"},{\"start\":\"60464\",\"end\":\"60471\"},{\"start\":\"60684\",\"end\":\"60699\"},{\"start\":\"60858\",\"end\":\"60874\"},{\"start\":\"61278\",\"end\":\"61297\"}]", "table": "[{\"start\":\"56524\",\"end\":\"56845\"},{\"start\":\"56931\",\"end\":\"58301\"},{\"start\":\"58325\",\"end\":\"58935\"},{\"start\":\"59035\",\"end\":\"59373\"},{\"start\":\"59611\",\"end\":\"59897\"},{\"start\":\"59908\",\"end\":\"60462\"},{\"start\":\"60740\",\"end\":\"60856\"},{\"start\":\"60918\",\"end\":\"61276\"},{\"start\":\"61337\",\"end\":\"61903\"}]", "figure_caption": "[{\"start\":\"53809\",\"end\":\"53852\"},{\"start\":\"53864\",\"end\":\"53900\"},{\"start\":\"53912\",\"end\":\"54013\"},{\"start\":\"54030\",\"end\":\"54308\"},{\"start\":\"54311\",\"end\":\"54454\"},{\"start\":\"54469\",\"end\":\"54708\"},{\"start\":\"54711\",\"end\":\"54797\"},{\"start\":\"54809\",\"end\":\"54853\"},{\"start\":\"54867\",\"end\":\"54894\"},{\"start\":\"54897\",\"end\":\"55477\"},{\"start\":\"55491\",\"end\":\"55536\"},{\"start\":\"55550\",\"end\":\"55592\"},{\"start\":\"55606\",\"end\":\"55640\"},{\"start\":\"55654\",\"end\":\"55862\"},{\"start\":\"55865\",\"end\":\"56285\"},{\"start\":\"56288\",\"end\":\"56524\"},{\"start\":\"56848\",\"end\":\"56931\"},{\"start\":\"58304\",\"end\":\"58325\"},{\"start\":\"58938\",\"end\":\"59035\"},{\"start\":\"59401\",\"end\":\"59611\"},{\"start\":\"60473\",\"end\":\"60682\"},{\"start\":\"60702\",\"end\":\"60740\"},{\"start\":\"60878\",\"end\":\"60918\"},{\"start\":\"61300\",\"end\":\"61337\"}]", "figure_ref": "[{\"start\":\"9939\",\"end\":\"9945\",\"attributes\":{\"ref_id\":\"fig_0\"}},{\"start\":\"10420\",\"end\":\"10426\",\"attributes\":{\"ref_id\":\"fig_7\"}},{\"start\":\"11880\",\"end\":\"11886\",\"attributes\":{\"ref_id\":\"fig_2\"}},{\"start\":\"12653\",\"end\":\"12659\",\"attributes\":{\"ref_id\":\"fig_7\"}},{\"start\":\"13341\",\"end\":\"13348\"},{\"start\":\"13816\",\"end\":\"13823\",\"attributes\":{\"ref_id\":\"fig_3\"}},{\"start\":\"14028\",\"end\":\"14035\",\"attributes\":{\"ref_id\":\"fig_3\"}},{\"start\":\"14248\",\"end\":\"14255\"},{\"start\":\"14677\",\"end\":\"14684\"},{\"start\":\"15866\",\"end\":\"15873\"},{\"start\":\"16280\",\"end\":\"16286\"},{\"start\":\"21023\",\"end\":\"21030\"},{\"start\":\"21337\",\"end\":\"21344\"},{\"start\":\"24178\",\"end\":\"24184\"},{\"start\":\"26349\",\"end\":\"26358\"},{\"start\":\"26385\",\"end\":\"26394\"},{\"start\":\"32851\",\"end\":\"32858\",\"attributes\":{\"ref_id\":\"fig_11\"}},{\"start\":\"33022\",\"end\":\"33029\",\"attributes\":{\"ref_id\":\"fig_11\"}},{\"start\":\"33279\",\"end\":\"33287\",\"attributes\":{\"ref_id\":\"fig_11\"}},{\"start\":\"35659\",\"end\":\"35666\",\"attributes\":{\"ref_id\":\"fig_0\"}},{\"start\":\"37718\",\"end\":\"37725\",\"attributes\":{\"ref_id\":\"fig_0\"}},{\"start\":\"39108\",\"end\":\"39115\",\"attributes\":{\"ref_id\":\"fig_0\"}},{\"start\":\"39904\",\"end\":\"39910\",\"attributes\":{\"ref_id\":\"fig_0\"}},{\"start\":\"41926\",\"end\":\"41933\",\"attributes\":{\"ref_id\":\"fig_0\"}},{\"start\":\"47725\",\"end\":\"47732\",\"attributes\":{\"ref_id\":\"fig_0\"}},{\"start\":\"48352\",\"end\":\"48359\",\"attributes\":{\"ref_id\":\"fig_0\"}},{\"start\":\"49950\",\"end\":\"49957\",\"attributes\":{\"ref_id\":\"fig_0\"}}]", "bib_author_first_name": "[{\"start\":\"62294\",\"end\":\"62295\"},{\"start\":\"62816\",\"end\":\"62817\"},{\"start\":\"62830\",\"end\":\"62831\"},{\"start\":\"62842\",\"end\":\"62843\"},{\"start\":\"62855\",\"end\":\"62856\"},{\"start\":\"63260\",\"end\":\"63261\"},{\"start\":\"63272\",\"end\":\"63273\"},{\"start\":\"63281\",\"end\":\"63282\"},{\"start\":\"63769\",\"end\":\"63770\"},{\"start\":\"63781\",\"end\":\"63782\"},{\"start\":\"64102\",\"end\":\"64103\"},{\"start\":\"64116\",\"end\":\"64117\"},{\"start\":\"64699\",\"end\":\"64700\"},{\"start\":\"64701\",\"end\":\"64702\"},{\"start\":\"64709\",\"end\":\"64710\"},{\"start\":\"64711\",\"end\":\"64714\"},{\"start\":\"65257\",\"end\":\"65258\"},{\"start\":\"65266\",\"end\":\"65267\"},{\"start\":\"65684\",\"end\":\"65685\"},{\"start\":\"65694\",\"end\":\"65695\"},{\"start\":\"65696\",\"end\":\"65697\"},{\"start\":\"65706\",\"end\":\"65707\"},{\"start\":\"65708\",\"end\":\"65711\"},{\"start\":\"65718\",\"end\":\"65719\"},{\"start\":\"65726\",\"end\":\"65727\"},{\"start\":\"65735\",\"end\":\"65736\"},{\"start\":\"66267\",\"end\":\"66268\"},{\"start\":\"66279\",\"end\":\"66280\"},{\"start\":\"66291\",\"end\":\"66292\"},{\"start\":\"66293\",\"end\":\"66296\"},{\"start\":\"66305\",\"end\":\"66306\"},{\"start\":\"66968\",\"end\":\"66969\"},{\"start\":\"66983\",\"end\":\"66984\"},{\"start\":\"66985\",\"end\":\"66988\"},{\"start\":\"66997\",\"end\":\"66998\"},{\"start\":\"67498\",\"end\":\"67499\"},{\"start\":\"67511\",\"end\":\"67512\"},{\"start\":\"67524\",\"end\":\"67525\"},{\"start\":\"67536\",\"end\":\"67537\"},{\"start\":\"67546\",\"end\":\"67547\"},{\"start\":\"68023\",\"end\":\"68024\"},{\"start\":\"68032\",\"end\":\"68033\"},{\"start\":\"68039\",\"end\":\"68040\"},{\"start\":\"69028\",\"end\":\"69029\"},{\"start\":\"69482\",\"end\":\"69483\"},{\"start\":\"69495\",\"end\":\"69496\"},{\"start\":\"69503\",\"end\":\"69504\"},{\"start\":\"69517\",\"end\":\"69521\"},{\"start\":\"69531\",\"end\":\"69532\"},{\"start\":\"69542\",\"end\":\"69543\"},{\"start\":\"70022\",\"end\":\"70023\"},{\"start\":\"70028\",\"end\":\"70029\"},{\"start\":\"70036\",\"end\":\"70037\"},{\"start\":\"70043\",\"end\":\"70044\"},{\"start\":\"70609\",\"end\":\"70610\"},{\"start\":\"70620\",\"end\":\"70621\"},{\"start\":\"70627\",\"end\":\"70628\"},{\"start\":\"70954\",\"end\":\"70955\"},{\"start\":\"70964\",\"end\":\"70965\"},{\"start\":\"70972\",\"end\":\"70973\"},{\"start\":\"70980\",\"end\":\"70981\"},{\"start\":\"70989\",\"end\":\"70990\"},{\"start\":\"71002\",\"end\":\"71003\"},{\"start\":\"71009\",\"end\":\"71010\"},{\"start\":\"71692\",\"end\":\"71693\"},{\"start\":\"72172\",\"end\":\"72173\"},{\"start\":\"72187\",\"end\":\"72188\"},{\"start\":\"72196\",\"end\":\"72197\"},{\"start\":\"72204\",\"end\":\"72205\"},{\"start\":\"72206\",\"end\":\"72207\"},{\"start\":\"72215\",\"end\":\"72219\"},{\"start\":\"72228\",\"end\":\"72229\"},{\"start\":\"72706\",\"end\":\"72707\"},{\"start\":\"72718\",\"end\":\"72719\"},{\"start\":\"72720\",\"end\":\"72721\"},{\"start\":\"72730\",\"end\":\"72731\"},{\"start\":\"72742\",\"end\":\"72743\"},{\"start\":\"72744\",\"end\":\"72745\"},{\"start\":\"72753\",\"end\":\"72754\"},{\"start\":\"72765\",\"end\":\"72766\"},{\"start\":\"72774\",\"end\":\"72775\"},{\"start\":\"72784\",\"end\":\"72785\"},{\"start\":\"72786\",\"end\":\"72787\"},{\"start\":\"72797\",\"end\":\"72798\"},{\"start\":\"72807\",\"end\":\"72808\"},{\"start\":\"73351\",\"end\":\"73352\"},{\"start\":\"73363\",\"end\":\"73364\"},{\"start\":\"73374\",\"end\":\"73375\"},{\"start\":\"73381\",\"end\":\"73382\"},{\"start\":\"73388\",\"end\":\"73389\"},{\"start\":\"73390\",\"end\":\"73391\"},{\"start\":\"73400\",\"end\":\"73401\"},{\"start\":\"73412\",\"end\":\"73413\"},{\"start\":\"73421\",\"end\":\"73422\"},{\"start\":\"73430\",\"end\":\"73431\"},{\"start\":\"73432\",\"end\":\"73433\"},{\"start\":\"73443\",\"end\":\"73444\"},{\"start\":\"73445\",\"end\":\"73446\"},{\"start\":\"73458\",\"end\":\"73459\"},{\"start\":\"73465\",\"end\":\"73466\"},{\"start\":\"73467\",\"end\":\"73468\"},{\"start\":\"73478\",\"end\":\"73479\"},{\"start\":\"73480\",\"end\":\"73483\"},{\"start\":\"73492\",\"end\":\"73493\"},{\"start\":\"73494\",\"end\":\"73495\"},{\"start\":\"73951\",\"end\":\"73952\"},{\"start\":\"73958\",\"end\":\"73959\"},{\"start\":\"73966\",\"end\":\"73967\"},{\"start\":\"73973\",\"end\":\"73974\"},{\"start\":\"73983\",\"end\":\"73984\"},{\"start\":\"73985\",\"end\":\"73986\"},{\"start\":\"73992\",\"end\":\"73993\"},{\"start\":\"73999\",\"end\":\"74000\"},{\"start\":\"74012\",\"end\":\"74013\"},{\"start\":\"74019\",\"end\":\"74020\"},{\"start\":\"74564\",\"end\":\"74565\"},{\"start\":\"74566\",\"end\":\"74567\"},{\"start\":\"74575\",\"end\":\"74576\"},{\"start\":\"74585\",\"end\":\"74586\"},{\"start\":\"75106\",\"end\":\"75107\"},{\"start\":\"75115\",\"end\":\"75116\"},{\"start\":\"75534\",\"end\":\"75535\"},{\"start\":\"75544\",\"end\":\"75545\"},{\"start\":\"75552\",\"end\":\"75553\"},{\"start\":\"75560\",\"end\":\"75561\"},{\"start\":\"75570\",\"end\":\"75571\"},{\"start\":\"75579\",\"end\":\"75580\"},{\"start\":\"75587\",\"end\":\"75588\"},{\"start\":\"75598\",\"end\":\"75599\"},{\"start\":\"75606\",\"end\":\"75607\"},{\"start\":\"75617\",\"end\":\"75618\"},{\"start\":\"75629\",\"end\":\"75630\"},{\"start\":\"75640\",\"end\":\"75641\"},{\"start\":\"76097\",\"end\":\"76098\"},{\"start\":\"76105\",\"end\":\"76106\"},{\"start\":\"76116\",\"end\":\"76117\"},{\"start\":\"76125\",\"end\":\"76126\"},{\"start\":\"76137\",\"end\":\"76138\"},{\"start\":\"76145\",\"end\":\"76146\"},{\"start\":\"76153\",\"end\":\"76154\"},{\"start\":\"76161\",\"end\":\"76162\"},{\"start\":\"76172\",\"end\":\"76173\"},{\"start\":\"76182\",\"end\":\"76183\"},{\"start\":\"76192\",\"end\":\"76193\"},{\"start\":\"76201\",\"end\":\"76202\"},{\"start\":\"76664\",\"end\":\"76665\"},{\"start\":\"76675\",\"end\":\"76676\"},{\"start\":\"77222\",\"end\":\"77223\"},{\"start\":\"77230\",\"end\":\"77231\"},{\"start\":\"77232\",\"end\":\"77233\"},{\"start\":\"77458\",\"end\":\"77459\"},{\"start\":\"77471\",\"end\":\"77472\"},{\"start\":\"77482\",\"end\":\"77483\"},{\"start\":\"77488\",\"end\":\"77489\"},{\"start\":\"78171\",\"end\":\"78172\"},{\"start\":\"78173\",\"end\":\"78176\"},{\"start\":\"78199\",\"end\":\"78205\"},{\"start\":\"78705\",\"end\":\"78706\"},{\"start\":\"78707\",\"end\":\"78708\"},{\"start\":\"78933\",\"end\":\"78934\"},{\"start\":\"78941\",\"end\":\"78942\"},{\"start\":\"78947\",\"end\":\"78948\"},{\"start\":\"78949\",\"end\":\"78950\"},{\"start\":\"78958\",\"end\":\"78959\"},{\"start\":\"78969\",\"end\":\"78970\"},{\"start\":\"78971\",\"end\":\"78972\"},{\"start\":\"79361\",\"end\":\"79362\"},{\"start\":\"79372\",\"end\":\"79373\"},{\"start\":\"79384\",\"end\":\"79385\"},{\"start\":\"79393\",\"end\":\"79394\"},{\"start\":\"79395\",\"end\":\"79396\"},{\"start\":\"79408\",\"end\":\"79409\"},{\"start\":\"79417\",\"end\":\"79418\"},{\"start\":\"79425\",\"end\":\"79426\"},{\"start\":\"79437\",\"end\":\"79438\"},{\"start\":\"79439\",\"end\":\"79440\"},{\"start\":\"79448\",\"end\":\"79449\"},{\"start\":\"79459\",\"end\":\"79460\"},{\"start\":\"79472\",\"end\":\"79473\"},{\"start\":\"79479\",\"end\":\"79480\"},{\"start\":\"79489\",\"end\":\"79490\"},{\"start\":\"79499\",\"end\":\"79500\"},{\"start\":\"79508\",\"end\":\"79509\"},{\"start\":\"79510\",\"end\":\"79511\"},{\"start\":\"79518\",\"end\":\"79519\"},{\"start\":\"79520\",\"end\":\"79521\"},{\"start\":\"79882\",\"end\":\"79883\"},{\"start\":\"80171\",\"end\":\"80172\"},{\"start\":\"80179\",\"end\":\"80180\"},{\"start\":\"80187\",\"end\":\"80188\"},{\"start\":\"80195\",\"end\":\"80196\"},{\"start\":\"80202\",\"end\":\"80203\"},{\"start\":\"80209\",\"end\":\"80210\"},{\"start\":\"80216\",\"end\":\"80217\"},{\"start\":\"80223\",\"end\":\"80224\"},{\"start\":\"80893\",\"end\":\"80894\"},{\"start\":\"80900\",\"end\":\"80901\"},{\"start\":\"80912\",\"end\":\"80913\"},{\"start\":\"80925\",\"end\":\"80926\"},{\"start\":\"80927\",\"end\":\"80928\"},{\"start\":\"80938\",\"end\":\"80939\"},{\"start\":\"80945\",\"end\":\"80946\"},{\"start\":\"80959\",\"end\":\"80960\"},{\"start\":\"80967\",\"end\":\"80968\"},{\"start\":\"80969\",\"end\":\"80970\"},{\"start\":\"80980\",\"end\":\"80981\"},{\"start\":\"80982\",\"end\":\"80983\"},{\"start\":\"80991\",\"end\":\"80992\"},{\"start\":\"80993\",\"end\":\"80996\"},{\"start\":\"81005\",\"end\":\"81006\"},{\"start\":\"81007\",\"end\":\"81008\"},{\"start\":\"81714\",\"end\":\"81715\"},{\"start\":\"81725\",\"end\":\"81726\"}]", "bib_author_last_name": "[{\"start\":\"62076\",\"end\":\"62082\"},{\"start\":\"62296\",\"end\":\"62302\"},{\"start\":\"62818\",\"end\":\"62828\"},{\"start\":\"62832\",\"end\":\"62840\"},{\"start\":\"62844\",\"end\":\"62853\"},{\"start\":\"62857\",\"end\":\"62863\"},{\"start\":\"63262\",\"end\":\"63270\"},{\"start\":\"63274\",\"end\":\"63279\"},{\"start\":\"63283\",\"end\":\"63288\"},{\"start\":\"63771\",\"end\":\"63779\"},{\"start\":\"63783\",\"end\":\"63788\"},{\"start\":\"64104\",\"end\":\"64114\"},{\"start\":\"64118\",\"end\":\"64124\"},{\"start\":\"64703\",\"end\":\"64707\"},{\"start\":\"64715\",\"end\":\"64718\"},{\"start\":\"65259\",\"end\":\"65264\"},{\"start\":\"65268\",\"end\":\"65281\"},{\"start\":\"65686\",\"end\":\"65692\"},{\"start\":\"65698\",\"end\":\"65704\"},{\"start\":\"65712\",\"end\":\"65716\"},{\"start\":\"65720\",\"end\":\"65724\"},{\"start\":\"65728\",\"end\":\"65733\"},{\"start\":\"65737\",\"end\":\"65750\"},{\"start\":\"66269\",\"end\":\"66277\"},{\"start\":\"66281\",\"end\":\"66289\"},{\"start\":\"66297\",\"end\":\"66303\"},{\"start\":\"66307\",\"end\":\"66316\"},{\"start\":\"66970\",\"end\":\"66981\"},{\"start\":\"66989\",\"end\":\"66995\"},{\"start\":\"66999\",\"end\":\"67008\"},{\"start\":\"67500\",\"end\":\"67509\"},{\"start\":\"67513\",\"end\":\"67522\"},{\"start\":\"67526\",\"end\":\"67534\"},{\"start\":\"67538\",\"end\":\"67544\"},{\"start\":\"67548\",\"end\":\"67554\"},{\"start\":\"68025\",\"end\":\"68030\"},{\"start\":\"68034\",\"end\":\"68037\"},{\"start\":\"68041\",\"end\":\"68045\"},{\"start\":\"68719\",\"end\":\"68722\"},{\"start\":\"69030\",\"end\":\"69037\"},{\"start\":\"69484\",\"end\":\"69493\"},{\"start\":\"69497\",\"end\":\"69501\"},{\"start\":\"69505\",\"end\":\"69515\"},{\"start\":\"69522\",\"end\":\"69529\"},{\"start\":\"69533\",\"end\":\"69540\"},{\"start\":\"69544\",\"end\":\"69551\"},{\"start\":\"70024\",\"end\":\"70026\"},{\"start\":\"70030\",\"end\":\"70034\"},{\"start\":\"70038\",\"end\":\"70041\"},{\"start\":\"70045\",\"end\":\"70048\"},{\"start\":\"70611\",\"end\":\"70618\"},{\"start\":\"70622\",\"end\":\"70625\"},{\"start\":\"70629\",\"end\":\"70638\"},{\"start\":\"70956\",\"end\":\"70962\"},{\"start\":\"70966\",\"end\":\"70970\"},{\"start\":\"70974\",\"end\":\"70978\"},{\"start\":\"70982\",\"end\":\"70987\"},{\"start\":\"70991\",\"end\":\"71000\"},{\"start\":\"71004\",\"end\":\"71007\"},{\"start\":\"71011\",\"end\":\"71024\"},{\"start\":\"71694\",\"end\":\"71700\"},{\"start\":\"72174\",\"end\":\"72185\"},{\"start\":\"72189\",\"end\":\"72194\"},{\"start\":\"72198\",\"end\":\"72202\"},{\"start\":\"72208\",\"end\":\"72213\"},{\"start\":\"72220\",\"end\":\"72226\"},{\"start\":\"72230\",\"end\":\"72236\"},{\"start\":\"72708\",\"end\":\"72716\"},{\"start\":\"72722\",\"end\":\"72728\"},{\"start\":\"72732\",\"end\":\"72740\"},{\"start\":\"72746\",\"end\":\"72751\"},{\"start\":\"72755\",\"end\":\"72763\"},{\"start\":\"72767\",\"end\":\"72772\"},{\"start\":\"72776\",\"end\":\"72782\"},{\"start\":\"72788\",\"end\":\"72795\"},{\"start\":\"72799\",\"end\":\"72805\"},{\"start\":\"72809\",\"end\":\"72812\"},{\"start\":\"73353\",\"end\":\"73361\"},{\"start\":\"73365\",\"end\":\"73372\"},{\"start\":\"73376\",\"end\":\"73379\"},{\"start\":\"73383\",\"end\":\"73386\"},{\"start\":\"73392\",\"end\":\"73398\"},{\"start\":\"73402\",\"end\":\"73410\"},{\"start\":\"73414\",\"end\":\"73419\"},{\"start\":\"73423\",\"end\":\"73428\"},{\"start\":\"73434\",\"end\":\"73441\"},{\"start\":\"73447\",\"end\":\"73456\"},{\"start\":\"73460\",\"end\":\"73463\"},{\"start\":\"73469\",\"end\":\"73476\"},{\"start\":\"73484\",\"end\":\"73490\"},{\"start\":\"73496\",\"end\":\"73501\"},{\"start\":\"73953\",\"end\":\"73956\"},{\"start\":\"73960\",\"end\":\"73964\"},{\"start\":\"73968\",\"end\":\"73971\"},{\"start\":\"73975\",\"end\":\"73981\"},{\"start\":\"73987\",\"end\":\"73990\"},{\"start\":\"73994\",\"end\":\"73997\"},{\"start\":\"74001\",\"end\":\"74010\"},{\"start\":\"74014\",\"end\":\"74017\"},{\"start\":\"74021\",\"end\":\"74026\"},{\"start\":\"74568\",\"end\":\"74573\"},{\"start\":\"74577\",\"end\":\"74583\"},{\"start\":\"74587\",\"end\":\"74593\"},{\"start\":\"75108\",\"end\":\"75113\"},{\"start\":\"75117\",\"end\":\"75124\"},{\"start\":\"75536\",\"end\":\"75542\"},{\"start\":\"75546\",\"end\":\"75550\"},{\"start\":\"75554\",\"end\":\"75558\"},{\"start\":\"75562\",\"end\":\"75568\"},{\"start\":\"75572\",\"end\":\"75577\"},{\"start\":\"75581\",\"end\":\"75585\"},{\"start\":\"75589\",\"end\":\"75596\"},{\"start\":\"75600\",\"end\":\"75604\"},{\"start\":\"75608\",\"end\":\"75615\"},{\"start\":\"75619\",\"end\":\"75627\"},{\"start\":\"75631\",\"end\":\"75638\"},{\"start\":\"75642\",\"end\":\"75647\"},{\"start\":\"76099\",\"end\":\"76103\"},{\"start\":\"76107\",\"end\":\"76114\"},{\"start\":\"76118\",\"end\":\"76123\"},{\"start\":\"76127\",\"end\":\"76135\"},{\"start\":\"76139\",\"end\":\"76143\"},{\"start\":\"76147\",\"end\":\"76151\"},{\"start\":\"76155\",\"end\":\"76159\"},{\"start\":\"76163\",\"end\":\"76170\"},{\"start\":\"76174\",\"end\":\"76180\"},{\"start\":\"76184\",\"end\":\"76190\"},{\"start\":\"76194\",\"end\":\"76199\"},{\"start\":\"76203\",\"end\":\"76210\"},{\"start\":\"76666\",\"end\":\"76673\"},{\"start\":\"76677\",\"end\":\"76681\"},{\"start\":\"77224\",\"end\":\"77228\"},{\"start\":\"77234\",\"end\":\"77240\"},{\"start\":\"77460\",\"end\":\"77469\"},{\"start\":\"77473\",\"end\":\"77480\"},{\"start\":\"77484\",\"end\":\"77486\"},{\"start\":\"77490\",\"end\":\"77499\"},{\"start\":\"78177\",\"end\":\"78197\"},{\"start\":\"78206\",\"end\":\"78221\"},{\"start\":\"78709\",\"end\":\"78716\"},{\"start\":\"78935\",\"end\":\"78939\"},{\"start\":\"78943\",\"end\":\"78945\"},{\"start\":\"78951\",\"end\":\"78956\"},{\"start\":\"78960\",\"end\":\"78967\"},{\"start\":\"78973\",\"end\":\"78977\"},{\"start\":\"79363\",\"end\":\"79370\"},{\"start\":\"79374\",\"end\":\"79382\"},{\"start\":\"79386\",\"end\":\"79391\"},{\"start\":\"79397\",\"end\":\"79406\"},{\"start\":\"79410\",\"end\":\"79415\"},{\"start\":\"79419\",\"end\":\"79423\"},{\"start\":\"79427\",\"end\":\"79435\"},{\"start\":\"79441\",\"end\":\"79446\"},{\"start\":\"79450\",\"end\":\"79457\"},{\"start\":\"79461\",\"end\":\"79470\"},{\"start\":\"79474\",\"end\":\"79477\"},{\"start\":\"79481\",\"end\":\"79487\"},{\"start\":\"79491\",\"end\":\"79497\"},{\"start\":\"79501\",\"end\":\"79506\"},{\"start\":\"79512\",\"end\":\"79516\"},{\"start\":\"79522\",\"end\":\"79526\"},{\"start\":\"79884\",\"end\":\"79890\"},{\"start\":\"80173\",\"end\":\"80177\"},{\"start\":\"80181\",\"end\":\"80185\"},{\"start\":\"80189\",\"end\":\"80193\"},{\"start\":\"80197\",\"end\":\"80200\"},{\"start\":\"80204\",\"end\":\"80207\"},{\"start\":\"80211\",\"end\":\"80214\"},{\"start\":\"80218\",\"end\":\"80221\"},{\"start\":\"80225\",\"end\":\"80229\"},{\"start\":\"80626\",\"end\":\"80632\"},{\"start\":\"80895\",\"end\":\"80898\"},{\"start\":\"80902\",\"end\":\"80910\"},{\"start\":\"80914\",\"end\":\"80923\"},{\"start\":\"80929\",\"end\":\"80936\"},{\"start\":\"80940\",\"end\":\"80943\"},{\"start\":\"80947\",\"end\":\"80957\"},{\"start\":\"80961\",\"end\":\"80965\"},{\"start\":\"80971\",\"end\":\"80978\"},{\"start\":\"80984\",\"end\":\"80989\"},{\"start\":\"80997\",\"end\":\"81003\"},{\"start\":\"81009\",\"end\":\"81014\"},{\"start\":\"81716\",\"end\":\"81723\"},{\"start\":\"81727\",\"end\":\"81733\"}]", "bib_entry": "[{\"start\":\"62052\",\"end\":\"62199\",\"attributes\":{\"id\":\"b0\"}},{\"start\":\"62201\",\"end\":\"62493\",\"attributes\":{\"id\":\"b1\"}},{\"start\":\"62495\",\"end\":\"62764\",\"attributes\":{\"id\":\"b2\"}},{\"start\":\"62766\",\"end\":\"63228\",\"attributes\":{\"matched_paper_id\":\"11024896\",\"id\":\"b3\"}},{\"start\":\"63230\",\"end\":\"63709\",\"attributes\":{\"matched_paper_id\":\"16496367\",\"id\":\"b4\"}},{\"start\":\"63711\",\"end\":\"64030\",\"attributes\":{\"matched_paper_id\":\"1798819\",\"id\":\"b5\"}},{\"start\":\"64032\",\"end\":\"64620\",\"attributes\":{\"matched_paper_id\":\"5812369\",\"id\":\"b6\"}},{\"start\":\"64622\",\"end\":\"65220\",\"attributes\":{\"matched_paper_id\":\"4918751\",\"id\":\"b7\"}},{\"start\":\"65222\",\"end\":\"65621\",\"attributes\":{\"matched_paper_id\":\"19177604\",\"id\":\"b8\"}},{\"start\":\"65623\",\"end\":\"66182\",\"attributes\":{\"matched_paper_id\":\"174799235\",\"id\":\"b9\"}},{\"start\":\"66184\",\"end\":\"66878\",\"attributes\":{\"matched_paper_id\":\"8254904\",\"id\":\"b10\"}},{\"start\":\"66880\",\"end\":\"67421\",\"attributes\":{\"matched_paper_id\":\"2215568\",\"id\":\"b11\"}},{\"start\":\"67423\",\"end\":\"67946\",\"attributes\":{\"matched_paper_id\":\"49233609\",\"id\":\"b12\"}},{\"start\":\"67948\",\"end\":\"68642\",\"attributes\":{\"matched_paper_id\":\"102347768\",\"id\":\"b13\"}},{\"start\":\"68644\",\"end\":\"68929\",\"attributes\":{\"id\":\"b14\"}},{\"start\":\"68931\",\"end\":\"69435\",\"attributes\":{\"matched_paper_id\":\"11639591\",\"id\":\"b15\"}},{\"start\":\"69437\",\"end\":\"69945\",\"attributes\":{\"matched_paper_id\":\"207182734\",\"id\":\"b16\"}},{\"start\":\"69947\",\"end\":\"70519\",\"attributes\":{\"matched_paper_id\":\"17282462\",\"id\":\"b17\"}},{\"start\":\"70521\",\"end\":\"70907\",\"attributes\":{\"matched_paper_id\":\"28968350\",\"id\":\"b18\"}},{\"start\":\"70909\",\"end\":\"71513\",\"attributes\":{\"matched_paper_id\":\"18007530\",\"id\":\"b19\"}},{\"start\":\"71515\",\"end\":\"72099\",\"attributes\":{\"id\":\"b20\"}},{\"start\":\"72101\",\"end\":\"72641\",\"attributes\":{\"matched_paper_id\":\"53721743\",\"id\":\"b21\"}},{\"start\":\"72643\",\"end\":\"73295\",\"attributes\":{\"matched_paper_id\":\"1158102\",\"id\":\"b22\"}},{\"start\":\"73297\",\"end\":\"73851\",\"attributes\":{\"matched_paper_id\":\"155740276\",\"id\":\"b23\"}},{\"start\":\"73853\",\"end\":\"74510\",\"attributes\":{\"matched_paper_id\":\"14508569\",\"id\":\"b24\"}},{\"start\":\"74512\",\"end\":\"75030\",\"attributes\":{\"matched_paper_id\":\"8034563\",\"id\":\"b25\"}},{\"start\":\"75032\",\"end\":\"75481\",\"attributes\":{\"matched_paper_id\":\"5171267\",\"id\":\"b26\"}},{\"start\":\"75483\",\"end\":\"76046\",\"attributes\":{\"matched_paper_id\":\"373888\",\"id\":\"b27\"}},{\"start\":\"76048\",\"end\":\"76584\",\"attributes\":{\"matched_paper_id\":\"51815608\",\"id\":\"b28\"}},{\"start\":\"76586\",\"end\":\"77204\",\"attributes\":{\"matched_paper_id\":\"978769\",\"id\":\"b29\"}},{\"start\":\"77206\",\"end\":\"77373\",\"attributes\":{\"matched_paper_id\":\"2447135\",\"id\":\"b30\"}},{\"start\":\"77375\",\"end\":\"78128\",\"attributes\":{\"matched_paper_id\":\"210927720\",\"id\":\"b31\"}},{\"start\":\"78130\",\"end\":\"78378\",\"attributes\":{\"id\":\"b32\"}},{\"start\":\"78380\",\"end\":\"78516\",\"attributes\":{\"id\":\"b33\"}},{\"start\":\"78518\",\"end\":\"78666\",\"attributes\":{\"id\":\"b34\"}},{\"start\":\"78668\",\"end\":\"78883\",\"attributes\":{\"matched_paper_id\":\"8911258\",\"id\":\"b35\"}},{\"start\":\"78885\",\"end\":\"79339\",\"attributes\":{\"matched_paper_id\":\"2211881\",\"id\":\"b36\"}},{\"start\":\"79341\",\"end\":\"79851\",\"attributes\":{\"matched_paper_id\":\"195349294\",\"id\":\"b37\"}},{\"start\":\"79853\",\"end\":\"80054\",\"attributes\":{\"matched_paper_id\":\"41178004\",\"id\":\"b38\"}},{\"start\":\"80056\",\"end\":\"80124\",\"attributes\":{\"id\":\"b39\"}},{\"start\":\"80126\",\"end\":\"80561\",\"attributes\":{\"matched_paper_id\":\"7628008\",\"id\":\"b40\"}},{\"start\":\"80563\",\"end\":\"80793\",\"attributes\":{\"id\":\"b41\"}},{\"start\":\"80795\",\"end\":\"81621\",\"attributes\":{\"matched_paper_id\":\"202726723\",\"id\":\"b42\"}},{\"start\":\"81623\",\"end\":\"82122\",\"attributes\":{\"matched_paper_id\":\"218537479\",\"id\":\"b43\"}}]", "bib_title": "[{\"start\":\"62766\",\"end\":\"62814\"},{\"start\":\"63230\",\"end\":\"63258\"},{\"start\":\"63711\",\"end\":\"63767\"},{\"start\":\"64032\",\"end\":\"64100\"},{\"start\":\"64622\",\"end\":\"64697\"},{\"start\":\"65222\",\"end\":\"65255\"},{\"start\":\"65623\",\"end\":\"65682\"},{\"start\":\"66184\",\"end\":\"66265\"},{\"start\":\"66880\",\"end\":\"66966\"},{\"start\":\"67423\",\"end\":\"67496\"},{\"start\":\"67948\",\"end\":\"68021\"},{\"start\":\"68931\",\"end\":\"69026\"},{\"start\":\"69437\",\"end\":\"69480\"},{\"start\":\"69947\",\"end\":\"70020\"},{\"start\":\"70521\",\"end\":\"70607\"},{\"start\":\"70909\",\"end\":\"70952\"},{\"start\":\"71515\",\"end\":\"71690\"},{\"start\":\"72101\",\"end\":\"72170\"},{\"start\":\"72643\",\"end\":\"72704\"},{\"start\":\"73297\",\"end\":\"73349\"},{\"start\":\"73853\",\"end\":\"73949\"},{\"start\":\"74512\",\"end\":\"74562\"},{\"start\":\"75032\",\"end\":\"75104\"},{\"start\":\"75483\",\"end\":\"75532\"},{\"start\":\"76048\",\"end\":\"76095\"},{\"start\":\"76586\",\"end\":\"76662\"},{\"start\":\"77206\",\"end\":\"77220\"},{\"start\":\"77375\",\"end\":\"77456\"},{\"start\":\"78668\",\"end\":\"78703\"},{\"start\":\"78885\",\"end\":\"78931\"},{\"start\":\"79341\",\"end\":\"79359\"},{\"start\":\"79853\",\"end\":\"79880\"},{\"start\":\"80126\",\"end\":\"80169\"},{\"start\":\"80795\",\"end\":\"80891\"},{\"start\":\"81623\",\"end\":\"81712\"}]", "bib_author": "[{\"start\":\"62076\",\"end\":\"62084\"},{\"start\":\"62294\",\"end\":\"62304\"},{\"start\":\"62816\",\"end\":\"62830\"},{\"start\":\"62830\",\"end\":\"62842\"},{\"start\":\"62842\",\"end\":\"62855\"},{\"start\":\"62855\",\"end\":\"62865\"},{\"start\":\"63260\",\"end\":\"63272\"},{\"start\":\"63272\",\"end\":\"63281\"},{\"start\":\"63281\",\"end\":\"63290\"},{\"start\":\"63769\",\"end\":\"63781\"},{\"start\":\"63781\",\"end\":\"63790\"},{\"start\":\"64102\",\"end\":\"64116\"},{\"start\":\"64116\",\"end\":\"64126\"},{\"start\":\"64699\",\"end\":\"64709\"},{\"start\":\"64709\",\"end\":\"64720\"},{\"start\":\"65257\",\"end\":\"65266\"},{\"start\":\"65266\",\"end\":\"65283\"},{\"start\":\"65684\",\"end\":\"65694\"},{\"start\":\"65694\",\"end\":\"65706\"},{\"start\":\"65706\",\"end\":\"65718\"},{\"start\":\"65718\",\"end\":\"65726\"},{\"start\":\"65726\",\"end\":\"65735\"},{\"start\":\"65735\",\"end\":\"65752\"},{\"start\":\"66267\",\"end\":\"66279\"},{\"start\":\"66279\",\"end\":\"66291\"},{\"start\":\"66291\",\"end\":\"66305\"},{\"start\":\"66305\",\"end\":\"66318\"},{\"start\":\"66968\",\"end\":\"66983\"},{\"start\":\"66983\",\"end\":\"66997\"},{\"start\":\"66997\",\"end\":\"67010\"},{\"start\":\"67498\",\"end\":\"67511\"},{\"start\":\"67511\",\"end\":\"67524\"},{\"start\":\"67524\",\"end\":\"67536\"},{\"start\":\"67536\",\"end\":\"67546\"},{\"start\":\"67546\",\"end\":\"67556\"},{\"start\":\"68023\",\"end\":\"68032\"},{\"start\":\"68032\",\"end\":\"68039\"},{\"start\":\"68039\",\"end\":\"68047\"},{\"start\":\"68719\",\"end\":\"68724\"},{\"start\":\"69028\",\"end\":\"69039\"},{\"start\":\"69482\",\"end\":\"69495\"},{\"start\":\"69495\",\"end\":\"69503\"},{\"start\":\"69503\",\"end\":\"69517\"},{\"start\":\"69517\",\"end\":\"69531\"},{\"start\":\"69531\",\"end\":\"69542\"},{\"start\":\"69542\",\"end\":\"69553\"},{\"start\":\"70022\",\"end\":\"70028\"},{\"start\":\"70028\",\"end\":\"70036\"},{\"start\":\"70036\",\"end\":\"70043\"},{\"start\":\"70043\",\"end\":\"70050\"},{\"start\":\"70609\",\"end\":\"70620\"},{\"start\":\"70620\",\"end\":\"70627\"},{\"start\":\"70627\",\"end\":\"70640\"},{\"start\":\"70954\",\"end\":\"70964\"},{\"start\":\"70964\",\"end\":\"70972\"},{\"start\":\"70972\",\"end\":\"70980\"},{\"start\":\"70980\",\"end\":\"70989\"},{\"start\":\"70989\",\"end\":\"71002\"},{\"start\":\"71002\",\"end\":\"71009\"},{\"start\":\"71009\",\"end\":\"71026\"},{\"start\":\"71692\",\"end\":\"71702\"},{\"start\":\"72172\",\"end\":\"72187\"},{\"start\":\"72187\",\"end\":\"72196\"},{\"start\":\"72196\",\"end\":\"72204\"},{\"start\":\"72204\",\"end\":\"72215\"},{\"start\":\"72215\",\"end\":\"72228\"},{\"start\":\"72228\",\"end\":\"72238\"},{\"start\":\"72706\",\"end\":\"72718\"},{\"start\":\"72718\",\"end\":\"72730\"},{\"start\":\"72730\",\"end\":\"72742\"},{\"start\":\"72742\",\"end\":\"72753\"},{\"start\":\"72753\",\"end\":\"72765\"},{\"start\":\"72765\",\"end\":\"72774\"},{\"start\":\"72774\",\"end\":\"72784\"},{\"start\":\"72784\",\"end\":\"72797\"},{\"start\":\"72797\",\"end\":\"72807\"},{\"start\":\"72807\",\"end\":\"72814\"},{\"start\":\"73351\",\"end\":\"73363\"},{\"start\":\"73363\",\"end\":\"73374\"},{\"start\":\"73374\",\"end\":\"73381\"},{\"start\":\"73381\",\"end\":\"73388\"},{\"start\":\"73388\",\"end\":\"73400\"},{\"start\":\"73400\",\"end\":\"73412\"},{\"start\":\"73412\",\"end\":\"73421\"},{\"start\":\"73421\",\"end\":\"73430\"},{\"start\":\"73430\",\"end\":\"73443\"},{\"start\":\"73443\",\"end\":\"73458\"},{\"start\":\"73458\",\"end\":\"73465\"},{\"start\":\"73465\",\"end\":\"73478\"},{\"start\":\"73478\",\"end\":\"73492\"},{\"start\":\"73492\",\"end\":\"73503\"},{\"start\":\"73951\",\"end\":\"73958\"},{\"start\":\"73958\",\"end\":\"73966\"},{\"start\":\"73966\",\"end\":\"73973\"},{\"start\":\"73973\",\"end\":\"73983\"},{\"start\":\"73983\",\"end\":\"73992\"},{\"start\":\"73992\",\"end\":\"73999\"},{\"start\":\"73999\",\"end\":\"74012\"},{\"start\":\"74012\",\"end\":\"74019\"},{\"start\":\"74019\",\"end\":\"74028\"},{\"start\":\"74564\",\"end\":\"74575\"},{\"start\":\"74575\",\"end\":\"74585\"},{\"start\":\"74585\",\"end\":\"74595\"},{\"start\":\"75106\",\"end\":\"75115\"},{\"start\":\"75115\",\"end\":\"75126\"},{\"start\":\"75534\",\"end\":\"75544\"},{\"start\":\"75544\",\"end\":\"75552\"},{\"start\":\"75552\",\"end\":\"75560\"},{\"start\":\"75560\",\"end\":\"75570\"},{\"start\":\"75570\",\"end\":\"75579\"},{\"start\":\"75579\",\"end\":\"75587\"},{\"start\":\"75587\",\"end\":\"75598\"},{\"start\":\"75598\",\"end\":\"75606\"},{\"start\":\"75606\",\"end\":\"75617\"},{\"start\":\"75617\",\"end\":\"75629\"},{\"start\":\"75629\",\"end\":\"75640\"},{\"start\":\"75640\",\"end\":\"75649\"},{\"start\":\"76097\",\"end\":\"76105\"},{\"start\":\"76105\",\"end\":\"76116\"},{\"start\":\"76116\",\"end\":\"76125\"},{\"start\":\"76125\",\"end\":\"76137\"},{\"start\":\"76137\",\"end\":\"76145\"},{\"start\":\"76145\",\"end\":\"76153\"},{\"start\":\"76153\",\"end\":\"76161\"},{\"start\":\"76161\",\"end\":\"76172\"},{\"start\":\"76172\",\"end\":\"76182\"},{\"start\":\"76182\",\"end\":\"76192\"},{\"start\":\"76192\",\"end\":\"76201\"},{\"start\":\"76201\",\"end\":\"76212\"},{\"start\":\"76664\",\"end\":\"76675\"},{\"start\":\"76675\",\"end\":\"76683\"},{\"start\":\"77222\",\"end\":\"77230\"},{\"start\":\"77230\",\"end\":\"77242\"},{\"start\":\"77458\",\"end\":\"77471\"},{\"start\":\"77471\",\"end\":\"77482\"},{\"start\":\"77482\",\"end\":\"77488\"},{\"start\":\"77488\",\"end\":\"77501\"},{\"start\":\"78171\",\"end\":\"78199\"},{\"start\":\"78199\",\"end\":\"78223\"},{\"start\":\"78705\",\"end\":\"78718\"},{\"start\":\"78933\",\"end\":\"78941\"},{\"start\":\"78941\",\"end\":\"78947\"},{\"start\":\"78947\",\"end\":\"78958\"},{\"start\":\"78958\",\"end\":\"78969\"},{\"start\":\"78969\",\"end\":\"78979\"},{\"start\":\"79361\",\"end\":\"79372\"},{\"start\":\"79372\",\"end\":\"79384\"},{\"start\":\"79384\",\"end\":\"79393\"},{\"start\":\"79393\",\"end\":\"79408\"},{\"start\":\"79408\",\"end\":\"79417\"},{\"start\":\"79417\",\"end\":\"79425\"},{\"start\":\"79425\",\"end\":\"79437\"},{\"start\":\"79437\",\"end\":\"79448\"},{\"start\":\"79448\",\"end\":\"79459\"},{\"start\":\"79459\",\"end\":\"79472\"},{\"start\":\"79472\",\"end\":\"79479\"},{\"start\":\"79479\",\"end\":\"79489\"},{\"start\":\"79489\",\"end\":\"79499\"},{\"start\":\"79499\",\"end\":\"79508\"},{\"start\":\"79508\",\"end\":\"79518\"},{\"start\":\"79518\",\"end\":\"79528\"},{\"start\":\"79882\",\"end\":\"79892\"},{\"start\":\"80171\",\"end\":\"80179\"},{\"start\":\"80179\",\"end\":\"80187\"},{\"start\":\"80187\",\"end\":\"80195\"},{\"start\":\"80195\",\"end\":\"80202\"},{\"start\":\"80202\",\"end\":\"80209\"},{\"start\":\"80209\",\"end\":\"80216\"},{\"start\":\"80216\",\"end\":\"80223\"},{\"start\":\"80223\",\"end\":\"80231\"},{\"start\":\"80626\",\"end\":\"80634\"},{\"start\":\"80893\",\"end\":\"80900\"},{\"start\":\"80900\",\"end\":\"80912\"},{\"start\":\"80912\",\"end\":\"80925\"},{\"start\":\"80925\",\"end\":\"80938\"},{\"start\":\"80938\",\"end\":\"80945\"},{\"start\":\"80945\",\"end\":\"80959\"},{\"start\":\"80959\",\"end\":\"80967\"},{\"start\":\"80967\",\"end\":\"80980\"},{\"start\":\"80980\",\"end\":\"80991\"},{\"start\":\"80991\",\"end\":\"81005\"},{\"start\":\"81005\",\"end\":\"81016\"},{\"start\":\"81714\",\"end\":\"81725\"},{\"start\":\"81725\",\"end\":\"81735\"}]", "bib_venue": "[{\"start\":\"62945\",\"end\":\"63008\"},{\"start\":\"63381\",\"end\":\"63455\"},{\"start\":\"63840\",\"end\":\"63873\"},{\"start\":\"64231\",\"end\":\"64319\"},{\"start\":\"64825\",\"end\":\"64913\"},{\"start\":\"65371\",\"end\":\"65442\"},{\"start\":\"65846\",\"end\":\"65923\"},{\"start\":\"66454\",\"end\":\"66573\"},{\"start\":\"67098\",\"end\":\"67169\"},{\"start\":\"67635\",\"end\":\"67697\"},{\"start\":\"68183\",\"end\":\"68302\"},{\"start\":\"69132\",\"end\":\"69208\"},{\"start\":\"69639\",\"end\":\"69708\"},{\"start\":\"70143\",\"end\":\"70219\"},{\"start\":\"71119\",\"end\":\"71195\"},{\"start\":\"72321\",\"end\":\"72387\"},{\"start\":\"72902\",\"end\":\"72973\"},{\"start\":\"74116\",\"end\":\"74187\"},{\"start\":\"74697\",\"end\":\"74782\"},{\"start\":\"75209\",\"end\":\"75275\"},{\"start\":\"75719\",\"end\":\"75772\"},{\"start\":\"76274\",\"end\":\"76319\"},{\"start\":\"76813\",\"end\":\"76926\"},{\"start\":\"77638\",\"end\":\"77758\"},{\"start\":\"79062\",\"end\":\"79128\"},{\"start\":\"80301\",\"end\":\"80354\"},{\"start\":\"81110\",\"end\":\"81187\"},{\"start\":\"81823\",\"end\":\"81894\"},{\"start\":\"62052\",\"end\":\"62074\"},{\"start\":\"62201\",\"end\":\"62292\"},{\"start\":\"62495\",\"end\":\"62625\"},{\"start\":\"62865\",\"end\":\"62943\"},{\"start\":\"63290\",\"end\":\"63379\"},{\"start\":\"63790\",\"end\":\"63838\"},{\"start\":\"64126\",\"end\":\"64229\"},{\"start\":\"64720\",\"end\":\"64823\"},{\"start\":\"65283\",\"end\":\"65369\"},{\"start\":\"65752\",\"end\":\"65844\"},{\"start\":\"66318\",\"end\":\"66452\"},{\"start\":\"67010\",\"end\":\"67096\"},{\"start\":\"67556\",\"end\":\"67633\"},{\"start\":\"68047\",\"end\":\"68181\"},{\"start\":\"68644\",\"end\":\"68717\"},{\"start\":\"69039\",\"end\":\"69130\"},{\"start\":\"69553\",\"end\":\"69637\"},{\"start\":\"70050\",\"end\":\"70141\"},{\"start\":\"70640\",\"end\":\"70700\"},{\"start\":\"71026\",\"end\":\"71117\"},{\"start\":\"71702\",\"end\":\"71750\"},{\"start\":\"72238\",\"end\":\"72319\"},{\"start\":\"72814\",\"end\":\"72900\"},{\"start\":\"73503\",\"end\":\"73538\"},{\"start\":\"74028\",\"end\":\"74114\"},{\"start\":\"74595\",\"end\":\"74695\"},{\"start\":\"75126\",\"end\":\"75207\"},{\"start\":\"75649\",\"end\":\"75717\"},{\"start\":\"76212\",\"end\":\"76272\"},{\"start\":\"76683\",\"end\":\"76811\"},{\"start\":\"77242\",\"end\":\"77263\"},{\"start\":\"77501\",\"end\":\"77636\"},{\"start\":\"78130\",\"end\":\"78169\"},{\"start\":\"78380\",\"end\":\"78419\"},{\"start\":\"78518\",\"end\":\"78570\"},{\"start\":\"78718\",\"end\":\"78752\"},{\"start\":\"78979\",\"end\":\"79060\"},{\"start\":\"79528\",\"end\":\"79562\"},{\"start\":\"79892\",\"end\":\"79932\"},{\"start\":\"80056\",\"end\":\"80066\"},{\"start\":\"80231\",\"end\":\"80299\"},{\"start\":\"80563\",\"end\":\"80624\"},{\"start\":\"81016\",\"end\":\"81108\"},{\"start\":\"81735\",\"end\":\"81821\"}]"}}}, "year": 2023, "month": 12, "day": 17}