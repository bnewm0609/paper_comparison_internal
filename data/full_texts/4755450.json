{"id": 4755450, "updated": "2023-09-28 18:15:35.414", "metadata": {"title": "Inductive Representation Learning on Large Graphs", "authors": "[{\"first\":\"William\",\"last\":\"Hamilton\",\"middle\":[\"L.\"]},{\"first\":\"Rex\",\"last\":\"Ying\",\"middle\":[]},{\"first\":\"Jure\",\"last\":\"Leskovec\",\"middle\":[]}]", "venue": "NIPS", "journal": "1024-1034", "publication_date": {"year": 2017, "month": 6, "day": 7}, "abstract": "Low-dimensional embeddings of nodes in large graphs have proved extremely useful in a variety of prediction tasks, from content recommendation to identifying protein functions. However, most existing approaches require that all nodes in the graph are present during training of the embeddings; these previous approaches are inherently transductive and do not naturally generalize to unseen nodes. Here we present GraphSAGE, a general, inductive framework that leverages node feature information (e.g., text attributes) to efficiently generate node embeddings for previously unseen data. Instead of training individual embeddings for each node, we learn a function that generates embeddings by sampling and aggregating features from a node's local neighborhood. Our algorithm outperforms strong baselines on three inductive node-classification benchmarks: we classify the category of unseen nodes in evolving information graphs based on citation and Reddit post data, and we show that our algorithm generalizes to completely unseen graphs using a multi-graph dataset of protein-protein interactions.", "fields_of_study": "[\"Computer Science\",\"Mathematics\"]", "external_ids": {"arxiv": "1706.02216", "mag": "2962767366", "acl": null, "pubmed": null, "pubmedcentral": null, "dblp": "conf/nips/HamiltonYL17", "doi": null}}, "content": {"source": {"pdf_hash": "a9e4b6831b3c7669f791b29713d873ede982a621", "pdf_src": "Arxiv", "pdf_uri": "[\"https://arxiv.org/pdf/1706.02216v1.pdf\"]", "oa_url_match": false, "oa_info": null}, "grobid": {"id": "f975dda39b1ff3680feb7ce51f04ab46d8c87bba", "type": "plain-text", "url": "s3://ai2-s2-pdf-extraction-prod/parse-results/s2orc_worker/a9e4b6831b3c7669f791b29713d873ede982a621.txt", "contents": "\nInductive Representation Learning on Large Graphs\n\n\nWilliam L Hamilton \nDepartment of Computer Science\nStanford University Stanford\n94305CA\n\nRex Ying rexying@stanford.edu \nDepartment of Computer Science\nStanford University Stanford\n94305CA\n\nJure Leskovec \nDepartment of Computer Science\nStanford University Stanford\n94305CA\n\nInductive Representation Learning on Large Graphs\n\nLow-dimensional embeddings of nodes in large graphs have proved extremely useful in a variety of prediction tasks, from content recommendation to identifying protein functions. However, most existing approaches require that all nodes in the graph are present during training of the embeddings; these previous approaches are inherently transductive and do not naturally generalize to unseen nodes. Here we present GraphSAGE, a general inductive framework that leverages node feature information (e.g., text attributes) to efficiently generate node embeddings for previously unseen data. Instead of training individual embeddings for each node, we learn a function that generates embeddings by sampling and aggregating features from a node's local neighborhood. Our algorithm outperforms strong baselines on three inductive node-classification benchmarks: we classify the category of unseen nodes in evolving information graphs based on citation and Reddit post data, and we show that our algorithm generalizes to completely unseen graphs using a multi-graph dataset of protein-protein interactions.\n\nIntroduction\n\nLow-dimensional vector embeddings of nodes in large graphs 1 have proved extremely useful as feature inputs for a wide variety of prediction and graph analysis tasks [5,10,26,32,33]. The basic idea behind node embedding approaches is to use dimensionality reduction techniques to distill the high-dimensional information about a node's neighborhood into a dense vector embedding. These node embeddings can then be fed to downstream machine learning systems and aid in tasks such as node classification, clustering, and link prediction [10,26,32].\n\nHowever, previous works have focused on embedding nodes from a single fixed graph, and many real-world applications require embeddings to be quickly generated for unseen nodes, or entirely new (sub)graphs. This inductive capability is essential for high-throughput, production machine learning systems, which operate on evolving graphs and constantly encounter unseen nodes (e.g., posts on Reddit, users and videos on Youtube). An inductive approach to generating node embeddings also facilitates generalization across graphs with the same form of features: for example, one could train an embedding generator on protein-protein interaction graphs derived from a model organism, and then easily produce node embeddings for data collected on new organisms using the trained model.\n\nThe inductive node embedding problem is especially difficult, compared to the transductive setting, because generalizing to unseen nodes requires \"aligning\" newly observed subgraphs to the node embeddings that the algorithm has already optimized on. An inductive framework must learn to recognize structural properties of a node's neighborhood that reveal both the nodes local role in the graph, as well as its global position.\n\nMost existing approaches to generating node embeddings are inherently transductive. The majority of these approaches directly optimize the embeddings for each node using matrix-factorization-based objectives, and do not naturally generalize to unseen data, since they make predictions on nodes in a single, fixed graph [5,10,21,26,32,33,34,36]. These approaches can be modified to operate in an inductive setting (e.g., [26]), but these modifications tend to be computationally expensive, requiring additional rounds of gradient descent before new predictions can be made. There are also recent approaches to learning over graph structures using convolution operators that offer promise as an embedding methodology [15]. So far, graph convolutional networks (GCNs) have only been applied in the transductive setting with fixed graphs [15,16]. In this work we both extend GCNs to the task of inductive unsupervised learning and propose a framework that generalizes the GCN approach to use trainable aggregation functions (beyond simple convolutions).\n\nPresent work. We propose a general framework, called GraphSAGE (SAmple and aggreGatE), for inductive node embedding. Unlike embedding approaches that are based on matrix factorization, we leverage node features (e.g., text attributes, node profile information, node degrees) in order to learn an embedding function that generalizes to unseen nodes. By incorporating node features in the learning algorithm, we simultaneously learn the topological structure of each node's neighborhood as well as the distribution of node features in the neighborhood. While we focus on feature-rich graphs (e.g., citation data with text attributes, biological data with functional/molecular markers), our approach can also make use of structural features that are present in all graphs (e.g., node degrees). Thus, our algorithm can also be applied to graphs without node features.\n\nInstead of training a distinct embedding vector for each node, we train a set of aggregator functions that learn to recursively aggregate feature information from a node's local neighborhood ( Figure 1). Each aggregator function aggregates information from a different number of hops, or search depth, away from a given node. At test, or inference time, we use our trained system to generate embeddings for entirely unseen nodes by applying the learned aggregation functions. Following previous work on generating node embeddings, we design an unsupervised loss function that allows GraphSAGE to be trained without task-specific supervision. We also show that GraphSAGE can be trained in a fully supervised manner.\n\nWe evaluate our algorithm on three node-classification benchmarks, which test GraphSAGE's ability to generate useful embeddings on unseen data. We use two evolving document graphs based on citation data and Reddit post data (predicting paper and post categories, respectively), and a multigraph generalization experiment based on a dataset of protein-protein interactions (predicting protein functions). Using these benchmarks, we show that our approach is able to effectively generate representations for unseen nodes and outperform relevant baselines by a significant margin: across domains, our supervised approach improves classification F1-scores by an average of 51% compared to using node features alone and GraphSAGE consistently outperforms a strong, transductive baseline [26], despite this baseline taking \u223c100\u00d7 longer to run on unseen nodes. We also show that the new aggregator architectures we propose provide significant gains (7.4% on average) compared to an aggregator inspired by graph convolutional networks [15]. Lastly, we probe the expressive capability of our approach and show, through theoretical analysis, that GraphSAGE is capable of learning structural information about a node's role in a graph, despite the fact that it is inherently based on features (Section 5).\n\n\nRelated work\n\nOur algorithm is conceptually related to previous node embedding approaches, general supervised approaches to learning over graphs, and recent advancements in applying convolutional neural networks to graph-structured data.\n\nFactorization-based embedding approaches. There are a number of recent node embedding approaches that learn low-dimensional embeddings using random walk statistics and matrix factorization-based learning objectives [5,10,26,32,33]. These methods also bear close relationships to more classic approaches to spectral clustering [21], multi-dimensional scaling [17], as well as the PageRank algorithm [23]. Since these embedding algorithms directly train node embeddings for individual nodes, they are inherently transductive and, at the very least, require expensive additional training (e.g., via stochastic gradient descent) to make predictions on new nodes. In addition, for many of these approaches (e.g., [10,26,32,33]) the objective function is invariant to orthogonal transformations of the embeddings, which means that the embedding space does not naturally generalize between graphs and can drift during re-training. One notable exception to this trend is the Planetoid-I algorithm introduced by [37], which is an inductive, embedding-based approach to semi-supervised learning. However, Planetoid-I does not use any graph structural information during inference; instead, it uses the graph structure as a form of regularization during training. Unlike these previous approaches, we leverage feature information in order to train a model to produce embeddings for unseen nodes.\n\nSupervised learning over graphs. Beyond node embedding approaches, there is a rich literature on supervised learning over graph-structured data. This includes a wide variety of kernel-based approaches, where feature vectors for graphs are derived from various graph kernels (see [30] and references therein). There are also a number of recent neural network approaches to supervised learning over graph structures [6,9,19,29]. Our approach is conceptually inspired by a number of these algorithms. However, whereas these previous approaches attempt to classify entire graphs (or subgraphs), the focus of this work is generating useful representations for individual nodes.\n\nGraph convolutional networks. In recent years, several convolutional neural network architectures for learning over graphs have been proposed (e.g., [4,8,7,15,22]). The majority of these methods do not scale to large graphs or are designed for whole-graph classification (or both) [4,8,7,22]. However, our approach is closely related to the graph convolutional network (GCN), introduced by Kipf et al. [15,16]. The original GCN algorithm [15] is designed for semi-supervised learning in a transductive setting, and the exact algorithm requires that the full graph Laplacian is known during training. A simple variant of our algorithm can be viewed as an extension of the GCN framework to the setting of inductive, unsupervised learning, a point which we revisit in Section 3.3.\n\n\nProposed method: GraphSAGE\n\nThe key idea behind our approach is that we learn how to aggregate feature information from a node's local neighborhood (e.g., the degrees or text attributes of nearby nodes). We first describe the GraphSAGE embedding generation (i.e., forward propagation) algorithm, which generates embeddings for nodes assuming that the GraphSAGE model parameters are already learned (Section 3.1). We then describe how the GraphSAGE model parameters can be learned using standard stochastic gradient descent and backpropagation techniques (Section 3.2).\n\n\nEmbedding generation (i.e., forward propagation) algorithm\n\nIn this section, we describe the embedding generation, or forward propagation algorithm (Algorithm 1), which assumes that the model has already been trained and that the parameters are fixed. In particular, we assume that we have learned the parameters of K aggregator functions (denoted {AGGREGATE k , \u2200k \u2208 [1, K]}), which aggregate information from node neighbors, as well as a set of weight matrices {W k , \u2200k \u2208 [1, K]}, which are used to propagate information between different layers of the model or \"search depths\". Section 3.2 describes how we train these parameters.\n\nThe intuition behind Algorithm 1 is that at each iteration, or search depth, nodes aggregate information from their local neighbors, and as this process iterates, nodes incrementally gain more and more information from further reaches of the graph. \nv \u2192 2 V Output : Vector representations z v for all v \u2208 V 1 h 0 v \u2190 x v , \u2200v \u2208 V ; 2 for k = 1...K do 3 for v \u2208 V do 4 h k N (v) \u2190 AGGREGATE k ({h k\u22121 u , \u2200u \u2208 N (v)}); 5 h k v \u2190 \u03c3 W k \u00b7 CONCAT(h k\u22121 v , h k N (v) ) 6 end 7 h k v \u2190 h k v / h k v 2 , \u2200v \u2208 V 8 end 9 z v \u2190 h K v , \u2200v \u2208 V\nAlgorithm 1 describes the embedding generation process in the case where the entire graph, G = (V, E), and features for all nodes x v , \u2200v \u2208 V, are provided as input. We describe how to generalize this to the minibatch setting below. Each step in the outer loop of Algorithm 1 proceeds as follows, where k denotes the current step in the outer loop (or the depth of the recursive search) and h k denotes a node's representation at this step: First, each node v \u2208 V aggregates the representations of the nodes in its immediate neighborhood,\n{h k\u22121 u , \u2200u \u2208 N (v)}, into a single vector h k\u22121 N (v)\n. Note that this aggregation step depends on the representations generated at the previous iteration of the outer loop (i.e., k \u2212 1), and the k = 0 (\"base case\") representations are defined as the input node features. After aggregating the neighboring feature vectors, GraphSAGE then concatenates the node's current representation, h k\u22121 v , with the aggregated neighborhood vector, h k\u22121 N (v) , and this concatenated vector is fed through a fully connected layer with nonlinear activation function \u03c3, which transforms the representations to be used at the next step of the algorithm (i.e., h k v , \u2200v \u2208 V). For notational convenience, we denote the final representations output at depth K as z v \u2261 h K v , \u2200v \u2208 V. The aggregation of the neighbor representations can be done by a variety of aggregator architectures (denoted by the AGGREGATE placeholder in Algorithm 1), and we discuss different architecture choices in Section 3.3 below.\n\nTo extend Algorithm 1 to the minibatch setting, given a set of input nodes, we first forward sample the required neighborhood sets (up to depth K) and then we run the inner loop (line 3 in Algorithm 1), but instead of iterating over all nodes, we compute only the representations that are necessary to satisfy the recursion at each depth (Appendix A contains complete minibatch pseudocode).\n\nRelation to the Weisfeiler-Lehman Isomorphism Test. The GraphSAGE algorithm is conceptually inspired by a classic algorithm for testing graph isomorphism. If, in Algorithm 1, we (i) set K = |V|, (ii) set the weight matrices as the identity, and (iii) use an appropriate hash function as an aggregator (with no non-linearity), then Algorithm 1 is an instance of the Weisfeiler-Lehman (WL) isomorphism test, also known as \"naive vertex refinement\" [30]. If the set of representations {z v , \u2200v \u2208 V} output by Algorithm 1 for two subgraphs are identical then the WL test declares the two subgraphs to be isomorphic. This test is known to fail in some cases, but is valid for a broad class of graphs [30]. GraphSAGE is a continuous approximation to the WL test, where we replace the hash function with trainable neural network aggregators. Of course, we use GraphSAGE to generate useful node representations-not to test graph isomorphism. Nevertheless, the connection between GraphSAGE and the classic WL test provides theoretical context for our algorithm design to learn the topological structure of node neighborhoods.\n\nNeighborhood definition. In this work, we uniformly sample a fixed-size set of neighbors, instead of recursing on full neighborhood sets in Algorithm 1, in order to keep the computational footprint of each batch fixed. 2 That is, using overloaded notation, we define N (v) as a fixed-size, uniform draw from the set {u \u2208 V : (u, v) \u2208 E}, and we draw different uniform samples at each iteration, k, in Algorithm 1. Without this sampling the memory and expected runtime of a single batch is unpredictable and in the worst case O(|V|). In contrast, the per-batch space and time complexity for\nGraphSAGE is fixed at O( K i=1 S i ), where {S i , i \u2208 [1, .\n.., K]} and K are user-specified constants. Practically speaking we found that our approach could achieve high performance with K = 2 and S 1 \u00b7 S 2 \u2264 500 (Section 4.3).\n\n\nLearning the parameters of GraphSAGE\n\nIn order to learn useful, predictive representations in a fully unsupervised setting, we apply a graphbased loss function to the output representations, {z u , \u2200u \u2208 V}, and tune the weight matrices, {W k , \u2200k \u2208 [1, K]}, and parameters of the aggregator functions via stochastic gradient descent. The graph-based loss function encourages nearby nodes to have similar representations, while enforcing that the representations of disparate nodes are highly distinct:\nJ G (z u ) = \u2212 log \u03c3(z u z v ) \u2212 Q \u00b7 E vn\u223cPn(v) log \u03c3(\u2212z u z vn ) ,(1)\nwhere v is a node that co-occurs near u on fixed-length random walk, \u03c3 is the sigmoid function, P n is a negative sampling distribution, and Q defines the number of negative samples. Importantly, unlike previous embedding approaches, the representations z u that we feed into this loss function are generated from the features contained within a node's local neighborhood, rather than training a unique embedding for each node (via an embedding look-up).\n\nThis unsupervised setting emulates situations where node features are provided to downstream machine learning applications, as a service or in a static repository. In cases where representations are to be used only on a specific downstream task, the unsupervised loss (Equation 1) can simply be replaced, or augmented, by a task-specific objective (e.g., cross-entropy loss).\n\n\nAggregator Architectures\n\nUnlike machine learning over N-D lattices (e.g., sentences, images, or 3-D volumes), a node's neighbors have no natural ordering; thus, the aggregator functions in Algorithm 1 must operate over an unordered set of vectors. Ideally, an aggregator function would be symmetric (i.e., invariant to permutations of its inputs) while still being trainable and maintaining high representational capacity. The symmetry property of the aggregation function ensures that our neural network model can be trained and applied to arbitrarily ordered node neighborhood feature sets. We examined three candidate aggregator functions:\n\nMean aggregator. Our first candidate aggregator function is the mean operator, where we simply take the elementwise mean of the vectors in {h k\u22121 u , \u2200u \u2208 N (v)}. The mean aggregator is nearly equivalent to the convolutional propagation rule used in the transductive GCN framework [15]. In particular, we can derive an inductive variant of the GCN approach by replacing lines 4 and 5 in Algorithm 1 with the following: 3\nh k v \u2190 \u03c3(W \u00b7 MEAN({h k\u22121 v } \u222a {h k\u22121 u , \u2200u \u2208 N (v)}).(2)\nWe call this modified mean-based aggregator convolutional since it is a rough, linear approximation of a localized spectral convolution [15].\n\nLSTM aggregator. We also examined a more complex aggregator based on an LSTM architecture [12]. Compared to the mean aggregator, LSTMs have the advantage of larger expressive capability. However, it is important to note that LSTMs are not inherently symmetric (i.e., they are not permutation invariant), since they process their inputs in a sequential manner. We adapt LSTMs to operate on an unordered set by simply applying the LSTMs to a random permutation of a node's neighbors.\n\nPooling aggregator. The final aggregator we examine is both symmetric and trainable. In this pooling approach, each neighbor's vector is independently fed through a fully-connected neural network; following this transformation, an elementwise max-pooling operation is applied to aggregate information across the neighbor set:\nAGGREGATE pool k = max({\u03c3 W pool h k ui + b , \u2200u i \u2208 N (v)}),(3)\n3 Note that this differs from Kipf et al's exact equation by a minor normalization constant [15].\n\nwhere max denotes the element-wise max operator and \u03c3 is a nonlinear activation function. In principle, the function applied before the max pooling can be an arbitrarily deep multi-layer perceptron, but we focus on simple single-layer architectures in this work. This approach is inspired by recent advancements in applying neural network architectures to learn over general point sets [27]. Intuitively, the multi-layer perceptron can be thought of as a set of functions that compute features for each of the node representations in the neighbor set. By applying the max-pooling operator to each of the computed features, the model effectively captures different aspects of the neighborhood set.\n\n\nExperiments\n\nWe test the performance of GraphSAGE on three benchmark tasks: (i) classifying academic papers into different subjects using the Web of Science citation dataset, (ii) classifying Reddit posts as belonging to different communities, and (iii) classifying protein functions across various biological protein-protein interaction (PPI) graphs. Sections 4.1 and 4.2 summarize the datasets, and the supplementary material contains additional information. In all these experiments, we perform predictions on nodes that are not seen during training, and, in the case of the PPI dataset, we test on entirely unseen graphs.\n\nExperimental set-up. To contextualize the empirical results on our inductive benchmarks, we compare against four baselines: a random classifer, a logistic regression feature-based classifier (that ignores graph structure), the DeepWalk algorithm [26] as a representative factorization-based approach, and a concatenation of the raw features and DeepWalk embeddings. We also compare four variants of GraphSAGE that use the different aggregator functions (Section 3.3). Since, the \"convolutional\" variant of GraphSAGE is an extended, inductive version of Kipf et al's semi-supervised GCN [15], we term this variant GraphSAGE-GCN. We test unsupervised variants of GraphSAGE trained according to the loss in Equation (1), as well as supervised variants that are trained directly on classification cross-entropy loss. For all the GraphSAGE variants we used rectified linear units as the non-linearity and set K = 2 with neighborhood sample sizes S 1 = 25 and S 2 = 10 (see Section 4.3 for sensitivity analyses).\n\nFor the Reddit and citation datasets, we use \"online\" training for DeepWalk as described in [26], where we run a new round of SGD optimization to embed the new test nodes before making predictions (see the Appendix for details). In the multi-graph setting, we cannot apply DeepWalk, since the embedding spaces generated by running the DeepWalk algorithm on different disjoint graphs can be arbitrarily rotated with respect to each other (Appendix D).\n\nAll models were implemented in Tensorflow [1] with the Adam optimizer [14] (except DeepWalk, which performed better with the vanilla gradient descent optimizer). In order to provide a fair comparison, all models share an identical implementation of their minibatch iterators, loss function and neighborhood sampler (when applicable). The appendix contains further implementation details. 4\n\n\nInductive learning on evolving graphs: Citation and Reddit data\n\nOur first two experiments are on classifying nodes in evolving information graphs, a task that is especially relevant to high-throughput production systems, which constantly encounter unseen data.\n\nCitation data. Our first task is predicting paper subject categories on a large citation dataset. We use an undirected citation graph dataset derived from the Thomson Reuters Web of Science Core Collection, corresponding to all papers in six biology-related fields for the years 2000-2005. The node labels for this dataset correspond to the six different field labels. In total, this is dataset contains 302,424 nodes with an average degree of 9.15. We train all the algorithms on the 2000-2004 data and use the 2005 data for testing (with 30% used for validation). For features, we used node degrees and processed the paper abstracts according Arora et al (2017)'s [2] sentence embedding approach, with 300-dimensional word vectors trained using the GenSim word2vec implementation [28].\n\nReddit data. In our second task, we predict which community different Reddit posts belong to. Reddit is a large online discussion forum where users post and comment on content in different topical communities. We constructed a graph dataset from Reddit posts made in the month of September, 2014. The node label in this case is the community, or \"subreddit\", that a post belongs to. We sampled  The first four columns of Table 1 summarize the performance of GraphSAGE as well as the baseline approaches on these two datasets. We find that GraphSAGE outperforms all the baselines by a significant margin, and the trainable, neural network aggregators provide significant gains compared to the GCN approach. For example, the unsupervised variant GraphSAGE-pool outperforms the concatenation of the DeepWalk embeddings and the raw features by 13.8% on the citation data and 29.1% on the Reddit data, while the supervised version provides a gain of 19.7% and 37.2%, respectively. Interestingly, the LSTM based aggregator shows strong performance, despite the fact that it is designed for sequential data and not unordered sets. Lastly, we see that the performance of unsupervised GraphSAGE is reasonably competitive with the fully supervised version, indicating that our framework can achieve strong performance without task-specific fine-tuning.\n\n\nGeneralizing across graphs: Protein-protein interactions\n\nWe now consider the task of generalizing across graphs, which requires learning about node roles rather than community structure. We classify protein roles-in terms of their cellular functions from gene ontology-in various protein-protein interaction (PPI) graphs, with each graph corresponding to a different human tissue [38]. We use positional gene sets, motif gene sets and immunological signatures as features and gene ontology sets as labels (121 in total), collected from the Molecular Signatures Database [31]. The average graph contains 3000 nodes, with an average degree of 28.8.\n\nWe train all algorithms on 20 graphs and then average prediction F1 scores on two test graphs (with two other graphs used for validation).\n\nThe final two columns of Table 1 summarize the accuracies of the various approaches on this data. Again we see that GraphSAGE significantly outperforms the baseline approaches, with the LSTM and max-pooling based aggregators providing substantial gains over the mean and GCN-based aggregators. For the GraphSAGE variants, we found that setting K = 2 provided a consistent boost in accuracy of around 10-15%, on average, compared to K = 1; however, increasing K beyond 2 gave marginal returns in performance (0-5%) while increasing the runtime by a prohibitively large factor of 10-100\u00d7, depending on the neighborhood sample size. We also found diminishing returns for sampling large neighborhoods (Figure 2.B). Thus, despite the higher variance induced by sub-sampling neighborhoods, GraphSAGE is still able to maintain strong predictive accuracy, while significantly improving the runtime.\n\n\nRuntime and parameter sensitivity\n\n\nTheoretical analysis\n\nIn this section, we probe the expressive capabilities of GraphSAGE in order to provide insight into how GraphSAGE can learn about graph structure, even though it is inherently based on features.\n\nAs a case-study, we consider whether GraphSAGE can learn to predict the clustering coefficient of a node, i.e. the proportion of triangles that are closed within the node's 1-hop neighborhood [35]. The clustering coefficient is a popular measure of how clustered a node's local neighborhood is, and it serves as a building block for many more complicated structural motifs [3]. We can show that Algorithm 1 is capable of approximating clustering coefficients to an arbitrary degree of precision: Theorem 1. Let x v \u2208 U, \u2200v \u2208 V denote the feature inputs for Algorithm 1 on graph G = (V, E), where U is any compact subset of R d . Suppose that there exists a fixed positive constant C \u2208 R + such that x v \u2212 x v 2 > C for all pairs of nodes. Then we have that \u2200 > 0 there exists a parameter setting \u0398 * for Algorithm 1 such that after K = 4 iterations\n|z v \u2212 c v | < , \u2200v \u2208 V,\nwhere z v \u2208 R are final output values generated by Algorithm 1 and c v are node clustering coefficients.\n\nTheorem 1 states that for any graph there exists a parameter setting for Algorithm 1 such that it can approximate clustering coefficients in that graph to an arbitrary precision, if the features for every node are distinct (and if the model is sufficiently high-dimensional). The full proof of Theorem 1 is in the Appendix. Note that as a corollary of Theorem 1, GraphSAGE can learn about local graph structure, even when the node feature inputs are sampled from an absolutely continuous random distribution (see the Appendix for details). The basic idea behind the proof is that if each node has a unique feature representation, then we can learn to map nodes to indicator vectors and identify node neighborhoods. The proof of Theorem 1 relies on some properties of the pooling aggregator, which also provides insight into why GraphSAGE-pool outperforms the GCN and mean-based aggregators.\n\n\nConclusion\n\nWe introduced a novel approach that allows embeddings to be efficiently generated for unseen nodes. GraphSAGE consistently outperforms state-of-the-art baselines, effectively trades off performance and runtime by sampling node neighborhoods, and our theoretical analysis provides insight into how our approach can learn about local graph structures. A number of extensions and potential improvements are possible, such as extending GraphSAGE to incorporate directed or multi-modal graphs. A particularly interesting direction for future work is exploring non-uniform neighborhood sampling functions, and perhaps even learning these functions as part of the GraphSAGE optimization.\n\n\nAppendices A Minibatch pseudocode\n\nIn order to use stochastic gradient descent, we adapt our algorithm to allow forward and backward propagation for minibatches of nodes and edges. Here we focus on the minibatch forward propagation algorithm, analogous to Algorithm 1. In the unsupervised version of GraphSAGE, the minibatch B contains nodes in that we want to generate representations for. In the forward propagation stage, the goal of the algorithm is to compute the representation of every node in the current batch B, as described in Algorithm 2.\n\nThe main idea is to sample all the nodes needed for the computation first, and then apply aggregation for each layer. Line 2-7 of Algorithm 2 corresponds to the sampling stage for all layers. For each node \nv \u2208 B 1 for v \u2208 B do 2 B K v \u2192 B for k = K \u2212 1...0 do 3 B k v \u2192 B k+1 v ; 4 for u \u2208 B k\u22121 v do 5 B k v \u2192 B k v \u222a N (u) 6 end 7 end 8 h 0 u \u2190 x v , \u2200v \u2208 B K v ; 9 for k = 1...K do 10 for u \u2208 B k v do 11 h k N (u) \u2190 AGGREGATE k ({h k\u22121 u , \u2200u \u2208 N (u)}); 12 h k u \u2190 \u03c3 W k \u00b7 CONCAT(h k\u22121 u , h k N (u) ) 13 end 14 h k u \u2190 h k u / h k u 2 , \u2200u \u2208 B k v 15 end 16 end 17 z v \u2190 h K v , \u2200v \u2208 V v \u2208 B, each set B k v , 0 \u2264 k \u2264 K,\ncontains nodes that are needed to compute the representation of node v at the k-th layer, which is computed by taking the union of B k\u22121 v and the sampled neighbors of nodes in B k\u22121 v . Line 9-15 corresponds to the aggregation stage, which is almost identical to the batch inference algorithm. Note that the representation at layer k of any node in set B k can be computed, because the representations at layer k \u2212 1 of the node and its sampled neighbors have already been computed in the previous loop. The algorithm thus avoids computing the representations for nodes that are not in the current minibatch and not used during the current iteration of stochastic gradient descent.\n\n\nB Additional Dataset Details\n\nIn this section, we provide some additional, relevant dataset details. The full PPI and Reddit datasets are available at: http://snap.stanford.edu/graphsage/. The Web of Science dataset (WoS) is licensed by Thomson Reuters and can be made available to groups with valid WoS licenses.\n\nReddit data To sample communities, we ranked communities by their total number of comments in 2014 and selected the communities with ranks [11,50] (inclusive). We omitted the largest communities because they are large, generic default communities that substantially skew the class distribution. We took the largest connected component of the graph defined over the union of these communities. We performed early validation experiments and model development on data from October and November, 2014.\n\nDetails on the source of the Reddit data are at: https://archive.org/details/ FullRedditSubmissionCorpus2006ThruAugust2015 and https://archive. org/details/2015_reddit_comments_corpus.\n\n\nWoS data\n\nWe selected the following subfields manually, based on them being of relatively equal size and all biology-related fields. We performed early validation and model development on the neuroscience subfield (code=RU, which is excluded from our final set). We did not run any experiments on any other subsets of the WoS data. We took the largest connected component of the graph defined over the union of these fields. PPI Tissue Data For training, we randomly selected 20 PPI networks that had at least 15,000 edges. For testing and validation, we selected 4 large networks (2 for validation, 2 for testing, each with at least 35,000 edges). All experiments for model design and development were performed on the same 2 validation networks, and we used the same random training set in all experiments.\n\nWe selected features that included at least 10% of the proteins that appear in any of the PPI graphs. Note that the feature data is very sparse for dataset (42% of nodes have no non-zero feature values), which makes leveraging neighborhood information critical.\n\n\nC Details on the Experimental Setup and Hyperparameter Tuning\n\nRandom walks for the unsupervised objective For all settings, we ran 50 random walks of length 5 from each node in order to obtain the pairs needed for the unsupervised loss (Equation 1). Our implementation of the random walks is in pure Python and is based directly on Python code provided by Perozzi et al [26].\n\nLogistic regression model For the feature only model and to make predictions on the embeddings output from the unsupervised models, we used the logistic SGDClassifier from the scikit-learn Python package [24], with all default settings. Note that this model is always optimized only on the training nodes and it is not fine-tuned on the embeddings that are generated for the test data.\n\nHyperparameter selection In all settings, we performed hyperparameter selection on the learning rate and the model dimension. With the exception of DeepWalk, we performed a parameter sweep on initial learning rates {0.01, 0.001, 0.0001} for the supervised models and {0.001, 0.0001, 0.00001} for the unsupervised models. When applicable, we tested a \"big\" and \"small\" version of each model, where we tried to keep the overall model sizes comparable. For the pooling aggregator, the \"big\" model had a pooling dimension of 1024, while the \"small\" model had a dimension of 512. For the LSTM aggregator, the \"big\" model had a hidden dimension of 256, while the \"small\" model had a hidden dimension of 128; note that the actual parameter count for the LSTM is roughly 4\u00d7 this number, due to weights for the different gates. In all experiments and for all models we specify the output dimension of the h k i vectors at every depth k of the recursion to be 256. All models use rectified linear units as a non-linear activation function. All the unsupervised GraphSAGE models and DeepWalk used 20 negative samples with context distribution smoothing over node degrees using a smoothing parameter of 0.75, following [10,20,26]. Initial experiments revealed that DeepWalk performed much better with large learning rates, so we swept over rates in the set {0.2, 0.4, 0.8}. For the supervised GraphSAGE methods, we ran 10 epochs for all models. All methods except DeepWalk use batch sizes of 512. We found that DeepWalk achieved faster wall-clock convergence with a smaller batch size of 64.\n\nHardware Except for DeepWalk, we ran experiments single a machine with 4 NVIDIA Titan X Pascal GPUs (12Gb of RAM at 10Gbps speed), 16 Intel Xeon CPUs (E5-2623 v4 @ 2.60GHz), and 256Gb of RAM. DeepWalk was faster on a CPU intensive machine with 144 Intel Xeon CPUs (E7-8890 v3 @ 2.50GHz) and 2Tb of RAM.\n\nNotes on the DeepWalk implementation Existing DeepWalk implementations [26,10] are simply wrappers around dedicated word2vec code, and they do not easily support embedding new nodes and other variations. Moreover, this makes it difficult to compare runtimes and other statistics for these approaches. For this reason, we reimplemented DeepWalk in pure TensorFlow, using the vector initializations etc that are described in the TensorFlow word2vec tutorial. 5 We found that DeepWalk was much slower to converge than the other methods, and since it is 2-5X faster at training, we gave it 5 passes over the random walk data, instead of one. To update the DeepWalk method on new data, we ran 50 random walks of length 5 (as described above) and performed updates on the embeddings for the new nodes while holding the already trained embeddings fixed. We also tested two variants, one where we restricted the sampled random walk \"context nodes\" to only be from the set of already trained nodes (which alleviates statistical drift) and an approach without this restriction. We always selected the better performing variant. Note that despite DeepWalk's poor performance on the inductive task, it is far more competitive when tested in the transductive setting, where it can be extensively trained on a single, fixed graph. (That said, Kipf et al [15] [16] found that GCN-based approach consistently outperformed DeepWalk, even in the transductive setting on link prediction, a task that theoretically favors DeepWalk.) We did observe DeepWalk's performance could improve with further training, and in some cases it could become competitive with the unsupervised GraphSAGE approaches (but not the supervised approaches) if we let it run for >1000\u00d7 longer than the other approaches (in terms of wall clock time for prediction on the test set); however, we did not deem this to be a meaningful comparison for the inductive task.\n\nNote that DeepWalk is also equivalent to the node2vec model [10] with p = q = 1.\n\nNotes on neighborhood sampling Due to the heavy-tailed nature of degree distributions we downsample the edges in all graphs before feeding them into the GraphSAGE algorithm. In particular, we subsample edges so that no node has degree larger than 100. Since we only sample at most 25 neighbors per node, this is a reasonable tradeoff. This downsampling allows us to store neighborhood information as dense adjacency lists, which drastically improves computational efficiency. For the Reddit data we performed this downsampling as an initial preprocessing step directly on the data files (since this drastically decreases the loading time for reading this data). We provide both the downsampled and full versions on the project website.\n\n\nD Alignment Issues and Orthogonal Invariance for DeepWalk and Related Approaches\n\nDeepWalk [26], node2vec [10], and other recent successful node embedding approaches employ objective functions of the form:\n\u03b1 i,j\u2208A f (z i z j ) + \u03b2 i,j\u2208B g(z i z j )(4)\nwhere f , g are smooth, continuous functions, z i are the node representations that are being directly optimized (i.e., via embedding look-ups), and A, B are sets of pairs of nodes. Note that in many cases, in the actual code implementations used by the authors of these approaches, nodes are associated with two unique embedding vectors and the arguments to the dot products in f and g are drawn for distinct embedding look-ups (e.g., [10,26]); however, this does not fundamentally alter the learning algorithm. The majority of approaches also normalize the learned embeddings to unit length, so we assume this post-processing as well.\n\nBy connection to word embedding approaches and the arguments of [18], these approaches can also be viewed as stochastic, implicit matrix factorizations where we are trying to learn a matrix Z \u2208 R |V|\u00d7d such that ZZ \u2248 M,\n\nwhere M is some matrix containing random walk statistics.\n\nAn important consequence of this structure is that the embeddings can be rotated by an arbitrary orthogonal matrix, without impacting the objective:\nZQ QZ = ZZ ,(6)\nwhere Q \u2208 R d\u00d7d is any orthogonal matrix. Since the embeddings are otherwise unconstrained and the only error signal comes from the orthogonally-invariant objective (4), the entire embedding space is free to arbitrarily rotate during training.\n\nTwo clear consequences of this are:\n\n1. Suppose we run an embedding approach based on (4) on two separate graphs A and B using the same output dimension. Without some explicit penalty enforcing alignment, the learned embeddings spaces for the two graphs will be arbitrarily rotated with respect to each other after training. Thus, for any node classification method that is trained on individual embeddings from graph A, inputting the embeddings from graph B will be essentially random. This fact is also simply true by virtue of the fact that the M matrices of these graphs are completely disjoint. Of course, if we had a way to match \"similar\" nodes between the graphs, then it could be possible to use an alignment procedure to share information between the graphs, such as the procedure proposed by [11] for aligning the output of word embedding algorithms. Investigating such alignment procedures is an interesting direction for future work; though these approaches will inevitably be slow run on new data, compared to approaches like GraphSAGE that can simply generate embeddings for new nodes without any additional training or alignment. 2. Suppose that we run an embedding approach based on (4) on graph C at time t and train a classifier on the learned embeddings. Then at time t + 1 we add more nodes to C and run a new round of SGD and update all embeddings. Two issues arise: First by analogy to point 1 above, if the new nodes are only connected to a very small number of the old nodes, then the embedding space for the new nodes can essentially become rotated with respect to the original embedding space. Moreover, if we update all embeddings during training (not just for the new nodes), as suggested by [26]'s streaming approach to DeepWalk, then the embedding space can arbitrarily rotate compared to the embedding space that we trained our classifier on, which only further exasperates the problem.\n\nNote that this rotational invariance is not problematic for tasks that only rely on pairwise node distances (e.g., link prediction via dot products). Moreover, some reasonable approaches to alleviate this issue of statistical drift are to (1) not update the already trained embeddings when optimizing the embeddings for new test nodes and (2) to only keep existing nodes as \"context nodes\" in the sampled random walks, i.e. to ensure that every dot-product in the skip-gram objective is the product of an already-trained node and a new/test node. We tried both of these approaches in this work and always selected the best performing DeepWalk variant.\n\nAlso note that empirically DeepWalk performs better on the citation data than the Reddit data (Section 4.1) because this statistical drift is worse in the Reddit data, compared to the citation graph.\n\nIn particular, the Reddit data has fewer edges from the test set to the train set, which help prevent mis-alignment: 96% of the 2005 citation links connect back to the 2000-2004 data, while only 73% of edges in the Reddit test set connect back to the train data.\n\n\nE Proof of Theorem 1\n\nTo prove Theorem 1, we first prove three lemmas:\n\n\u2022 Lemma 1 states that there exists a continuous function that is guaranteed to only be positive in closed balls around a fixed number of points, with some noise tolerance. \u2022 Lemma 2 notes that we can approximate the function in Lemma 1 to an arbitrary precision using a multilayer perceptron with a single hidden layer. \u2022 Lemma 3 builds off the preceding two lemmas to prove that the pooling architecture can learn to map nodes to unique indicator vectors, assuming that all the input feature vectors are sufficiently distinct.\n\nWe also rely on fact that the max-pooling operator (with at least one hidden layer) is capable of approximating any Hausdorff continuous, symmetric function to an arbitrary precision [27].\n\nWe note that all of the following are essentially identifiability arguments. We show that there exists a parameter setting for which Algorithm 1 can learn nodes clustering coefficients, which is non-obvious given that it operates by aggregating feature information. The efficient learnability of the functions described is the subject of future work. We also note that these proofs are conservative in the sense that clustering coefficients may be in fact identifiable in fewer iterations, or with less restrictions, than we impose. Moreover, due to our reliance on two universal approximation theorems [13,27], the required dimensionality is in principle O(|V|). We can provide a more informative bound on the required output dimension of some particular layers (e..g., Lemma 3); however, in the worst case this identifiability argument relies on having a dimension of O(|V|). It is worth noting, however, that Kipf et al's \"featureless\" GCN approach has parameter dimension O(|V|), so this requirement is not entirely unreasonable [15,16].\n\nFollowing Theorem 1, we let x v \u2208 U, \u2200v \u2208 V denote the feature inputs for Algorithm 1 on graph G = (V, E), where U is any compact subset of R d . Lemma 1. Let C \u2208 R + be a fixed positive constant. Then for any non-empty finite subset of nodes D \u2286 V, there exists a continuous function g : U \u2192 R such that\ng(x) > , if x \u2212 x v 2 = 0 for some v \u2208 D g(x) \u2264 \u2212 , if x \u2212 x v 2 > C, \u2200v \u2208 D,(7)\nwhere < 0.5 is a chosen error tolerance.\n\nProof. Many such functions exist. For concreteness, we provide one construction that satisfies these criteria. Let x \u2208 U denote an arbitrary input to g, let d v = x \u2212 x v 2 , \u2200v \u2208 D, and let g be defined as g(\nx) = v\u2208D g v (x) with g v (x) = 3|D| bd 2 v + 1 \u2212 2 (8) where b = 3|D|\u22121 C 2 > 0. By construction: 1. g v has a unique maximum of 3|D| \u2212 2 > 2|D| at d v = 0. 2. lim dv\u2192\u221e 3|D| bd 2 v +1 \u2212 2 = \u22122 3. 3|D| bd 2 v +1 \u2212 2 \u2264 \u2212 if d v \u2265 C.\nNote also that g is continuous on its domain (d v \u2208 R + ) since it is the sum of finite set of continuous functions. Moreover, we have that, for a given input x \u2208 U , if d v \u2265 C for all points v \u2208 D then g(x) = v\u2208D g v (a) \u2264 \u2212 by property 3 above. And, if d v = 0 for any v \u2208 D, then g is positive by construction, by properties 1 and 2, since in this case,\ng v (x) + v \u2208D\\v g v (x) \u2265 g v (x) \u2212 (|D| \u2212 1)2 > g v (x) \u2212 2(|D|) > 2(|D|) \u2212 2(|D|) > 0,\nso we know that g is positive whenever d v = 0 for any node and negative whenever d v > C for all nodes.\n\nLemma 2. The function g : U \u2192 R can be approximated to an arbitrary degree of precision by standard multilayer perceptron (MLP) with least one hidden layer and a non-constant monotonically increasing activation function (e.g., a rectified linear unit). In precise terms, if we let f \u03b8\u03c3 denote this MLP and \u03b8 \u03c3 its parameters, we have that \u2200 , \u2203\u03b8 \u03c3 such that |f \u03b8\u03c3 (x) \u2212 g(x)| < |, \u2200x \u2208 U .\n\nProof. This is a direct consequence of Theorem 2 in [13].\n\nLemma 3. Let A be the adjacency matrix of G, let N 3 (v) denote the 3-hop neighborhood of a node, v, and define \u03c7(G 3 ) as the chromatic number of the graph with adjacency matrix A 3 (ignoring self-loops). Suppose that there exists a fixed positive constant C \u2208 R + such that x v \u2212 x v 2 > C for all pairs of nodes. Then we have that there exists a parameter setting for Algorithm 1, using a pooling aggregator at depth k = 1, where this pooling aggregator has \u2265 2 hidden layers with rectified non-linear units, such that\nh 1 v = h 1 v , \u2200(v, v ) \u2208 {(v, v ) : \u2203u \u2208 V, v, v \u2208 N 3 (u)}, h 1 v , h 1 v \u2208 E \u03c7(G 3 ) I where E \u03c7(G 3 ) I\nis the set of one-hot indicator vectors of dimension \u03c7(G 3 ).\n\nProof. By the definition of the chromatic number, we know that we can label every node in V using \u03c7(G 3 ) unique colors, such that no two nodes that co-occur in any node's 3-hop neighborhood are assigned the same color. Thus, with exactly \u03c7(G 3 ) dimensions we can assign a unique one-hot indicator vector to every node, where no two nodes that co-occur in any 3-hop neighborhood have the same vector. In other words, each color defines a subset of nodes D \u2286 V and this subset of nodes can all be mapped to the same indicator vector without introducing conflicts.\n\nBy Lemma 1 and 2 and the assumption that x v \u2212 x v 2 > C for all pairs of nodes, we can choose an < 0.5 and there exists a single-layer MLP, f \u03b8\u03c3 , such that for any subset of nodes D \u2286 V:\nf \u03b8\u03c3 (x v ) > 0, \u2200v \u2208 D f \u03b8\u03c3 (x v ) < 0, \u2200v \u2208 V \\ D.(9)\nBy making this MLP one layer deeper and specifically using a rectified linear activation function, we can return a positive value only for nodes in the subset D and zero otherwise, and, since we normalize after applying the aggregator layer, this single positive value can be mapped to an indicator vector. Moreover, we can create \u03c7(G 3 ) such MLPs, where each MLP corresponds to a different color/subset; equivalently each MLP corresponds to a different max-pooling dimension in equation 3 of the main text.\n\nWe now restate Theorem 1 and provide a proof.\nTheorem 1. Let x v \u2208 R d , \u2200v \u2208 V denote the feature inputs for Algorithm 1 on graph G = (V, E),\nwhere U is any compact subset of R d . Suppose that there exists a fixed positive constant C \u2208 R + such that x v \u2212 x v 2 > C for all pairs of nodes. Then we have that \u2200 > 0 there exists a parameter setting \u0398 * for Algorithm 1 such that after K = 4 iterations\n|z v \u2212 c v | < , \u2200v \u2208 V,\nwhere z v \u2208 R are final output values generated by Algorithm 1 and c v are node clustering coefficients, as defined in [35].\n\nProof. Without loss of generality, we describe how to compute the clustering coefficient for an arbitrary node v. For notational convenience we use \u2295 to denote vector concatenation and d v to denote the degree of node v. This proof requires 4 iterations of Algorithm 1, where we use the pooling aggregator at all depths. For clarity and we ignore issues related to vector normalization and we use the fact that the pooling aggregator can approximate any Hausdorff continuous function to an arbitrary precision [27]. Note that we can always account for normalization constants (line 7 in Algorithm 1) by having aggregators prepend a unit value to all output representations; the normalization constant can then be recovered at later layers by taking the inverse of this prepended value. Note also that almost certainly exist settings where the symmetric functions described below can be computed exactly by the pooling aggregator (or a variant of it), but the symmetric universal approximation theorem of [27] along with Lipschitz continuity arguments suffice for the purposes of proving identifiability of clustering coefficients (up to an arbitrary precision). In particular, the functions described below, that we need approximate to compute clustering coefficients, are all Lipschitz continuous on their domains (assuming we only run on nodes with positive degrees) so the errors introduced by approximation remain bounded by fixed constants (that can be made arbitrarily small).\n\nWe assume that the weight matrices, W 1 , W 2 at depths k = 2 and k = 3 are the identity, and that all non-linearities are rectified linear units. In addition, for the final iteration (i.e, k = 4) we completely ignore neighborhood information and simply treat this layers as an MLP with a single hidden layer. Theorem 1 can be equivalently stated as requiring K = 3 iterations of Algorithm 1, with the representations then being fed to a single-layer MLP.\n\nBy Lemma 3, we can assume that at depth k = 1 all nodes in v's 3-hop neighborhood have unique, one-hot indicator vectors, h 1 v \u2208 E I . Thus, at depth k = 2 in Algorithm 1, suppose that we sum the unnormalized representations of the neighboring nodes (which is possible by Lemma 4). Then without loss of generality, we will have that h 2 v = h 1 v \u2295 A v where A is the adjacency matrix of the subgraph containing all nodes connected to v in G 3 and A v is the row of the adjacency matrix corresponding to v. Then, at depth k = 3, again assume that we sum the neighboring representations (with the weight matrices as the identity), then we will have that\nh 3 v = x v \u2295 A v \u2295 \uf8eb \uf8ed v\u2208N (v) x v \u2295 A v \uf8f6 \uf8f8 .(10)\nLetting m denote the dimensionality of the h 1 v vectors (i.e., m \u2261 \u03c7(G 3 ) from Lemma 3) and using square brackets to denote vector indexing, we can observe that \nb c \u2212 d v ) (d v )(d v \u2212 1) = 2|{e v,v : v, v \u2208 N (v), e v,v \u2208 E}| (d v )(d v \u2212 1) (11) = c v ,(12)\nand since this is a continuous function of h 3 v , we can approximate it to an arbitrary precision with a single-layer MLP (or equivalently, one more iteration of Algorithm 1, ignoring neighborhood information). Again this last step follows directly from [13].\n\nCorollary 2. Suppose we sample nodes features from any probability distribution \u00b5 over x \u2208 U , where \u00b5 is absolutely continuous with respect to the Lebesgue measure. Then the conditions of Theorem 1 are almost surely satisfied with feature inputs x v \u223c \u00b5.\n\nCorollary 2 is a direct consequence of Theorem 1 and the fact that, for any probability distribution that is absolutely continuous w.r.t. the Lebesgue measure, the probability of sampling two identical points is zero. Empirically, we found that GraphSAGE-pool was in fact capable of maintaining modest performance by leveraging graph structure, even with completely random feature inputs (see Figure 3 below). However, the performance GraphSAGE-GCN was not so robust, which makes intuitive sense given that the Lemmas 1, 2, and 3 rely directly on the universal expressive capability of the pooling aggregator.\n\nFinally, we note that Theorem 1 and Corollary 2 are expressed with respect to a particular given graph and are thus somewhat transductive. For the inductive setting, we can state Corollary 3. Suppose that for all graphs G = (V, E) belonging to some class of graphs G * , we have that \u2203k, d \u2265 0, k, d \u2208 Z such that\nh k v = h k v , \u2200(v, v ) \u2208 {(v, v ) : \u2203u \u2208 V, v, v \u2208 N 3 (u)}, h k v , h k v \u2208 E d I ,\nthen we can approximate clustering coefficients to an arbitrary epsilon after K = k + 4 iterations of Algorithm 1.\n\nCorollary 3 simply states that if after k iterations of Algorithm 1, we can learn to uniquely identify nodes for a class of graphs, then we can also approximate clustering coefficients to an arbitrary precision for this class of graphs. Figure 3: Accuracy (in F1-score) for different approaches on the citation data as the feature matrix is incrementally replaced with random Gaussian noise.\n\nFigure 1 :\n1Visual illustration of the GraphSAGE sample and aggregate approach.\n\nFigure 2 :\n2A: Timing experiments on Reddit data, with training batches of size 512 and inference on the full test set (79,534 nodes). B: Model performance with respect to the size of the sampled neighborhood, where the \"neighborhood sample size\" refers to the number of neighbors sampled at each depth for K = 2 with S 1 = S 2 (on the citation data using GraphSAGE-mean). 50 large communities and built a post-to-post graph, connecting posts if the same user comments on both. In total this dataset contains 232,965 posts with an average degree of 492. We use the first 20 days for training and the remaining days for testing (with 30% used for validation). For features, we use off-the-shelf 300-dimensional GloVe CommonCrawl word vectors[25]; for each post, we concatenated (i) the average embedding of the post title, (ii) the average embedding of all the post's comments (iii) the post's score, and (iv) the number of comments made on the post.\n\nFigure 2 .\n2A summarizes the training and test runtimes for the different approaches. The training time for the methods are comparable (with GraphSAGE-LSTM being the slowest). However, the need to sample new random walks and run new rounds of SGD to embed unseen nodes makes DeepWalk 100-500\u00d7 slower at test time.\n\n\u2022\u2022\nImmunology Endocrinology and Metabolism (code: IA, number of documents: 52225). \u2022 Cell Biology (code: DR, number of documents: 84231) \u2022 Biology (other) (code: CU, number of documents: 13988)\n\n\n\u2022 a \u2261 h 3 v [0 : m] is v's one-hot indicator vector. \u2022 b \u2261 h 3 v [m : 2m] is v's row in the adjacency matrix, A. \u2022 c \u2261 h 3 v [3m : 4m] isthe sum of the adjacency rows of v's neighbors. Thus, we have that b c is the number of edges in the subgraph containing only v and it's immediate neighbors and m i=0 b[i] = d v . Finally we can compute 2(\n\nAlgorithm 1 :\n1GraphSAGE embedding generation (i.e., forward propagation) algorithm Input : Graph G(V, E); input features {x v , \u2200v \u2208 V}; depth K; weight matrices {W k , \u2200k \u2208 [1, K]}; non-linearity \u03c3; differentiable aggregator functions {AGGREGATE k , \u2200k \u2208 [1, K]}; neighborhood function N :\n\nTable 1 :\n1Prediction results for the three datasets (micro-averaged F1 scores). Results for unsupervised and fully supervised GraphSAGE are shown. Analogous trends hold for macro-averaged scores. Name Unsup. F1 Sup. F1 Unsup. F1 Sup. F1 Unsup. F1 Sup. F1Citation \nReddit \nPPI \n\nRandom \n0.206 \n0.206 \n0.043 \n0.042 \n0.396 \n0.396 \nRaw features \n0.575 \n0.575 \n0.585 \n0.585 \n0.422 \n0.422 \nDeepWalk \n0.565 \n0.565 \n0.324 \n0.324 \n-\n-\nDeepWalk + features \n0.701 \n0.701 \n0.691 \n0.691 \n-\n-\nGraphSAGE-GCN \n0.742 \n0.772 \n0.908 \n0.930 \n0.465 \n0.500 \nGraphSAGE-mean \n0.778 \n0.820 \n0.897 \n0.950 \n0.486 \n0.598 \nGraphSAGE-LSTM \n0.788 \n0.832 \n0.907 \n0.954 \n0.482 \n0.612 \nGraphSAGE-pool \n0.798 \n0.839 \n0.892 \n0.948 \n0.502 \n0.600 \n\n% gain over feat. \n39% \n46% \n55% \n63% \n19% \n45% \n\n\n\nAlgorithm 2 :\n2GraphSAGE minibatch forward propagation algorithm Input : Graph G(V, E); input features {x v , \u2200v \u2208 B}; depth K; weight matrices {W k , \u2200k \u2208 [1, K]}; non-linearity \u03c3; differentiable aggregator functions {AGGREGATE k , \u2200k \u2208 [1, K]} Output : Vector representations z v for all\nExploring non-uniform samplers is an important direction for future work.\nCode and links to the datasets: http://snap.stanford.edu/graphsage/\nhttps://github.com/tensorflow/models/blob/master/tutorials/embedding/ word2vec.py\nAcknowledgments The authors thank Austin Benson, Aditya Grover, Bryan He, Dan Jurafsky, Alex Ratner, and Daniel Selsam for their helpful discussions and comments on early drafts. This research has been supported in part by NSF IIS-1149837, DARPA SIMPLEX, Stanford Data Science Initiative, and Chan Zuckerberg Biohub. W.L.H. was also supported by the SAP Stanford Graduate Fellowship and an NSERC PGS-D grant. The views and conclusions expressed in this material are those of the authors and should not be interpreted as necessarily representing the official policies or endorsements, either expressed or implied, of the above funding agencies, corporations, or the U.S. and Canadian governments.\nM Abadi, A Agarwal, P Barham, E Brevdo, Z Chen, C Citro, G S Corrado, A Davis, J Dean, M Devin, arXiv:1603.04467Large-scale machine learning on heterogeneous distributed systems. arXiv preprintM. Abadi, A. Agarwal, P. Barham, E. Brevdo, Z. Chen, C. Citro, G. S. Corrado, A. Davis, J. Dean, M. Devin, et al. Tensorflow: Large-scale machine learning on heterogeneous distributed systems. arXiv preprint arXiv:1603.04467, 2016.\n\nA simple but tough-to-beat baseline for sentence embeddings. S Arora, Y Liang, T Ma, S. Arora, Y. Liang, and T. Ma. A simple but tough-to-beat baseline for sentence embeddings. In ICLR, 2017.\n\nHigher-order organization of complex networks. A R Benson, D F Gleich, J Leskovec, Science. 3536295A. R. Benson, D. F. Gleich, and J. Leskovec. Higher-order organization of complex networks. Science, 353(6295):163-166, 2016.\n\nSpectral networks and locally connected networks on graphs. J Bruna, W Zaremba, A Szlam, Y Lecun, ICLR. J. Bruna, W. Zaremba, A. Szlam, and Y. LeCun. Spectral networks and locally connected networks on graphs. In ICLR, 2014.\n\nGrarep: Learning graph representations with global structural information. S Cao, W Lu, Q Xu, KDD. S. Cao, W. Lu, and Q. Xu. Grarep: Learning graph representations with global structural information. In KDD, 2015.\n\nDiscriminative embeddings of latent variable models for structured data. H Dai, B Dai, L Song, ICML. H. Dai, B. Dai, and L. Song. Discriminative embeddings of latent variable models for structured data. In ICML, 2016.\n\nConvolutional neural networks on graphs with fast localized spectral filtering. M Defferrard, X Bresson, P Vandergheynst, NIPS. M. Defferrard, X. Bresson, and P. Vandergheynst. Convolutional neural networks on graphs with fast localized spectral filtering. In NIPS, 2016.\n\nConvolutional networks on graphs for learning molecular fingerprints. D K Duvenaud, D Maclaurin, J Iparraguirre, R Bombarell, T Hirzel, A Aspuru-Guzik, R P Adams, NIPS. D. K. Duvenaud, D. Maclaurin, J. Iparraguirre, R. Bombarell, T. Hirzel, A. Aspuru-Guzik, and R. P. Adams. Convolutional networks on graphs for learning molecular fingerprints. In NIPS, 2015.\n\nA new model for learning in graph domains. M Gori, G Monfardini, F Scarselli, IEEE International Joint Conference on Neural Networks. 2M. Gori, G. Monfardini, and F. Scarselli. A new model for learning in graph domains. In IEEE International Joint Conference on Neural Networks, volume 2, pages 729-734, 2005.\n\nnode2vec: Scalable feature learning for networks. A Grover, J Leskovec, KDD. A. Grover and J. Leskovec. node2vec: Scalable feature learning for networks. In KDD, 2016.\n\nDiachronic word embeddings reveal statistical laws of semantic change. W L Hamilton, J Leskovec, D Jurafsky, ACL. W. L. Hamilton, J. Leskovec, and D. Jurafsky. Diachronic word embeddings reveal statistical laws of semantic change. In ACL, 2016.\n\nLong short-term memory. S Hochreiter, J Schmidhuber, Neural Computation. 98S. Hochreiter and J. Schmidhuber. Long short-term memory. Neural Computation, 9(8):1735- 1780, 1997.\n\nApproximation capabilities of multilayer feedforward networks. K Hornik, Neural Networks. 42K. Hornik. Approximation capabilities of multilayer feedforward networks. Neural Networks, 4(2):251-257, 1991.\n\nAdam: A method for stochastic optimization. D Kingma, J Ba, ICLR. D. Kingma and J. Ba. Adam: A method for stochastic optimization. In ICLR, 2015.\n\nSemi-supervised classification with graph convolutional networks. T N Kipf, M Welling, ICLR. T. N. Kipf and M. Welling. Semi-supervised classification with graph convolutional networks. In ICLR, 2016.\n\nVariational graph auto-encoders. T N Kipf, M Welling, NIPS Workshop on Bayesian Deep Learning. T. N. Kipf and M. Welling. Variational graph auto-encoders. In NIPS Workshop on Bayesian Deep Learning, 2016.\n\nMultidimensional scaling by optimizing goodness of fit to a nonmetric hypothesis. J B , Psychometrika. 291J. B. Kruskal. Multidimensional scaling by optimizing goodness of fit to a nonmetric hypothesis. Psychometrika, 29(1):1-27, 1964.\n\nNeural word embedding as implicit matrix factorization. O Levy, Y Goldberg, NIPS. O. Levy and Y. Goldberg. Neural word embedding as implicit matrix factorization. In NIPS, 2014.\n\nGated graph sequence neural networks. Y Li, D Tarlow, M Brockschmidt, R Zemel, ICLR. Y. Li, D. Tarlow, M. Brockschmidt, and R. Zemel. Gated graph sequence neural networks. In ICLR, 2015.\n\nDistributed representations of words and phrases and their compositionality. T Mikolov, I Sutskever, K Chen, G S Corrado, J Dean, NIPS. T. Mikolov, I. Sutskever, K. Chen, G. S. Corrado, and J. Dean. Distributed representations of words and phrases and their compositionality. In NIPS, 2013.\n\nOn spectral clustering: Analysis and an algorithm. A Y Ng, M I Jordan, Y Weiss, NIPS. A. Y. Ng, M. I. Jordan, Y. Weiss, et al. On spectral clustering: Analysis and an algorithm. In NIPS, 2001.\n\nLearning convolutional neural networks for graphs. M Niepert, M Ahmed, K Kutzkov, ICML. M. Niepert, M. Ahmed, and K. Kutzkov. Learning convolutional neural networks for graphs. In ICML, 2016.\n\nThe pagerank citation ranking: Bringing order to the web. L Page, S Brin, R Motwani, T Winograd, Stanford InfoLabTechnical reportL. Page, S. Brin, R. Motwani, and T. Winograd. The pagerank citation ranking: Bringing order to the web. Technical report, Stanford InfoLab, 1999.\n\nScikit-learn: Machine learning in Python. F Pedregosa, G Varoquaux, A Gramfort, V Michel, B Thirion, O Grisel, M Blondel, P Prettenhofer, R Weiss, V Dubourg, J Vanderplas, A Passos, D Cournapeau, M Brucher, M Perrot, E Duchesnay, Journal of Machine Learning Research. 12F. Pedregosa, G. Varoquaux, A. Gramfort, V. Michel, B. Thirion, O. Grisel, M. Blondel, P. Prettenhofer, R. Weiss, V. Dubourg, J. Vanderplas, A. Passos, D. Cournapeau, M. Brucher, M. Perrot, and E. Duchesnay. Scikit-learn: Machine learning in Python. Journal of Machine Learning Research, 12:2825-2830, 2011.\n\nGlove: Global vectors for word representation. J Pennington, R Socher, C D Manning, EMNLP. J. Pennington, R. Socher, and C. D. Manning. Glove: Global vectors for word representation. In EMNLP, 2014.\n\nDeepwalk: Online learning of social representations. B Perozzi, R Al-Rfou, S Skiena, KDD. B. Perozzi, R. Al-Rfou, and S. Skiena. Deepwalk: Online learning of social representations. In KDD, 2014.\n\nPointnet: Deep learning on point sets for 3d classification and segmentation. C R Qi, H Su, K Mo, L J Guibas, CVPR. C. R. Qi, H. Su, K. Mo, and L. J. Guibas. Pointnet: Deep learning on point sets for 3d classification and segmentation. In CVPR, 2017.\n\nSoftware Framework for Topic Modelling with Large Corpora. R \u0158eh\u016f\u0159ek, P Sojka, LREC. R.\u0158eh\u016f\u0159ek and P. Sojka. Software Framework for Topic Modelling with Large Corpora. In LREC, 2010.\n\nThe graph neural network model. F Scarselli, M Gori, A C Tsoi, M Hagenbuchner, G Monfardini, IEEE Transactions on Neural Networks. 201F. Scarselli, M. Gori, A. C. Tsoi, M. Hagenbuchner, and G. Monfardini. The graph neural network model. IEEE Transactions on Neural Networks, 20(1):61-80, 2009.\n\nWeisfeilerlehman graph kernels. N Shervashidze, P Schweitzer, E J Leeuwen, K Mehlhorn, K M Borgwardt, Journal of Machine Learning Research. 12N. Shervashidze, P. Schweitzer, E. J. v. Leeuwen, K. Mehlhorn, and K. M. Borgwardt. Weisfeiler- lehman graph kernels. Journal of Machine Learning Research, 12:2539-2561, 2011.\n\nGene set enrichment analysis: a knowledge-based approach for interpreting genome-wide expression profiles. A Subramanian, P Tamayo, V K Mootha, S Mukherjee, B L Ebert, M A Gillette, A Paulovich, S L Pomeroy, T R Golub, E S Lander, Proceedings of the National Academy of Sciences. 10243A. Subramanian, P. Tamayo, V. K. Mootha, S. Mukherjee, B. L. Ebert, M. A. Gillette, A. Paulovich, S. L. Pomeroy, T. R. Golub, E. S. Lander, et al. Gene set enrichment analysis: a knowledge-based approach for interpreting genome-wide expression profiles. Proceedings of the National Academy of Sciences, 102(43):15545-15550, 2005.\n\nLine: Large-scale information network embedding. J Tang, M Qu, M Wang, M Zhang, J Yan, Q Mei, WWWJ. Tang, M. Qu, M. Wang, M. Zhang, J. Yan, and Q. Mei. Line: Large-scale information network embedding. In WWW, 2015.\n\nStructural deep network embedding. D Wang, P Cui, W Zhu, KDD. D. Wang, P. Cui, and W. Zhu. Structural deep network embedding. In KDD, 2016.\n\nCommunity preserving network embedding. X Wang, P Cui, J Wang, J Pei, W Zhu, S Yang, AAAI. X. Wang, P. Cui, J. Wang, J. Pei, W. Zhu, and S. Yang. Community preserving network embedding. In AAAI, 2017.\n\nCollective dynamics of 'small-world' networks. D J Watts, S H Strogatz, Nature. 3936684D. J. Watts and S. H. Strogatz. Collective dynamics of 'small-world' networks. Nature, 393(6684):440-442, 1998.\n\nEmbedding identity and interest for social networks. L Xu, X Wei, J Cao, P S Yu, WWWL. Xu, X. Wei, J. Cao, and P. S. Yu. Embedding identity and interest for social networks. In WWW, 2017.\n\nRevisiting semi-supervised learning with graph embeddings. Z Yang, W Cohen, R Salakhutdinov, ICML. Z. Yang, W. Cohen, and R. Salakhutdinov. Revisiting semi-supervised learning with graph embeddings. In ICML, 2016.\n\nPredicting multicellular function through multi-layer tissue networks. M Zitnik, J Leskovec, Bioinformatics. M. Zitnik and J. Leskovec. Predicting multicellular function through multi-layer tissue networks. Bioinformatics, 2017.\n", "annotations": {"author": "[{\"end\":141,\"start\":53},{\"end\":241,\"start\":142},{\"end\":325,\"start\":242}]", "publisher": null, "author_last_name": "[{\"end\":71,\"start\":63},{\"end\":150,\"start\":146},{\"end\":255,\"start\":247}]", "author_first_name": "[{\"end\":60,\"start\":53},{\"end\":62,\"start\":61},{\"end\":145,\"start\":142},{\"end\":246,\"start\":242}]", "author_affiliation": "[{\"end\":140,\"start\":73},{\"end\":240,\"start\":173},{\"end\":324,\"start\":257}]", "title": "[{\"end\":50,\"start\":1},{\"end\":375,\"start\":326}]", "venue": null, "abstract": "[{\"end\":1474,\"start\":377}]", "bib_ref": "[{\"attributes\":{\"ref_id\":\"b4\"},\"end\":1659,\"start\":1656},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":1662,\"start\":1659},{\"attributes\":{\"ref_id\":\"b25\"},\"end\":1665,\"start\":1662},{\"attributes\":{\"ref_id\":\"b31\"},\"end\":1668,\"start\":1665},{\"attributes\":{\"ref_id\":\"b32\"},\"end\":1671,\"start\":1668},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":2029,\"start\":2025},{\"attributes\":{\"ref_id\":\"b25\"},\"end\":2032,\"start\":2029},{\"attributes\":{\"ref_id\":\"b31\"},\"end\":2035,\"start\":2032},{\"attributes\":{\"ref_id\":\"b4\"},\"end\":3570,\"start\":3567},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":3573,\"start\":3570},{\"attributes\":{\"ref_id\":\"b20\"},\"end\":3576,\"start\":3573},{\"attributes\":{\"ref_id\":\"b25\"},\"end\":3579,\"start\":3576},{\"attributes\":{\"ref_id\":\"b31\"},\"end\":3582,\"start\":3579},{\"attributes\":{\"ref_id\":\"b32\"},\"end\":3585,\"start\":3582},{\"attributes\":{\"ref_id\":\"b33\"},\"end\":3588,\"start\":3585},{\"attributes\":{\"ref_id\":\"b35\"},\"end\":3591,\"start\":3588},{\"attributes\":{\"ref_id\":\"b25\"},\"end\":3672,\"start\":3668},{\"attributes\":{\"ref_id\":\"b14\"},\"end\":3967,\"start\":3963},{\"attributes\":{\"ref_id\":\"b14\"},\"end\":4086,\"start\":4082},{\"attributes\":{\"ref_id\":\"b15\"},\"end\":4089,\"start\":4086},{\"attributes\":{\"ref_id\":\"b25\"},\"end\":6666,\"start\":6662},{\"attributes\":{\"ref_id\":\"b14\"},\"end\":6911,\"start\":6907},{\"attributes\":{\"ref_id\":\"b4\"},\"end\":7634,\"start\":7631},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":7637,\"start\":7634},{\"attributes\":{\"ref_id\":\"b25\"},\"end\":7640,\"start\":7637},{\"attributes\":{\"ref_id\":\"b31\"},\"end\":7643,\"start\":7640},{\"attributes\":{\"ref_id\":\"b32\"},\"end\":7646,\"start\":7643},{\"attributes\":{\"ref_id\":\"b20\"},\"end\":7746,\"start\":7742},{\"attributes\":{\"ref_id\":\"b16\"},\"end\":7778,\"start\":7774},{\"attributes\":{\"ref_id\":\"b22\"},\"end\":7818,\"start\":7814},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":8128,\"start\":8124},{\"attributes\":{\"ref_id\":\"b25\"},\"end\":8131,\"start\":8128},{\"attributes\":{\"ref_id\":\"b31\"},\"end\":8134,\"start\":8131},{\"attributes\":{\"ref_id\":\"b32\"},\"end\":8137,\"start\":8134},{\"attributes\":{\"ref_id\":\"b36\"},\"end\":8423,\"start\":8419},{\"attributes\":{\"ref_id\":\"b29\"},\"end\":9085,\"start\":9081},{\"attributes\":{\"ref_id\":\"b5\"},\"end\":9219,\"start\":9216},{\"attributes\":{\"ref_id\":\"b8\"},\"end\":9221,\"start\":9219},{\"attributes\":{\"ref_id\":\"b18\"},\"end\":9224,\"start\":9221},{\"attributes\":{\"ref_id\":\"b28\"},\"end\":9227,\"start\":9224},{\"attributes\":{\"ref_id\":\"b3\"},\"end\":9628,\"start\":9625},{\"attributes\":{\"ref_id\":\"b7\"},\"end\":9630,\"start\":9628},{\"attributes\":{\"ref_id\":\"b6\"},\"end\":9632,\"start\":9630},{\"attributes\":{\"ref_id\":\"b14\"},\"end\":9635,\"start\":9632},{\"attributes\":{\"ref_id\":\"b21\"},\"end\":9638,\"start\":9635},{\"attributes\":{\"ref_id\":\"b3\"},\"end\":9760,\"start\":9757},{\"attributes\":{\"ref_id\":\"b7\"},\"end\":9762,\"start\":9760},{\"attributes\":{\"ref_id\":\"b6\"},\"end\":9764,\"start\":9762},{\"attributes\":{\"ref_id\":\"b21\"},\"end\":9767,\"start\":9764},{\"attributes\":{\"ref_id\":\"b14\"},\"end\":9882,\"start\":9878},{\"attributes\":{\"ref_id\":\"b15\"},\"end\":9885,\"start\":9882},{\"attributes\":{\"ref_id\":\"b14\"},\"end\":9918,\"start\":9914},{\"attributes\":{\"ref_id\":\"b29\"},\"end\":14379,\"start\":14375},{\"attributes\":{\"ref_id\":\"b29\"},\"end\":14629,\"start\":14625},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":15268,\"start\":15267},{\"attributes\":{\"ref_id\":\"b14\"},\"end\":18207,\"start\":18203},{\"attributes\":{\"ref_id\":\"b14\"},\"end\":18543,\"start\":18539},{\"attributes\":{\"ref_id\":\"b11\"},\"end\":18640,\"start\":18636},{\"attributes\":{\"ref_id\":\"b14\"},\"end\":19516,\"start\":19512},{\"attributes\":{\"ref_id\":\"b26\"},\"end\":19909,\"start\":19905},{\"attributes\":{\"ref_id\":\"b25\"},\"end\":21095,\"start\":21091},{\"attributes\":{\"ref_id\":\"b14\"},\"end\":21435,\"start\":21431},{\"attributes\":{\"ref_id\":\"b25\"},\"end\":21949,\"start\":21945},{\"attributes\":{\"ref_id\":\"b0\"},\"end\":22350,\"start\":22347},{\"attributes\":{\"ref_id\":\"b13\"},\"end\":22379,\"start\":22375},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":23629,\"start\":23626},{\"attributes\":{\"ref_id\":\"b27\"},\"end\":23746,\"start\":23742},{\"attributes\":{\"ref_id\":\"b37\"},\"end\":25479,\"start\":25475},{\"attributes\":{\"ref_id\":\"b30\"},\"end\":25669,\"start\":25665},{\"attributes\":{\"ref_id\":\"b34\"},\"end\":27226,\"start\":27222},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":27406,\"start\":27403},{\"attributes\":{\"ref_id\":\"b10\"},\"end\":31920,\"start\":31916},{\"end\":31923,\"start\":31920},{\"attributes\":{\"ref_id\":\"b25\"},\"end\":33912,\"start\":33908},{\"attributes\":{\"ref_id\":\"b23\"},\"end\":34123,\"start\":34119},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":35513,\"start\":35509},{\"attributes\":{\"ref_id\":\"b19\"},\"end\":35516,\"start\":35513},{\"attributes\":{\"ref_id\":\"b25\"},\"end\":35519,\"start\":35516},{\"attributes\":{\"ref_id\":\"b25\"},\"end\":36262,\"start\":36258},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":36265,\"start\":36262},{\"attributes\":{\"ref_id\":\"b4\"},\"end\":36645,\"start\":36644},{\"attributes\":{\"ref_id\":\"b14\"},\"end\":37531,\"start\":37527},{\"attributes\":{\"ref_id\":\"b15\"},\"end\":37536,\"start\":37532},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":38172,\"start\":38168},{\"attributes\":{\"ref_id\":\"b25\"},\"end\":39023,\"start\":39019},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":39038,\"start\":39034},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":39620,\"start\":39616},{\"attributes\":{\"ref_id\":\"b25\"},\"end\":39623,\"start\":39620},{\"attributes\":{\"ref_id\":\"b17\"},\"end\":39886,\"start\":39882},{\"attributes\":{\"ref_id\":\"b10\"},\"end\":41315,\"start\":41311},{\"attributes\":{\"ref_id\":\"b25\"},\"end\":42233,\"start\":42229},{\"attributes\":{\"ref_id\":\"b26\"},\"end\":44335,\"start\":44331},{\"attributes\":{\"ref_id\":\"b12\"},\"end\":44945,\"start\":44941},{\"attributes\":{\"ref_id\":\"b26\"},\"end\":44948,\"start\":44945},{\"attributes\":{\"ref_id\":\"b14\"},\"end\":45375,\"start\":45371},{\"attributes\":{\"ref_id\":\"b15\"},\"end\":45378,\"start\":45375},{\"attributes\":{\"ref_id\":\"b12\"},\"end\":47252,\"start\":47248},{\"attributes\":{\"ref_id\":\"b34\"},\"end\":49819,\"start\":49815},{\"attributes\":{\"ref_id\":\"b26\"},\"end\":50336,\"start\":50332},{\"attributes\":{\"ref_id\":\"b26\"},\"end\":50830,\"start\":50826},{\"end\":52044,\"start\":52036},{\"attributes\":{\"ref_id\":\"b12\"},\"end\":52992,\"start\":52988},{\"attributes\":{\"ref_id\":\"b24\"},\"end\":55598,\"start\":55594}]", "figure": "[{\"attributes\":{\"id\":\"fig_0\"},\"end\":54852,\"start\":54772},{\"attributes\":{\"id\":\"fig_1\"},\"end\":55803,\"start\":54853},{\"attributes\":{\"id\":\"fig_2\"},\"end\":56118,\"start\":55804},{\"attributes\":{\"id\":\"fig_3\"},\"end\":56313,\"start\":56119},{\"attributes\":{\"id\":\"fig_4\"},\"end\":56658,\"start\":56314},{\"attributes\":{\"id\":\"tab_0\",\"type\":\"table\"},\"end\":56951,\"start\":56659},{\"attributes\":{\"id\":\"tab_1\",\"type\":\"table\"},\"end\":57715,\"start\":56952},{\"attributes\":{\"id\":\"tab_2\",\"type\":\"table\"},\"end\":58006,\"start\":57716}]", "paragraph": "[{\"end\":2036,\"start\":1490},{\"end\":2817,\"start\":2038},{\"end\":3246,\"start\":2819},{\"end\":4297,\"start\":3248},{\"end\":5162,\"start\":4299},{\"end\":5878,\"start\":5164},{\"end\":7174,\"start\":5880},{\"end\":7414,\"start\":7191},{\"end\":8800,\"start\":7416},{\"end\":9474,\"start\":8802},{\"end\":10253,\"start\":9476},{\"end\":10824,\"start\":10284},{\"end\":11461,\"start\":10887},{\"end\":11712,\"start\":11463},{\"end\":12538,\"start\":11999},{\"end\":13535,\"start\":12596},{\"end\":13927,\"start\":13537},{\"end\":15046,\"start\":13929},{\"end\":15637,\"start\":15048},{\"end\":15867,\"start\":15699},{\"end\":16371,\"start\":15908},{\"end\":16897,\"start\":16443},{\"end\":17274,\"start\":16899},{\"end\":17920,\"start\":17303},{\"end\":18342,\"start\":17922},{\"end\":18544,\"start\":18403},{\"end\":19027,\"start\":18546},{\"end\":19354,\"start\":19029},{\"end\":19517,\"start\":19420},{\"end\":20215,\"start\":19519},{\"end\":20843,\"start\":20231},{\"end\":21851,\"start\":20845},{\"end\":22303,\"start\":21853},{\"end\":22694,\"start\":22305},{\"end\":22958,\"start\":22762},{\"end\":23747,\"start\":22960},{\"end\":25091,\"start\":23749},{\"end\":25741,\"start\":25152},{\"end\":25881,\"start\":25743},{\"end\":26773,\"start\":25883},{\"end\":27028,\"start\":26834},{\"end\":27878,\"start\":27030},{\"end\":28008,\"start\":27904},{\"end\":28900,\"start\":28010},{\"end\":29595,\"start\":28915},{\"end\":30148,\"start\":29633},{\"end\":30356,\"start\":30150},{\"end\":31459,\"start\":30777},{\"end\":31775,\"start\":31492},{\"end\":32274,\"start\":31777},{\"end\":32460,\"start\":32276},{\"end\":33271,\"start\":32473},{\"end\":33534,\"start\":33273},{\"end\":33913,\"start\":33600},{\"end\":34300,\"start\":33915},{\"end\":35881,\"start\":34302},{\"end\":36185,\"start\":35883},{\"end\":38106,\"start\":36187},{\"end\":38188,\"start\":38108},{\"end\":38925,\"start\":38190},{\"end\":39133,\"start\":39010},{\"end\":39816,\"start\":39180},{\"end\":40037,\"start\":39818},{\"end\":40096,\"start\":40039},{\"end\":40246,\"start\":40098},{\"end\":40506,\"start\":40263},{\"end\":40543,\"start\":40508},{\"end\":42426,\"start\":40545},{\"end\":43079,\"start\":42428},{\"end\":43280,\"start\":43081},{\"end\":43544,\"start\":43282},{\"end\":43617,\"start\":43569},{\"end\":44146,\"start\":43619},{\"end\":44336,\"start\":44148},{\"end\":45379,\"start\":44338},{\"end\":45685,\"start\":45381},{\"end\":45807,\"start\":45767},{\"end\":46018,\"start\":45809},{\"end\":46608,\"start\":46251},{\"end\":46803,\"start\":46699},{\"end\":47194,\"start\":46805},{\"end\":47253,\"start\":47196},{\"end\":47776,\"start\":47255},{\"end\":47947,\"start\":47886},{\"end\":48512,\"start\":47949},{\"end\":48702,\"start\":48514},{\"end\":49267,\"start\":48759},{\"end\":49314,\"start\":49269},{\"end\":49670,\"start\":49412},{\"end\":49820,\"start\":49696},{\"end\":51304,\"start\":49822},{\"end\":51761,\"start\":51306},{\"end\":52416,\"start\":51763},{\"end\":52632,\"start\":52469},{\"end\":52993,\"start\":52733},{\"end\":53250,\"start\":52995},{\"end\":53861,\"start\":53252},{\"end\":54176,\"start\":53863},{\"end\":54378,\"start\":54264},{\"end\":54771,\"start\":54380}]", "formula": "[{\"attributes\":{\"id\":\"formula_0\"},\"end\":11998,\"start\":11713},{\"attributes\":{\"id\":\"formula_1\"},\"end\":12595,\"start\":12539},{\"attributes\":{\"id\":\"formula_2\"},\"end\":15698,\"start\":15638},{\"attributes\":{\"id\":\"formula_3\"},\"end\":16442,\"start\":16372},{\"attributes\":{\"id\":\"formula_4\"},\"end\":18402,\"start\":18343},{\"attributes\":{\"id\":\"formula_5\"},\"end\":19419,\"start\":19355},{\"attributes\":{\"id\":\"formula_6\"},\"end\":27903,\"start\":27879},{\"attributes\":{\"id\":\"formula_7\"},\"end\":30776,\"start\":30357},{\"attributes\":{\"id\":\"formula_8\"},\"end\":39179,\"start\":39134},{\"attributes\":{\"id\":\"formula_10\"},\"end\":40262,\"start\":40247},{\"attributes\":{\"id\":\"formula_11\"},\"end\":45766,\"start\":45686},{\"attributes\":{\"id\":\"formula_12\"},\"end\":46250,\"start\":46019},{\"attributes\":{\"id\":\"formula_13\"},\"end\":46698,\"start\":46609},{\"attributes\":{\"id\":\"formula_14\"},\"end\":47885,\"start\":47777},{\"attributes\":{\"id\":\"formula_15\"},\"end\":48758,\"start\":48703},{\"attributes\":{\"id\":\"formula_16\"},\"end\":49411,\"start\":49315},{\"attributes\":{\"id\":\"formula_17\"},\"end\":49695,\"start\":49671},{\"attributes\":{\"id\":\"formula_18\"},\"end\":52468,\"start\":52417},{\"attributes\":{\"id\":\"formula_19\"},\"end\":52732,\"start\":52633},{\"attributes\":{\"id\":\"formula_20\"},\"end\":54263,\"start\":54177}]", "table_ref": "[{\"attributes\":{\"ref_id\":\"tab_0\"},\"end\":24177,\"start\":24170},{\"attributes\":{\"ref_id\":\"tab_0\"},\"end\":25915,\"start\":25908}]", "section_header": "[{\"attributes\":{\"n\":\"1\"},\"end\":1488,\"start\":1476},{\"attributes\":{\"n\":\"2\"},\"end\":7189,\"start\":7177},{\"attributes\":{\"n\":\"3\"},\"end\":10282,\"start\":10256},{\"attributes\":{\"n\":\"3.1\"},\"end\":10885,\"start\":10827},{\"attributes\":{\"n\":\"3.2\"},\"end\":15906,\"start\":15870},{\"attributes\":{\"n\":\"3.3\"},\"end\":17301,\"start\":17277},{\"attributes\":{\"n\":\"4\"},\"end\":20229,\"start\":20218},{\"attributes\":{\"n\":\"4.1\"},\"end\":22760,\"start\":22697},{\"attributes\":{\"n\":\"4.2\"},\"end\":25150,\"start\":25094},{\"attributes\":{\"n\":\"4.3\"},\"end\":26809,\"start\":26776},{\"attributes\":{\"n\":\"5\"},\"end\":26832,\"start\":26812},{\"attributes\":{\"n\":\"6\"},\"end\":28913,\"start\":28903},{\"end\":29631,\"start\":29598},{\"end\":31490,\"start\":31462},{\"end\":32471,\"start\":32463},{\"end\":33598,\"start\":33537},{\"end\":39008,\"start\":38928},{\"end\":43567,\"start\":43547},{\"end\":54783,\"start\":54773},{\"end\":54864,\"start\":54854},{\"end\":55815,\"start\":55805},{\"end\":56122,\"start\":56120},{\"end\":56673,\"start\":56660},{\"end\":56962,\"start\":56953},{\"end\":57730,\"start\":57717}]", "table": "[{\"end\":57715,\"start\":57208}]", "figure_caption": "[{\"end\":54852,\"start\":54785},{\"end\":55803,\"start\":54866},{\"end\":56118,\"start\":55817},{\"end\":56313,\"start\":56123},{\"end\":56658,\"start\":56316},{\"end\":56951,\"start\":56675},{\"end\":57208,\"start\":56964},{\"end\":58006,\"start\":57732}]", "figure_ref": "[{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":5365,\"start\":5357},{\"attributes\":{\"ref_id\":\"fig_1\"},\"end\":26589,\"start\":26580},{\"end\":53653,\"start\":53645},{\"end\":54625,\"start\":54617}]", "bib_author_first_name": "[{\"end\":58928,\"start\":58927},{\"end\":58937,\"start\":58936},{\"end\":58948,\"start\":58947},{\"end\":58958,\"start\":58957},{\"end\":58968,\"start\":58967},{\"end\":58976,\"start\":58975},{\"end\":58985,\"start\":58984},{\"end\":58987,\"start\":58986},{\"end\":58998,\"start\":58997},{\"end\":59007,\"start\":59006},{\"end\":59015,\"start\":59014},{\"end\":59415,\"start\":59414},{\"end\":59424,\"start\":59423},{\"end\":59433,\"start\":59432},{\"end\":59594,\"start\":59593},{\"end\":59596,\"start\":59595},{\"end\":59606,\"start\":59605},{\"end\":59608,\"start\":59607},{\"end\":59618,\"start\":59617},{\"end\":59833,\"start\":59832},{\"end\":59842,\"start\":59841},{\"end\":59853,\"start\":59852},{\"end\":59862,\"start\":59861},{\"end\":60074,\"start\":60073},{\"end\":60081,\"start\":60080},{\"end\":60087,\"start\":60086},{\"end\":60287,\"start\":60286},{\"end\":60294,\"start\":60293},{\"end\":60301,\"start\":60300},{\"end\":60513,\"start\":60512},{\"end\":60527,\"start\":60526},{\"end\":60538,\"start\":60537},{\"end\":60776,\"start\":60775},{\"end\":60778,\"start\":60777},{\"end\":60790,\"start\":60789},{\"end\":60803,\"start\":60802},{\"end\":60819,\"start\":60818},{\"end\":60832,\"start\":60831},{\"end\":60842,\"start\":60841},{\"end\":60858,\"start\":60857},{\"end\":60860,\"start\":60859},{\"end\":61110,\"start\":61109},{\"end\":61118,\"start\":61117},{\"end\":61132,\"start\":61131},{\"end\":61428,\"start\":61427},{\"end\":61438,\"start\":61437},{\"end\":61618,\"start\":61617},{\"end\":61620,\"start\":61619},{\"end\":61632,\"start\":61631},{\"end\":61644,\"start\":61643},{\"end\":61817,\"start\":61816},{\"end\":61831,\"start\":61830},{\"end\":62033,\"start\":62032},{\"end\":62218,\"start\":62217},{\"end\":62228,\"start\":62227},{\"end\":62387,\"start\":62386},{\"end\":62389,\"start\":62388},{\"end\":62397,\"start\":62396},{\"end\":62556,\"start\":62555},{\"end\":62558,\"start\":62557},{\"end\":62566,\"start\":62565},{\"end\":62811,\"start\":62810},{\"end\":62813,\"start\":62812},{\"end\":63022,\"start\":63021},{\"end\":63030,\"start\":63029},{\"end\":63183,\"start\":63182},{\"end\":63189,\"start\":63188},{\"end\":63199,\"start\":63198},{\"end\":63215,\"start\":63214},{\"end\":63410,\"start\":63409},{\"end\":63421,\"start\":63420},{\"end\":63434,\"start\":63433},{\"end\":63442,\"start\":63441},{\"end\":63444,\"start\":63443},{\"end\":63455,\"start\":63454},{\"end\":63676,\"start\":63675},{\"end\":63678,\"start\":63677},{\"end\":63684,\"start\":63683},{\"end\":63686,\"start\":63685},{\"end\":63696,\"start\":63695},{\"end\":63870,\"start\":63869},{\"end\":63881,\"start\":63880},{\"end\":63890,\"start\":63889},{\"end\":64070,\"start\":64069},{\"end\":64078,\"start\":64077},{\"end\":64086,\"start\":64085},{\"end\":64097,\"start\":64096},{\"end\":64331,\"start\":64330},{\"end\":64344,\"start\":64343},{\"end\":64357,\"start\":64356},{\"end\":64369,\"start\":64368},{\"end\":64379,\"start\":64378},{\"end\":64390,\"start\":64389},{\"end\":64400,\"start\":64399},{\"end\":64411,\"start\":64410},{\"end\":64427,\"start\":64426},{\"end\":64436,\"start\":64435},{\"end\":64447,\"start\":64446},{\"end\":64461,\"start\":64460},{\"end\":64471,\"start\":64470},{\"end\":64485,\"start\":64484},{\"end\":64496,\"start\":64495},{\"end\":64506,\"start\":64505},{\"end\":64915,\"start\":64914},{\"end\":64929,\"start\":64928},{\"end\":64939,\"start\":64938},{\"end\":64941,\"start\":64940},{\"end\":65121,\"start\":65120},{\"end\":65132,\"start\":65131},{\"end\":65143,\"start\":65142},{\"end\":65343,\"start\":65342},{\"end\":65345,\"start\":65344},{\"end\":65351,\"start\":65350},{\"end\":65357,\"start\":65356},{\"end\":65363,\"start\":65362},{\"end\":65365,\"start\":65364},{\"end\":65576,\"start\":65575},{\"end\":65587,\"start\":65586},{\"end\":65733,\"start\":65732},{\"end\":65746,\"start\":65745},{\"end\":65754,\"start\":65753},{\"end\":65756,\"start\":65755},{\"end\":65764,\"start\":65763},{\"end\":65780,\"start\":65779},{\"end\":66028,\"start\":66027},{\"end\":66044,\"start\":66043},{\"end\":66058,\"start\":66057},{\"end\":66060,\"start\":66059},{\"end\":66071,\"start\":66070},{\"end\":66083,\"start\":66082},{\"end\":66085,\"start\":66084},{\"end\":66422,\"start\":66421},{\"end\":66437,\"start\":66436},{\"end\":66447,\"start\":66446},{\"end\":66449,\"start\":66448},{\"end\":66459,\"start\":66458},{\"end\":66472,\"start\":66471},{\"end\":66474,\"start\":66473},{\"end\":66483,\"start\":66482},{\"end\":66485,\"start\":66484},{\"end\":66497,\"start\":66496},{\"end\":66510,\"start\":66509},{\"end\":66512,\"start\":66511},{\"end\":66523,\"start\":66522},{\"end\":66525,\"start\":66524},{\"end\":66534,\"start\":66533},{\"end\":66536,\"start\":66535},{\"end\":66980,\"start\":66979},{\"end\":66988,\"start\":66987},{\"end\":66994,\"start\":66993},{\"end\":67002,\"start\":67001},{\"end\":67011,\"start\":67010},{\"end\":67018,\"start\":67017},{\"end\":67182,\"start\":67181},{\"end\":67190,\"start\":67189},{\"end\":67197,\"start\":67196},{\"end\":67328,\"start\":67327},{\"end\":67336,\"start\":67335},{\"end\":67343,\"start\":67342},{\"end\":67351,\"start\":67350},{\"end\":67358,\"start\":67357},{\"end\":67365,\"start\":67364},{\"end\":67537,\"start\":67536},{\"end\":67539,\"start\":67538},{\"end\":67548,\"start\":67547},{\"end\":67550,\"start\":67549},{\"end\":67743,\"start\":67742},{\"end\":67749,\"start\":67748},{\"end\":67756,\"start\":67755},{\"end\":67763,\"start\":67762},{\"end\":67765,\"start\":67764},{\"end\":67938,\"start\":67937},{\"end\":67946,\"start\":67945},{\"end\":67955,\"start\":67954},{\"end\":68165,\"start\":68164},{\"end\":68175,\"start\":68174}]", "bib_author_last_name": "[{\"end\":58934,\"start\":58929},{\"end\":58945,\"start\":58938},{\"end\":58955,\"start\":58949},{\"end\":58965,\"start\":58959},{\"end\":58973,\"start\":58969},{\"end\":58982,\"start\":58977},{\"end\":58995,\"start\":58988},{\"end\":59004,\"start\":58999},{\"end\":59012,\"start\":59008},{\"end\":59021,\"start\":59016},{\"end\":59421,\"start\":59416},{\"end\":59430,\"start\":59425},{\"end\":59436,\"start\":59434},{\"end\":59603,\"start\":59597},{\"end\":59615,\"start\":59609},{\"end\":59627,\"start\":59619},{\"end\":59839,\"start\":59834},{\"end\":59850,\"start\":59843},{\"end\":59859,\"start\":59854},{\"end\":59868,\"start\":59863},{\"end\":60078,\"start\":60075},{\"end\":60084,\"start\":60082},{\"end\":60090,\"start\":60088},{\"end\":60291,\"start\":60288},{\"end\":60298,\"start\":60295},{\"end\":60306,\"start\":60302},{\"end\":60524,\"start\":60514},{\"end\":60535,\"start\":60528},{\"end\":60552,\"start\":60539},{\"end\":60787,\"start\":60779},{\"end\":60800,\"start\":60791},{\"end\":60816,\"start\":60804},{\"end\":60829,\"start\":60820},{\"end\":60839,\"start\":60833},{\"end\":60855,\"start\":60843},{\"end\":60866,\"start\":60861},{\"end\":61115,\"start\":61111},{\"end\":61129,\"start\":61119},{\"end\":61142,\"start\":61133},{\"end\":61435,\"start\":61429},{\"end\":61447,\"start\":61439},{\"end\":61629,\"start\":61621},{\"end\":61641,\"start\":61633},{\"end\":61653,\"start\":61645},{\"end\":61828,\"start\":61818},{\"end\":61843,\"start\":61832},{\"end\":62040,\"start\":62034},{\"end\":62225,\"start\":62219},{\"end\":62231,\"start\":62229},{\"end\":62394,\"start\":62390},{\"end\":62405,\"start\":62398},{\"end\":62563,\"start\":62559},{\"end\":62574,\"start\":62567},{\"end\":63027,\"start\":63023},{\"end\":63039,\"start\":63031},{\"end\":63186,\"start\":63184},{\"end\":63196,\"start\":63190},{\"end\":63212,\"start\":63200},{\"end\":63221,\"start\":63216},{\"end\":63418,\"start\":63411},{\"end\":63431,\"start\":63422},{\"end\":63439,\"start\":63435},{\"end\":63452,\"start\":63445},{\"end\":63460,\"start\":63456},{\"end\":63681,\"start\":63679},{\"end\":63693,\"start\":63687},{\"end\":63702,\"start\":63697},{\"end\":63878,\"start\":63871},{\"end\":63887,\"start\":63882},{\"end\":63898,\"start\":63891},{\"end\":64075,\"start\":64071},{\"end\":64083,\"start\":64079},{\"end\":64094,\"start\":64087},{\"end\":64106,\"start\":64098},{\"end\":64341,\"start\":64332},{\"end\":64354,\"start\":64345},{\"end\":64366,\"start\":64358},{\"end\":64376,\"start\":64370},{\"end\":64387,\"start\":64380},{\"end\":64397,\"start\":64391},{\"end\":64408,\"start\":64401},{\"end\":64424,\"start\":64412},{\"end\":64433,\"start\":64428},{\"end\":64444,\"start\":64437},{\"end\":64458,\"start\":64448},{\"end\":64468,\"start\":64462},{\"end\":64482,\"start\":64472},{\"end\":64493,\"start\":64486},{\"end\":64503,\"start\":64497},{\"end\":64516,\"start\":64507},{\"end\":64926,\"start\":64916},{\"end\":64936,\"start\":64930},{\"end\":64949,\"start\":64942},{\"end\":65129,\"start\":65122},{\"end\":65140,\"start\":65133},{\"end\":65150,\"start\":65144},{\"end\":65348,\"start\":65346},{\"end\":65354,\"start\":65352},{\"end\":65360,\"start\":65358},{\"end\":65372,\"start\":65366},{\"end\":65584,\"start\":65577},{\"end\":65593,\"start\":65588},{\"end\":65743,\"start\":65734},{\"end\":65751,\"start\":65747},{\"end\":65761,\"start\":65757},{\"end\":65777,\"start\":65765},{\"end\":65791,\"start\":65781},{\"end\":66041,\"start\":66029},{\"end\":66055,\"start\":66045},{\"end\":66068,\"start\":66061},{\"end\":66080,\"start\":66072},{\"end\":66095,\"start\":66086},{\"end\":66434,\"start\":66423},{\"end\":66444,\"start\":66438},{\"end\":66456,\"start\":66450},{\"end\":66469,\"start\":66460},{\"end\":66480,\"start\":66475},{\"end\":66494,\"start\":66486},{\"end\":66507,\"start\":66498},{\"end\":66520,\"start\":66513},{\"end\":66531,\"start\":66526},{\"end\":66543,\"start\":66537},{\"end\":66985,\"start\":66981},{\"end\":66991,\"start\":66989},{\"end\":66999,\"start\":66995},{\"end\":67008,\"start\":67003},{\"end\":67015,\"start\":67012},{\"end\":67022,\"start\":67019},{\"end\":67187,\"start\":67183},{\"end\":67194,\"start\":67191},{\"end\":67201,\"start\":67198},{\"end\":67333,\"start\":67329},{\"end\":67340,\"start\":67337},{\"end\":67348,\"start\":67344},{\"end\":67355,\"start\":67352},{\"end\":67362,\"start\":67359},{\"end\":67370,\"start\":67366},{\"end\":67545,\"start\":67540},{\"end\":67559,\"start\":67551},{\"end\":67746,\"start\":67744},{\"end\":67753,\"start\":67750},{\"end\":67760,\"start\":67757},{\"end\":67768,\"start\":67766},{\"end\":67943,\"start\":67939},{\"end\":67952,\"start\":67947},{\"end\":67969,\"start\":67956},{\"end\":68172,\"start\":68166},{\"end\":68184,\"start\":68176}]", "bib_entry": "[{\"attributes\":{\"doi\":\"arXiv:1603.04467\",\"id\":\"b0\"},\"end\":59351,\"start\":58927},{\"attributes\":{\"id\":\"b1\"},\"end\":59544,\"start\":59353},{\"attributes\":{\"id\":\"b2\",\"matched_paper_id\":3635447},\"end\":59770,\"start\":59546},{\"attributes\":{\"id\":\"b3\",\"matched_paper_id\":17682909},\"end\":59996,\"start\":59772},{\"attributes\":{\"id\":\"b4\",\"matched_paper_id\":17341970},\"end\":60211,\"start\":59998},{\"attributes\":{\"id\":\"b5\",\"matched_paper_id\":2708270},\"end\":60430,\"start\":60213},{\"attributes\":{\"id\":\"b6\",\"matched_paper_id\":3016223},\"end\":60703,\"start\":60432},{\"attributes\":{\"id\":\"b7\",\"matched_paper_id\":1690180},\"end\":61064,\"start\":60705},{\"attributes\":{\"id\":\"b8\",\"matched_paper_id\":20480879},\"end\":61375,\"start\":61066},{\"attributes\":{\"id\":\"b9\",\"matched_paper_id\":207238980},\"end\":61544,\"start\":61377},{\"attributes\":{\"id\":\"b10\",\"matched_paper_id\":5480561},\"end\":61790,\"start\":61546},{\"attributes\":{\"id\":\"b11\",\"matched_paper_id\":1915014},\"end\":61967,\"start\":61792},{\"attributes\":{\"id\":\"b12\",\"matched_paper_id\":7343126},\"end\":62171,\"start\":61969},{\"attributes\":{\"id\":\"b13\",\"matched_paper_id\":6628106},\"end\":62318,\"start\":62173},{\"attributes\":{\"id\":\"b14\",\"matched_paper_id\":3144218},\"end\":62520,\"start\":62320},{\"attributes\":{\"id\":\"b15\",\"matched_paper_id\":14249137},\"end\":62726,\"start\":62522},{\"attributes\":{\"id\":\"b16\",\"matched_paper_id\":48165675},\"end\":62963,\"start\":62728},{\"attributes\":{\"id\":\"b17\",\"matched_paper_id\":1190093},\"end\":63142,\"start\":62965},{\"attributes\":{\"id\":\"b18\",\"matched_paper_id\":8393918},\"end\":63330,\"start\":63144},{\"attributes\":{\"id\":\"b19\",\"matched_paper_id\":16447573},\"end\":63622,\"start\":63332},{\"attributes\":{\"id\":\"b20\",\"matched_paper_id\":18764978},\"end\":63816,\"start\":63624},{\"attributes\":{\"id\":\"b21\",\"matched_paper_id\":1430801},\"end\":64009,\"start\":63818},{\"attributes\":{\"id\":\"b22\"},\"end\":64286,\"start\":64011},{\"attributes\":{\"id\":\"b23\",\"matched_paper_id\":10659969},\"end\":64865,\"start\":64288},{\"attributes\":{\"id\":\"b24\",\"matched_paper_id\":1957433},\"end\":65065,\"start\":64867},{\"attributes\":{\"id\":\"b25\",\"matched_paper_id\":3051291},\"end\":65262,\"start\":65067},{\"attributes\":{\"id\":\"b26\",\"matched_paper_id\":5115938},\"end\":65514,\"start\":65264},{\"attributes\":{\"id\":\"b27\",\"matched_paper_id\":18593743},\"end\":65698,\"start\":65516},{\"attributes\":{\"id\":\"b28\",\"matched_paper_id\":206756462},\"end\":65993,\"start\":65700},{\"attributes\":{\"id\":\"b29\"},\"end\":66312,\"start\":65995},{\"attributes\":{\"id\":\"b30\",\"matched_paper_id\":2374637},\"end\":66928,\"start\":66314},{\"attributes\":{\"id\":\"b31\"},\"end\":67144,\"start\":66930},{\"attributes\":{\"id\":\"b32\",\"matched_paper_id\":207238964},\"end\":67285,\"start\":67146},{\"attributes\":{\"id\":\"b33\",\"matched_paper_id\":29154877},\"end\":67487,\"start\":67287},{\"attributes\":{\"id\":\"b34\",\"matched_paper_id\":3034643},\"end\":67687,\"start\":67489},{\"attributes\":{\"id\":\"b35\"},\"end\":67876,\"start\":67689},{\"attributes\":{\"id\":\"b36\",\"matched_paper_id\":7008752},\"end\":68091,\"start\":67878},{\"attributes\":{\"id\":\"b37\",\"matched_paper_id\":4640611},\"end\":68321,\"start\":68093}]", "bib_title": "[{\"end\":59591,\"start\":59546},{\"end\":59830,\"start\":59772},{\"end\":60071,\"start\":59998},{\"end\":60284,\"start\":60213},{\"end\":60510,\"start\":60432},{\"end\":60773,\"start\":60705},{\"end\":61107,\"start\":61066},{\"end\":61425,\"start\":61377},{\"end\":61615,\"start\":61546},{\"end\":61814,\"start\":61792},{\"end\":62030,\"start\":61969},{\"end\":62215,\"start\":62173},{\"end\":62384,\"start\":62320},{\"end\":62553,\"start\":62522},{\"end\":62808,\"start\":62728},{\"end\":63019,\"start\":62965},{\"end\":63180,\"start\":63144},{\"end\":63407,\"start\":63332},{\"end\":63673,\"start\":63624},{\"end\":63867,\"start\":63818},{\"end\":64328,\"start\":64288},{\"end\":64912,\"start\":64867},{\"end\":65118,\"start\":65067},{\"end\":65340,\"start\":65264},{\"end\":65573,\"start\":65516},{\"end\":65730,\"start\":65700},{\"end\":66025,\"start\":65995},{\"end\":66419,\"start\":66314},{\"end\":67179,\"start\":67146},{\"end\":67325,\"start\":67287},{\"end\":67534,\"start\":67489},{\"end\":67935,\"start\":67878},{\"end\":68162,\"start\":68093}]", "bib_author": "[{\"end\":58936,\"start\":58927},{\"end\":58947,\"start\":58936},{\"end\":58957,\"start\":58947},{\"end\":58967,\"start\":58957},{\"end\":58975,\"start\":58967},{\"end\":58984,\"start\":58975},{\"end\":58997,\"start\":58984},{\"end\":59006,\"start\":58997},{\"end\":59014,\"start\":59006},{\"end\":59023,\"start\":59014},{\"end\":59423,\"start\":59414},{\"end\":59432,\"start\":59423},{\"end\":59438,\"start\":59432},{\"end\":59605,\"start\":59593},{\"end\":59617,\"start\":59605},{\"end\":59629,\"start\":59617},{\"end\":59841,\"start\":59832},{\"end\":59852,\"start\":59841},{\"end\":59861,\"start\":59852},{\"end\":59870,\"start\":59861},{\"end\":60080,\"start\":60073},{\"end\":60086,\"start\":60080},{\"end\":60092,\"start\":60086},{\"end\":60293,\"start\":60286},{\"end\":60300,\"start\":60293},{\"end\":60308,\"start\":60300},{\"end\":60526,\"start\":60512},{\"end\":60537,\"start\":60526},{\"end\":60554,\"start\":60537},{\"end\":60789,\"start\":60775},{\"end\":60802,\"start\":60789},{\"end\":60818,\"start\":60802},{\"end\":60831,\"start\":60818},{\"end\":60841,\"start\":60831},{\"end\":60857,\"start\":60841},{\"end\":60868,\"start\":60857},{\"end\":61117,\"start\":61109},{\"end\":61131,\"start\":61117},{\"end\":61144,\"start\":61131},{\"end\":61437,\"start\":61427},{\"end\":61449,\"start\":61437},{\"end\":61631,\"start\":61617},{\"end\":61643,\"start\":61631},{\"end\":61655,\"start\":61643},{\"end\":61830,\"start\":61816},{\"end\":61845,\"start\":61830},{\"end\":62042,\"start\":62032},{\"end\":62227,\"start\":62217},{\"end\":62233,\"start\":62227},{\"end\":62396,\"start\":62386},{\"end\":62407,\"start\":62396},{\"end\":62565,\"start\":62555},{\"end\":62576,\"start\":62565},{\"end\":62816,\"start\":62810},{\"end\":63029,\"start\":63021},{\"end\":63041,\"start\":63029},{\"end\":63188,\"start\":63182},{\"end\":63198,\"start\":63188},{\"end\":63214,\"start\":63198},{\"end\":63223,\"start\":63214},{\"end\":63420,\"start\":63409},{\"end\":63433,\"start\":63420},{\"end\":63441,\"start\":63433},{\"end\":63454,\"start\":63441},{\"end\":63462,\"start\":63454},{\"end\":63683,\"start\":63675},{\"end\":63695,\"start\":63683},{\"end\":63704,\"start\":63695},{\"end\":63880,\"start\":63869},{\"end\":63889,\"start\":63880},{\"end\":63900,\"start\":63889},{\"end\":64077,\"start\":64069},{\"end\":64085,\"start\":64077},{\"end\":64096,\"start\":64085},{\"end\":64108,\"start\":64096},{\"end\":64343,\"start\":64330},{\"end\":64356,\"start\":64343},{\"end\":64368,\"start\":64356},{\"end\":64378,\"start\":64368},{\"end\":64389,\"start\":64378},{\"end\":64399,\"start\":64389},{\"end\":64410,\"start\":64399},{\"end\":64426,\"start\":64410},{\"end\":64435,\"start\":64426},{\"end\":64446,\"start\":64435},{\"end\":64460,\"start\":64446},{\"end\":64470,\"start\":64460},{\"end\":64484,\"start\":64470},{\"end\":64495,\"start\":64484},{\"end\":64505,\"start\":64495},{\"end\":64518,\"start\":64505},{\"end\":64928,\"start\":64914},{\"end\":64938,\"start\":64928},{\"end\":64951,\"start\":64938},{\"end\":65131,\"start\":65120},{\"end\":65142,\"start\":65131},{\"end\":65152,\"start\":65142},{\"end\":65350,\"start\":65342},{\"end\":65356,\"start\":65350},{\"end\":65362,\"start\":65356},{\"end\":65374,\"start\":65362},{\"end\":65586,\"start\":65575},{\"end\":65595,\"start\":65586},{\"end\":65745,\"start\":65732},{\"end\":65753,\"start\":65745},{\"end\":65763,\"start\":65753},{\"end\":65779,\"start\":65763},{\"end\":65793,\"start\":65779},{\"end\":66043,\"start\":66027},{\"end\":66057,\"start\":66043},{\"end\":66070,\"start\":66057},{\"end\":66082,\"start\":66070},{\"end\":66097,\"start\":66082},{\"end\":66436,\"start\":66421},{\"end\":66446,\"start\":66436},{\"end\":66458,\"start\":66446},{\"end\":66471,\"start\":66458},{\"end\":66482,\"start\":66471},{\"end\":66496,\"start\":66482},{\"end\":66509,\"start\":66496},{\"end\":66522,\"start\":66509},{\"end\":66533,\"start\":66522},{\"end\":66545,\"start\":66533},{\"end\":66987,\"start\":66979},{\"end\":66993,\"start\":66987},{\"end\":67001,\"start\":66993},{\"end\":67010,\"start\":67001},{\"end\":67017,\"start\":67010},{\"end\":67024,\"start\":67017},{\"end\":67189,\"start\":67181},{\"end\":67196,\"start\":67189},{\"end\":67203,\"start\":67196},{\"end\":67335,\"start\":67327},{\"end\":67342,\"start\":67335},{\"end\":67350,\"start\":67342},{\"end\":67357,\"start\":67350},{\"end\":67364,\"start\":67357},{\"end\":67372,\"start\":67364},{\"end\":67547,\"start\":67536},{\"end\":67561,\"start\":67547},{\"end\":67748,\"start\":67742},{\"end\":67755,\"start\":67748},{\"end\":67762,\"start\":67755},{\"end\":67770,\"start\":67762},{\"end\":67945,\"start\":67937},{\"end\":67954,\"start\":67945},{\"end\":67971,\"start\":67954},{\"end\":68174,\"start\":68164},{\"end\":68186,\"start\":68174}]", "bib_venue": "[{\"end\":59104,\"start\":59039},{\"end\":59412,\"start\":59353},{\"end\":59636,\"start\":59629},{\"end\":59874,\"start\":59870},{\"end\":60095,\"start\":60092},{\"end\":60312,\"start\":60308},{\"end\":60558,\"start\":60554},{\"end\":60872,\"start\":60868},{\"end\":61198,\"start\":61144},{\"end\":61452,\"start\":61449},{\"end\":61658,\"start\":61655},{\"end\":61863,\"start\":61845},{\"end\":62057,\"start\":62042},{\"end\":62237,\"start\":62233},{\"end\":62411,\"start\":62407},{\"end\":62615,\"start\":62576},{\"end\":62829,\"start\":62816},{\"end\":63045,\"start\":63041},{\"end\":63227,\"start\":63223},{\"end\":63466,\"start\":63462},{\"end\":63708,\"start\":63704},{\"end\":63904,\"start\":63900},{\"end\":64067,\"start\":64011},{\"end\":64554,\"start\":64518},{\"end\":64956,\"start\":64951},{\"end\":65155,\"start\":65152},{\"end\":65378,\"start\":65374},{\"end\":65599,\"start\":65595},{\"end\":65829,\"start\":65793},{\"end\":66133,\"start\":66097},{\"end\":66592,\"start\":66545},{\"end\":66977,\"start\":66930},{\"end\":67206,\"start\":67203},{\"end\":67376,\"start\":67372},{\"end\":67567,\"start\":67561},{\"end\":67740,\"start\":67689},{\"end\":67975,\"start\":67971},{\"end\":68200,\"start\":68186}]"}}}, "year": 2023, "month": 12, "day": 17}