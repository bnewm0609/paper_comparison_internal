{"id": 49291228, "updated": "2023-09-30 23:06:04.309", "metadata": {"title": "PULP-HD: Accelerating Brain-Inspired High-Dimensional Computing on a Parallel Ultra-Low Power Platform", "authors": "[{\"first\":\"Fabio\",\"last\":\"Montagna\",\"middle\":[]},{\"first\":\"Abbas\",\"last\":\"Rahimi\",\"middle\":[]},{\"first\":\"Simone\",\"last\":\"Benatti\",\"middle\":[]},{\"first\":\"Davide\",\"last\":\"Rossi\",\"middle\":[]},{\"first\":\"Luca\",\"last\":\"Benini\",\"middle\":[]}]", "venue": "2018 55th ACM/ESDA/IEEE Design Automation Conference (DAC)", "journal": "2018 55th ACM/ESDA/IEEE Design Automation Conference (DAC)", "publication_date": {"year": 2018, "month": 4, "day": 24}, "abstract": "Computing with high-dimensional (HD) vectors, also referred to as $\\textit{hypervectors}$, is a brain-inspired alternative to computing with scalars. Key properties of HD computing include a well-defined set of arithmetic operations on hypervectors, generality, scalability, robustness, fast learning, and ubiquitous parallel operations. HD computing is about manipulating and comparing large patterns-binary hypervectors with 10,000 dimensions-making its efficient realization on minimalistic ultra-low-power platforms challenging. This paper describes HD computing's acceleration and its optimization of memory accesses and operations on a silicon prototype of the PULPv3 4-core platform (1.5mm$^2$, 2mW), surpassing the state-of-the-art classification accuracy (on average 92.4%) with simultaneous 3.7$\\times$ end-to-end speed-up and 2$\\times$ energy saving compared to its single-core execution. We further explore the scalability of our accelerator by increasing the number of inputs and classification window on a new generation of the PULP architecture featuring bit-manipulation instruction extensions and larger number of 8 cores. These together enable a near ideal speed-up of 18.4$\\times$ compared to the single-core PULPv3.", "fields_of_study": "[\"Engineering\"]", "external_ids": {"arxiv": "1804.09123", "mag": "2962967667", "acl": null, "pubmed": null, "pubmedcentral": null, "dblp": "conf/dac/MontagnaRBRB18", "doi": "10.1145/3195970.3196096"}}, "content": {"source": {"pdf_hash": "909728642886c8bd63e41c198db83d08f6bc4702", "pdf_src": "Arxiv", "pdf_uri": "[\"https://arxiv.org/pdf/1804.09123v1.pdf\"]", "oa_url_match": false, "oa_info": {"license": null, "open_access_url": "https://cris.unibo.it/bitstream/11585/647800/1/DAC_pap.pdf", "status": "GREEN"}}, "grobid": {"id": "e873e68e3aa2f5994e524f292b6638ff3d377764", "type": "plain-text", "url": "s3://ai2-s2-pdf-extraction-prod/parse-results/s2orc_worker/909728642886c8bd63e41c198db83d08f6bc4702.txt", "contents": "\nPULP-HD: Accelerating Brain-Inspired High-Dimensional Computing on a Parallel Ultra-Low Power Platform\n\n\nFabio Montagna \nUniversity of Bologna\n\u2021 UC Berkeley\n\u22c6 ETH Zurich\n\n\nAbbas Rahimi \nUniversity of Bologna\n\u2021 UC Berkeley\n\u22c6 ETH Zurich\n\n\nSimone Benatti \nUniversity of Bologna\n\u2021 UC Berkeley\n\u22c6 ETH Zurich\n\n\nDavide Rossi \u2020\u22c6 \nUniversity of Bologna\n\u2021 UC Berkeley\n\u22c6 ETH Zurich\n\n\nLuca Benini lbenini@iis.ee.ethz.ch \nUniversity of Bologna\n\u2021 UC Berkeley\n\u22c6 ETH Zurich\n\n\nPULP-HD: Accelerating Brain-Inspired High-Dimensional Computing on a Parallel Ultra-Low Power Platform\n\nComputing with high-dimensional (HD) vectors, also referred to as hypervectors, is a brain-inspired alternative to computing with scalars. Key properties of HD computing include a well-defined set of arithmetic operations on hypervectors, generality, scalability, robustness, fast learning, and ubiquitous parallel operations. HD computing is about manipulating and comparing large patternsbinary hypervectors with 10,000 dimensions-making its efficient realization on minimalistic ultra-low-power platforms challenging. This paper describes HD computing's acceleration and its optimization of memory accesses and operations on a silicon prototype of the PULPv3 4-core platform (1.5 mm 2 , 2 mW), surpassing the stateof-the-art classification accuracy (on average 92.4%) with simultaneous 3.7\u00d7 end-to-end speed-up and 2\u00d7 energy saving compared to its single-core execution. We further explore the scalability of our accelerator by increasing the number of inputs and classification window on a new generation of the PULP architecture featuring bitmanipulation instruction extensions and larger number of 8 cores. These together enable a near ideal speed-up of 18.4\u00d7 compared to the single-core PULPv3.\n\nINTRODUCTION\n\nThe brain's circuits are massive in terms of numbers of neurons and synapses, suggesting that large circuits are fundamental to the brain's computing [7,9,16]. High-dimensional (HD) computing, aka hyperdimensional computing [9], is based on the understanding that brains compute with patterns of neural activity that are not readily associated with numbers. In fact, the brain's ability to calculate with numbers is feeble. However, by virtue of the large size of brain's circuits, we can model neural activity patterns in points of a highdimensional space, that is, with hypervectors. When dimensionality is in the thousands (e.g., 10,000-D), the term \"hyperdimensional\" is used [9]. Hypervectors are also holographic and (pseudo)random with independent and identically distributed (i.i.d.) components. Such hypervectors can be mathematically manipulated to not only classify but also to make associations, form hierarchies, and perform other types of cognitive computations [9]. Key properties of HD computing include generality, scalability, a well-defined set of arithmetic operations on hypervectors, ubiquitous parallel operations, robustness, and graceful degradation making it possible to develop efficient nanoscalable learning machines [20].\n\nHD computing is a complete computational paradigm that is easily applied to various learning problems, e.g., analogical processing [16], language recognitions [11,12], and speech recognition [22]. HD computing has also been used for multimodal data fusion and prediction, including categorization of body physical activities from several heterogeneous sensors [23], predicting behavior of mobiledevice users (e.g., media player prediction) [24], and reactive robot learning [14]. More recently, HD computing has shown promise in biosignal processing and classification of raw electromyography (EMG) [19] as well as electroencephalography (EEG) [21] data with minimal information: e.g., in the absence of domain expert knowledge and using smaller training datasets, without affecting the robustness of classification.\n\nAt its very core, HD computing is about manipulating and comparing large patterns stored in memory. Its mathematical operations allow a high degree of parallelism by needing to communicate with only a local component or its immediate neighbors. Other operations such as distance computation can be performed in a distributed fashion. However, there has been no silicon proof yet to assess the advantages of HD computing for a large extensive application. Hence, we target accelerating HD computing on a parallel ultra-low power (PULP) platform [17] which exploits nearthreshold operation coupled with parallel execution over multiple cores. The architecture is described in detail in [25]. This paper makes the following contributions:\n\n\u2022 We present an accelerator for all operations of HD computing and optimize their memory accesses on a PULP platform. We target a silicon prototype of the PULP platform featuring 4 cores operating at 0.5 V, fabricated in 28 nm FD-SOI technology aka PULPv3 [26]. To the best of our knowledge, this is the first realization of an accelerated HD computing on an embedded platform with tight resources (1.5 mm 2 , 2 mW) fabricated in the standard silicon-based technology. We efficiently represent the components of binary hypervectors to unsigned integer arrays and carefully optimize their layout in L1/L2 memory; this enables double buffering for efficient data transfer and naturally exploits data level parallelism with bitwise and distributed operations. These optimizations construct a universal accelerator for all applications of HD computing that are described using the open multiprocessing (OpenMP) directives. This paper shows an example of using this accelerator in the EMGbased hand gesture recognition for a highly energy-efficient and wearable form-factor system. \u2022 Our accelerator preserves the semantic of HD computing by avoiding any lossy optimization on binary hypervectors, and its classification accuracy (on average 92.4%) matches the golden MATLAB model 1 . This classification accuracy already surpasses the state-ofthe-art support vector machines (SVMs) [3]. We demonstrate that HD computing is computationally affordable on a mW platform, and highly amenable for perfect parallel execution: PULPv3 with 4 cores achieves 3.7\u00d7 end-to-end speed-up and 2\u00d7 energy saving compared to its single core execution.\n\n\u2022 We further investigate how acceleration of HD computing can benefit on a new generation of the PULP featuring RISC-V based processors (called Wolf) extended for energy-efficient digital signal processing [6] such as bit-manipulation instructions. This instruction extension together with a larger number of 8 cores achieves 18.4\u00d7 speed-up compared to the single-core PULPv3. We also evaluate the scalability of our accelerator by increasing the number of input channels and larger temporal windows of classification.\n\nWe observe that HD computing scales very well, and the savings linearly benefit from a large number of cores paving the way for the development of future HD-centric accelerators.\n\n\nBACKGROUND\n\nIn this section, we first provide background in HD computing, and describe the main modules of an HD computing-based classifier. Then, we describe in details the PULP platform that is used for acceleration of the HD classifier.\n\n\nHigh-dimensional (HD) Computing\n\nComputing with 10,000-bit words takes us into the realm of very high-dimensional spaces and vectors. There exist a huge number of different, nearly orthogonal hypervectors with the dimensionality in the thousands [7,9]. This lets us combine two such hypervectors into a new hypervector using well-defined vector space operations, while keeping the information of the two with high probability. The binary hypervectors are initially taken from a 10,000-D space and have an equal number of randomly placed 1s and 0s, i.e., {0, 1} D [8]. The number of places at which two binary hypervectors differ is called the Hamming distance and it provides a measure of similarity between hypervectors.\n\nHD computing uses three operations: multiplication, addition, and permutation (MAP). The addition of binary hypervectors [A + B + . . .] is defined as the componentwise majority with ties broken at random. The multiplication is defined as the componentwise XOR (\u2295), and permutation (\u03c1) shuffles the components, e.g., 1-bit rotation. All these MAP operations produce a D-bit hypervector. The usefulness of HD computing comes from the nature of the operations. Specifically, the addition produces a hypervector that is similar to the input hypervectors, whereas multiplication produces a dissimilar hypervector. Hence, the addition is well suited for representing sets, and the multiplication is useful for binding two hypervectors. The permutation also generates a dissimilar pseudoorthogonal hypervector that is good for storing a sequence. The multiplication and permutation are invertible.\n\n2.1.1 Modules of HD Classifier. In the following, we describe three main modules for classification using HD computing. First, an item memory (IM) maps all symbols in the system to the HD space. In a typical biosignal processing system, the names of channels (or electrodes) are the basic symbols for mapping. The IM assigns a random hypervectors (with i.i.d. components) to every channel's name, i.e., E 1 \u22a5 E 2 ... \u22a5 E i . Besides the discrete symbols, the system has analog values (e.g., the signal levels of channels) for mapping. To map these analog values, the notion of IM is further extended to a continuous item memory (CIM) [19]. In the continuous vector space of CIM, orthogonal endpoint hypervectors are generated for the minimum and maximum signal levels. For instance, when the channel i produces a maximum signal level at time t and the minimum signal level at t + k, the corresponding generated hypervectors by CIM are orthogonal, i.e., V t i \u22a5 V t +k i . The hypervectors for intermediate levels are then generated by linear interpolation between these endpoints and are prestored in the CIM [19,21]. The IM and CIM stay fixed throughout the computation, and they serve as seeds from which further representations are made.\n\nSecond, the seed hypervectors are encoded by the MAP operations to represent the event of interest for classification. For instance, a spatial encoder can represent a set of all channel-value pairs at timestamp t into a binary hypervector (S t ). To this end, the multiplication is used to bind each channel to its signal level, and to form the set all these bound hypervectors are bundled by the addition, i.e.,\nS t = [(E 1 \u2295 V t 1 ) + ... + (E i \u2295 V t i )].\nThe generated binary hypervector (S t ) only captures the spatial information for a given time-aligned samples of channels. However, in many applications temporal information is of concern as well. A temporal encoder can capture the relevant temporal information by using the permutation and multiplication that together form an N-gram hypervector from a sequence of N hypervectors . Hence, a sequence of N spatial hypervectors at consecutive timestamps are encoded into an N-gram hypervector:\nS t \u2295 \u03c1 1 S t +1 \u2295 \u03c1 2 S t +2 \u2295 ... \u2295 \u03c1 n\u22121 S t +n\u22121\nwhere \u03c1 k is a rotation over k positions of the hypervector. Some biosignal processing applications such as EEG-based brain-machine interfaces may require a large temporal window as large as N-gram of 29 [21].\n\nFinally, for a given class, across all its trials, the corresponding N-gram hypervectors are added to produce a binary prototype hypervector. During training, the prototype hypervectors are stored in an associative memory (AM) as the learned patterns. During classification, in an identical way to prototypes, a query hypervector is generated from unseen inputs. The AM compares the query hypervectors to all learned prototype hypervectors, and returns the label of the one that has the minimum Hamming distance. Since these three modules are commonly used across various applications of HD computing [19][20][21], we target their accelerations to achieve end-to-end benefits in learning and classification tasks.\n\n\nParallel Ultra-Low Power (PULP) Platform\n\nThe PULPv3 SoC used is in work exploits a software programmable, 4 processors cluster architecture operating in near-threshold (0.7 V-0.5 V), fabricated in 28 nm FD-SOI technology [26]. The processors used in the cluster are based on an optimized implementation of the open-source OpenRISC instruction set architecture (ISA) which share 48 kB of multi-banked tightly coupled data memory (TCDM) acting as software-managed L1 scratchpad memory. The 64 kB offcluster L2 memory can be accessed by a tightly coupled direct memory access (DMA) optimized for low power through the 64-bit AXI4 interconnect, which guarantees high L1 to L2 communication bandwidth (i.e., up to 32 Gbit/s at 500 MHz).\n\nThe cluster and the rest of the SoC (which includes L2 memory and peripherals) reside in two clock and power domains controlled by frequency-locked loops (FLLs), and external voltage regulators [18]. Hence, voltage and frequency can be scaled according to the performance requirements of the applications. The SoC features a standard peripheral set which includes SPI, QSPI, UART, I2C, I2S to connect to external commercial devices such as analog to digital converters (ADC). PULPv3 relies on OpenMP v3.0, as the de facto standard parallel programming model, that operates on top of GCC 4.9 toolchain. The OpenMP implementation is based on a highly optimized bare-metal library to exclude an operating system that would otherwise introduce huge software overheads not suitable for ultra-low-power parallel accelerators.\n\n\nACCELERATING HD COMPUTING ON PULP\n\nThis section describes the acceleration of the HD Computing on the PULP platform. To reduce the computational requirements, we first pack a binary hypervector in an array of conventional data type. We directly map 32 consecutive binary components of a hypervector to an unsigned integer variable with 32 bits. In this way, a binary hypervectors, with 10,000 randomly placed 1s and 0s, can be losslessly represented with 313 unsigned integers. This leads to a significant reduction of the memory accesses. Moreover, having hypervectors united in 32 bits unsigned integers paves the way to aggressive code optimizations for the MAP operations, using simple componentwise majority, XOR, and shift operations. Fig. 1 illustrates the processing chain of HD computing that is composed by three main kernels: mapping to the HD space and spatial encoder, temporal encoder, and AM for classification. Each kernel of the processing chain is parallelized separately using an optimized version of the OpenMP directives to efficiently distribute the workload over multiple cores.\n\nThe input EMG signals are acquired through a 16-bits ADC [2] and casted to the 32-bit floating-point representation. The preprocessing block includes power line interference removal and envelope extraction. This preprocessing block is not executed on the PULP platform, hence we exclude it from our parallel processing chain. The first kernel of our processing chain maps the EMG samples to the HD space, and performs spatial encoding among the channels. To map the four samples (see Fig. 1) to the internal HD representation, we use the CIM with a fixed number of levels, e.g., 22 linear levels are suitable for the EMG task where the amplitude of signal typically ranges from 0 to 21 mV. A set of 22 hypervectors corresponding to each of these levels are generated offline and prestored in the CIM. The CIM utilizes a simple quantization step in which every sample is rounded to the closest integer level. Besides, the 4 EMG channels are also mapped to corresponding hypervectors on the IM with 4 orthogonal hypervectors. In this kernel, parallelization is performed at data level.\n\nAfter mapping to the HD space, the workload is equally distributed among the cores, giving to each core a portion of the hypervectors on which the required encoding operations are performed. In this way, the cores execute first the componentwise XOR operation from the outputs of CIM and IM, and then the componentwise majority to create the spatial hypervector in parallel. In Fig. 2 (right), a code snippet of the spatial encoder kernel is presented to show how OpenMP directives are used for the parallelization of the entire processing chain. In Section 5, we demonstrate that this kernel shows an high level of scalability on large number of cores, achieving a nearly ideal speed-up.\n\nThe spatial hypervector (1x313), which goes as input in the temporal encoder, is stored directly in the L1 memory to avoid useless accesses to the high latency memory (L2) and requires 2 kB of memory. Instead, the CIM (22x313 matrix, 27 kB) and IM (4x313 matrix, 5 kB) are stored in the L2 memory. By applying a double buffering policy via DMA, data are moved from high latency memory (L2) to L1 memory while the cores are processing the data already available in L1. In this way, data transfers and processing phases can be superimposed improving the performance and the energy efficiency of the system.\n\nAs mentioned in the Section 2.1.1, in the case of N-grams greater than one, after the spatial encoder, the temporal encoder is executed. In this kernel, a sequence of N spatial hypervectors are encoded and combined through a componentwise XOR operation after shifting them by one position as permutation. The output of this kernel is the N-gram hypervector that requires 2 kB (stored the in L1 memory), and serves as the input of the AM kernel.\n\nThe last part of the processing chain is the AM kernel. The AM matrix is composed by the prototype hypervectors associated to each classes, derived from the learning session performed off-line. Nevertheless, the AM matrix can be continuously updated for online learning. The Hamming distances are calculated between the query hypervector and all of hypervectors contained in the AM matrix. This kernel is parallelized at data level as well: the hypervectors are equally distributed among the cores to perform componentwise XOR between the components of the query and the components of the AM, and count the number of mismatches as distances. The AM (5x313) matrix requires 7 kB and is allocated in the L2 memory. Here as well, the data are efficiently transferred from the L2 to L1 memory through the double buffering via the DMA. The total memory requirements for the EMG application, considering 10,000-D hypervectors is around 50 kB, perfectly matching the storage capabilities of the PULPv3 SoC.\n\n\nEXPERIMENTAL SETUP AND RESULTS\n\nWe evaluate our accelerator on an EMG dataset acquired from five subjects [19]. The EMG signals are sampled at 500 Hz from four channels placed on the forearm of the subjects. The dataset includes four common hand gestures: closed hand, open hand, 2finger pinch, and point index. It also includes the rest position between subsequent gestures. The gesture are three second long and each one is repeated 10 times.\n\n\nComparison with SVM on ARM Cortex M4\n\nIn literature, the most used algorithms for EMG gesture recognition are support vector machine (SVMs), linear discriminant analysis (LDA) and k-nearest neighbor (KNN). As shown in [15], through these techniques, SVM yields the highest accuracy. Hence, we first show a comparison between classification accuracy of HD computing and the state-of-the-art SVM [3]. Then, we measure performance and power consumption of specialized serial versions of these two algorithms on a commercial embedded ARM Cortex M4, featuring the most commonly used ISA in the low-power embedded domain.\n\nAs the first step, we implement and validate these two algorithms on MATLAB to establish a golden model to follow. We use an identical setup for both algorithms as presented in [19]; the model training is done per subject and off-line using 25% of the dataset, while the entire dataset is used for testing. The mean classification accuracy of gestures among five subjects is 89.6% with SVM, and 92.4% with the HD classifier. More importantly, the HD classifier exhibits a graceful degradation with lower dimensionality, or faulty components, allowing a trade-off between the application's accuracy and the available hardware resources in a platform [19,20]. We can exploit this graceful degradation capability by reducing the dimensionality of hypervectors that eases the execution on the commercial ARM Cortex M4. To do so, we perform simulations by reducing the dimensionality from 10,000 to 100. The HD classifier closely maintains its accuracy when its dimensionality is reduced from 10,000 to 200, but beyond this point the accuracy is dropped significantly. Therefore, for this experiment, we fix its dimension to 200-D showing a mean accuracy of 90.7%, slightly higher than the SVM. This tuning allows compacting a hypervector to seven unsigned integers, and linearly reduces the number of operations of the HD classifier with no significant impact on its accuracy (i.e., iso-accuracy with SVM). On the other hand, the SVM does not support such a flexibility. A trained model of SVM is composed by a number of support vectors (SVs). This parameter is not determined a priori, and can vary due to several factors such as the scaling of the data, the kernel function, and the level of tolerable miss-classification. Obviously, all this variability requires time to find the best configuration that leads to the smallest number of SVs maintaining the highest accuracy. Hence, a different number of SVs and the dimension of input feature vectors (i.e., the number of channels) induce substantial differences in performance. For this exploration, the dimension of the SVs is fixed to four as the number of input channels, while the number of SVs varies significantly across the model of five subjects, and finally is chosen to be 55 as the smallest among the subjects. This is in sharp contrast to the HD classifier since there is no variability in its model size after choosing its parameters: the dimension of the hypervectors, the N-gram size, and the number of input channels. Table 1 summarizes the performance and accuracy results derived from the serial execution of the two algorithms on the ARM Cortex M4. The CIM, IM, and AM matrices of the HD classifier, and the SVs and coefficients matrices of the SVM, as the trained models, are loaded into the ARM Cortex M4 for testing. For SVM, a fixedpoint approach is used to avoid all the computation needed to be executed in the floating-point. It is already demonstrated [13] that this approach leads to best performance preserving the accuracy. As shown, the HD classifier achieves \u22482\u00d7 faster execution and lower power at iso-accuracy compared to the SVM on the ARM Cortex M4. This is due to the fact that HD classifier mostly uses basic componentwise operations on the hypervectors. In the following, we show how HD classifier can further benefit from our accelerator.\n\n\nHD computing on PULPv3 versus ARM\n\nCortex M4 Table 2 shows the performance and power measurements of the HD computing on the PULPv3 prototype [26] in different operating conditions, and compares it with the ARM Cortex M4, benchmarked on an STM32F4-DISCOVERY board. In this experiment we use 10,000-D to retain to the best accuracy of 92.4%, and accordingly configure the clock frequency of the processors to achieve a detection latency of 10 ms [3,4,10]. The second column of Table 2 shows that with respect to the single-core PULPv3, the ARM Cortex M4 can operate at a lower frequency for the target detection latency, exploiting some optimized instructions that speed up the execution, namely load and shift and load 32-bit immediate. The key features of the PULPv3 SoC exploited in this work are performance-tunable near-threshold computing and parallelism. The 4.9\u00d7 power gap between the ARM Cortex M4 and the single-core PULPv3 power at 0.7 V is partially given by the technology gap (i.e., 90 nm vs. 28 nm), but also by the cluster architecture and its implementation strategy optimized for energy-efficient operation [26]. Significant energy boost can be achieved through parallel computing over the 4 cores of the cluster. This allows to fully exploit the parallel compute power of the cluster and to reduce the operating frequency of the system by 3.72\u00d7 (almost ideal speed-up over 4 cores), which saves significant power, leading to 8.1\u00d7 power reduction with respect to the ARM Cortex M4, at the operating voltage of 0.7V. Finally we exploit the process and temperature compensation capabilities of the SoC to enable aggressive voltage scaling, still reaching the target operating frequency of 14.3 MHz [26]. This key feature of the PULPv3 SoC allows to scale the voltage of the cluster down to 0.5 V, improving energy efficiency and leading to a power reduction of about one order of magnitude (9.9\u00d7) with respect to the ARM Cortex M4. It should be noted that the clock generation subsystem of PULPv3, composed of 2 frequency locked loops (FLL), is not optimized for low-power operation, featuring a reference frequency of 40 MHz and a power consumption of 1,45 mW. This block forms a bottleneck for energy efficiency at low voltage, dominating the overall power of the system. Replacing this block with a new generation FLL optimized for low-power [1] would reduce the clock generation power by 4\u00d7 leading to a further 2\u00d7 reduction of system power, and boosting energy efficiency by \u224820\u00d7 with respect to the ARM Cortex M4. This result motivates us to assess the accelerator with larger workloads, and devise further architectural optimizations.\n\n\nIMPROVED ACCELERATOR AND SCALABILITY\n\nThis section describes how the performance of HD computing can be optimized on a new generation PULP platform (Wolf) featuring an optimized cluster architecture [5] and RISC-V processors enhanced with ISA extensions targeting energy efficient digital signal processing [6]. We also show how our accelerator allows to increase the workload of the processing chain without exceeding a 10 ms detection latency, which is an order of magnitude lower than state-of-the-art systems [3,4,10]. \n\n\nHD Computing on Wolf\n\nWith respect to the PULPv3 architecture, the main architectural improvement of the Wolf cluster include a better scalability (up to 8 processors), an hardware synchronization mechanism which allows to significantly reduce the programming overheads of the OpenMP runtime, fully exploiting the intrinsic parallelism of applications, and an enhanced processor extending the RISC-V ISA with advanced arithmetic operations, that can be inserted in optimized C code adopting built-in functions [6]. The flavor of the dedicated instructions that can be exploited in HD computing mainly include those accelerating for loops and bit manipulation instructions. Indeed, in the processing chain of HD, there are several operations where single bits need to be read/inserted from/into 32-bit words, and where the number of 1's in a 32-bit word needs to be counted. The bit manipulation instructions used to optimize the performance of the application are p.extractu, p.insert and p.cnt. The first and the second built-ins, p.extractu and p.insert, are used respectively to read and set the value assumed by a given bit in an unsigned 32-bit integer variable in a register. The last one, p.cnt, is so-called popcount and gives the number of bits set to 1 in a word. The builtins p.extractu and p.insert are used to further optimize the spacial encoder kernel. In this part of the processing chain after binding each channel to its signal level in the HD space, a componentwise majority is needed to be applied on these bound hypervectors to produce the spatial hypervector, i.e., S t = [(E 1 \u2295V t 1 )+...+(E i \u2295V t i )]. As shown in Fig. 2 (left), the componentwise majority operation needs to extract i components of these hypervectors (i.e., bit-by-bit) and to count the number of bits that are set to 1 for the majority voting. If the number of channels (i) is even, one random but reproducible hypervector is generated, by componentwise XOR between two bound hypervectors, for the majority to break the ties at random. For instance, with four channels, we use five bound hypervectors for the majority, and extract and insert five bits (one bit from every hypervector) in an unsigned integer. Then, we use the popcount (p.cnt) to decide whether the number of bits that are set to 1 is higher than the number of bits that are set to 0. If it holds, we set the related bit (i.e., the same component) to 1 in the spatial hypervector.\n\nThe popcount is used in the AM kernel as well. Here, the Hamming distances between the query hypervector and the prototype hypervectors stored in the AM matrix are computed. To do that, the popcount is applied to all variables that compose the hypervectors after the componentwise XOR operation between the query and the prototype hypervectors. Table 3 shows that 1.23\u00d7 speed-up is achieved by migrating from the single-core PULPv3 to the singlecore Wolf architecture with a general-purpose ANSI-C code, thanks to the optimized RISC-V ISA and compiler. Further 2.3x speedup can be achieved on the Wolf SoC thanks to the support of the specialized instruction extensions that are included in the C code as built-ins (2.8\u00d7 wrt single-core PULPv3).\n\nMoreover, our accelerator linearly benefits from larger number of cores that are available in Wolf. Table 3 also summarizes the execution time in clock cycles of the HD Computing using various number of cores in PULPv3 and Wolf. When a larger number of cores is used, a conspicuous reduction in the execution time is achieved. These results show that the accelerator can scale perfectly among multiple cores (up to 8 cores). In fact, a speed-up of 3.7\u00d7 is obtained by moving execution from single-core to 4 cores on PULPv3, while the implementation on the Wolf cluster gains 6.5\u00d7 speedup, scaling from single-core to 8 cores. The map and encoding kernels present nearly ideal speed-ups, while the AM kernel tends to saturate the improvement. The main reason is that the computational load is small and the OpenMP runtime overhead increasingly degrades the parallel performance. Despite this, the impact on the total gain is negligible.\n\nAs shown in Table 3, the single-core and 8-core Wolf are around 2.8\u00d7 and 18.4\u00d7 faster compared to the single-core PULPv3. These excellent improvements in our accelerator is achieved as a cumulative results of the better ISA, compiler, as well as the built-in extensions on the 8-core Wolf cluster. In the single-core PULPv3, the map and encoding kernels require 92.30% of the overall execution, while the AM kernel takes the remaining computational load (7.70%). In the 8-core Wolf execution with built-in this gap decreases as a result of the saturation in speed-up due to the OpenMP runtime overhead. Hereafter, the exploration and scalability analysis are done on the Wolf.\n\n\nAccelerator Scalability\n\nThe earlier results presented in Section 4 focused on the EMG task with a small number of four channels and an N-gram size of one. However, as we mentioned, for more complex tasks such as EEG classification, a larger number of channels and wider temporal window (i.e., larger N-gram size) are required [21]. Therefore, we assess the scalability of our accelerator by extensively increasing the number of channels up to 256, the N-gram size up to 10 and the dimension of hypervectors up to 10000, showing that the accelerator can be tailored for other type of applications. The dimensionality is related to capacity of hypervectors. Increasing the dimensionality of the hypervectors creates higher capacity for handling more complex tasks, and leads to an overall increase in the number of operations in the processing chain. Fig. 3 demonstrates that increasing the dimension of the hypervectors, for every N-gram size, corresponds to a linear growth of the execution time in terms of number of clock cycles. Hereinafter, the dimension of the hypervectors are fixed to 10,000-D to explore the capability of the accelerator with higher computational requirements for complex tasks. We also evaluate how increasing the size of N-gram from 1 to 10 affects the performance of our accelerator, and how this workload scales among different cores. Fig. 4 demonstrates that the accelerator is  able to scale such excessive workload perfectly among the cores. As shown in Fig. 5, ranging the number of channels from 4 to 256, the clock cycles increases linearly with the number of channels, and our accelerator meets the latency constraint. We should note that the commercial ARM Cortex M4 could not handle such a workload for HD computing: it cannot meet the 10 ms latency constraint when the number of channels is larger than 16. Moreover, a linear increase in the number of channels induces only a linear growth of the the memory footprint (Fig. 5, red line) to store and allocate all the matrices for the HD computing. This is a superb property of HD computing as the memory footprint has a considerable impact on the design of the embedded ultra-low power architectures.\n\n\nCONCLUSION\n\nThis work presents accelerating HD computing on the PULP platform with optimized operations and memory accesses. We show its application on the EMG hand gesture classification that surpasses the state-of-the-art SVM accuracy. For the end-to-end execution of classification, our accelerator in PULPv3 achieves 3.7\u00d7 speed-up and 2\u00d7 energy saving compared to its single-core execution; it also achieves 9.9\u00d7 energy saving compared to the ARM Cortex M4. We further evaluate our accelerator in Wolf that demonstrates nearly ideal speed-up by exploiting bit-manipulation ISA extensions and larger cores: Wolf with single core and 8 cores achieves 2.8\u00d7 and 18.4\u00d7 faster execution compared to the single-core PULPv3. Moreover, we show that increasing the number of input channels to 256, and the length of temporal window to 10 (i.e., the N-gram size) poses only a linear growth in the execution time and the memory footprint that are efficiently handled by our accelerator without exceeding the 10 ms detection latency requirement.\n\nFigure 1 :\n1Parallel processing chain of HD computing. The number of cores n varies from 1 to 8 depending on the target architecture. Empty boxes indicate no memory usage.\n\nFigure 2 :\n2Illustration of how built-ins (p.extractu, p.insert, p.cnt) are used in the spatial encoder (left). A code snippet to show how parallelism is achieved through OpenMP directives in the entire processing chain (right).\n\nFigure 3 :\n3Exploring the dimension of the hypervectors with different large N-grams on Wolf 8 cores with built-in.\n\nFigure 4 :\n4Performance of accelerated HD computing with large N-grams when executing on multiple cores on Wolf with built-in and 10,000-D.\n\nFigure 5 :\n5Performance and memory footprint of accelerated HD computing with increased number of channels on 8 cores Wolf with built-in and 10,000-D .\n\nTable 1 :\n1Comparison of HD computing (200-D) versus SVM at iso-accuracy on ARM Cortex M4. The results refer to a 10 ms detection latency.ARM Cortex M4 \n\nKernel \nCycles(k) Accuracy(%) \nHD COMPUTING \n12.35 \n90.70 \nSVM \n25.10 \n89.60 \n\n\n\nTable 2 :\n2Detailed power (P) comparison of HD algorithm on \nthe ARM Cortex M4 and PULPv3 based on number of cycles \n(CYC) and frequency (FREQ). The results refer to a 10 ms de-\ntection latency. \n\nCYC FREQ FLL P SOC P CLUSTER P TOT. P P BOOST \n[k] [MHz] [mW] [mW] \n[mW] \n[mW] \n[\u00d7] \n\nHD COMPUTING \nARM CORTEX M4@1.85V 439 \n43.90 \n-\n20.83 \nN.A. \n20.83 \n-\nPULPv3 1 CORE@0.7V \n533 \n53.30 \n1.45 \n0.87 \n1.90 \n4.22 \n4.9 \nPULPv3 4 CORES@0.7V 143 \n14.30 \n1.45 \n0.23 \n0.88 \n2.56 \n8.1 \nPULPv3 4 CORES@0.5V 143 \n14.30 \n1.45 \n0.23 \n0.42 \n2.10 \n9.9 \n\n\n\nTable 3 :\n3Performance of accelerated HD computing on \nPULPv3 versus Wolf. Results refer to the execution with \nbuilt-in, 10,000-D, N=1; Cyc, ld, sp stand for cycles, load, and \nspeed-up (sp wrt PULPv3 1 core). \n\nPULPv3 \nPULPv3 \nWolf \nWolf \nWolf \n1 core \n4 cores \n1 core \n1 core built-in \n8 cores built-in \n\nKernel \ncyc(k) \nld(%) cyc(k) sp(\u00d7) cyc(k) sp(\u00d7) cyc(k) sp(\u00d7) cyc(k) \nld(%) sp(\u00d7) \nMAP+ENCODERS \n492 \n92.30 \n129 3.81 \n401 1.23 \n176 \n2.80 \n25 \n86.21 19.68 \nAM \n41 \n7.70 \n14 2.93 \n33 1.24 \n12 \n3.42 \n4 \n13.79 10.25 \nTOTAL \n533 100.00 \n143 3.73 \n434 1.23 \n188 \n2.84 \n29 100.00 18.38 \n\n\nMATLAB code, C code for ARM Cortex M4 and our accelerator are open access at https://github.com/fabio-montagna/PULP-HD\nACKNOWLEDGMENT This work was supported by the European project EuroCPS (grant n. 644090), the ETH Zurich Postdoctoral Fellowship and the Marie Curie Actions for People COFUND programs.\nA wide tuning-range ADFLL for mW-SoCs with ditheringenhanced accuracy in 65 nm CMOS. D Bellasi, 10.1109/ISCAS.2017.80502842017 IEEE International Symposium on Circuits and Systems (ISCAS). 1-4. D. Bellasi et al. 2017. A wide tuning-range ADFLL for mW-SoCs with dithering- enhanced accuracy in 65 nm CMOS. In 2017 IEEE International Symposium on Circuits and Systems (ISCAS). 1-4. https://doi.org/10.1109/ISCAS.2017.8050284\n\nA Versatile Embedded Platform for EMG Acquisition and Gesture Recognition. S Benatti, 10.1109/TBCAS.2015.2476555IEEE Transactions on Biomedical Circuits and Systems. 95S. Benatti et al. 2015. A Versatile Embedded Platform for EMG Acquisition and Gesture Recognition. IEEE Transactions on Biomedical Circuits and Systems 9, 5 (Oct 2015), 620-630. https://doi.org/10.1109/TBCAS.2015.2476555\n\nA Prosthetic Hand Body Area Controller Based on Efficient Pattern Recognition Control Strategies. Simone Benatti, Sensors. 17869Simone Benatti et al. 2017. A Prosthetic Hand Body Area Controller Based on Efficient Pattern Recognition Control Strategies. Sensors 17, 4 (2017), 869.\n\nA Real-Time EMG Pattern Recognition System Based on Linear-Nonlinear Feature Projection for a Multifunction Myoelectric Hand. J U Chu, IEEE Transactions on Biomedical Engineering. 53J. U. Chu et al. 2006. A Real-Time EMG Pattern Recognition System Based on Linear-Nonlinear Feature Projection for a Multifunction Myoelectric Hand. IEEE Transactions on Biomedical Engineering 53, 11 (Nov 2006), 2232-2239.\n\nAn IoT Endpoint System-on-Chip for Secure and Energy-Efficient Near-Sensor Analytics. F Conti, IEEE Transactions on Circuits and Systems I: Regular Papers. 649F. Conti et al. 2017. An IoT Endpoint System-on-Chip for Secure and Energy- Efficient Near-Sensor Analytics. IEEE Transactions on Circuits and Systems I: Regular Papers 64, 9 (Sept 2017), 2481-2494.\n\nNear-Threshold RISC-V Core With DSP Extensions for Scalable IoT Endpoint Devices. Michael Gautschi, IEEE Transactions on Very Large Scale Integration. Michael Gautschi et al. 2017. Near-Threshold RISC-V Core With DSP Exten- sions for Scalable IoT Endpoint Devices. IEEE Transactions on Very Large Scale Integration (VLSI) Systems (2017).\n\nPentti Kanerva, Sparse Distributed Memory. USAMIT PressPentti Kanerva. 1988. Sparse Distributed Memory. MIT Press, USA.\n\nBinary Spatter-Coding of ordered K-tuples. Pentti Kanerva, ICANN'96, Proceedings of the International Conference on Artificial Neural Networks (Lecture Notes in Computer Science). Springer1112Pentti Kanerva. 1996. Binary Spatter-Coding of ordered K-tuples. In ICANN'96, Proceedings of the International Conference on Artificial Neural Networks (Lecture Notes in Computer Science), (Ed.), Vol. 1112. Springer, 869-873.\n\nHyperdimensional Computing: An Introduction to Computing in Distributed Representation with High-Dimensional Random Vectors. Pentti Kanerva, Cognitive Computation. 1Pentti Kanerva. 2009. Hyperdimensional Computing: An Introduction to Com- puting in Distributed Representation with High-Dimensional Random Vectors. Cognitive Computation 1, 2 (2009), 139-159.\n\nReal-time intelligent pattern recognition algorithm for surface EMG signals. Mahdi Khezri, Mehran Jahed, Biomedical engineering online. 645Mahdi Khezri and Mehran Jahed. 2007. Real-time intelligent pattern recognition algorithm for surface EMG signals. Biomedical engineering online 6, 1 (2007), 45.\n\nHyperdimensional computing with 3D VRRAM in-memory kernels: Device-architecture co-design for energy-efficient, error-resilient language recognition. H Li, 10.1109/IEDM.2016.78384282016 IEEE International Electron Devices Meeting. IEDM). 16.1.1-16.1.4.H. Li et al. 2016. Hyperdimensional computing with 3D VRRAM in-memory kernels: Device-architecture co-design for energy-efficient, error-resilient lan- guage recognition. In 2016 IEEE International Electron Devices Meeting (IEDM). 16.1.1-16.1.4. https://doi.org/10.1109/IEDM.2016.7838428\n\nH Li, Resistive RAM-Centric Computing: Design and Modeling Methodology. IEEE Transactions on Circuits and Systems I. H. Li et al. 2017. Resistive RAM-Centric Computing: Design and Modeling Methodology. IEEE Transactions on Circuits and Systems I (Sept 2017).\n\n. F Montagna, Flexible, Scalable and Energy Efficient Bio-Signals Processing on the PULP Platform: A Case Study on Seizure Detection. JLPEA. F. Montagna et al. 2017. Flexible, Scalable and Energy Efficient Bio-Signals Processing on the PULP Platform: A Case Study on Seizure Detection. JLPEA (2017).\n\nLearning Vector Symbolic Architectures for Reactive Robot Behaviours. Peer Neubert, IROS 2016. Peer Neubert et al. 2016. Learning Vector Symbolic Architectures for Reactive Robot Behaviours. In IROS 2016.\n\nSupport vector machine-based classification scheme for myoelectric control applied to upper limb. Mohammadreza Asghari Oskoei, IEEE transactions on biomedical engineering. 55Mohammadreza Asghari Oskoei et al. 2008. Support vector machine-based classi- fication scheme for myoelectric control applied to upper limb. IEEE transactions on biomedical engineering 55, 8 (2008), 1956-1965.\n\nHolographic reduced representations. T A Plate, IEEE Transactions on Neural Networks. 6T.A. Plate. 1995. Holographic reduced representations. IEEE Transactions on Neural Networks 6, 3 (1995), 623-641.\n\nPULP: Parallel Ultra-Low-Power Platform. 2018. PULP: Parallel Ultra-Low-Power Platform. 2018. (2018). www.pulp-platform.org\n\nA Dual Processor Energy-Efficient Platform with Multi-core Accelerator for Smart Sensing. A Pullini, Springer International PublishingChamA. Pullini et al. 2017. A Dual Processor Energy-Efficient Platform with Multi-core Accelerator for Smart Sensing. Springer International Publishing, Cham, 29-40.\n\nHyperdimensional Biosignal Processing: A Case Study for EMG-based Hand Gesture Recognition. Abbas Rahimi, IEEE International Conference on Rebooting Computing. Abbas Rahimi et al. 2016. Hyperdimensional Biosignal Processing: A Case Study for EMG-based Hand Gesture Recognition. In IEEE International Conference on Rebooting Computing.\n\nHigh-Dimensional Computing as a Nanoscalable Paradigm. A Rahimi, IEEE Transactions on Circuits and Systems I: Regular Papers. A. Rahimi et al. 2017. High-Dimensional Computing as a Nanoscalable Paradigm. IEEE Transactions on Circuits and Systems I: Regular Papers (2017).\n\nHyperdimensional Computing for Noninvasive Brain-Computer Interfaces: Blind and One-Shot Classification of EEG Error-Related Potentials. Abbas Rahimi, Abbas Rahimi et al. 2017. Hyperdimensional Computing for Noninvasive Brain- Computer Interfaces: Blind and One-Shot Classification of EEG Error-Related Potentials. BICT (2017).\n\nGenerating Hyperdimensional Distributed Representations from Continuous Valued Multivariate Sensory Input. O Rasanen, Proceedings of the 37th Annual Meeting of the Cognitive Science Society. the 37th Annual Meeting of the Cognitive Science SocietyO. Rasanen. 2015. Generating Hyperdimensional Distributed Representations from Continuous Valued Multivariate Sensory Input. In Proceedings of the 37th Annual Meeting of the Cognitive Science Society. 1943-1948.\n\nModeling Dependencies in Multiple Parallel Data Streams with Hyperdimensional Computing. O Rasanen, IEEE Signal Processing Letters. O. Rasanen et al. 2014. Modeling Dependencies in Multiple Parallel Data Streams with Hyperdimensional Computing. IEEE Signal Processing Letters (2014).\n\nSequence Prediction With Sparse Distributed Hyperdimensional Coding Applied to the Analysis of Mobile Phone Use Patterns. O Rasanen, J Saarinen, IEEE Transactions on Neural Networks and Learning Systems PP. O. Rasanen and J. Saarinen. 2015. Sequence Prediction With Sparse Distributed Hyperdimensional Coding Applied to the Analysis of Mobile Phone Use Patterns. IEEE Transactions on Neural Networks and Learning Systems PP, 99 (2015), 1-12.\n\nPULP: A parallel ultra low power platform for next generation IoT applications. D Rossi, Hot Chips 27 Symposium (HCS). IEEED. Rossi et al. 2015. PULP: A parallel ultra low power platform for next generation IoT applications. In Hot Chips 27 Symposium (HCS), 2015. IEEE, 1-39.\n\nA Self-Aware Architecture for PVT Compensation and Power Nap in Near Threshold Processors. D Rossi, IEEE Design Test. 346D. Rossi et al. 2017. A Self-Aware Architecture for PVT Compensation and Power Nap in Near Threshold Processors. IEEE Design Test 34, 6 (Dec 2017), 46-53.\n", "annotations": {"author": "[{\"end\":172,\"start\":106},{\"end\":237,\"start\":173},{\"end\":304,\"start\":238},{\"end\":372,\"start\":305},{\"end\":459,\"start\":373}]", "publisher": null, "author_last_name": "[{\"end\":120,\"start\":112},{\"end\":185,\"start\":179},{\"end\":252,\"start\":245},{\"end\":320,\"start\":318},{\"end\":384,\"start\":378}]", "author_first_name": "[{\"end\":111,\"start\":106},{\"end\":178,\"start\":173},{\"end\":244,\"start\":238},{\"end\":311,\"start\":305},{\"end\":317,\"start\":312},{\"end\":377,\"start\":373}]", "author_affiliation": "[{\"end\":171,\"start\":122},{\"end\":236,\"start\":187},{\"end\":303,\"start\":254},{\"end\":371,\"start\":322},{\"end\":458,\"start\":409}]", "title": "[{\"end\":103,\"start\":1},{\"end\":562,\"start\":460}]", "venue": null, "abstract": "[{\"end\":1765,\"start\":564}]", "bib_ref": "[{\"attributes\":{\"ref_id\":\"b6\"},\"end\":1934,\"start\":1931},{\"attributes\":{\"ref_id\":\"b8\"},\"end\":1936,\"start\":1934},{\"attributes\":{\"ref_id\":\"b15\"},\"end\":1939,\"start\":1936},{\"attributes\":{\"ref_id\":\"b8\"},\"end\":2008,\"start\":2005},{\"attributes\":{\"ref_id\":\"b8\"},\"end\":2464,\"start\":2461},{\"attributes\":{\"ref_id\":\"b8\"},\"end\":2760,\"start\":2757},{\"attributes\":{\"ref_id\":\"b19\"},\"end\":3031,\"start\":3027},{\"attributes\":{\"ref_id\":\"b15\"},\"end\":3169,\"start\":3165},{\"attributes\":{\"ref_id\":\"b10\"},\"end\":3197,\"start\":3193},{\"attributes\":{\"ref_id\":\"b11\"},\"end\":3200,\"start\":3197},{\"attributes\":{\"ref_id\":\"b21\"},\"end\":3229,\"start\":3225},{\"attributes\":{\"ref_id\":\"b22\"},\"end\":3398,\"start\":3394},{\"attributes\":{\"ref_id\":\"b23\"},\"end\":3478,\"start\":3474},{\"attributes\":{\"ref_id\":\"b13\"},\"end\":3512,\"start\":3508},{\"attributes\":{\"ref_id\":\"b18\"},\"end\":3637,\"start\":3633},{\"attributes\":{\"ref_id\":\"b20\"},\"end\":3682,\"start\":3678},{\"attributes\":{\"ref_id\":\"b16\"},\"end\":4400,\"start\":4396},{\"attributes\":{\"ref_id\":\"b24\"},\"end\":4540,\"start\":4536},{\"attributes\":{\"ref_id\":\"b25\"},\"end\":4849,\"start\":4845},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":5970,\"start\":5967},{\"attributes\":{\"ref_id\":\"b5\"},\"end\":6429,\"start\":6426},{\"attributes\":{\"ref_id\":\"b6\"},\"end\":7412,\"start\":7409},{\"attributes\":{\"ref_id\":\"b8\"},\"end\":7414,\"start\":7412},{\"attributes\":{\"ref_id\":\"b7\"},\"end\":7729,\"start\":7726},{\"attributes\":{\"ref_id\":\"b18\"},\"end\":9417,\"start\":9413},{\"attributes\":{\"ref_id\":\"b18\"},\"end\":9892,\"start\":9888},{\"attributes\":{\"ref_id\":\"b20\"},\"end\":9895,\"start\":9892},{\"attributes\":{\"ref_id\":\"b20\"},\"end\":11236,\"start\":11232},{\"attributes\":{\"ref_id\":\"b18\"},\"end\":11844,\"start\":11840},{\"attributes\":{\"ref_id\":\"b19\"},\"end\":11848,\"start\":11844},{\"attributes\":{\"ref_id\":\"b20\"},\"end\":11852,\"start\":11848},{\"attributes\":{\"ref_id\":\"b25\"},\"end\":12181,\"start\":12177},{\"attributes\":{\"ref_id\":\"b17\"},\"end\":12887,\"start\":12883},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":14674,\"start\":14671},{\"attributes\":{\"ref_id\":\"b18\"},\"end\":18553,\"start\":18549},{\"attributes\":{\"ref_id\":\"b14\"},\"end\":19112,\"start\":19108},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":19287,\"start\":19284},{\"attributes\":{\"ref_id\":\"b18\"},\"end\":19688,\"start\":19684},{\"attributes\":{\"ref_id\":\"b18\"},\"end\":20160,\"start\":20156},{\"attributes\":{\"ref_id\":\"b19\"},\"end\":20163,\"start\":20160},{\"attributes\":{\"ref_id\":\"b12\"},\"end\":22439,\"start\":22435},{\"attributes\":{\"ref_id\":\"b25\"},\"end\":22983,\"start\":22979},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":23285,\"start\":23282},{\"attributes\":{\"ref_id\":\"b3\"},\"end\":23287,\"start\":23285},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":23290,\"start\":23287},{\"attributes\":{\"ref_id\":\"b25\"},\"end\":23965,\"start\":23961},{\"attributes\":{\"ref_id\":\"b25\"},\"end\":24554,\"start\":24550},{\"attributes\":{\"ref_id\":\"b0\"},\"end\":25200,\"start\":25197},{\"attributes\":{\"ref_id\":\"b4\"},\"end\":25698,\"start\":25695},{\"attributes\":{\"ref_id\":\"b5\"},\"end\":25806,\"start\":25803},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":26012,\"start\":26009},{\"attributes\":{\"ref_id\":\"b3\"},\"end\":26014,\"start\":26012},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":26017,\"start\":26014},{\"attributes\":{\"ref_id\":\"b5\"},\"end\":26535,\"start\":26532},{\"attributes\":{\"ref_id\":\"b20\"},\"end\":31159,\"start\":31155}]", "figure": "[{\"attributes\":{\"id\":\"fig_0\"},\"end\":34230,\"start\":34058},{\"attributes\":{\"id\":\"fig_1\"},\"end\":34460,\"start\":34231},{\"attributes\":{\"id\":\"fig_2\"},\"end\":34577,\"start\":34461},{\"attributes\":{\"id\":\"fig_3\"},\"end\":34718,\"start\":34578},{\"attributes\":{\"id\":\"fig_4\"},\"end\":34871,\"start\":34719},{\"attributes\":{\"id\":\"tab_0\",\"type\":\"table\"},\"end\":35106,\"start\":34872},{\"attributes\":{\"id\":\"tab_1\",\"type\":\"table\"},\"end\":35645,\"start\":35107},{\"attributes\":{\"id\":\"tab_2\",\"type\":\"table\"},\"end\":36237,\"start\":35646}]", "paragraph": "[{\"end\":3032,\"start\":1781},{\"end\":3850,\"start\":3034},{\"end\":4587,\"start\":3852},{\"end\":6218,\"start\":4589},{\"end\":6738,\"start\":6220},{\"end\":6918,\"start\":6740},{\"end\":7160,\"start\":6933},{\"end\":7884,\"start\":7196},{\"end\":8777,\"start\":7886},{\"end\":10019,\"start\":8779},{\"end\":10433,\"start\":10021},{\"end\":10974,\"start\":10481},{\"end\":11237,\"start\":11028},{\"end\":11952,\"start\":11239},{\"end\":12687,\"start\":11997},{\"end\":13508,\"start\":12689},{\"end\":14612,\"start\":13546},{\"end\":15697,\"start\":14614},{\"end\":16387,\"start\":15699},{\"end\":16993,\"start\":16389},{\"end\":17439,\"start\":16995},{\"end\":18440,\"start\":17441},{\"end\":18887,\"start\":18475},{\"end\":19505,\"start\":18928},{\"end\":22834,\"start\":19507},{\"end\":25493,\"start\":22872},{\"end\":26019,\"start\":25534},{\"end\":28463,\"start\":26044},{\"end\":29210,\"start\":28465},{\"end\":30147,\"start\":29212},{\"end\":30825,\"start\":30149},{\"end\":33018,\"start\":30853},{\"end\":34057,\"start\":33033}]", "formula": "[{\"attributes\":{\"id\":\"formula_0\"},\"end\":10480,\"start\":10434},{\"attributes\":{\"id\":\"formula_1\"},\"end\":11027,\"start\":10975}]", "table_ref": "[{\"attributes\":{\"ref_id\":\"tab_0\"},\"end\":21997,\"start\":21990},{\"attributes\":{\"ref_id\":\"tab_1\"},\"end\":22889,\"start\":22882},{\"attributes\":{\"ref_id\":\"tab_1\"},\"end\":23320,\"start\":23313},{\"attributes\":{\"ref_id\":\"tab_2\"},\"end\":28817,\"start\":28810},{\"attributes\":{\"ref_id\":\"tab_2\"},\"end\":29319,\"start\":29312},{\"attributes\":{\"ref_id\":\"tab_2\"},\"end\":30168,\"start\":30161}]", "section_header": "[{\"attributes\":{\"n\":\"1\"},\"end\":1779,\"start\":1767},{\"attributes\":{\"n\":\"2\"},\"end\":6931,\"start\":6921},{\"attributes\":{\"n\":\"2.1\"},\"end\":7194,\"start\":7163},{\"attributes\":{\"n\":\"2.2\"},\"end\":11995,\"start\":11955},{\"attributes\":{\"n\":\"3\"},\"end\":13544,\"start\":13511},{\"attributes\":{\"n\":\"4\"},\"end\":18473,\"start\":18443},{\"attributes\":{\"n\":\"4.1\"},\"end\":18926,\"start\":18890},{\"attributes\":{\"n\":\"4.2\"},\"end\":22870,\"start\":22837},{\"attributes\":{\"n\":\"5\"},\"end\":25532,\"start\":25496},{\"attributes\":{\"n\":\"5.1\"},\"end\":26042,\"start\":26022},{\"attributes\":{\"n\":\"5.2\"},\"end\":30851,\"start\":30828},{\"attributes\":{\"n\":\"6\"},\"end\":33031,\"start\":33021},{\"end\":34069,\"start\":34059},{\"end\":34242,\"start\":34232},{\"end\":34472,\"start\":34462},{\"end\":34589,\"start\":34579},{\"end\":34730,\"start\":34720},{\"end\":34882,\"start\":34873},{\"end\":35117,\"start\":35108},{\"end\":35656,\"start\":35647}]", "table": "[{\"end\":35106,\"start\":35011},{\"end\":35645,\"start\":35119},{\"end\":36237,\"start\":35658}]", "figure_caption": "[{\"end\":34230,\"start\":34071},{\"end\":34460,\"start\":34244},{\"end\":34577,\"start\":34474},{\"end\":34718,\"start\":34591},{\"end\":34871,\"start\":34732},{\"end\":35011,\"start\":34884}]", "figure_ref": "[{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":14258,\"start\":14252},{\"attributes\":{\"ref_id\":\"fig_0\"},\"end\":15104,\"start\":15098},{\"attributes\":{\"ref_id\":\"fig_1\"},\"end\":16083,\"start\":16077},{\"attributes\":{\"ref_id\":\"fig_1\"},\"end\":27676,\"start\":27663},{\"attributes\":{\"ref_id\":\"fig_2\"},\"end\":31684,\"start\":31678},{\"attributes\":{\"ref_id\":\"fig_3\"},\"end\":32199,\"start\":32193},{\"attributes\":{\"ref_id\":\"fig_4\"},\"end\":32321,\"start\":32315},{\"attributes\":{\"ref_id\":\"fig_4\"},\"end\":32793,\"start\":32786}]", "bib_author_first_name": "[{\"end\":36628,\"start\":36627},{\"end\":37042,\"start\":37041},{\"end\":37460,\"start\":37454},{\"end\":37765,\"start\":37764},{\"end\":37767,\"start\":37766},{\"end\":38131,\"start\":38130},{\"end\":38492,\"start\":38485},{\"end\":38748,\"start\":38742},{\"end\":38912,\"start\":38906},{\"end\":39413,\"start\":39407},{\"end\":39723,\"start\":39718},{\"end\":39738,\"start\":39732},{\"end\":40093,\"start\":40092},{\"end\":40484,\"start\":40483},{\"end\":40746,\"start\":40745},{\"end\":41118,\"start\":41114},{\"end\":41673,\"start\":41672},{\"end\":41675,\"start\":41674},{\"end\":42053,\"start\":42052},{\"end\":42360,\"start\":42355},{\"end\":42655,\"start\":42654},{\"end\":43014,\"start\":43009},{\"end\":43309,\"start\":43308},{\"end\":43751,\"start\":43750},{\"end\":44069,\"start\":44068},{\"end\":44080,\"start\":44079},{\"end\":44470,\"start\":44469},{\"end\":44758,\"start\":44757}]", "bib_author_last_name": "[{\"end\":36636,\"start\":36629},{\"end\":37050,\"start\":37043},{\"end\":37468,\"start\":37461},{\"end\":37771,\"start\":37768},{\"end\":38137,\"start\":38132},{\"end\":38501,\"start\":38493},{\"end\":38756,\"start\":38749},{\"end\":38920,\"start\":38913},{\"end\":39421,\"start\":39414},{\"end\":39730,\"start\":39724},{\"end\":39744,\"start\":39739},{\"end\":40096,\"start\":40094},{\"end\":40487,\"start\":40485},{\"end\":40755,\"start\":40747},{\"end\":41126,\"start\":41119},{\"end\":41375,\"start\":41348},{\"end\":41681,\"start\":41676},{\"end\":42061,\"start\":42054},{\"end\":42367,\"start\":42361},{\"end\":42662,\"start\":42656},{\"end\":43021,\"start\":43015},{\"end\":43317,\"start\":43310},{\"end\":43759,\"start\":43752},{\"end\":44077,\"start\":44070},{\"end\":44089,\"start\":44081},{\"end\":44476,\"start\":44471},{\"end\":44764,\"start\":44759}]", "bib_entry": "[{\"attributes\":{\"doi\":\"10.1109/ISCAS.2017.8050284\",\"id\":\"b0\"},\"end\":36964,\"start\":36542},{\"attributes\":{\"doi\":\"10.1109/TBCAS.2015.2476555\",\"id\":\"b1\",\"matched_paper_id\":9243959},\"end\":37354,\"start\":36966},{\"attributes\":{\"id\":\"b2\",\"matched_paper_id\":20872387},\"end\":37636,\"start\":37356},{\"attributes\":{\"id\":\"b3\",\"matched_paper_id\":9963931},\"end\":38042,\"start\":37638},{\"attributes\":{\"id\":\"b4\",\"matched_paper_id\":1003711},\"end\":38401,\"start\":38044},{\"attributes\":{\"id\":\"b5\",\"matched_paper_id\":4928383},\"end\":38740,\"start\":38403},{\"attributes\":{\"id\":\"b6\"},\"end\":38861,\"start\":38742},{\"attributes\":{\"id\":\"b7\",\"matched_paper_id\":12261165},\"end\":39280,\"start\":38863},{\"attributes\":{\"id\":\"b8\",\"matched_paper_id\":733980},\"end\":39639,\"start\":39282},{\"attributes\":{\"id\":\"b9\",\"matched_paper_id\":237400},\"end\":39940,\"start\":39641},{\"attributes\":{\"doi\":\"10.1109/IEDM.2016.7838428\",\"id\":\"b10\",\"matched_paper_id\":25209638},\"end\":40481,\"start\":39942},{\"attributes\":{\"id\":\"b11\"},\"end\":40741,\"start\":40483},{\"attributes\":{\"id\":\"b12\"},\"end\":41042,\"start\":40743},{\"attributes\":{\"id\":\"b13\",\"matched_paper_id\":53060237},\"end\":41248,\"start\":41044},{\"attributes\":{\"id\":\"b14\",\"matched_paper_id\":17162934},\"end\":41633,\"start\":41250},{\"attributes\":{\"id\":\"b15\",\"matched_paper_id\":2352281},\"end\":41835,\"start\":41635},{\"attributes\":{\"id\":\"b16\"},\"end\":41960,\"start\":41837},{\"attributes\":{\"id\":\"b17\"},\"end\":42261,\"start\":41962},{\"attributes\":{\"id\":\"b18\",\"matched_paper_id\":12008695},\"end\":42597,\"start\":42263},{\"attributes\":{\"id\":\"b19\",\"matched_paper_id\":10569020},\"end\":42870,\"start\":42599},{\"attributes\":{\"id\":\"b20\"},\"end\":43199,\"start\":42872},{\"attributes\":{\"id\":\"b21\",\"matched_paper_id\":15600360},\"end\":43659,\"start\":43201},{\"attributes\":{\"id\":\"b22\",\"matched_paper_id\":1690456},\"end\":43944,\"start\":43661},{\"attributes\":{\"id\":\"b23\",\"matched_paper_id\":15258913},\"end\":44387,\"start\":43946},{\"attributes\":{\"id\":\"b24\",\"matched_paper_id\":29024343},\"end\":44664,\"start\":44389},{\"attributes\":{\"id\":\"b25\",\"matched_paper_id\":10664789},\"end\":44941,\"start\":44666}]", "bib_title": "[{\"end\":36625,\"start\":36542},{\"end\":37039,\"start\":36966},{\"end\":37452,\"start\":37356},{\"end\":37762,\"start\":37638},{\"end\":38128,\"start\":38044},{\"end\":38483,\"start\":38403},{\"end\":38904,\"start\":38863},{\"end\":39405,\"start\":39282},{\"end\":39716,\"start\":39641},{\"end\":40090,\"start\":39942},{\"end\":41112,\"start\":41044},{\"end\":41346,\"start\":41250},{\"end\":41670,\"start\":41635},{\"end\":41876,\"start\":41837},{\"end\":42353,\"start\":42263},{\"end\":42652,\"start\":42599},{\"end\":43306,\"start\":43201},{\"end\":43748,\"start\":43661},{\"end\":44066,\"start\":43946},{\"end\":44467,\"start\":44389},{\"end\":44755,\"start\":44666}]", "bib_author": "[{\"end\":36638,\"start\":36627},{\"end\":37052,\"start\":37041},{\"end\":37470,\"start\":37454},{\"end\":37773,\"start\":37764},{\"end\":38139,\"start\":38130},{\"end\":38503,\"start\":38485},{\"end\":38758,\"start\":38742},{\"end\":38922,\"start\":38906},{\"end\":39423,\"start\":39407},{\"end\":39732,\"start\":39718},{\"end\":39746,\"start\":39732},{\"end\":40098,\"start\":40092},{\"end\":40489,\"start\":40483},{\"end\":40757,\"start\":40745},{\"end\":41128,\"start\":41114},{\"end\":41377,\"start\":41348},{\"end\":41683,\"start\":41672},{\"end\":42063,\"start\":42052},{\"end\":42369,\"start\":42355},{\"end\":42664,\"start\":42654},{\"end\":43023,\"start\":43009},{\"end\":43319,\"start\":43308},{\"end\":43761,\"start\":43750},{\"end\":44079,\"start\":44068},{\"end\":44091,\"start\":44079},{\"end\":44478,\"start\":44469},{\"end\":44766,\"start\":44757}]", "bib_venue": "[{\"end\":36734,\"start\":36664},{\"end\":37130,\"start\":37078},{\"end\":37477,\"start\":37470},{\"end\":37816,\"start\":37773},{\"end\":38198,\"start\":38139},{\"end\":38552,\"start\":38503},{\"end\":38783,\"start\":38758},{\"end\":39041,\"start\":38922},{\"end\":39444,\"start\":39423},{\"end\":39775,\"start\":39746},{\"end\":40171,\"start\":40123},{\"end\":40598,\"start\":40489},{\"end\":40882,\"start\":40757},{\"end\":41137,\"start\":41128},{\"end\":41420,\"start\":41377},{\"end\":41719,\"start\":41683},{\"end\":41882,\"start\":41878},{\"end\":42050,\"start\":41962},{\"end\":42421,\"start\":42369},{\"end\":42723,\"start\":42664},{\"end\":43007,\"start\":42872},{\"end\":43390,\"start\":43319},{\"end\":43791,\"start\":43761},{\"end\":44151,\"start\":44091},{\"end\":44506,\"start\":44478},{\"end\":44782,\"start\":44766},{\"end\":38788,\"start\":38785},{\"end\":43448,\"start\":43392}]"}}}, "year": 2023, "month": 12, "day": 17}