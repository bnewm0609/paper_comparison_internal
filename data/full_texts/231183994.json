{"id": 231183994, "updated": "2022-01-03 14:40:42.432", "metadata": {"title": "In-fat pointer: hardware-assisted tagged-pointer spatial memory safety defense with subobject granularity protection", "authors": "[{\"middle\":[],\"last\":\"Xu\",\"first\":\"Shengjie\"},{\"middle\":[],\"last\":\"Huang\",\"first\":\"Wei\"},{\"middle\":[],\"last\":\"Lie\",\"first\":\"David\"}]", "venue": null, "journal": "Proceedings of the 26th ACM International Conference on Architectural Support for Programming Languages and Operating Systems", "publication_date": {"year": 2021, "month": null, "day": null}, "abstract": "Programming languages like C and C++ are not memory-safe because they provide programmers with low-level pointer manipulation primitives. The incorrect use of these primitives can result in bugs and security vulnerabilities: for example, spatial memory safety errors can be caused by dereferencing pointers outside the legitimate address range belonging to the corresponding object. While a range of schemes to provide protection against these vulnerabilities have been proposed, they all suffer from the lack of one or more of low performance overhead, compatibility with legacy code, or comprehensive protection for all objects and subobjects. We present In-Fat Pointer, the first hardware-assisted defense that can achieve spatial memory safety at subobject granularity while maintaining compatibility with legacy code and low overhead. In-Fat Pointer improves the protection granularity of tagged-pointer schemes using object metadata, which is efficient and binary-compatible for object-bound spatial safety. Unlike previous work that devotes all pointer tag bits to object metadata lookup, In-Fat Pointer uses three complementary object metadata schemes to reduce the number pointer tag bits needed for metadata lookup, allowing it to use the left-over bits, along with in-memory type metadata, to refine the object bounds to subobject granularity. We show that this approach provides practical protection of fine-grained spatial memory safety.", "fields_of_study": "[\"Computer Science\"]", "external_ids": {"arxiv": null, "mag": null, "acl": null, "pubmed": null, "pubmedcentral": null, "dblp": "conf/asplos/Xu0L21", "doi": "10.1145/3445814.3446761"}}, "content": {"source": {"pdf_hash": "7c08a0a2abce7874f5232807372bb987abd84d4b", "pdf_src": "ACM", "pdf_uri": null, "oa_url_match": false, "oa_info": {"license": null, "open_access_url": "https://dl.acm.org/doi/pdf/10.1145/3445814.3446761", "status": "BRONZE"}}, "grobid": {"id": "c024c392006de69d3f3fe10a24820205c952bf1d", "type": "plain-text", "url": "s3://ai2-s2-pdf-extraction-prod/parse-results/s2orc_worker/7c08a0a2abce7874f5232807372bb987abd84d4b.txt", "contents": "\nIn-Fat Pointer: Hardware-Assisted Tagged-Pointer Spatial Memory Safety Defense with Subobject Granularity Protection\nApril 19\u015b23, 2021\n\nShengjie Xu shengjie.xu@mail.utoronto.ca \nUniversity of Toronto\nCanada\n\nWei Huang wh.huang@mail.utoronto.ca \nUniversity of Toronto\nCanada\n\nDavid Lie lie@eecg.toronto.edu \nUniversity of Toronto\nCanada\n\nIn-Fat Pointer: Hardware-Assisted Tagged-Pointer Spatial Memory Safety Defense with Subobject Granularity Protection\n\nASPLOS '21\nVirtual, USAApril 19\u015b23, 202110.1145/3445814.3446761ACM Reference Format: Shengjie Xu, Wei Huang, and David Lie. 2021. In-Fat Pointer: Hardware-Assisted Tagged-Pointer Spatial Memory Safety Defense with Subobject Granularity Protection. In Proceedings of the 26th ACM International Con-ference on Architectural Support for Programming Languages and Operating Systems (ASPLOS '21), April 19\u015b23, 2021, Virtual, USA. ACM, New York, NY, USA, 17 pages. https://Memory SafetySpatial Memory ErrorsBuffer O verflowsSub- object Bound CheckingBound CheckingTagged-pointerObject Metadata\nProgramming languages like C and C++ are not memory-safe because they provide programmers with low-level pointer manipulation primitives. The incorrect use of these primitives can result in bugs and security vulnerabilities: for example, spatial memory safety errors can be caused by dereferencing pointers outside the legitimate address range belonging to the corresponding object. While a range of schemes to provide protection against these vulnerabilities have been proposed, they all suffer from the lack of one or more of low performance overhead, compatibility with legacy code, or comprehensive protection for all objects and subobjects.We present In-Fat Pointer, the first hardware-assisted defense that can achieve spatial memory safety at subobject granularity while maintaining compatibility with legacy code and low overhead. In-Fat Pointer improves the protection granularity of taggedpointer schemes using object metadata, which is efficient and binarycompatible for object-bound spatial safety. Unlike previous work that devotes all pointer tag bits to object metadata lookup, In-Fat Pointer uses three complementary object metadata schemes to reduce the number pointer tag bits needed for metadata lookup, allowing it to use the left-over bits, along with in-memory type metadata, to refine the object bounds to subobject granularity. We show that this approach provides practical protection of fine-grained spatial memory safety.CCS CONCEPTS\u00b7 Security and privacy \u2192 Hardware security implementation; Software and application security; Systems security.\n\nINTRODUCTION\n\nMemory corruption vulnerabilities in programs written in nonmemory-safe programming languages like C and C++ have been a research focus for more than a decade [40]. When a pointer is dereferenced, errors, causing memory-safety violations, can result in the unintended disclosure or corruption of memory. Such errors are a powerful primitive for attackers to mount further attacks, such as code reuse attacks [34] and data-only attacks [18]. Memorysafety violations usually result from spatial memory errors, where incorrect pointer arithmetic causes an address to point outside the intended memory range when it is dereferenced.\n\nTo detect all spatial memory errors, the value of the pointer must be checked against pointer bounds, which are metadata that describes the memory range over which the pointer may safely point [40]. Traditional fat-pointer schemes are able to maintain full, fine-grained bounds, by either storing these bounds in a separate memory region (i.e., out-of-band), which incurs 50% or higher performance and memory overhead on average with high (sometimes an order of magnitude) variance depending on the program [10,29,32]; or inline with the pointer, which changes the memory layout and loses pointer-size compatibility with legacy code [42]. Therefore, more recent work explores coarse-grained spatial protection approaches [5,24,30,36,38], but must still trade-off protection granularity, compatibility, and efficiency. As a result, none of these approaches are able to achieve spatial protection at the same granularity as fat-pointers without losing compatibility or efficiency.\n\nIn this work, we propose In-Fat Pointer, a hardware-assisted spatial memory defense that provides fine-grained protection on-par with traditional fat-pointer schemes but preserves compatibility and efficiency. To provide pointer-size compatibility with legacy code without storing pointer metadata in a separate region, In-Fat Pointer employs a tagged-pointer scheme, which uses the unused upper bits (which we call the tag) on the pointer [24]. Because the size of the tag (usually 16 bits or less) is too small to store full metadata, In-Fat Pointer follows the approach used in previous work [5,14,22,30] which uses the tag to facilitate lookups to perobject metadata stored in memory. However, previous work using this approach alone can only provide object-granularity protection and cannot detect intra-object overflow as fat-pointer schemes would. Considering the short code example in Listing 1. Such a scheme may detect overflow from vulnerable array at Line 2 only if the overflow corrupts memory outside of struct S, while a finergrained scheme providing subobject-granularity 1 protection should also detect intra-object overflow that corrupts the sensitive subobject at Line 3. To achieve this protection granularity, the pointer 1 struct S { 2 char vulnerable [12]; /* attacker can overflow */ 3 char sensitive [12]; 4 };\n\nListing 1: Simple Intra-object Overflow Example bounds must be maintained as per-pointer metadata 2 so that, for example, when a pointer to struct S derives another pointer to vulnerable, the bounds of the derived pointer can be narrowed to exactly cover vulnerable without affecting the source pointer. Therefore, In-Fat Pointer needs to find an efficient way to (1) compactly represent the subobject bounds on pointer tags, and (2) save pointer tag bits from object metadata lookup to be used for bounds narrowing operations.\n\nTo address the two challenges, In-Fat Pointer utilizes two key techniques. First, In-Fat Pointer efficiently narrows the object bounds to that of a subobject by (1) identifying which subobject the narrowed pointer points to using per-pointer metadata in the tag and (2) using per-type metadata indexed by subobject to compute the subobject bounds. Second, by designing multiple object metadata schemes with each scheme for one category of objects, In-Fat Pointer can devote fewer bits to object metadata lookup (and therefore more bits for subobject information) without losing efficiency, as opposed to previous approaches that devote all pointer tag bits to object metadata lookup.\n\nTo the best of our knowledge, In-Fat Pointer is the first hardwarebased spatial memory defense using a tagged-pointer approach that is able to protect against intra-object overflow while maintaining the same pointer size as legacy code. We show that with these approaches combined, In-Fat Pointer can provide spatial memory safety comparable with fat pointer schemes while preserving compatibility and low overhead. This paper makes the following contributions:\n\n\u2022 We present the design and implementation of In-Fat Pointer, a hardware-assisted tagged-pointer scheme that provides subobject-granularity spatial memory protection. We describe how In-Fat Pointer uses hardware-software co-design to enforce fine-grained spatial memory safety with binary compatibility with legacy code and low overhead. \u2022 We describe three complementary metadata schemes used by In-Fat Pointer. We show that by designing separate object metadata schemes for each category of objects, the three In-Fat Pointer schemes reduce consumption of precious pointer tag bits without losing efficiency. \u2022 We describe the subobject bounds narrowing mechanism that In-Fat Pointer uses to refine the object bounds to subobject granularity during pointer bounds retrieval. \u2022 We implement an In-Fat Pointer prototype on an FPGA. We evaluate its ability to detect memory safety violations using the Juliet test suite, and performance and memory overhead against a set of application benchmarks.\n\n\nBACKGROUND AND RELATED WORK\n\nBecause pointer safety cannot always be determined at compile time, all defenses enforcing spatial memory safety introduce additional metadata and dynamic checks into the program to verify that memory accesses are safe. Table 1 summarizes previous work in this area. There is a large design space on possible metadata and assertions, which results in varying protection granularity and limitations, including loss of compatibility and dependence on hardware or software features. We group the related work into (1) fat-pointer schemes, (2) object-based schemes, (3) memory-based schemes, and (4) tagged-pointer schemes in the table according to the subject of introduced in-memory metadata and the use of tagged-pointer. Note that while the use of tagged-pointer is orthogonal to the use of in-memory metadata, all schemes using tagged-pointers in their designs are considered tagged-pointer schemes in this section. Because the only way to detect all spatial memory errors is to associate pointer bounds to pointers and perform bounds checking [40], and retrieving and maintaining pointer bounds tends to contribute most to the cost of spatial safety enforcement [32], when discussing related works that enforce object-or subobjectgranularity protection, we focus on the schemes used for pointer bounds retrieval and maintenance.\n\n\nFat-Pointer Schemes\n\nTraditional fat-pointer schemes maintain persistent 3 per-pointer bounds throughout the lifetime of a pointer, and then check the pointer against the bounds when it is dereferenced. Such pointerbased schemes can detect overflows at the subobject level: when a pointer to an object derives a pointer to one of the subobjects, for example, by taking the address of a struct member, the bounds for the derived pointer can be narrowed to stop overflow that would corrupt other struct members. To maintain the bounds (and additional metadata if any) with the pointer, the most straightforward way is to store them along with the pointer itself [9,42], thus increasing the apparent size of the pointer. For example, CHERI [42] extends each 64-bit pointer to a capability pointer, which includes permissions and bounds information and is 256 bits in the worst case. However, storing metadata with the pointer has two drawbacks: (1) it increases memory overhead as each pointer is increased in size, and (2) it creates binary incompatibility between the instrumented code and legacy code that makes assumptions about the size of pointers. Another approach is to store all the metadata in a shadow memory, where the scheme can use the address of a pointer to compute the address of its metadata. For example, Hard-Bound [10] manages pointer bounds in a direct-mapped shadow memory that is logically twice the size as the address space, while Intel MPX [32] manages them in a two-level directory structure to relax the constraint on virtual address space layout. Unfortunately, storing metadata separately impacts performance, as the locality of the metadata with the pointer is lost and the shadow memory address computation can be costly.\n\nPer-pointer bounds can also be extended with additional metadata to enforce other memory-related security properties. Watch-dogLite [28], Shakti-MS [9], and ALEXIA [21] can detect temporal The scheme uses tagged-pointers. 1 Whether the work can detect spatial memory errors at the bounds of the subobject (Subobject), at the bounds of the object (Object), or the detection is conditional or probabilistic (Partial). 2 Whether the work increases pointer size and loses binary compatibility ( B \u25cb) or requires source code change ( S \u25cb) 3 Whether the work requires a shadow memory( S \u25cb) (can be either software-based or hardware-based) that either grows with the number of metadata subjects or reserves a fixed percentage of memory in the virtual address space, or a hardware-based tagged memory( T \u25cb) [19] 4 BaggyBound describes (1) a 32-bit system design that uses shadow memory for in-memory bounds table, and (2) a 64-bit system implementation that uses tagged-pointers to store bounds on pointer tags. memory errors, for example, when a dangling pointer is dereferenced. They use a lock-and-key approach, where the metadata for each pointer also carries a value as \u0142key\u017e that is required to match with the \u0142lock\u017e value from per-object metadata when dereferencing.\n\n\nObject-Based and Memory-Based Schemes\n\nObject-based schemes maintain per-object metadata in memory, either along with the objects they describe, or with a 1-to-1 mapping from the object [1,12]. The per-object metadata is usually immutable over the lifetime of the corresponding object and can be efficiently shared among all pointers pointing to anywhere in the same object. However, without per-pointer information, the granularity of protection is limited to the object (or coarser) level.\n\nTo add per-pointer information, recent work uses pointer tags to lookup in-memory object metadata, and these works are categorized to tagged-pointer schemes described in Section 2.3 below. In-Fat Pointer is able to achieve finer granularity protection by associating a per-pointer subobject index with each pointer.\n\nMemory-based schemes associate metadata at a fixed ratio with application memory, and enforce \u0142digested\u017e security policies derived from object allocations, types, or higher-level programming language constructs [35,36,38]. AddressSanitizer [36] is a software sanitizer that marks all memory containing live objects as valid with one byte of shadow memory for every eight bytes in the application memory, and catches all the access to invalid memory regions. It also uses a quarantine zone that delays reuse of freed memory locations to assist in catching some temporal memory safety violations. REST [38] and Califorms [35] use hardware-based tagged memory [19] to blacklist memory that the application should not access, and the hardware will trap any access to the blacklisted memory rages. Instead of introducing metadata, Prober [26] pads on-heap array allocations with guard pages to catch overflows using the existing page permission checks. While it is possible to use heavy-weight metadata to enforce fine-grained protections (e.g., SDMP [11] assigns pointer-sized tags to each word in memory), most work trades security for low overhead and therefore provides incomplete protection [26,35,36,38]. \n\n\nTagged-Pointer Schemes\n\nThe top bits of a 64-bit pointer are often not used in 64-bit architectures due to physical limitations in addressable memory. These unused bits can thus be used to store pointer metadata, known as a tag. We refer to any scheme that makes use of pointer tags in its design as a tagged-pointer scheme. Note that it is possible for a software protection scheme to manipulate the virtual address space layout to embed metadata in the used virtual address bits [13]\u00d0we also consider such schemes as tagged-pointer schemes.\n\nTagged-pointers open up new possibilities for efficient and binarycompatible memory safety enforcement because (1) they can introduce per-pointer metadata without growing pointer size; and (2) the pointer tag can be propagated along with the pointer value without additional instructions to move them. For example, schemes may encode the pointer bounds directly into the tags without in-memory metadata [8,13,24]. Memory-based schemes can also use the tags to express stronger security policies. ARM MTE [2] combines 4 bits of a pointer tag with an in-memory tag to achieve probabilistic detection of spatial and temporal memory errors\u00d0objects are assigned with a specific tag upon allocation, and all pointers derived from the object will copy the object tag. Therefore a pointer dereference on an object with a tag that doesn't match the pointer tag is a memory error.\n\nMore recent works use the pointer tag to lookup an object metadata in memory and retrieve the object bounds from the metadata when a bounds check is needed, as shown in Figure 1. CUP [5] stores all object bounds in a metadata table, and embed the table index into the pointer tag. FRAMER [30] is a generic object metadata scheme that uses 16-bit pointer tags to lookup an object metadata near the object. AOS [20] maintains all heap object bounds in a hash table, and the ARM Pointer Authentication Codes [2] on pointers are used as keys to access the hash table. EffectiveSan [14] uses the software Low-Fat Pointer scheme [13] to lookup the object metadata prepended to each object. However, these works need all pointer tag bits for object metadata lookup, therefore they cannot store mutable per-pointer metadata in the tags and can thus only provide spatial safety at an object bound granularity. The only exception is EffectiveSan [14], which can narrow the bounds to the current subobject by using in-memory type metadata and taking the use type of the pointer and the address offset as inputs.\n\nInspired by the approach of EffectiveSan, In-Fat Pointer also uses a two-stage process for bounds retrieval that involves an object metadata lookup and a subobject narrowing stage, but is able  Figure 2: Pointer Bounds Retrieval in In-Fat Pointer to achieve more efficient subobject narrowing through the use of pointer-tag bits freed up by the use of multiple object-specific metadata lookup schemes. In addition, EffectiveSan depends on accurate type information when retrieving bounds to perform narrowing, so the narrowing is not possible for a void pointer. In-Fat Pointer's mechanism does not rely on types during bounds retrieval and thus does not suffer from this limitation.\n\n\nIN-FAT POINTER'S APPROACH\n\nThe goal of In-Fat Pointer (short for \u0142Internal Fat Pointer\u017e) is to provide hardware-assisted fine-grained spatial memory protection on par with fat pointers without either compromising compatibility with legacy code, as inline fat pointers would (e.g., CHERI [42]), or suffering high overhead from per-pointer metadata, as shadowspace-based fat pointers would (e.g., Intel MPX [32]). To do this, In-Fat Pointer uses a novel pointer bounds retrieval mechanism shown in Figure 2, which uses tagged-pointers to accelerate lookups of in-memory metadata and narrows the object bounds to the most accurate subobject bounds. First, In-Fat Pointer uses three separate object metadata schemes that optimize the tagged pointer space usage so that additional bits can be used to track the dynamic information required for precise subobject bounds checking. Second, In-Fat Pointer keeps track of the currently pointed subobject by maintaining the subobject index field on pointer tags so that the subobject bounds for precise checking can be computed by narrowing the bounds from the object metadata. The retrieved bounds are saved in registers and used for bounds checking as traditional fat pointers. In-Fat Pointer is designed for a 64-bit architecture with at least 16 bits available for pointer tags.\n\nProtection Scope and Guarantees. Due to the use of pointer tags as metadata storage, In-Fat Pointer assumes that the application will preserve those pointer tag bits, therefore it does not support applications that modify these bits.\n\nFor applications that use pointers as a black box, In-Fat Pointer guarantees that all spatial memory errors will generate exceptions when application source code is available for instrumentation. In-Fat Pointer requires protected binaries to have been compiled with additional instrumentation. For applications that link with legacy, uninstrumented binary libraries, In-Fat Pointer provides no guarantee on overflow of objects allocated in the legacy code, or spatial errors that occur in the legacy code.  In-Fat Pointer supports pointer casting with void pointers. In the presence of incorrect casts on a pointer, In-Fat Pointer may not be able to correctly determine which subobject is being addressed. As a result, In-Fat Pointer guarantees the absence of spatial errors only at the level of the object bounds if a pointer does not have the correct type during bounds narrowing. Otherwise, the same guarantee is provided at the level of the subobject bounds.\n\nIn-Fat Pointer supports multi-threaded programs. The introduced object metadata is read-only after initialized during object allocation, therefore these metadata can be safely accessed from multiple threads. However, In-Fat Pointer cannot detect temporal memory errors (i.e., use-after-free) beyond those that invalidate object metadata.\n\n\nOverview\n\nIn-Fat Pointer uses compiler instrumentation to protect the application code, and introduces new hardware instructions to accelerate commonly instrumented operations. Figure 3 shows the high-level compiler instrumentation performed by In-Fat Pointer. The modified compiler first identifies all pointers whose safety cannot be statically determined and instruments these for runtime checking. In addition, the compiler also adds hardware provided promote instructions to retrieve the bounds when they are needed. The promote instruction implements the entire object metadata lookup and subobject bounds narrowing procedure shown in Figure 2. To support the bounds retrieval, the compiler instruments object allocation and deallocation to initialize and clean up the object metadata. A modified dynamic memory allocator also assists in instrumenting heap-allocated objects. Finally, the compiler instruments pointer arithmetic with pointer tag update to ensure correct pointer tags for bounds retrieval. In addition to bounds retrieval, the hardware also provides new instructions for bounds checking and pointer tag update that help reduce instruction and performance overhead.\n\nTo illustrate, consider the code example shown in Listing 2. IFPprefixed functions represent high-level instrumented code fragments. Inside function main(), the compiler will instrument boo because its use cannot be statically determined to be safe\u00d0a pointer derived from boo (&boo.value) is saved to a global variable gv_ptr and used in another function. Therefore, the compiler will (1) instrument the allocation of boo to create object metadata for it; and (2) return a pointer to boo that has the correct pointer tag. This instrumentation is represented by IFP_Register() at line 15, whose return value is used to initialize ptr. Because the type information (struct Boo) is available, the instrumentation to object boo also triggers the generation of the in-memory type metadata (which we call layout table) for struct Boo at the compile time, and the information of the layout table is also included in the object metadata.\n\nThe object metadata will be cleared by IFP_Deregister(ptr) at line 23 when boo goes out of scope. To ensure that the tag on the pointer &boo.value assigned to gv_ptr is up-to-date, the compiler replaces the pointer arithmetic of &boo.value with IFP_GEP() at line 21 and uses its result as the assigned value to gv_ptr. The hardware provides specialized instructions to update the pointer tag along with the address computation. Finally, inside function foo(), the compiler cannot guarantee that gv_ptr is safe to dereference, therefore the pointer is checked with IFP_Check() at line 30, which involves a promote that retrieve the bounds and a subsequent bounds check. In-Fat Pointer uses poison bits on pointer tag to mark the validity of a pointer, and any check failure is indicated by setting the poison bits on the output pointer (also referred to as poisoning the pointer). The poison bits indicate whether a pointer is valid or not, and instructions that access memory check these bits. A memory fetch using a poisoned pointer generates an exception. Therefore, the returned pointer from IFP_Check() is dereferenced directly. We discuss poison bits in greater detail in Section 3.2. Whenever a pointer needs checking, the compiler will insert a new promote instruction is used to recompute the pointer bounds from available metadata, and then the bounds can be used for later checking.\n\n\nTag Address\n\nScheme Metadata +Subobject Index Scheme Selector Poison Bits To facilitate reuse of retrieved pointer bounds and reduce the number of promotes being executed, In-Fat Pointer introduces In-Fat Pointer Registers (IFPRs), which are a set of logical fat-pointer registers that hold bounds information corresponding to pointers stored in general-purpose registers. All new instructions introduced by In-Fat Pointer use IFPRs as storage for pointer bounds; for example, the promote instruction takes a 64-bit pointer as an operand and produces an IFPR output (i.e., \u0142promotes\" a 64-bit pointer to a fat pointer), and IFP_Check() checks a pointer against the bounds stored in the corresponding IFPR. Thus, In-Fat Pointer conceptually uses fat pointers under-the-hood but maintains binary compatibility as these fat pointers are never visible to the application. As a result, the fat pointers are \u0142internal\u017e to our design\u00d0hence the name \u0142Internal Fat Pointer\u017e.\n\n\nPromotion and Pointer Tag Fields\n\nIn-Fat Pointer embeds multiple metadata fields on the pointer tags to store necessary metadata for promote operations, as shown in Figure 4. The top 16 bits of each pointer are used as tags. The lowest 12 tag bits are used for object metadata lookup and subobject bounds narrowing, and these two fields are referred to as scheme metadata and subobject index. As mentioned in the introduction and shown in Figure 2, In-Fat Pointer introduces multiple object metadata schemes for object metadata lookup. Each metadata scheme encodes distinct metadata on the pointer tag and in the object metadata, and they do not use the same width for scheme metadata. To distinguish object metadata schemes that the pointer (and therefore the pointed object) is using, each pointer tag includes two bits as scheme selector to indicate the object metadata scheme in use. The bit pattern that conforms to the canonical addressing (i.e., 00 for pointers in userlevel code) are reserved for legacy pointers, which are pointers that carry no metadata. These pointers are created by legacy code or used for statically-safe objects in instrumented code. The top two bits of each tag are poison bits that encode whether the pointer is in one of three states: (1) valid, meaning that it points within the bounds;\n\n(2) invalid, meaning that the pointer has encountered irrecoverable errors (e.g., invalid object metadata, or indexing into a struct after a failed bounds check) and cannot be dereferenced again; and (3) out-of-bounds but recoverable, which is any other state, notably off-by-one 4 . All standard load and store instructions check the poison bits and will trap if the poison bit state is anything other than valid, allowing In-Fat Pointer to provide partial protection for legacy code. Poison bits are updated each time an operation changes the value of the underlying pointer, or when a bounds check fails. 4 Figure 5: Overview of Promote Operation. Grey boxes represent pointer tag fields in Figure 4 involved in the promote operation. The bounds retrieval is presented in Figure 2.\n\nIn-Fat Pointer introduces a promote instruction to drive the bounds retrieval procedure, as shown in Figure 5. First, promote will complete without retrieving any bounds if the poison bits on the pointer tag indicate the pointer is invalid. As we shall see, some object metadata schemes depend on the pointer value to perform a metadata lookup, therefore retrieving metadata with an invalid pointer value may generate an unexpected exception or introduce false positives if the promoted pointer is never dereferenced. If the pointer is not invalid, In-Fat Pointer checks the scheme selector field to see if the pointer contains metadata\u00d0legacy pointers will have bounds retrieval bypassed, and they will have the bounds cleared and are not subject to bounds checking. Finally, the hardware starts the bounds retrieval shown in Figure 2. It first uses the scheme selector bits from the pointer tag to dispatch the object metadata lookup and object bounds retrieval to corresponding logic. If the object metadata includes layout table information and the pointer is pointing to a subobject (indicated by a non-zero subobject index), then subobject bounds narrowing is performed after the object bounds are retrieved. In this procedure, the promote hardware will fetch metadata from memory, and any generated exception (e.g., page faults) will stop the bounds retrieval and the exception is reported as generated from the promote instruction. If any metadata is successfully fetched but found invalid, the bounds retrieval is terminated and the output IFPR will be poisoned.\n\nWe now present the object metadata schemes and the object metadata lookup in Section 3.3 below. The subobject bounds narrowing is described in Section 3.4.\n\n\nObject Metadata Schemes\n\nIn-Fat Pointer introduces three complementary metadata schemes, each of which is designed to suit a category of objects. By having separate schemes, In-Fat Pointer can make assumptions on the objects each scheme would serve and is able to make better use of the limited pointer tag bits to reduce the overhead of lookup. Table 2 compares the three schemes on the imposed constraints and the intended use scenario.\n\nEach lookup scheme retrieves object metadata, which contains (1) the base address and size of the object for bounds checking, (2) a pointer to a layout table which describes the size and placement of subobjects for pointer bounds narrowing, and optionally (3) a MAC  1 Whether the scheme impose constraints on a metric:\n\n\u2022 The scheme require control on object base address (B) \u2022 The scheme has a limit on maximum object size (S) \u2022 The scheme has a limit on number of objects supported (C) to protect the integrity of the metadata. Because the metadata is stored in memory and may be vulnerable to modification by legacy code or due to temporal memory errors, the MAC, which is checked during promote, is an additional security measure to detect tampering of metadata. In our prototype, the object metadata in each scheme uses different encodings to omit redundant information.\n\nStoring the layout table as a pointer allows our prototype to store one layout able for all objects of the same type as they will all have the same layout. We now describe the three metadata schemes.\n\n3.3.1 Local Offset Scheme. The local offset scheme is designed for lightweight compiler instrumentation on small objects, especially local variables. Figure 6 provides an illustration of the local offset scheme. The object metadata is appended to each object, and both the object and metadata base address is aligned to an implementation-defined granule. The pointer tag contains an offset field, which represents the offset from the current address to metadata in granules. Thus, the promote operation retrieves the metadata by adding the address with granule offset and retrieving the metadata. When the address is not granule-aligned, the lower bits are truncated. The local offset scheme also contains a subobject index field in the tag. When pointer arithmetic moves the pointer to a subobject, the instrumented instructions will update both the granule offset and the subobject index. Whereas it is possible to put the metadata at the beginning of an object, placing it at the end means that pointers are usable by legacy code as they still point to the object as opposed to the metadata. Because the metadata address is known from the granule offset, knowing the size is sufficient to derive the object base address. In our prototype, the local offset scheme's object metadata are 128 bits divided into 16 bits for the object size, a 64-bit pointer to the layout table for the object type, and a 48-bit MAC.\n\nThe advantage of the local offset scheme is that it has no constraints on the object placement, and is thus suitable for global, heap-allocated, and stack-allocated objects. The main disadvantage is that it places a limit on the size of the objects it can handle, which is constrained by the size of the granule and the offset field in the tag. A larger granule will result in fragmentation, while a smaller granule results in a smaller maximum object size. The tag bits are shared between the object field and the subobject index, so while increasing the object field allows larger objects, it decreases the number of subobjects that can be supported. In our prototype, we use 6 of the 12 bits for the offset, the other 6 bits for the subobject index, and a granule of 16 bytes. Therefore, the implementation can support objects up to (2 6 \u2212 1) \u00d7 16 = 1008 bytes in size and object types with at most 2 6 = 64 elements in the layout table. We expect that most of the objects are smaller than the imposed size limit [7,45].\n\n\nSubheap\n\nScheme. The subheap scheme intends to be implemented by dynamic memory allocators that group objects with the same sizes or types (e.g., Slab allocator [4]). As shown from Figure 7, the subheap scheme places objects inside power-of-2-sized and aligned memory blocks, where all objects inside the same block share the same copy of metadata in the memory block. The memory allocator will guarantee that only objects having the same size and type (and therefore identical metadata) would be placed inside the same block. Each block contains an array of slots where each slot stores a single object, and the slot has a size constrained to be efficient for hardware to perform division (e.g., power of two or fixed integer multiple of power of two). Besides the layout table information, the common metadata in each block encodes the layout of the slot array, including the start and end offset of the slot array, the size of a slot, and the object size. In the current implementation, the size of the common metadata in each block is 32 bytes. To locate the metadata given a pointer to one of the objects inside the block, the hardware still needs to know the block size and the offset from the block base address to the common metadata base address. In our prototype, we dedicate 16 control registers to store this information. The pointer tag bits in the subheap scheme thus only need to store an index of the control register being used. Thus our prototype uses 4 bits to select the control register, and the remaining 8 bits are used to store a subobject index.\n\nBecause the subheap scheme constrains objects to be allocated in the same subheap as other objects of the same size, it is not appropriate for stack-allocated objects. However, unlike the local Object Metadata Table  Base Addr + Index Pointer M Figure 8: Global Table Scheme offset scheme, it has no constraints on object size and can support a larger number of subobjects. Table Scheme. The global table scheme is designed to handle objects that cannot use the previous two metadata schemes, for example, global variables that are too large to use the local offset scheme. As shown in Figure 8, it stores all object metadata inside a global table whose base address is stored in a control register. Whenever an object needs to be registered, an empty row in the table is chosen to store the metadata, and the table index is stored in the pointer tag. When the pointer bounds are requested, the hardware simply indexes into the table to retrieve the metadata.\n\n\nGlobal\n\nThe number of objects that can use the global table scheme is limited by the size of the table, which is limited by the size of the index stored in the pointer tag. In our prototype, we allocate all 12 bits for the index, and thus objects using the global table scheme cannot narrow pointer bounds in promote. The size of each row in the global table is 16 bytes.\n\n\nLayout Table\n\nIn-Fat Pointer uses a structure called a layout table to encode the relationship between nested objects so that the correct bounds for subobjects can be calculated during bounds-narrowing operations. Consider the example given in Figure 9. The code example shows struct S, which contains several elements as well as an array of nested structs. Each (sub-)object is given a number (i.e., 0 for struct S, 1 for S.v1, etc...), which indicates the element that object or subobject occupies in the layout table. Figure 9b illustrates the structure as a logical tree, which is flattened and stored as an array of entries in the layout table. Each element contains the tuple  {  ,  , , }, where the base and bound is the bounds of the subobject represented as offsets from the base address of the parent subobject. For example, for S.array, which corresponds to element #2, would be pointing to element #0, would be the offset of the array field from the base of element #0, struct S, would be the upper bound of the S.array, and would be the size of each element in the array (i.e., sizeof(struct Nested Ty)). Note that the number of elements in S.array is not explicitly recorded, but can be computed by evaluating \u2212 .\n\nThe compiler instrumentation will update the subobject index to follow changes of the currently pointed subobject. When a pointer is set to point to a subobject, the bounds retrieved by promote is narrowed by incrementing the pointer's subobject index to point to the appropriate layout   Table Example that all subobject bounds can be computed by indexing into the layout table. Consider the element for S.v1 and S.v5 (element 1 and 5) from Figure 9; their bounds are represented as offsets from struct S (element 0), which corresponds to the object bounds. Therefore, when narrowing the bounds of a pointer to element S.v1, the subobject bounds can be computed by adding the offsets retrieved from the layout table element to the object base address. For array-of-struct nesting, the subobjects bounds under the nesting are represented as offsets from the parent, which does not correspond to the object bounds. Therefore, the hardware needs to compute the bounds for the parent (sub-)object before child subobjects. In this case, the subobject bounds narrowing is essentially a recursive procedure: to solve the bounds of the current subobject given the subobject index, the hardware will (1) fetch the layout table element to identify the parent element, (2) recursively solve the parent bounds, and (3) narrow the parent bounds according to the fetched element to get the current subobject bounds, as shown in Figure 9c. The base case of recursion is element 0, whose bounds are the object bounds and are known when the narrowing starts. If a pointer to S.array [1].v3 (which corresponds to element 3) is promoted, for example, the hardware will first fetch the layout table elements for S.array[].v3 (element 3) and then its parent, which is S.array[] (element 2). Because the parent of S.array[] is struct S (element 0), which is the base case, the bounds are the object bounds. Then, the hardware narrows the bounds to S.array[] first, compute the base address of the array element for the subobject (S.array [1]), and finally add the offset from element 3 to the base address of S.array [1] to obtain the bounds for S.array [1].v3. While the subobject bounds narrowing in this scenario can be costly, we expect this cost to be rarely paid because pointers to subobjects under array-of-struct nesting tend to be derived from another pointer to the parent (sub-)object, and the derived pointer can obtain the bounds statically without using promote instruction in this case. The compiler instrumentation can hoist promotes so that only pointers not derived from another pointer (e.g., just loaded from memory) need promote to obtain the bounds, therefore it is rare to promote pointers to subobjects under deep array-of-struct nesting.\n\nThe design of the layout table and subobject index has a number of benefits. First, the subobject index does not need to be updated when performing pointer arithmetic on an array, for example, a for loop that traverses S.array using pointers. Because all array elements are represented by the single layout table element, no instruction is needed to update the subobject index in such loops, which helps reduce the instrumentation overhead. Second, the layout table is efficient for common subobject bounds narrowing because of the simple indexing with the subobject index from the pointer tags. Finally, the layout table is memory-efficient because all objects of the same type can share a single table, as mentioned earlier.\n\n\nIMPLEMENTATION\n\nIn this section, we present the prototype implementation on 64-bit RISC-V architecture. We implemented the hardware prototype of In-Fat Pointer on CVA6 [44], an open-source 64-bit RISC-V processor core with a single-issue in-order pipeline implementing RV64IMAC features. We modified the RISC-V Linux port from the PULP platform [33] (based on Linux kernel 5.1.0-rc7) for the operating system support. The compiler instrumentation is implemented in Clang/L-LVM [25] 10.0.0. We also link in a runtime library to initialize the additional states and support the metadata schemes. Table 3 lists the essential instructions introduced by In-Fat Pointer. Our In-Fat Pointer implementation introduces one bounds register for each of the 32 general-purpose registers (GPRs), and each (GPR and bounds) register pair is treated as a logical IFPR. Each bounds register is 96 bits (48\u00d72 bits) in size, and can be loaded or stored with ldbnd or stbnd instructions. The promote instruction encapsulates the bounds retrieval operations, and the compiler will instrument them when it cannot statically determine the bounds for a pointer. If the object a pointer points to is known, or the bounds of a pointer need to be narrowed to a specific size, the compiler will instrument ifpbnd instructions to set the bounds to the known size. When the pointer needs to drop the associated bounds, for example, when the pointer will be stored to heap memory, In-Fat Pointer instruments ifpextract to \u0142demote\u017e the IFPR into GPR, which is essentially a truncation but will also update the poison bits if the pointer is (wildly) out-of-bounds and the exact bounds cannot be retrieved. The ifpadd instruction is used to implement address computations, for example when indexing into an array or a struct. If the code is indexing into a struct, besides the address computation, the compiler will also instrument ifpidx to update the subobject index on the pointer tag, and instrument ifpbnd to narrow the pointer bounds if needed. In-Fat Pointer implements bounds checking as an access size check, which checks both the current address against the lower bound and the address plus a size against the upper bound. To reduce the instruction overhead from pointer checks instrumentation, In-Fat Pointer can check a pointer either explicitly by instrumenting ifpchk instructions, or implicitly by using a subset of registers as the address operand of loads and stores. The implicit size checks are explained in Section 4.1.1 below. In addition, promote fuses a size check and ifpadd will update the poison bits when the address computation result is out of bounds. To reduce the instruction overhead from object allocation instrumentation, In-Fat Pointer provides ifpmac for MAC generation and ifpmd for pointer tags setup when instrumenting object allocations.\n\n\nISA Extension and Hardware Support\n\nThe prototype implementation introduces a new execution unit, IFP unit, to the execute stage of the processor pipeline. The IFP unit implements the promote and ifpmac instructions. The load-store unit from CVA6 is modified to (1) implement ldbnd and stbnd instructions, (2) perform implicit size checks and poison bits checks on address operands, and (3) serve metadata load requests from the IFP unit. The remaining instructions in Table 3 are implemented in the integer ALU and take a single cycle to execute.\n\n\nImplicit Checking.\n\nIn-Fat Pointer implementation selects a subset of IFPRs (referred to as bounds-checked IFPRs) to perform implicit bounds checking to reduce the instruction overhead. When a RISC-V load or store takes a GPR from the selected IFPRs as the address operand, the instruction issue logic will read the bounds associated with the pointer, and the load-store unit will check the bounds for the dereference. In this way, when the application code contains a loop that iterates over an array, In-Fat Pointer can incur no overhead on bounds checking by allocating the pointer loop variable into a bounds-checked IFPR. However, to prevent uninstrumented callee from accidentally picking up bounds from an instrumented caller when dereferencing pointers in callee-saved registers, the implicit bounds-checking should only be enabled when the bounds are caller-saved. Therefore, the In-Fat Pointer implementation apply implicit bounds checking for caller-saved registers. Bounds checking on other registers still require ifpchk instructions.\n\n\nCalling Convention.\n\nIn-Fat Pointer implementation extends the RISC-V calling convention to apply the same caller-callee saving and argument passing rules on GPRs to the bounds registers. Each function will save and restore all clobbered callee-saved registers, including both the bounds registers and the GPRs. In addition, if pointers are passed as function arguments or return values, the bounds should be passed in the corresponding bounds registers. This allows In-Fat Pointer to pass pointer bounds across functions more efficiently, without performing full promotion for all pointer arguments and return values. This property is also significant for our implementation to provide subobject granularity protection when there is no layout table for the object, because the bounds can be inherited from previous bounds narrowing operations. However, without additional measures, the pointer bounds may not match with the pointer value when there are calls between uninstrumented and instrumented code. For example, when the calling convention uses a register for both a call argument and the return value, an instrumented caller may obtain wrong bounds of a pointer returned from the uninstrumented callee; the callee will not update the bounds and the resulting bounds likely come from a function argument that the caller passed in. To address this problem, In-Fat Pointer introduces implicit bounds clearing; when a GPR involved in an argument or return value passing is modified by an existing instruction from RISC-V (i.e., not introduced by this work), the associated bounds register is automatically cleared by the hardware. Using this approach, the legacy binary either leaves the register value intact, in which case the bounds register still contains the correct bounds, or modifies the register using an existing instruction, which clears the bounds register. The instrumented code will therefore never obtain invalid bounds.\n\nBecause RISC-V has a single standard calling convention, the implementation currently enables implicit bounds checking and clearing on all caller-saved registers. For an architecture with multiple calling conventions, one possible implementation is to introduce a control register to encode which registers to enable implicit bounds checking and clearing. For applications that mix calling conventions in a single process, the selected set can be the union of caller-saved registers; this may result in callee-saved GPRs to pair with caller-saved bounds registers, but the compatibility can be preserved. If a pointer argument is passed in memory, the prototype implementation will demote the pointer and drop the bounds before saving the pointer to memory, and promote the loaded pointer after loading it back. We leave binary-compatible bounds-passing for in-memory arguments as future work.\n\n\nSoftware Support\n\nThe In-Fat Pointer prototype implementation modifies the software stack from the operating system to the applications. First of all, the OS kernel is modified to save and restore additional registers when entering and leaving kernel mode, as well as ignoring pointer tags (but not poison bits) when checking pointers from user space. Next, the implementation introduces a runtime library to (1) provide allocator functions for heap allocations, (2) initialize the In-Fat Pointer environment at application startup, and (3) manage the  global metadata table from the global table scheme. Lastly, the modified compiler is used to analyze and instrument the programs.\n\n\nDynamic Memory Allocators.\n\nTo evaluate In-Fat Pointer with dynamic memory allocators that may not support subheap scheme, we implemented two allocators in the runtime library: (1) a wrapped allocator on top of libc's malloc() and free() which uses the local offset scheme if possible and falls back to the global table scheme; and (2) a subheap allocator implemented as a pool allocator on top of a buddy allocator, which uses the subheap scheme. The wrapped allocator transparently over-allocates memory for objects when using the local offset scheme, and allows us to evaluate the impact on existing allocators that cannot support the subheap scheme. The subheap allocator implementation, however, intends to model state-of-the-art scalable memory allocators [15,23,27] modified to support the subheap scheme.\n\nTo utilize the provided allocator functions, during compiler instrumentation, all malloc(), free(), and other allocator calls in the source programs are rewritten to call the counterparts from the runtime library. For malloc()-like allocation functions, extra information (e.g., layout table metadata) is passed as additional arguments to the allocator. The runtime library guarantees that the pointers returned from the allocation functions (e.g., malloc()) have the tags properly initialized. The prototype implementation uses a compiler option to select which allocator to use for all such allocator function calls. However, we note that it is possible to use both allocators simultaneously and the runtime library can dynamically select allocators and metadata schemes. We leave such exploration as future work.\n\n\nLocal and Global Objects Instrumentation.\n\nFor local objects, the compiler will instrument metadata setup and cleanup code into the functions they are declared. The compiler will prefer the local offset scheme if the object is within the size limit, and fall back to the global table scheme otherwise. The runtime library provides functions to register and deregister the objects for the global table scheme, and the compiler will instrument calls to these library functions if the global table scheme is used.\n\nFor each global objects requiring instrumentation, the compiler will create a \u0142getptr\u017e function in the program, and this function is called when the application needs to obtain the pointer with tag. It will initialize the object metadata once in its first invocation, and simply return the pointer in subsequent calls. The compiler will create stub code in source files that only contains the declaration of the object, and create complete code in the source file the object is defined. The compiler will set the linkage so that the getptr function from the source file defining the object is prioritized during linking. Therefore, the stub version of getptr will only be used when the object is defined in an uninstrumented source file. Although getting a pointer to the global variable would involve a function call, it is only needed for code that makes the pointer escape, e.g., storing the address of the object to memory. Referencing global variables by name, for example, is not affected by the instrumentation.\n\n\nEVALUATION\n\nWe evaluate In-Fat Pointer (1) functionally by testing whether In-Fat Pointer can successfully catch spatial memory errors at runtime, (2) by measuring the performance and memory overhead of benchmarks and real workloads, and (3) by estimating hardware area overhead from our prototype implementation.\n\nWe used Xilinx Vivado 2018.2 to synthesize our modified CVA6 on a Digilent Genesys 2 FPGA development board, which has a Kintex-7 XC7K325T-2FFG900C FPGA chip and 1GB of DDR3 RAM. The processor runs at a fixed frequency of 50MHz. We run all experiments with /proc/sys/vm/overcommit_memory set to 1 to accommodate the subheap allocator implementation.\n\n\nFunctional Evaluation\n\nTo evaluate the correctness of In-Fat Pointer, we ran the NIST Juliet test suite 1.3 for C/C++ [31]. There are 64,099 total test cases in the Juliet test suite, where each test case is a program with both good and vulnerable code fragments, and the main() function calls the good code first, then the vulnerable code. We chose programs under the category of buffer overflow (stack-based and heap-based), underwrite, overread, and underread, which features out-of-bounds memory access that In-Fat Pointer intends to catch. Among the total of 16,572 test cases in the selected categories, we excluded all 6,484 C++ test cases because our prototype currently does not support C++. For the remaining 10,088 test cases, we excluded those that have external dependencies (e.g., requiring network connections, files, or input from stdin), and those that only run on Windows, leaving 9,328 test cases. We found that at least 182 test cases only exhibit spatial errors when a randomly generated value falls into specific ranges in the first round of experiments, so we modified the random number generation function to generate specific values according to an environment variable so that these programs exhibit spatial errors at least once when multiple runs with different environment variable values are used. After the adjustment, among all the 9,328 test cases, we found that 2,672 of them either have the spatial error triggered in uninstrumented libc, or do not involve spatial errors on our test environment because they either require special (non-zero) initial value in uninitialized memory or are only vulnerable on a 32-bit system. Among the rest 6,656 test cases, there are 1,084 of them have their spatial error optimized away by the compiler, leaving 5,572 valid test cases for In-Fat Pointer. We ran all 5,572 vulnerable and non-vulnerable test cases on our In-Fat Pointer prototype and found that In-Fat Pointer successfully detected all vulnerabilities while passing all non-vulnerable cases. While all intra-object overflow test cases have the overflow optimized away by the compiler and therefore excluded from the evaluation, the result validates our prototype for object-granularity protection, which increases our confidence of correctly implemented subobject-granularity protection.\n\n\nApplication Evaluation\n\nTo show that In-Fat Pointer is a practical approach for spatial memory safety defense, we run all programs from Olden [6], four programs (anagram, ft, ks, and yacr2) from PtrDist [3], and the following selected programs: (1) bzip2 [37] 1.0.8 compressing its own source code tarball, (2) 458.sjeng from SPEC2006 benchmark [17] with reduced search depth and runtime, (3) CoreMark [16], and (4) WolfCrypt's Diffie\u015bHellman benchmark [41]. These four programs are selected because they cover common application domains and can run on our prototype with limited resources and complete in a reasonable time. We modified yacr2's file parsing code to embed input data into the program to circumvent an implementation bug. PtrDist's bc is excluded because In-Fat Pointer detects the over-read from glibc's strlen() in its instrumented versions 5 .\n\nTo measure the runtime overhead from the promote instruction, we implement a version of In-Fat Pointer we call no-promote. Nopromote is identical to the standard In-Fat Pointer prototype except that promote treats all pointers as legacy pointers and do not perform any metadata access, therefore promote has the same cost as a nop. By comparing the performance of no-promote with the standard version of In-Fat Pointer, we can then isolate the performance impact of the promote instruction. We note that no-promote has no difference in memory overhead and has essentially identical memory usage as the standard version.\n\nOur experiments show that uninstrumented programs have no observable change in runtime or memory consumption when running on modified Linux or vanilla Linux, so all our analysis below uses uninstrumented programs running on modified Linux as a baseline. All reported overheads are normalized to the baseline results. Table 4 lists the statistics on object instrumentation, promote, and the total dynamic instruction counts. The results involving layout table and subobject index usage are collected from the subheap allocator versions of the programs. The local offset scheme is used for all local objects and most of the global objects, except one global object from sjeng and three from bzip2 using the global table scheme. The metadata scheme for each heap-allocated object depends on the used allocator. Therefore, the metadata scheme usage of each program version can be computed from the object instrumentation statistics. The subheap allocator versions have 5% geo-mean dynamic instruction increase and the wrapped allocator versions have a 14% increase. The difference results from the performance difference of the dynamic memory allocator which is explained in Section 5.2.2 below.\n\n\nInstrumentation Statistics.\n\nIn our experiments, In-Fat Pointer provides the same protection granularity as traditional fat pointers in 16 out of 18 programs except for CoreMark and bzip2. Most of the promotes only need to retrieve object bounds; among the 18 programs, only CoreMark, bzip2, and health contain promote of pointers to subobjects 6 (29%, 50%, and less than 1% of promote instructions respectively), and our results indicate that all subobject bounds narrowing in health are successful while all narrowing in CoreMark and bzip2 fail because the object metadata does not contain layout table information, and the bounds are coarsened to the object granularity. We found that CoreMark, bzip2, and wolfcrypt use custom wrapper functions for memory allocation, and both bzip2 and wolfcrypt use function pointers to invoke memory allocation functions. Our compiler instrumentation therefore cannot deduct the allocated type and create layout tables for these allocations. We leave support for allocation wrappers as future work.\n\nAnother observation is that more than 20% of promote instructions executed on average have NULL or legacy pointers as input. The approach used by In-Fat Pointer can perform better than traditional fat pointers in such scenarios because In-Fat Pointer can bypass the bounds retrieval for legacy or NULL pointers while traditional fat pointers cannot. Table 4 lists the statistics on promote that access object metadata in the Valid promote column. The ratio of NULL and legacy pointers operands depend on the program. In bisort, health, perimeter, treeadd, ks, and CoreMark, almost all promote bypassing metadata lookup encountered a NULL pointer. In voronoi, anagram, sjeng, and bzip2, almost all such promotes encounter pointers from legacy code. Among 23% of promotes that bypass metadata lookup in mst, 60% encounter a legacy pointer and 40% encounter a NULL pointer. In our experiments, these legacy pointers mostly come from the uninstrumented libc. For example, the source code of anagram contains multiple calls to isalpha() in loops, and each of them compiles to a call to __ctype_b_loc() that return a double pointer to a character traits table, a dereference on the double pointer followed by a promote on the result pointer, an array indexing that load the trait of the character, and a bitfield test on the trait. The instrumented promote will always get legacy pointer operands. We leave better support for libc functions and reduction of unnecessary promotes for future work.\n\nWe also found that almost all valid promotes retrieve bounds for pointers to heap-allocated objects; only CoreMark and sjeng has negligible (less than 1%) promote for local or global objects. This shows that passing pointer bounds through function arguments and return values is effective at reducing the number of executed promotes. The following discussion will also emphasize more on heap-allocated objects than local or global objects. Figure 10 shows the normalized runtime overhead for all programs. The subheap allocator versions incur about 12% geo-mean overhead, and the wrapped allocator versions incur 24% overhead. These overheads are lower than the reported values from software-only FRAMER (223%) and the hardwarebased Intel MPX (50%).\n\n\nPerformance Overhead.\n\nFirst of all, our subheap allocator implementation is more efficient in handling frequent dynamic allocations, especially the allocations of objects with the same size and type, than the allocator from glibc. Therefore, the subheap allocator versions of both perimeter and treeadd outperform the baseline because they perform a lot of dynamic allocations as shown in Table 4 and the performance gain from the allocator exceeds the instrumentation overhead.\n\nFor the rest of the programs, the largest contributing factor of the overhead are promote instructions. Figure 11 shows the counts of new instructions introduced by In-Fat Pointer including promote. The instruction counts are normalized against the baseline instruction counts in Table 4. The wrapped allocator versions of health and ft have the highest overhead (81% and 93% respectively), and as shown in the figure, promotes make up more than 10% of the instruction overhead introduced by In-Fat Pointer. The baseline of the two programs suffer from cache thrashing; they have approximately one L1 data cache miss in every 8 and 6 instructions executed, respectively. In this case, the metadata sharing in the subheap scheme reduces the memory footprint of the metadata and results in fewer cache misses. The wrapped allocator version increases L1 data cache misses by 93% and 96%, while the subheap allocator version increases cache misses by 26% and \u2248 0%, respectively. However, when the metadata can fit in the cache, the subheap scheme is slower than the other two schemes because of the larger metadata and unpipelined metadata fetching from the IFP unit. For example, ks has 17% promotes in the dynamic instruction count, and its subheap allocator version is slower than the wrapped allocator version. We also note that C programs written for resourceconstrained environments tend to make fewer dynamic memory allocations and therefore cannot benefit from the metadata sharing of the subheap scheme. For example, CoreMark only performs a single dynamic allocation and builds all data structures inside the allocated memory. It has about 5% promotes among all instructions executed, and the overhead is 24% for the subheap allocator version and 15% for the wrapped allocator version. Although promote instructions are slow, they contribute to less than 2% of total executed instructions in 10 out of 18 benchmarks. As shown in Figure 11, In-Fat Pointer also instruments many arithmetic instructions that update the pointer tags and bounds or maintain object metadata. We expect future work to use better compiler optimizations including whole-program analysis to optimize away more pointer checks and object instrumentations to reduce the overhead. Figure 12 shows the normalized memory overhead (maximum resident size reported by time -v) for both the wrapped allocator version and the subheap allocator version of the programs. Three programs (ks, yacr2, and CoreMark) are excluded in the figure because they use less than 6MB of memory in all versions and time -v reports no difference in maximum resident size. The geo-mean overhead from the rest of the programs is \u22126% for the subheap allocator version and 21% for the wrapped allocator version. The overhead from the wrapped allocator version is comparable with FRAMER [30] and CHERI [42], is much lower than Intel MPX's 1.9\u00d7 to 2.1\u00d7 [32].\n\n\nMemory Overhead.\n\nComparing with the allocator from glibc, the subheap allocator reduces the memory footprint in 6 of the 15 benchmarks. These benchmarks allocate objects individually (i.e., malloc(sizeof(T))), therefore the subheap allocator implementation can tightly pack these objects without per-object allocation metadata as the allocator from glibc would. On the opposite, em3d contains many array allocations for structs (i.e., malloc(num*sizeof(T))), and the subheap allocator must allocate arrays with different sizes to different memory blocks, resulting in the highest memory overhead among these benchmarks.\n\n\nPerformance Prediction on ASIC Implementation.\n\nWe may take several factors into account when trying to extrapolate the performance of our FPGA prototype to an ASIC implementation. First, the CVA6 core that our In-Fat Pointer prototype is based on is a simple single, in-order issue processor with relatively small caches. Second, the clock speed of our FPGA core is much slower than an ASIC compared to the speed of memory. As shown in Figure 11, in some of the programs, promote instructions are rare and most of the dynamic instructions introduced by In-Fat Pointer are arithmetic instructions that do not access memory. An out-oforder, superscalar processor may thus be able to hide the costs of the additional In-Fat Pointer instructions better thus having lower overhead than our prototype. However, there are programs that use pointers heavily and more promote instructions are executed than other arithmetic instructions introduced by In-Fat Pointer. The overhead will therefore also be application dependent, as data dependencies (especially on pointer values) may still limit the amount of instruction-level parallelism, and promote instructions may increase the load-to-use latency of pointers. We expect the relatively slower memory as compared to processor clock speed to have minimal impact, as In-Fat Pointer does not affect caches, and an ASIC implementation will likely have larger caches.\n\n\nHardware Cost Evaluation\n\nTo evaluate the hardware cost of our prototype implementation, we analyzed the resource utilization reports from Vivado. Although the resource utilization on FPGA is not a reliable prediction for chip area in ASIC implementations, it reflects the relative logic complexity of introduced hardware changes and shows possible trade-offs among hardware area cost, memory safety protection features, and performance. In addition, the FPGA resource utilization is relevant for embedded systems using soft-core processors synthesized on FPGAs.\n\nWhile the vanilla CVA6 processor uses 37,088 LUTs and 21,993 FFs, our modified code uses 59,261 LUTs and 32,545 FFs in total, which is about 60% increase in LUTs and 48% in FFs. Because in almost all hierarchies the design consumes more LUTs than FFs, all the following area analyses use LUTs to approximate the area cost. Figure 13 shows the LUT usage decomposition at each pipeline stage of CVA6. Among all the pipeline stages, about 62% of the overall utilization increase comes from the execute stage, where the IFP unit and the load-store unit contributes most to the increase (38% and 19% respectively). The usage increase in load-store unit mainly comes from the widened buffers and logic to implement bounds load and store. The 29% usage increase in the issue stage comes from the bounds registers and their operand forwarding logic, and an additional writeback port from the IFP unit. The rest of the changes, including data bandwidth improvement to the data cache, additional control registers and performance counters, and instruction decoding logic incurs less than 10% increase. The usage increase from the IFP unit is 38%. Therefore, if a system using a 64bit soft-core processor wants to implement IFP support but at the same time limit the area overhead below 30%, the implementation should consider avoiding implementing additional bounds registers and redesign the instruction set, because the bounds registers contribute more LUT usage increase than the IFP unit.\n\nIn the IFP unit, the layout table walker uses 3,059 LUTs, which is 36% of LUTs in the IFP unit. In comparison, the logic for all three object metadata schemes uses 2,501 (30%) LUTs. The layout table walker is the most complex component in the processor modification. In the prototype, it has 1,030 lines of SystemVerilog code, while the three object metadata schemes have 676 lines of code in total. Most of the complexity arises from the support for array-ofstruct nesting, in which case the layout table walker needs complex state machines and multi-cycle division logic. Therefore, if a softcore-based system is concerned about performance but wants to reduce area, the IFP implementation may simplify or drop support for layout table and rely on bounds narrowing in application code for fine-grained spatial protection.\n\n\nCONCLUSION\n\nIn this paper we present In-Fat Pointer, a hardware-based taggedpointer scheme that can provide spatial memory safety guarantee at subobject bound granularity without breaking compatibility with legacy code. We show that multiple object metadata schemes can reduce both the demand of pointer tag bits and the cost of object metadata lookup, and the spared tag bits can be used to assist subobject bound recomputation with the help of per-type layout table. We implemented and evaluated In-Fat Pointer on RISC-V architecture.\n\nIn the future, In-Fat Pointer can be improved with better compiler analysis and optimization to reduce the performance overhead and support more complex programs with full coverage. The design parameter selection of In-Fat Pointer metadata schemes will also benefit from a better knowledge of application behaviors. We also look towards better metadata scheme designs that can make more efficient use of pointer tag bits and the object metadata.  Figure 14 shows the general setup of the prototype implementation. A build environment is configured to prepare the application binaries and the bootable Linux image. The image is written to an SD card for use by the FPGA system. We use the Digilent Genesys 2 FPGA board for the prototype system, and the bitstream is generated from the CVA6 SoC with the modified processor with Xilinx Vivado 2018.2. A host machine is physically connected to the FPGA to communicate with the system. We used the USB UART serial port for the terminal and NFS over Ethernet for file sharing. Figure 15 shows how the application binaries are built in the build environment. The runtime library is first compiled and archived into a static library, and then linked into all instrumented programs. We use the modified Clang/LLVM compiler to cross-compile all source files to RISC-V object code, including the runtime library. We then use the RISC-V GNU toolchain from the patched Ariane-SDK 7 for linking. To compile and instrument applications with minimal change to the normal build procedure, our implementation includes wrapper scripts as drop-in replacements to CC for Makefiles and configure scripts.\n\nA.3.1 How to Access. We provided reviewers with a docker image containing the cross-compilation toolchains, and remote access to our machine connected with the FPGA board. This artifact is not publicly available; please contact the authors if access is desired.\n\nA.3.2 Hardware Dependencies. A Digilent Genesys 2 FPGA board is required to run the experiments. A Linux-capable host machine with at least one USB port and one Ethernet port is needed to communicate with the FPGA system.\n\nA.3.3 Software Dependencies. Xilinx Vivado 2018.2 is needed to synthesize the SoC and generate the FPGA bitstream. Vivado must have a license for synthesizing and implementing on the Xilinx XC7K325T-2FFG900C FPGA device (which is from the Kintex-7 series). Note that Vivado's free WebPACK edition does not contain these licenses.\n\n\nA.4 Installation\n\nThe setup of the build environment and the creation of application binaries and the Linux image consists of the following steps:\n\n\u2022 Patch Ariane-SDK and install the RISC-V cross-compilation toolchain \u2022 Patch Linux kernel and build the boot image with the Ariane-SDK \u2022 Build the Clang/LLVM cross-compilation toolchain \u2022 Build the runtime library \u2022 Build the application binaries\n\nWe have scripts for most of the steps, including the configuration and building of the applications.\n\nThe FPGA bitstream generation procedure of the modified CVA6 is identical to the procedure in upstream CVA6 repository 8 . During experiments, we run the following command on the host machine to open a terminal to the FPGA system after the cables are correctly connected:\n\n$ sudo screen -L /dev/ttyUSB0 115200\n\nIn all evaluations, the execution statistics of the programs are printed to the terminal, and -L option of the screen command will save the logs to a text file. We use scripts to parse all the terminal logs and generate spreadsheet files.\n\n\nA.5 Experiment Workflow\n\nThe performance evaluation of In-Fat Pointer involves (1) build the applications 9 , (2) copy the application binary to the NFS share on the host machine (if the build environment is not on the host machine), (3) run the benchmarks with the inputs in Listing 3, and (4) parse the terminal log file to extract the printed statistics. We have scripts to automate all the steps above (except the second step). $FILES points to the directory with the input files. The input files for PtrDist are distributed with the source code. The input sjeng.txt is based on 458.sjeng/data/ref/input/ref.txt with the depth (the even rows) changed from: 12,13,13,12,12,16,11,13,18 to: 6,7,7,6,6,8,5,7,8 The input source.tar for bzip2 is created with $ gunzip -k bzip2-1.0.8.tar.gz 8 The CVA6 repository is available at https://github.com/openhwgroup/cva6 9 Details for the benchmarks are available at: https://github.com/dlgroupuoft/ InFatPointer-ASPLOS2021-Eval. \n\n\nListing 3: Inputs to the Benchmarks\n\nAll the commands are run with time -v and the stdout redirected to /dev/null.\n\nThe functional evaluation of In-Fat Pointer follows a similar procedure above, although more manual configuration and analysis is involved. We use scripts to generate the Makefile, and all the binaries are run with a test script on the FPGA system. One can also test In-Fat Pointer with custom programs; a spatial error should result in a segmentation fault from dereferencing a poisoned pointer.\n\n\nA.6 Evaluation and Expected Results\n\nFor the performance evaluation, Figure 10 and 12 should be reproducible from the spreadsheet generated by parsing the terminal log. For the functional evaluation, all applicable programs should pass the test.\n\n\nA.7 Notes\n\nThe evaluation on Olden and PtrDist benchmark suites was added after the artifact evaluation procedure started, therefore their results are not independently verified for the reproducibility badges.\n\nFigure 3 :\n3Operations Instrumented by In-Fat Pointer. In-Fat Pointer introduce new instructions for hardware-assisted pointer checks, bounds retrieval (promote), and pointer tag updates.\n\n\nExample of In-Fat Pointer Instrumentation.\n\nFigure 4 :\n4Pointer Tag Bits Decomposition. The numbers above each field represent bit widths of the fields.\n\nFigure 6 :\n6Local Offset Scheme\n\nFigure 7 :\n7Subheap Scheme. The dashed box represents an implementation defined function that maps assigned tag bits to memory block size and metadata offset.\n\nFigure 9 :\n9Layout\n\nFigure 10 :Figure 11 :\n1011Performance Dynamic Instruction Counts for Instructions from In-Fat Pointer\n\nFigure 12 :\n12Memory Overhead of Applicable Benchmarks\n\nFigure 13 :\n13LUT Increase in the Modified Processor\n\nFigure 14 :Figure 15 :\n1415Overview Software Build Procedure\n\nTable 1 :\n1Comparison between In-Fat Pointer and Related Works on Memory Safety.(Hardware-or Software-based) defense \nSubject of introduced in-memory \nSpatial protection \nLost \nRequired \nor software sanitizer [39] \nmetadata for checking \ngranularity 1 \ncompatibility 2 feature 3 \n\nIntel MPX [32] \nPointer \nSubobject \n\u00d0 \nS \n\u25cb \nHardBound [10] \nPointer \nSubobject \n\u00d0 \nS \n\u25cb \nWatchdogLite [28] \nPointer \nSubobject \n\u00d0 \nS \n\u25cb \nSoftBound [29] \nPointer \nSubobject \n\u00d0 \nS \n\u25cb \nCHERI [42] \nPointer \nSubobject \nB \n\u25cb S \n\u25cb \nT \n\u25cb \nShakti-MS [9] \nPointer + Object \nSubobject \nB \n\u25cb \n\u00d0 \nALEXIA [21] \nPointer + Object \nSubobject \nB \n\u25cb \n\u00d0 \nBaggyBound 4 [1] [12] \nObject/None 2 \nObject \n\u00d0 \nS \n\u25cb/\u00d0 2 \nPAriCheck [43] \nObject \nObject \n\u015b \nS \n\u25cb \nAddressSanitizer [36] \nMemory \nPartial \n\u00d0 \nS \n\u25cb \nREST [38] \nMemory \nPartial \n\u00d0 \nT \n\u25cb \nCaliforms [35] \nMemory \nPartial \nB \n\u25cb S \n\u25cb \nT \n\u25cb \nProber [26] \nNone (page permissions only) \nPartial \n\u00d0 \n\u00d0 \n\nLow-Fat Pointer [24] \nNone 2 \nObject \n\u00d0 \n\u00d0 \nSMA [8] \nNone 2 \nObject \n\u00d0 \n\u00d0 \nCUP [5] \nObject 2 \nObject \n\u00d0 \n\u00d0 \nFRAMER [30] \nObject 2 \nObject \n\u00d0 \n\u00d0 \nAOS [20] \nObject 2 \nObject \n\u00d0 \n\u00d0 \nEffectiveSan [14] \nObject 2 \nSubobject \n\u00d0 \n\u00d0 \nARM MTE [2] \nMemory 2 \nPartial \n\u00d0 \nT \n\u25cb \n\nIn-Fat Pointer \nObject 2 \nSubobject \n\u00d0 \n\u00d0 \n2 \n\n\nFigure 1: Pointer Bounds Retrieval in Previous Taggedpointer Schemes using Object Metadata. The subobject bounds narrowing is unique to EffectiveSan[14].Pointer \n\nObject \nMetadata \n\nObject \nBounds \n\nSubobject \nBounds \n\nType \nMetadata \n\nSubobject \nBounds \nNarrowing \n\nPoints to \n\nLookup \n\n\n\n\nC legally permits pointers to points one byte beyond the object's upper boundpromote Start \n\nPointer \nInvalid? \n\nPoisoned \nIFPR \n\nY \n\nHas Metadata? \n\nIFPR with \nBounds Cleared \n\nN \n\nN (Legacy Pointer) \n\nBounds \nRetrieval \n\nMetadata \nInvalid \n\nIFPR with \nRetrieved Bounds \n\nSuccess \n\nY \n\nM+I \n\nP \n\nS \n\n\n\nTable 2 :\n2Object Metadata Schemes Comparison. Cons 1 Use scenario Local Offset Scheme -S -Small Objects, Local Variables Subheap Scheme B --Heap-allocated Objects Global Table Scheme --C Global Arrays, Fallback\n\n\ntable element, thus updating the lower base and upper bound the pointer can legally point to. The layout table design optimizes subobject bounds narrowing for common struct nesting. If a type hierarchy only contains struct members or arrays of elementary type, then it can be flattened such1 struct S { \n// 0: struct S \n\n2 \n\nint v1 ; \n// 1: S. v1 \n\n3 \n\nstruct NestedTy { \n\n4 \n\nint v3 ; \n// 3: S. array []. v3 \n\n5 \n\nint v4 ; \n// 4: S. array []. v4 \n\n6 \n\n} array [2]; // 2: S. array \n\n7 \n\nint v5 ; \n// 5: S. v5 \n\n8 }; \n\n(a) Code Example \n\n0 [0, 24), size = 24 \nS \n\n1 \n[0, 4), size = 4 \nS.v1 \n\n2 \n[4, 20), size = 8 \nS.array \n\n3 \n[0, 4), size = 4 \n\n4 \n[4, 8), size = 4 \n\n5 [20, 24), size = 4 \nS.v5 \n\nS.array[].v3 \n\nS.array[].v4 \n\n[<base>, <bound>), size = <element size> \n\n<parent> \n\n(b) Generated Layout Table. The top part shows the \nfields in each layout table element. \n\n3 4 3 4 \n\n2 \n1 \n5 \n\n0 \n\nAddress Increase Direction \n\nBounds Narrowing Order \n+ Parenting Relationship \n\nLayout Table Element \nFetching Order \n\n(c) Memory View and Operation Orders \n\n\n\nTable 3 :\n3Core Instructions from In-Fat Pointer Multiple variants of the instruction exists.Mnemonic \nDescription \npromote \npointer bounds retrieval \nifpmac \nMAC computation \nldbnd \nload bounds from memory \nstbnd \nstore bounds to memory \nifpbnd \ncreate pointer bounds with given size \nifpadd \naddress computation and tag update \nifpidx \nsubobject index update \nifpchk \n(bounds) access size check \nifpextract 2 extract fields from IFPR / demote \nifpmd 2 \npointer tags manipulation \n2 \n\nTable 4 :\n4Dynamic Event Counts on Object Instrumentation, Promotion, and Instructions Executed Each cell contains (1) the number of objects instrumented, and (2) percentage of object metadata which includes layout table metadata. If no layout table is used, the zero is omitted.2 Each cell contains (1) the number of promote not bypassing object metadata lookup are executed, and (2) their ratio within all promote.Benchmark \nGlobal objects 1 \nLocal objects 1 \nHeap objects 1 \nValid promote 2 \nDynamic instruction counts \n# Object % LT # Object % LT # Object \n% LT # promote \n% Total Baseline Subheap Wrapped \nbh \n0 \n1.24 \u00d7 10 7 , 100% 6.15 \u00d7 10 3 , \n33% 4.89 \u00d7 10 6 \n(99%) 1.11 \u00d7 10 9 \n1.21\u00d7 \n1.21\u00d7 \nbisort \n0 \n0 \n1.31 \u00d7 10 5 \n1.53 \u00d7 10 7 \n(55%) 3.38 \u00d7 10 8 \n1.04\u00d7 \n1.14\u00d7 \nem3d \n0 \n0 \n1.60 \u00d7 10 4 \n3.25 \u00d7 10 6 (\u2248 100%) 2.38 \u00d7 10 8 \n1.11\u00d7 \n1.11\u00d7 \nhealth \n0 \n0 \n1.73 \u00d7 10 5 , < 1% 2.44 \u00d7 10 7 \n(94%) 2.02 \u00d7 10 8 \n1.10\u00d7 \n1.32\u00d7 \nmst \n0 \n0 \n838, \n< 1% 9.15 \u00d7 10 6 \n(78%) 1.78 \u00d7 10 8 \n1.12\u00d7 \n1.11\u00d7 \nperimeter \n0 \n0 \n1.40 \u00d7 10 6 \n1.95 \u00d7 10 7 \n(82%) 1.03 \u00d7 10 9 \n0.80\u00d7 \n1.11\u00d7 \npower \n0 \n0 \n1.83 \u00d7 10 4 , \n9% 1.08 \u00d7 10 6 \n(100%) 1.54 \u00d7 10 9 \n1.00\u00d7 \n1.00\u00d7 \ntreeadd \n0 \n4, \n100% 2.10 \u00d7 10 6 \n2.10 \u00d7 10 6 \n(50%) 8.22 \u00d7 10 8 \n0.61\u00d7 \n1.21\u00d7 \ntsp \n0 \n0 \n1.31 \u00d7 10 5 \n1.04 \u00d7 10 7 \n(99%) 3.37 \u00d7 10 8 \n1.00\u00d7 \n1.09\u00d7 \nvoronoi \n0 \n1.67 \u00d7 10 3 , 100% 3.28 \u00d7 10 4 , < 1% 4.34 \u00d7 10 6 \n(44%) 3.29 \u00d7 10 8 \n1.04\u00d7 \n1.07\u00d7 \nanagram \n3, \n33% 1, \n100% 314, \n\u2248 100% 2.37 \u00d7 10 5 \n(41%) 2.01 \u00d7 10 7 \n1.18\u00d7 \n1.18\u00d7 \nft \n0 \n1 \n9.01 \u00d7 10 4 , < 1% 2.27 \u00d7 10 8 (\u2248 100%) 1.50 \u00d7 10 9 \n1.22\u00d7 \n1.28\u00d7 \nks \n4 \n0 \n2.01 \u00d7 10 3 \n6.67 \u00d7 10 8 \n(79%) 4.20 \u00d7 10 9 \n1.21\u00d7 \n1.21\u00d7 \nyacr2 \n0 \n0 \n85, \n2% 1.97 \u00d7 10 6 (\u2248 100%) 2.02 \u00d7 10 8 \n1.16\u00d7 \n1.16\u00d7 \nwolfcrypt-dh \n1, \n100% 592, \n89% 8.34 \u00d7 10 3 \n2.51 \u00d7 10 6 (\u2248 100%) 3.25 \u00d7 10 9 \n1.14\u00d7 \n1.13\u00d7 \nsjeng \n5 \n4.69 \u00d7 10 6 , < 1% 4 \n2.08 \u00d7 10 6 \n(26%) 5.68 \u00d7 10 9 \n1.06\u00d7 \n1.06\u00d7 \ncoremark \n2, \n100% 2, \n50% 1 \n2.12 \u00d7 10 7 \n(98%) 4.53 \u00d7 10 8 \n1.08\u00d7 \n1.08\u00d7 \nbzip2 \n4, \n25% 9, \n33% 11 \n9.07 \u00d7 10 6 \n(74%) 8.31 \u00d7 10 9 \n1.09\u00d7 \n1.09\u00d7 \n1 \nA subobject represents a C struct member, array, or any data field.\nWe use \u0142per-pointer metadata\" to refer to metadata on each pointer that can change without affecting the metadata on other pointers. For example, if all pointers to the same object must be associated with identical metadata, the metadata is per-object.\nThe scheme stores and propagates the full pointer bounds along with the pointer value.\nThe strlen() implementation makes word-sized (64-bit) read for word-aligned strings, including short strings allocated with less than 8 bytes of memory.6 These promote instructions take a pointer operand with non-zero subobject index.\nThe upstream Ariane-SDK is available at https://github.com/pulp-platform/arianesdk. The Ariane processor was renamed to CVA6 around the time of publication.\nACKNOWLEDGEMENTSWe thank the anonymous reviewers and our shepherd, Michael Swift, for their thoughtful and insightful comments. We would also like to thank Tony Liao, Tarek Abdelrahman and Natalie Enright Jerger for their feedback. This work is supported in part by NSERC CRD Grant CRDPJ 541942-19 and funding from Huawei Canada.A ARTIFACT APPENDIX A.1 AbstractThe artifact mainly contains the source code for (1) the modified CVA6 processor, (2) the modified Clang/LLVM compiler, (3) the modified Linux kernel, (4) the runtime library for supporting In-Fat Pointer instrumentation, and (5) patches and configuration files for Ariane-SDK and its RISC-V GNU toolchain to generate the bootable Linux image and provide the linker and glibc for the Clang/LLVM toolchain. Unfortnately, we could not make the artifact publicly available.A.2 Artifact Check-List (Meta-Information)\u2022 Program: Benchmarks used in Section 5.\nBaggy Bounds Checking: An Efficient and Backwards-Compatible Defense against Outof-Bounds Errors. Periklis Akritidis, Manuel Costa, Miguel Castro, Steven Hand, Proceedings of the USENIX security symposium (USENIX Security '09). the USENIX security symposium (USENIX Security '09)Montreal, CanadaPeriklis Akritidis, Manuel Costa, Miguel Castro, and Steven Hand. 2009. Baggy Bounds Checking: An Efficient and Backwards-Compatible Defense against Out- of-Bounds Errors. In Proceedings of the USENIX security symposium (USENIX Security '09). Montreal, Canada. https://www.usenix.org/legacy/event/sec09/ tech/full_papers/sec09_memory.pdf\n\nARM Architecture Reference Manual ARMv8, for ARMv8-A architecture profile. Arm Ltd, ARM LtdARM Ltd. 2020. ARM Architecture Reference Manual ARMv8, for ARMv8-A architec- ture profile. ARM Ltd. https://developer.arm.com/documentation/ddi0487/latest\n\nPointer-Intensive Benchmark Suite. Todd Austin, Todd Austin. 1995. Pointer-Intensive Benchmark Suite. http://pages.cs.wisc. edu/~austin/ptr-dist.html\n\nThe Slab Allocator: An Object-Caching Kernel Memory Allocator. Jeff Bonwick, USENIX Summer 1994 Technical Conference. USENIX Association. Boston, MA, USAJeff Bonwick. 1994. The Slab Allocator: An Object-Caching Kernel Memory Allocator. In USENIX Summer 1994 Technical Conference. USENIX Association, Boston, MA, USA. https://www.usenix.org/conference/usenix-summer-1994- technical-conference/slab-allocator-object-caching-kernel\n\nCUP: Comprehensive User-Space Protection for C/C++. Nathan Burow, Derrick Mckee, Scott A Carr, Mathias Payer, Proceedings of the ACM ASIA Conference on Computer & Communications Security. the ACM ASIA Conference on Computer & Communications SecurityASIACCS18Nathan Burow, Derrick McKee, Scott A. Carr, and Mathias Payer. 2018. CUP: Comprehensive User-Space Protection for C/C++. In Proceedings of the ACM ASIA Conference on Computer & Communications Security 2018 (ASIACCS '18).\n\n. Republic Incheon, Korea, 10.1145/3196494.3196540Incheon, Republic of Korea, 381\u015b392. https://doi.org/10.1145/3196494.3196540\n\nSoftware Caching and Computation Migration in Olden. C Martin, Anne Carlisle, Rogers, 10.1145/209936.209941Proceedings of the Fifth ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming (PPOPP '95). the Fifth ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming (PPOPP '95)Santa Barbara, CA, USA, 29\u015b38Martin C. Carlisle and Anne Rogers. 1995. Software Caching and Computation Migration in Olden. In Proceedings of the Fifth ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming (PPOPP '95). Santa Barbara, CA, USA, 29\u015b38. https://doi.org/10.1145/209936.209941\n\nA study of the allocation behavior of C++ programs. J , Morris Chang, 10.1016/S0164-1212(00)00122-9Journal of Systems and Software. 572Woo Hyong Lee, and Witawas Srisa-anJ.Morris Chang, Woo Hyong Lee, and Witawas Srisa-an. 2001. A study of the allocation behavior of C++ programs. Journal of Systems and Software 57, 2 (June 2001), 107\u015b118. https://doi.org/10.1016/S0164-1212(00)00122-9\n\nSaturation Memory Access: Mitigating Memory Spatial Errors without Terminating Programs. Dongwei Chen, Daliang Xu, Dong Tong, Kang Sun, Xuetao Guan, Chun Yang, Xu Cheng, arXiv:2002.02831Dongwei Chen, Daliang Xu, Dong Tong, Kang Sun, Xuetao Guan, Chun Yang, and Xu Cheng. 2020. Saturation Memory Access: Mitigating Memory Spatial Errors without Terminating Programs. (April 2020). arXiv:2002.02831 [cs.CR] https://arxiv.org/abs/2002.02831\n\nSHAKTI-MS: A RISC-V Processor for Memory Safety in C. R Sourav Das, Arjun Harikrishnan Unnithan, Chester Menon, Kamakoti Rebeiro, Veezhinathan, 10.1145/3316482.3326356Proceedings of the 20th ACM SIGPLAN/SIGBED International Conference on Languages, Compilers, and Tools for Embedded Systems (LCTES 2019). the 20th ACM SIGPLAN/SIGBED International Conference on Languages, Compilers, and Tools for Embedded Systems (LCTES 2019)Phoenix, AZ, USASourav Das, R. Harikrishnan Unnithan, Arjun Menon, Chester Rebeiro, and Ka- makoti Veezhinathan. 2019. SHAKTI-MS: A RISC-V Processor for Memory Safety in C. In Proceedings of the 20th ACM SIGPLAN/SIGBED International Conference on Languages, Compilers, and Tools for Embedded Systems (LCTES 2019). Phoenix, AZ, USA, 19\u015b32. https://doi.org/10.1145/3316482.3326356\n\nHardbound: Architectural Support for Spatial Safety of the C Programming Language. Joe Devietti, Colin Blundell, Milo M K Martin, Steve Zdancewic, 10.1145/1346281.1346295Proceedings of the 13th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS XIII). the 13th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS XIII)Seattle, WA, USA, 103\u015b114Joe Devietti, Colin Blundell, Milo M. K. Martin, and Steve Zdancewic. 2008. Hardbound: Architectural Support for Spatial Safety of the C Programming Language. In Proceedings of the 13th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS XIII). Seattle, WA, USA, 103\u015b114. https://doi.org/10.1145/1346281.1346295\n\nArchitectural Support for Software-Defined Metadata Processing. Udit Dhawan, Catalin Hritcu, Raphael Rubin, Nikos Vasilakis, Silviu Chiricescu, Jonathan M Smith, Thomas F Knight, Benjamin C Pierce, Andre Dehon, 10.1145/2694344.2694383Proceedings of the Twentieth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS '15). the Twentieth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS '15)Istanbul, TurkeyUdit Dhawan, Catalin Hritcu, Raphael Rubin, Nikos Vasilakis, Silviu Chiricescu, Jonathan M. Smith, Thomas F. Knight, Benjamin C. Pierce, and Andre DeHon. 2015. Architectural Support for Software-Defined Metadata Processing. In Pro- ceedings of the Twentieth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS '15). Istanbul, Turkey, 487\u015b502. https://doi.org/10.1145/2694344.2694383\n\nBaggy Bounds with Accurate Checking. Baozeng Ding, Yeping He, Yanjun Wu, Alex Miller, John Criswell, 10.1109/ISSREW.2012.24Proceedings of the 23rd International Symposium on Software Reliability Engineering Workshops (ISSRE '12). the 23rd International Symposium on Software Reliability Engineering Workshops (ISSRE '12)Dallas, TX, USABaozeng Ding, Yeping He, Yanjun Wu, Alex Miller, and John Criswell. 2012. Baggy Bounds with Accurate Checking. In Proceedings of the 23rd International Symposium on Software Reliability Engineering Workshops (ISSRE '12). Dallas, TX, USA. https://doi.org/10.1109/ISSREW.2012.24\n\nStack Bounds Protection with Low Fat Pointers. J Gregory, Duck, H C Roland, Lorenzo Yap, Cavallaro, 10.14722/ndss.2017.23287Proceedings of the 2017 Network and Distributed System Security Symposium. the 2017 Network and Distributed System Security SymposiumSan Diego, CA, USAGregory J Duck, Roland HC Yap, and Lorenzo Cavallaro. 2017. Stack Bounds Protection with Low Fat Pointers. In Proceedings of the 2017 Network and Dis- tributed System Security Symposium (NDSS 2017). San Diego, CA, USA. https: //doi.org/10.14722/ndss.2017.23287\n\nEffectiveSan: Type and Memory Error Detection Using Dynamically Typed C/C++. J Gregory, Duck, H C Roland, Yap, 10.1145/3192366.3192388Proceedings of the 39th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI '18). the 39th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI '18)Philadephia, PA, USA, 181\u015b195Gregory J. Duck and Roland H. C. Yap. 2018. EffectiveSan: Type and Memory Error Detection Using Dynamically Typed C/C++. In Proceedings of the 39th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI '18). Philadephia, PA, USA, 181\u015b195. https://doi.org/10.1145/3192366.3192388\n\nA scalable concurrent malloc(3) implementation for FreeBSD. Jason Evans, Ottawa, CanadaJason Evans. 2006. A scalable concurrent malloc(3) implementation for FreeBSD (BSDCan 2006). Ottawa, Canada. https://papers.freebsd.org/2006/bsdcan/evans- jemalloc/\n\nExploring CoreMark a benchmark maximizing simplicity and efficacy. Shay Gal-On, Markus Levy, Shay Gal-On and Markus Levy. 2012. Exploring CoreMark a benchmark maxi- mizing simplicity and efficacy. (2012). https://www.eembc.org/coremark/\n\nSPEC CPU2006 Benchmark Descriptions. L John, Henning, 10.1145/1186736.1186737ACM SIGARCH Computer Architecture News. 344John L. Henning. 2006. SPEC CPU2006 Benchmark Descriptions. ACM SIGARCH Computer Architecture News 34, 4 (September 2006), 1\u015b17. https://doi.org/10. 1145/1186736.1186737\n\nData-oriented programming: On the expressiveness of non-control data attacks. Hong Hu, Shweta Shinde, Sendroiu Adrian, Zheng Leong Chua, Prateek Saxena, Zhenkai Liang, 10.1109/SP.2016.62Porceedings of the 37th IEEE Symposium on Security and Privacy (Oakland '16). San Jose, CA, USAHong Hu, Shweta Shinde, Sendroiu Adrian, Zheng Leong Chua, Prateek Saxena, and Zhenkai Liang. 2016. Data-oriented programming: On the expressiveness of non-control data attacks. In Porceedings of the 37th IEEE Symposium on Security and Privacy (Oakland '16). San Jose, CA, USA. https://doi.org/10.1109/SP.2016.62\n\nEfficient Tagged Memory. Alexandre Joannou, Jonathan Woodruff, Robert Kovacsics, W Simon, Alex Moore, Hongyan Bradbury, Xia, N M Robert, David Watson, Michael Chisnall, Brooks Roe, Edward Davis, John Napierala, Khilan Baldwin, Peter G Gudka, Alfredo Neumann, Mazzinghi, 10.1109/ICCD.2017.1122017 IEEE International Conference on Computer Design. Alex Richardson, Stacey Son, and A. Theodore Markettos; Boston, MA, USA, 641\u015b648Alexandre Joannou, Jonathan Woodruff, Robert Kovacsics, Simon W Moore, Alex Bradbury, Hongyan Xia, Robert NM Watson, David Chisnall, Michael Roe, Brooks Davis, Edward Napierala, John Baldwin, Khilan Gudka, Peter G. Neumann, Alfredo Mazzinghi, Alex Richardson, Stacey Son, and A. Theodore Markettos. 2017. Efficient Tagged Memory. In 2017 IEEE International Conference on Computer Design (ICCD 2017). Boston, MA, USA, 641\u015b648. https://doi.org/10.1109/ICCD. 2017.112\n\nHardware-based Always-On Heap Memory Safety. Yonghae Kim, Jaekyu Lee, Hyesoon Kim, 10.1109/MICRO50266.2020.000952020 53rd Annual IEEE/ACM International Symposium on Microarchitecture (MICRO 2020). 1153\u015b1166. Yonghae Kim, Jaekyu Lee, and Hyesoon Kim. 2020. Hardware-based Always-On Heap Memory Safety. In 2020 53rd Annual IEEE/ACM International Symposium on Microarchitecture (MICRO 2020). 1153\u015b1166. https://doi.org/10.1109/MICRO50266. 2020.00095\n\nALEXIA: A Processor with Lightweight Extensions for Memory Safety. Gnanambikai Krishnakumar, Reddy Kommuru Alekhya, Chester Rebeiro, 10.1145/3362064ACM Transactions on Embedded Computing Systems. 18ArticleGnanambikai Krishnakumar, Kommuru Alekhya REDDY, and Chester Rebeiro. 2019. ALEXIA: A Processor with Lightweight Extensions for Memory Safety. ACM Transactions on Embedded Computing Systems 18, 6, Article 122 (November 2019), 27 pages. https://doi.org/10.1145/3362064\n\nFast and Generic Metadata Management with Mid-Fat Pointers. Taddeus Kroes, Koen Koning, Cristiano Giuffrida, Herbert Bos, Erik Van Der Kouwe, Proceedings of the 10th European Workshop on Systems Security (EuroSec '17). the 10th European Workshop on Systems Security (EuroSec '17)Taddeus Kroes, Koen Koning, Cristiano Giuffrida, Herbert Bos, and Erik van der Kouwe. 2017. Fast and Generic Metadata Management with Mid-Fat Pointers. In Proceedings of the 10th European Workshop on Systems Security (EuroSec '17).\n\n. Serbia Belgrade, 10.1145/3065913.3065920Belgrade, Serbia. https://doi.org/10.1145/3065913.3065920\n\nAlexey Kukanov, J Michael, Voss, The Foundations for Scalable Multicore Software in Intel Threading Building Blocks. 11Alexey Kukanov and Michael J Voss. 2007. The Foundations for Scalable Multi- core Software in Intel Threading Building Blocks. Intel Technology Journal 11, 4 (November 2007), 309\u015b322.\n\nLow-fat pointers: compact encoding and efficient gate-level implementation of fat pointers for spatial safety and capability-based security. Albert Kwon, Udit Dhawan, Jonathan M Smith, Thomas F Knight Jr, Andre De-Hon, 10.1145/2508859.2516713Proceedings of the 2013 ACM SIGSAC conference on Computer & communications security (CCS '13. the 2013 ACM SIGSAC conference on Computer & communications security (CCS '13Berlin, GermanyAlbert Kwon, Udit Dhawan, Jonathan M Smith, Thomas F Knight Jr, and Andre De- Hon. 2013. Low-fat pointers: compact encoding and efficient gate-level implemen- tation of fat pointers for spatial safety and capability-based security. In Proceedings of the 2013 ACM SIGSAC conference on Computer & communications security (CCS '13). Berlin, Germany, 721\u015b732. https://doi.org/10.1145/2508859.2516713\n\nLLVM: A compilation framework for lifelong program analysis & transformation. Chris Lattner, Vikram Adve, 10.1109/CGO.2004.1281665International Symposium on Code Generation and Optimization (CGO '04). San Jose, CA, USA, 75\u015b86Chris Lattner and Vikram Adve. 2004. LLVM: A compilation framework for lifelong program analysis & transformation. In International Symposium on Code Generation and Optimization (CGO '04). San Jose, CA, USA, 75\u015b86. https://doi. org/10.1109/CGO.2004.1281665\n\nProber: Practically Defending Overflows with Page Protection. Hongyu Liu, Ruiqin Tian, Tongping Bin Ren, Liu, 10.1145/3324884.3416533Proceedings of the 35th IEEE/ACM International Conference on Automated Software Engineering (Virtual, Australia) (ASE '20). 1116\u015b1128. the 35th IEEE/ACM International Conference on Automated Software Engineering (Virtual, Australia) (ASE '20). 1116\u015b1128Hongyu Liu, Ruiqin Tian, Bin Ren, and Tongping Liu. 2020. Prober: Practically Defending Overflows with Page Protection. In Proceedings of the 35th IEEE/ACM International Conference on Automated Software Engineering (Virtual, Australia) (ASE '20). 1116\u015b1128. https://doi.org/10.1145/3324884.3416533\n\nTCMalloc : Thread-Caching Malloc. Llc Google, Google LLC. 2005. TCMalloc : Thread-Caching Malloc. http://goog-perftools. sourceforge.net/doc/tcmalloc.html\n\nWatchdogLite: Hardware-Accelerated Compiler-Based Pointer Checking. Santosh Nagarakatte, M K Milo, Steve Martin, Zdancewic, 10.1145/2544137.2544147Proceedings of Annual IEEE/ACM International Symposium on Code Generation and Optimization (CGO '14). Annual IEEE/ACM International Symposium on Code Generation and Optimization (CGO '14)Orlando, FL, USA, 175\u015b184Santosh Nagarakatte, Milo MK Martin, and Steve Zdancewic. 2014. WatchdogLite: Hardware-Accelerated Compiler-Based Pointer Checking. In Proceedings of An- nual IEEE/ACM International Symposium on Code Generation and Optimization (CGO '14). Orlando, FL, USA, 175\u015b184. https://doi.org/10.1145/2544137.2544147\n\nSoftBound: Highly Compatible and Complete Spatial Memory Safety for C. Jianzhou Santosh Nagarakatte, Milo M K Zhao, Steve Martin, Zdancewic, 10.1145/1542476.1542504Proceedings of the 30th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI '09). the 30th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI '09)Dublin, IrelandSantosh Nagarakatte, Jianzhou Zhao, Milo M.K. Martin, and Steve Zdancewic. 2009. SoftBound: Highly Compatible and Complete Spatial Memory Safety for C. In Proceedings of the 30th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI '09). Dublin, Ireland, 245\u015b258. https: //doi.org/10.1145/1542476.1542504\n\nFRAMER: A Tagged-Pointer Capability System with Memory Safety Applications. Periklis Myoung Jin Nam, David J Akritidis, Greaves, Proceedings of the 35th Annual Computer Security Applications Conference (ACSAC '19). the 35th Annual Computer Security Applications Conference (ACSAC '19)Myoung Jin Nam, Periklis Akritidis, and David J Greaves. 2019. FRAMER: A Tagged-Pointer Capability System with Memory Safety Applications. In Proceed- ings of the 35th Annual Computer Security Applications Conference (ACSAC '19).\n\n. San Juan, Puerto Rico, Usa, 10.1145/3359789.3359799San Juan, Puerto Rico, USA, 612\u015b626. https://doi.org/10.1145/3359789.3359799\n\nIntel MPX Explained: A Cross-layer Analysis of the Intel MPX System Stack. Oleksii Oleksenko, Dmitrii Kuvaiskii, Pramod Bhatotia, Pascal Felber, Christof Fetzer, 10.1145/3224423Proc. ACM Meas. Anal. Comput. Syst. 22ArticleOleksii Oleksenko, Dmitrii Kuvaiskii, Pramod Bhatotia, Pascal Felber, and Christof Fetzer. 2018. Intel MPX Explained: A Cross-layer Analysis of the Intel MPX System Stack. Proc. ACM Meas. Anal. Comput. Syst. 2, 2, Article 28 (June 2018), 30 pages. https://doi.org/10.1145/3224423\n\npulp-platform/linux: Linux kernel source tree. Pulp Platform, PULP Platform. 2019. pulp-platform/linux: Linux kernel source tree. https: //github.com/pulp-platform/linux\n\nReturn-Oriented Programming. Marco Prandini, Marco Ramilli, 10.1109/MSP.2012.152IEEE Security & Privacy. 10Marco Prandini and Marco Ramilli. 2012. Return-Oriented Programming. IEEE Security & Privacy 10, 6 (December 2012), 84\u015b87. https://doi.org/10.1109/MSP. 2012.152\n\nPractical Byte-Granular Memory Blacklisting Using Califorms. Hiroshi Sasaki, Miguel A Arroyo, M Tarek Ibn Ziad, Koustubha Bhat, Kanad Sinha, Simha Sethumadhavan, 10.1145/3352460.3358299Proceedings of the 52nd Annual IEEE/ACM International Symposium on Microarchitecture (MICRO '52). the 52nd Annual IEEE/ACM International Symposium on Microarchitecture (MICRO '52)Columbus, OH, USA, 558\u015b571Hiroshi Sasaki, Miguel A. Arroyo, M. Tarek Ibn Ziad, Koustubha Bhat, Kanad Sinha, and Simha Sethumadhavan. 2019. Practical Byte-Granular Memory Black- listing Using Califorms. In Proceedings of the 52nd Annual IEEE/ACM International Symposium on Microarchitecture (MICRO '52). Columbus, OH, USA, 558\u015b571. https://doi.org/10.1145/3352460.3358299\n\nAddressSanitizer: A Fast Address Sanity Checker. Konstantin Serebryany, Derek Bruening, Alexander Potapenko, Dmitriy Vyukov, Proceedings of the 2012 USENIX Annual Technical Conference (USENIX ATC '12). the 2012 USENIX Annual Technical Conference (USENIX ATC '12)Boston, MA, USAKonstantin Serebryany, Derek Bruening, Alexander Potapenko, and Dmitriy Vyukov. 2012. AddressSanitizer: A Fast Address Sanity Checker. In Proceedings of the 2012 USENIX Annual Technical Conference (USENIX ATC '12). Boston, MA, USA. https://www.usenix.org/conference/atc12/technical-sessions/presentation/ serebryany\n\n. Julian Seward, Julian Seward. 2019. bzip2. (2019). https://www.sourceware.org/bzip2/\n\nPractical Memory Safety with REST. Kanad Sinha, Simha Sethumadhavan, 10.1109/ISCA.2018.00056Proceedings of the ACM/IEEE 45th International Symposium on Computer Architecture (ISCA '18). the ACM/IEEE 45th International Symposium on Computer Architecture (ISCA '18)Los Angeles, CA, USAKanad Sinha and Simha Sethumadhavan. 2018. Practical Memory Safety with REST. In Proceedings of the ACM/IEEE 45th International Symposium on Computer Architecture (ISCA '18). Los Angeles, CA, USA. https://doi.org/10.1109/ISCA. 2018.00056\n\nSoK: Sanitizing for Security. Dokyung Song, Julian Lettner, Prabhu Rajasekaran, Yeoul Na, Stijn Volckaert, Per Larsen, Michael Franz, 10.1109/SP.2019.000102019 IEEE Symposium on Security and Privacy (Oakland '19). San Francisco, CA, USADokyung Song, Julian Lettner, Prabhu Rajasekaran, Yeoul Na, Stijn Volckaert, Per Larsen, and Michael Franz. 2019. SoK: Sanitizing for Security. In 2019 IEEE Symposium on Security and Privacy (Oakland '19). San Francisco, CA, USA, 1275\u015b 1295. https://doi.org/10.1109/SP.2019.00010\n\nSoK: Eternal war in memory. Laszlo Szekeres, Mathias Payer, Tao Wei, Dawn Song, 10.1109/SP.2013.13Porceedings of the 34th IEEE Symposium on Security and Privacy (Oakland '13). San Francisco, CA, USA, 48\u015b62Laszlo Szekeres, Mathias Payer, Tao Wei, and Dawn Song. 2013. SoK: Eternal war in memory. In Porceedings of the 34th IEEE Symposium on Security and Privacy (Oakland '13). San Francisco, CA, USA, 48\u015b62. https://doi.org/10.1109/SP.2013.13\n\nWolfCrypt Embedded Crypto Engine. Wolfssl Inc, WolfSSL Inc. 2020. WolfCrypt Embedded Crypto Engine. (2020). https://www. wolfssl.com/products/wolfcrypt-2/\n\nThe CHERI capability model: Revisiting RISC in an age of risk. Jonathan Woodruff, N M Robert, David Watson, Chisnall, W Simon, Jonathan Moore, Brooks Anderson, Ben Davis, Laurie, G Peter, Robert Neumann, Michael Norton, Roe, 10.1109/ISCA.2014.6853201Proceedings of the ACM/IEEE 41st International Symposium on Computer Architecture (ISCA '14). the ACM/IEEE 41st International Symposium on Computer Architecture (ISCA '14)Minneapolis, MN, USA, 457\u015b468Jonathan Woodruff, Robert NM Watson, David Chisnall, Simon W Moore, Jonathan Anderson, Brooks Davis, Ben Laurie, Peter G Neumann, Robert Nor- ton, and Michael Roe. 2014. The CHERI capability model: Revisiting RISC in an age of risk. In Proceedings of the ACM/IEEE 41st International Sympo- sium on Computer Architecture (ISCA '14). Minneapolis, MN, USA, 457\u015b468. https://doi.org/10.1109/ISCA.2014.6853201\n\nPAriCheck: An Efficient Pointer Arithmetic Checker for C Programs. Yves Younan, Pieter Philippaerts, Lorenzo Cavallaro, R Sekar, Frank Piessens, Wouter Joosen, 10.1145/1755688.1755707Proceedings of the 5th ACM Symposium on Information, Computer and Communications Security (ASIACCS '10). the 5th ACM Symposium on Information, Computer and Communications Security (ASIACCS '10)Beijing, ChinaYves Younan, Pieter Philippaerts, Lorenzo Cavallaro, R. Sekar, Frank Piessens, and Wouter Joosen. 2010. PAriCheck: An Efficient Pointer Arithmetic Checker for C Programs. In Proceedings of the 5th ACM Symposium on Information, Computer and Communications Security (ASIACCS '10). Beijing, China, 145\u015b156. https: //doi.org/10.1145/1755688.1755707\n\nThe Cost of Application-Class Processing: Energy and Performance Analysis of a Linux-Ready 1.7-GHz 64-Bit RISC-V Core in 22-nm FDSOI Technology. Florian Zaruba, Luca Benini, 10.1109/TVLSI.2019.2926114IEEE Transactions on Very Large Scale Integration (VLSI) Systems. 27Florian Zaruba and Luca Benini. 2019. The Cost of Application-Class Processing: Energy and Performance Analysis of a Linux-Ready 1.7-GHz 64-Bit RISC-V Core in 22-nm FDSOI Technology. IEEE Transactions on Very Large Scale Integration (VLSI) Systems 27, 11 (November 2019), 2629\u015b2640. https://doi.org/10.1109/TVLSI. 2019.2926114\n\nEmpirical Measurements of Six Allocation-Intensive C Programs. Benjamin Zorn, Dirk Grunwald, 10.1145/142181.142200ACM SIGPLAN Notices. 27Benjamin Zorn and Dirk Grunwald. 1992. Empirical Measurements of Six Allocation-Intensive C Programs. ACM SIGPLAN Notices 27, 12 (December 1992), 71\u015b80. https://doi.org/10.1145/142181.142200\n", "annotations": {"author": "[{\"start\":\"137\",\"end\":\"208\"},{\"start\":\"209\",\"end\":\"275\"},{\"start\":\"276\",\"end\":\"337\"}]", "publisher": null, "author_last_name": "[{\"start\":\"146\",\"end\":\"148\"},{\"start\":\"213\",\"end\":\"218\"},{\"start\":\"282\",\"end\":\"285\"}]", "author_first_name": "[{\"start\":\"137\",\"end\":\"145\"},{\"start\":\"209\",\"end\":\"212\"},{\"start\":\"276\",\"end\":\"281\"}]", "author_affiliation": "[{\"start\":\"179\",\"end\":\"207\"},{\"start\":\"246\",\"end\":\"274\"},{\"start\":\"308\",\"end\":\"336\"}]", "title": "[{\"start\":\"1\",\"end\":\"117\"},{\"start\":\"338\",\"end\":\"454\"}]", "venue": "[{\"start\":\"456\",\"end\":\"466\"}]", "abstract": "[{\"start\":\"1044\",\"end\":\"2614\"}]", "bib_ref": "[{\"start\":\"2789\",\"end\":\"2793\",\"attributes\":{\"ref_id\":\"b41\"}},{\"start\":\"3038\",\"end\":\"3042\",\"attributes\":{\"ref_id\":\"b35\"}},{\"start\":\"3065\",\"end\":\"3069\",\"attributes\":{\"ref_id\":\"b18\"}},{\"start\":\"3453\",\"end\":\"3457\",\"attributes\":{\"ref_id\":\"b41\"}},{\"start\":\"3767\",\"end\":\"3771\",\"attributes\":{\"ref_id\":\"b10\"}},{\"start\":\"3771\",\"end\":\"3774\",\"attributes\":{\"ref_id\":\"b30\"}},{\"start\":\"3774\",\"end\":\"3777\",\"attributes\":{\"ref_id\":\"b33\"}},{\"start\":\"3893\",\"end\":\"3897\",\"attributes\":{\"ref_id\":\"b43\"}},{\"start\":\"3981\",\"end\":\"3984\",\"attributes\":{\"ref_id\":\"b4\"}},{\"start\":\"3984\",\"end\":\"3987\",\"attributes\":{\"ref_id\":\"b25\"}},{\"start\":\"3987\",\"end\":\"3990\",\"attributes\":{\"ref_id\":\"b31\"}},{\"start\":\"3990\",\"end\":\"3993\",\"attributes\":{\"ref_id\":\"b37\"}},{\"start\":\"3993\",\"end\":\"3996\",\"attributes\":{\"ref_id\":\"b39\"}},{\"start\":\"4680\",\"end\":\"4684\",\"attributes\":{\"ref_id\":\"b25\"}},{\"start\":\"4835\",\"end\":\"4838\",\"attributes\":{\"ref_id\":\"b4\"}},{\"start\":\"4838\",\"end\":\"4841\",\"attributes\":{\"ref_id\":\"b14\"}},{\"start\":\"4841\",\"end\":\"4844\",\"attributes\":{\"ref_id\":\"b22\"}},{\"start\":\"4844\",\"end\":\"4847\",\"attributes\":{\"ref_id\":\"b31\"}},{\"start\":\"5514\",\"end\":\"5518\",\"attributes\":{\"ref_id\":\"b12\"}},{\"start\":\"5565\",\"end\":\"5569\",\"attributes\":{\"ref_id\":\"b12\"}},{\"start\":\"6267\",\"end\":\"6270\",\"attributes\":{\"ref_id\":\"b0\"}},{\"start\":\"8817\",\"end\":\"8820\",\"attributes\":{\"ref_id\":\"b1\"}},{\"start\":\"9326\",\"end\":\"9330\",\"attributes\":{\"ref_id\":\"b41\"}},{\"start\":\"9445\",\"end\":\"9449\",\"attributes\":{\"ref_id\":\"b33\"}},{\"start\":\"10274\",\"end\":\"10277\",\"attributes\":{\"ref_id\":\"b9\"}},{\"start\":\"10277\",\"end\":\"10280\",\"attributes\":{\"ref_id\":\"b43\"}},{\"start\":\"10351\",\"end\":\"10355\",\"attributes\":{\"ref_id\":\"b43\"}},{\"start\":\"10946\",\"end\":\"10950\",\"attributes\":{\"ref_id\":\"b10\"}},{\"start\":\"11078\",\"end\":\"11082\",\"attributes\":{\"ref_id\":\"b33\"}},{\"start\":\"11499\",\"end\":\"11503\",\"attributes\":{\"ref_id\":\"b29\"}},{\"start\":\"11515\",\"end\":\"11518\",\"attributes\":{\"ref_id\":\"b9\"}},{\"start\":\"11531\",\"end\":\"11535\",\"attributes\":{\"ref_id\":\"b21\"}},{\"start\":\"11589\",\"end\":\"11590\",\"attributes\":{\"ref_id\":\"b0\"}},{\"start\":\"11783\",\"end\":\"11784\",\"attributes\":{\"ref_id\":\"b1\"}},{\"start\":\"11901\",\"end\":\"11902\",\"attributes\":{\"ref_id\":\"b2\"}},{\"start\":\"12821\",\"end\":\"12824\",\"attributes\":{\"ref_id\":\"b0\"}},{\"start\":\"12824\",\"end\":\"12827\",\"attributes\":{\"ref_id\":\"b12\"}},{\"start\":\"13656\",\"end\":\"13660\",\"attributes\":{\"ref_id\":\"b36\"}},{\"start\":\"13660\",\"end\":\"13663\",\"attributes\":{\"ref_id\":\"b37\"}},{\"start\":\"13663\",\"end\":\"13666\",\"attributes\":{\"ref_id\":\"b39\"}},{\"start\":\"13685\",\"end\":\"13689\",\"attributes\":{\"ref_id\":\"b37\"}},{\"start\":\"14045\",\"end\":\"14049\",\"attributes\":{\"ref_id\":\"b39\"}},{\"start\":\"14064\",\"end\":\"14068\",\"attributes\":{\"ref_id\":\"b36\"}},{\"start\":\"14102\",\"end\":\"14106\",\"attributes\":{\"ref_id\":\"b19\"}},{\"start\":\"14278\",\"end\":\"14282\",\"attributes\":{\"ref_id\":\"b27\"}},{\"start\":\"14491\",\"end\":\"14495\",\"attributes\":{\"ref_id\":\"b11\"}},{\"start\":\"14636\",\"end\":\"14640\",\"attributes\":{\"ref_id\":\"b27\"}},{\"start\":\"14640\",\"end\":\"14643\",\"attributes\":{\"ref_id\":\"b36\"}},{\"start\":\"14643\",\"end\":\"14646\",\"attributes\":{\"ref_id\":\"b37\"}},{\"start\":\"14646\",\"end\":\"14649\",\"attributes\":{\"ref_id\":\"b39\"}},{\"start\":\"15135\",\"end\":\"15139\",\"attributes\":{\"ref_id\":\"b13\"}},{\"start\":\"15601\",\"end\":\"15604\",\"attributes\":{\"ref_id\":\"b8\"}},{\"start\":\"15604\",\"end\":\"15607\",\"attributes\":{\"ref_id\":\"b13\"}},{\"start\":\"15607\",\"end\":\"15610\",\"attributes\":{\"ref_id\":\"b25\"}},{\"start\":\"15702\",\"end\":\"15705\",\"attributes\":{\"ref_id\":\"b1\"}},{\"start\":\"16253\",\"end\":\"16256\",\"attributes\":{\"ref_id\":\"b4\"}},{\"start\":\"16358\",\"end\":\"16362\",\"attributes\":{\"ref_id\":\"b31\"}},{\"start\":\"16479\",\"end\":\"16483\",\"attributes\":{\"ref_id\":\"b20\"}},{\"start\":\"16575\",\"end\":\"16578\",\"attributes\":{\"ref_id\":\"b1\"}},{\"start\":\"16647\",\"end\":\"16651\",\"attributes\":{\"ref_id\":\"b14\"}},{\"start\":\"16693\",\"end\":\"16697\",\"attributes\":{\"ref_id\":\"b13\"}},{\"start\":\"17006\",\"end\":\"17010\",\"attributes\":{\"ref_id\":\"b14\"}},{\"start\":\"18145\",\"end\":\"18149\",\"attributes\":{\"ref_id\":\"b43\"}},{\"start\":\"18263\",\"end\":\"18267\",\"attributes\":{\"ref_id\":\"b33\"}},{\"start\":\"27133\",\"end\":\"27134\",\"attributes\":{\"ref_id\":\"b3\"}},{\"start\":\"29749\",\"end\":\"29750\",\"attributes\":{\"ref_id\":\"b0\"}},{\"start\":\"32993\",\"end\":\"32996\",\"attributes\":{\"ref_id\":\"b7\"}},{\"start\":\"32996\",\"end\":\"32999\",\"attributes\":{\"ref_id\":\"b46\"}},{\"start\":\"33164\",\"end\":\"33167\",\"attributes\":{\"ref_id\":\"b3\"}},{\"start\":\"38707\",\"end\":\"38710\",\"attributes\":{\"ref_id\":\"b0\"}},{\"start\":\"39157\",\"end\":\"39160\",\"attributes\":{\"ref_id\":\"b0\"}},{\"start\":\"39236\",\"end\":\"39239\",\"attributes\":{\"ref_id\":\"b0\"}},{\"start\":\"39273\",\"end\":\"39276\",\"attributes\":{\"ref_id\":\"b0\"}},{\"start\":\"40781\",\"end\":\"40785\",\"attributes\":{\"ref_id\":\"b45\"}},{\"start\":\"40958\",\"end\":\"40962\",\"attributes\":{\"ref_id\":\"b34\"}},{\"start\":\"41090\",\"end\":\"41094\",\"attributes\":{\"ref_id\":\"b26\"}},{\"start\":\"49343\",\"end\":\"49347\",\"attributes\":{\"ref_id\":\"b15\"}},{\"start\":\"49347\",\"end\":\"49350\",\"attributes\":{\"ref_id\":\"b24\"}},{\"start\":\"49350\",\"end\":\"49353\",\"attributes\":{\"ref_id\":\"b28\"}},{\"start\":\"52531\",\"end\":\"52535\"},{\"start\":\"54878\",\"end\":\"54881\",\"attributes\":{\"ref_id\":\"b6\"}},{\"start\":\"54939\",\"end\":\"54942\",\"attributes\":{\"ref_id\":\"b2\"}},{\"start\":\"54991\",\"end\":\"54995\",\"attributes\":{\"ref_id\":\"b38\"}},{\"start\":\"55081\",\"end\":\"55085\",\"attributes\":{\"ref_id\":\"b17\"}},{\"start\":\"55138\",\"end\":\"55142\",\"attributes\":{\"ref_id\":\"b16\"}},{\"start\":\"55189\",\"end\":\"55193\",\"attributes\":{\"ref_id\":\"b42\"}},{\"start\":\"55594\",\"end\":\"55595\",\"attributes\":{\"ref_id\":\"b4\"}},{\"start\":\"64010\",\"end\":\"64014\",\"attributes\":{\"ref_id\":\"b31\"}},{\"start\":\"64025\",\"end\":\"64029\",\"attributes\":{\"ref_id\":\"b43\"}},{\"start\":\"64075\",\"end\":\"64079\",\"attributes\":{\"ref_id\":\"b33\"}},{\"start\":\"72597\",\"end\":\"72598\",\"attributes\":{\"ref_id\":\"b8\"}},{\"start\":\"73691\",\"end\":\"73694\",\"attributes\":{\"ref_id\":\"b12\"}},{\"start\":\"73694\",\"end\":\"73697\",\"attributes\":{\"ref_id\":\"b13\"}},{\"start\":\"73697\",\"end\":\"73700\",\"attributes\":{\"ref_id\":\"b13\"}},{\"start\":\"73700\",\"end\":\"73703\",\"attributes\":{\"ref_id\":\"b12\"}},{\"start\":\"73703\",\"end\":\"73706\",\"attributes\":{\"ref_id\":\"b12\"}},{\"start\":\"73706\",\"end\":\"73709\",\"attributes\":{\"ref_id\":\"b16\"}},{\"start\":\"73709\",\"end\":\"73712\",\"attributes\":{\"ref_id\":\"b11\"}},{\"start\":\"73712\",\"end\":\"73715\",\"attributes\":{\"ref_id\":\"b13\"}},{\"start\":\"73715\",\"end\":\"73717\",\"attributes\":{\"ref_id\":\"b18\"}},{\"start\":\"73722\",\"end\":\"73724\",\"attributes\":{\"ref_id\":\"b6\"}},{\"start\":\"73724\",\"end\":\"73726\",\"attributes\":{\"ref_id\":\"b7\"}},{\"start\":\"73726\",\"end\":\"73728\",\"attributes\":{\"ref_id\":\"b7\"}},{\"start\":\"73728\",\"end\":\"73730\",\"attributes\":{\"ref_id\":\"b6\"}},{\"start\":\"73730\",\"end\":\"73732\",\"attributes\":{\"ref_id\":\"b6\"}},{\"start\":\"73732\",\"end\":\"73734\",\"attributes\":{\"ref_id\":\"b8\"}},{\"start\":\"73734\",\"end\":\"73736\",\"attributes\":{\"ref_id\":\"b4\"}},{\"start\":\"73736\",\"end\":\"73738\",\"attributes\":{\"ref_id\":\"b7\"}},{\"start\":\"73738\",\"end\":\"73739\",\"attributes\":{\"ref_id\":\"b8\"}},{\"start\":\"73818\",\"end\":\"73819\",\"attributes\":{\"ref_id\":\"b8\"}},{\"start\":\"77186\",\"end\":\"77190\",\"attributes\":{\"ref_id\":\"b14\"}},{\"start\":\"79666\",\"end\":\"79667\",\"attributes\":{\"ref_id\":\"b1\"}},{\"start\":\"81966\",\"end\":\"81967\",\"attributes\":{\"ref_id\":\"b6\"}}]", "figure": "[{\"start\":\"74977\",\"end\":\"75165\",\"attributes\":{\"id\":\"fig_1\"}},{\"start\":\"75166\",\"end\":\"75210\",\"attributes\":{\"id\":\"fig_2\"}},{\"start\":\"75211\",\"end\":\"75320\",\"attributes\":{\"id\":\"fig_3\"}},{\"start\":\"75321\",\"end\":\"75353\",\"attributes\":{\"id\":\"fig_4\"}},{\"start\":\"75354\",\"end\":\"75513\",\"attributes\":{\"id\":\"fig_5\"}},{\"start\":\"75514\",\"end\":\"75533\",\"attributes\":{\"id\":\"fig_6\"}},{\"start\":\"75534\",\"end\":\"75637\",\"attributes\":{\"id\":\"fig_7\"}},{\"start\":\"75638\",\"end\":\"75693\",\"attributes\":{\"id\":\"fig_8\"}},{\"start\":\"75694\",\"end\":\"75747\",\"attributes\":{\"id\":\"fig_9\"}},{\"start\":\"75748\",\"end\":\"75809\",\"attributes\":{\"id\":\"fig_10\"}},{\"start\":\"75810\",\"end\":\"77035\",\"attributes\":{\"id\":\"tab_0\",\"type\":\"table\"}},{\"start\":\"77036\",\"end\":\"77326\",\"attributes\":{\"id\":\"tab_1\",\"type\":\"table\"}},{\"start\":\"77327\",\"end\":\"77630\",\"attributes\":{\"id\":\"tab_3\",\"type\":\"table\"}},{\"start\":\"77631\",\"end\":\"77843\",\"attributes\":{\"id\":\"tab_4\",\"type\":\"table\"}},{\"start\":\"77844\",\"end\":\"78899\",\"attributes\":{\"id\":\"tab_5\",\"type\":\"table\"}},{\"start\":\"78900\",\"end\":\"79385\",\"attributes\":{\"id\":\"tab_6\",\"type\":\"table\"}},{\"start\":\"79386\",\"end\":\"81405\",\"attributes\":{\"id\":\"tab_7\",\"type\":\"table\"}}]", "paragraph": "[{\"start\":\"2630\",\"end\":\"3258\"},{\"start\":\"3260\",\"end\":\"4238\"},{\"start\":\"4240\",\"end\":\"5575\"},{\"start\":\"5577\",\"end\":\"6104\"},{\"start\":\"6106\",\"end\":\"6789\"},{\"start\":\"6791\",\"end\":\"7252\"},{\"start\":\"7254\",\"end\":\"8249\"},{\"start\":\"8281\",\"end\":\"9611\"},{\"start\":\"9635\",\"end\":\"11365\"},{\"start\":\"11367\",\"end\":\"12632\"},{\"start\":\"12674\",\"end\":\"13126\"},{\"start\":\"13128\",\"end\":\"13443\"},{\"start\":\"13445\",\"end\":\"14651\"},{\"start\":\"14678\",\"end\":\"15196\"},{\"start\":\"15198\",\"end\":\"16068\"},{\"start\":\"16070\",\"end\":\"17170\"},{\"start\":\"17172\",\"end\":\"17855\"},{\"start\":\"17885\",\"end\":\"19179\"},{\"start\":\"19181\",\"end\":\"19414\"},{\"start\":\"19416\",\"end\":\"20378\"},{\"start\":\"20380\",\"end\":\"20717\"},{\"start\":\"20730\",\"end\":\"21906\"},{\"start\":\"21908\",\"end\":\"22837\"},{\"start\":\"22839\",\"end\":\"24231\"},{\"start\":\"24247\",\"end\":\"25199\"},{\"start\":\"25236\",\"end\":\"26523\"},{\"start\":\"26525\",\"end\":\"27309\"},{\"start\":\"27311\",\"end\":\"28882\"},{\"start\":\"28884\",\"end\":\"29039\"},{\"start\":\"29067\",\"end\":\"29480\"},{\"start\":\"29482\",\"end\":\"29801\"},{\"start\":\"29803\",\"end\":\"30358\"},{\"start\":\"30360\",\"end\":\"30559\"},{\"start\":\"30561\",\"end\":\"31975\"},{\"start\":\"31977\",\"end\":\"33000\"},{\"start\":\"33012\",\"end\":\"34573\"},{\"start\":\"34575\",\"end\":\"35534\"},{\"start\":\"35545\",\"end\":\"35908\"},{\"start\":\"35925\",\"end\":\"37138\"},{\"start\":\"37140\",\"end\":\"39882\"},{\"start\":\"39884\",\"end\":\"40610\"},{\"start\":\"40629\",\"end\":\"43456\"},{\"start\":\"43495\",\"end\":\"44006\"},{\"start\":\"44029\",\"end\":\"45056\"},{\"start\":\"45080\",\"end\":\"46998\"},{\"start\":\"47000\",\"end\":\"47893\"},{\"start\":\"47914\",\"end\":\"48578\"},{\"start\":\"48609\",\"end\":\"49393\"},{\"start\":\"49395\",\"end\":\"50210\"},{\"start\":\"50256\",\"end\":\"50723\"},{\"start\":\"50725\",\"end\":\"51743\"},{\"start\":\"51758\",\"end\":\"52059\"},{\"start\":\"52061\",\"end\":\"52410\"},{\"start\":\"52436\",\"end\":\"54733\"},{\"start\":\"54760\",\"end\":\"55597\"},{\"start\":\"55599\",\"end\":\"56218\"},{\"start\":\"56220\",\"end\":\"57411\"},{\"start\":\"57443\",\"end\":\"58451\"},{\"start\":\"58453\",\"end\":\"59942\"},{\"start\":\"59944\",\"end\":\"60693\"},{\"start\":\"60719\",\"end\":\"61175\"},{\"start\":\"61177\",\"end\":\"64080\"},{\"start\":\"64101\",\"end\":\"64703\"},{\"start\":\"64754\",\"end\":\"66112\"},{\"start\":\"66141\",\"end\":\"66677\"},{\"start\":\"66679\",\"end\":\"68161\"},{\"start\":\"68163\",\"end\":\"68986\"},{\"start\":\"69001\",\"end\":\"69525\"},{\"start\":\"69527\",\"end\":\"71159\"},{\"start\":\"71161\",\"end\":\"71422\"},{\"start\":\"71424\",\"end\":\"71645\"},{\"start\":\"71647\",\"end\":\"71976\"},{\"start\":\"71997\",\"end\":\"72125\"},{\"start\":\"72127\",\"end\":\"72374\"},{\"start\":\"72376\",\"end\":\"72476\"},{\"start\":\"72478\",\"end\":\"72749\"},{\"start\":\"72751\",\"end\":\"72787\"},{\"start\":\"72789\",\"end\":\"73027\"},{\"start\":\"73055\",\"end\":\"74001\"},{\"start\":\"74041\",\"end\":\"74118\"},{\"start\":\"74120\",\"end\":\"74516\"},{\"start\":\"74556\",\"end\":\"74764\"},{\"start\":\"74778\",\"end\":\"74976\"}]", "formula": null, "table_ref": "[{\"start\":\"8501\",\"end\":\"8508\",\"attributes\":{\"ref_id\":\"tab_0\"}},{\"start\":\"29388\",\"end\":\"29395\",\"attributes\":{\"ref_id\":\"tab_4\"}},{\"start\":\"34785\",\"end\":\"34796\"},{\"start\":\"34837\",\"end\":\"34849\"},{\"start\":\"34949\",\"end\":\"34961\"},{\"start\":\"36554\",\"end\":\"36601\"},{\"start\":\"37429\",\"end\":\"37442\"},{\"start\":\"41207\",\"end\":\"41214\",\"attributes\":{\"ref_id\":\"tab_6\"}},{\"start\":\"43928\",\"end\":\"43935\",\"attributes\":{\"ref_id\":\"tab_6\"}},{\"start\":\"48433\",\"end\":\"48499\",\"attributes\":{\"ref_id\":\"tab_6\"}},{\"start\":\"56537\",\"end\":\"56544\",\"attributes\":{\"ref_id\":\"tab_7\"}},{\"start\":\"58803\",\"end\":\"58810\",\"attributes\":{\"ref_id\":\"tab_7\"}},{\"start\":\"61086\",\"end\":\"61093\",\"attributes\":{\"ref_id\":\"tab_7\"}},{\"start\":\"61457\",\"end\":\"61464\",\"attributes\":{\"ref_id\":\"tab_7\"}}]", "section_header": "[{\"start\":\"2616\",\"end\":\"2628\",\"attributes\":{\"n\":\"1\"}},{\"start\":\"8252\",\"end\":\"8279\",\"attributes\":{\"n\":\"2\"}},{\"start\":\"9614\",\"end\":\"9633\",\"attributes\":{\"n\":\"2.1\"}},{\"start\":\"12635\",\"end\":\"12672\",\"attributes\":{\"n\":\"2.2\"}},{\"start\":\"14654\",\"end\":\"14676\",\"attributes\":{\"n\":\"2.3\"}},{\"start\":\"17858\",\"end\":\"17883\",\"attributes\":{\"n\":\"3\"}},{\"start\":\"20720\",\"end\":\"20728\",\"attributes\":{\"n\":\"3.1\"}},{\"start\":\"24234\",\"end\":\"24245\"},{\"start\":\"25202\",\"end\":\"25234\",\"attributes\":{\"n\":\"3.2\"}},{\"start\":\"29042\",\"end\":\"29065\",\"attributes\":{\"n\":\"3.3\"}},{\"start\":\"33003\",\"end\":\"33010\",\"attributes\":{\"n\":\"3.3.2\"}},{\"start\":\"35537\",\"end\":\"35543\",\"attributes\":{\"n\":\"3.3.3\"}},{\"start\":\"35911\",\"end\":\"35923\",\"attributes\":{\"n\":\"3.4\"}},{\"start\":\"40613\",\"end\":\"40627\",\"attributes\":{\"n\":\"4\"}},{\"start\":\"43459\",\"end\":\"43493\",\"attributes\":{\"n\":\"4.1\"}},{\"start\":\"44009\",\"end\":\"44027\",\"attributes\":{\"n\":\"4.1.1\"}},{\"start\":\"45059\",\"end\":\"45078\",\"attributes\":{\"n\":\"4.1.2\"}},{\"start\":\"47896\",\"end\":\"47912\",\"attributes\":{\"n\":\"4.2\"}},{\"start\":\"48581\",\"end\":\"48607\",\"attributes\":{\"n\":\"4.2.1\"}},{\"start\":\"50213\",\"end\":\"50254\",\"attributes\":{\"n\":\"4.2.2\"}},{\"start\":\"51746\",\"end\":\"51756\",\"attributes\":{\"n\":\"5\"}},{\"start\":\"52413\",\"end\":\"52434\",\"attributes\":{\"n\":\"5.1\"}},{\"start\":\"54736\",\"end\":\"54758\",\"attributes\":{\"n\":\"5.2\"}},{\"start\":\"57414\",\"end\":\"57441\",\"attributes\":{\"n\":\"5.2.1\"}},{\"start\":\"60696\",\"end\":\"60717\",\"attributes\":{\"n\":\"5.2.2\"}},{\"start\":\"64083\",\"end\":\"64099\",\"attributes\":{\"n\":\"5.2.3\"}},{\"start\":\"64706\",\"end\":\"64752\",\"attributes\":{\"n\":\"5.2.4\"}},{\"start\":\"66115\",\"end\":\"66139\",\"attributes\":{\"n\":\"5.3\"}},{\"start\":\"68989\",\"end\":\"68999\",\"attributes\":{\"n\":\"6\"}},{\"start\":\"71979\",\"end\":\"71995\"},{\"start\":\"73030\",\"end\":\"73053\"},{\"start\":\"74004\",\"end\":\"74039\"},{\"start\":\"74519\",\"end\":\"74554\"},{\"start\":\"74767\",\"end\":\"74776\"},{\"start\":\"74978\",\"end\":\"74988\"},{\"start\":\"75212\",\"end\":\"75222\"},{\"start\":\"75322\",\"end\":\"75332\"},{\"start\":\"75355\",\"end\":\"75365\"},{\"start\":\"75515\",\"end\":\"75525\"},{\"start\":\"75535\",\"end\":\"75557\"},{\"start\":\"75639\",\"end\":\"75650\"},{\"start\":\"75695\",\"end\":\"75706\"},{\"start\":\"75749\",\"end\":\"75771\"},{\"start\":\"75811\",\"end\":\"75820\"},{\"start\":\"77632\",\"end\":\"77641\"},{\"start\":\"78901\",\"end\":\"78910\"},{\"start\":\"79387\",\"end\":\"79396\"}]", "table": "[{\"start\":\"75891\",\"end\":\"77035\"},{\"start\":\"77191\",\"end\":\"77326\"},{\"start\":\"77406\",\"end\":\"77630\"},{\"start\":\"78136\",\"end\":\"78899\"},{\"start\":\"78994\",\"end\":\"79385\"},{\"start\":\"79803\",\"end\":\"81405\"}]", "figure_caption": "[{\"start\":\"74990\",\"end\":\"75165\"},{\"start\":\"75168\",\"end\":\"75210\"},{\"start\":\"75224\",\"end\":\"75320\"},{\"start\":\"75334\",\"end\":\"75353\"},{\"start\":\"75367\",\"end\":\"75513\"},{\"start\":\"75527\",\"end\":\"75533\"},{\"start\":\"75562\",\"end\":\"75637\"},{\"start\":\"75653\",\"end\":\"75693\"},{\"start\":\"75709\",\"end\":\"75747\"},{\"start\":\"75776\",\"end\":\"75809\"},{\"start\":\"75822\",\"end\":\"75891\"},{\"start\":\"77038\",\"end\":\"77191\"},{\"start\":\"77329\",\"end\":\"77406\"},{\"start\":\"77643\",\"end\":\"77843\"},{\"start\":\"77846\",\"end\":\"78136\"},{\"start\":\"78912\",\"end\":\"78994\"},{\"start\":\"79398\",\"end\":\"79803\"}]", "figure_ref": "[{\"start\":\"16239\",\"end\":\"16247\"},{\"start\":\"17366\",\"end\":\"17374\"},{\"start\":\"18354\",\"end\":\"18362\"},{\"start\":\"20897\",\"end\":\"20905\",\"attributes\":{\"ref_id\":\"fig_1\"}},{\"start\":\"21361\",\"end\":\"21369\"},{\"start\":\"25367\",\"end\":\"25375\",\"attributes\":{\"ref_id\":\"fig_3\"}},{\"start\":\"25641\",\"end\":\"25649\"},{\"start\":\"27135\",\"end\":\"27143\"},{\"start\":\"27219\",\"end\":\"27227\",\"attributes\":{\"ref_id\":\"fig_3\"}},{\"start\":\"27300\",\"end\":\"27308\"},{\"start\":\"27412\",\"end\":\"27420\"},{\"start\":\"28138\",\"end\":\"28146\"},{\"start\":\"30711\",\"end\":\"30719\",\"attributes\":{\"ref_id\":\"fig_4\"}},{\"start\":\"33184\",\"end\":\"33192\",\"attributes\":{\"ref_id\":\"fig_5\"}},{\"start\":\"34820\",\"end\":\"34828\"},{\"start\":\"35161\",\"end\":\"35169\"},{\"start\":\"36155\",\"end\":\"36163\",\"attributes\":{\"ref_id\":\"fig_6\"}},{\"start\":\"36432\",\"end\":\"36441\",\"attributes\":{\"ref_id\":\"fig_6\"}},{\"start\":\"37582\",\"end\":\"37590\",\"attributes\":{\"ref_id\":\"fig_6\"}},{\"start\":\"38555\",\"end\":\"38564\",\"attributes\":{\"ref_id\":\"fig_6\"}},{\"start\":\"60384\",\"end\":\"60393\"},{\"start\":\"61281\",\"end\":\"61290\"},{\"start\":\"63112\",\"end\":\"63121\"},{\"start\":\"63434\",\"end\":\"63443\",\"attributes\":{\"ref_id\":\"fig_8\"}},{\"start\":\"65143\",\"end\":\"65152\"},{\"start\":\"67002\",\"end\":\"67011\",\"attributes\":{\"ref_id\":\"fig_1\"}},{\"start\":\"69974\",\"end\":\"69983\",\"attributes\":{\"ref_id\":\"fig_3\"}},{\"start\":\"70548\",\"end\":\"70557\"},{\"start\":\"74588\",\"end\":\"74597\"}]", "bib_author_first_name": "[{\"start\":\"83218\",\"end\":\"83226\"},{\"start\":\"83238\",\"end\":\"83244\"},{\"start\":\"83252\",\"end\":\"83258\"},{\"start\":\"83267\",\"end\":\"83273\"},{\"start\":\"84037\",\"end\":\"84041\"},{\"start\":\"84216\",\"end\":\"84220\"},{\"start\":\"84635\",\"end\":\"84641\"},{\"start\":\"84649\",\"end\":\"84656\"},{\"start\":\"84664\",\"end\":\"84669\"},{\"start\":\"84670\",\"end\":\"84671\"},{\"start\":\"84678\",\"end\":\"84685\"},{\"start\":\"85065\",\"end\":\"85073\"},{\"start\":\"85244\",\"end\":\"85245\"},{\"start\":\"85254\",\"end\":\"85258\"},{\"start\":\"85863\",\"end\":\"85864\"},{\"start\":\"85867\",\"end\":\"85873\"},{\"start\":\"86288\",\"end\":\"86295\"},{\"start\":\"86302\",\"end\":\"86309\"},{\"start\":\"86314\",\"end\":\"86318\"},{\"start\":\"86325\",\"end\":\"86329\"},{\"start\":\"86335\",\"end\":\"86341\"},{\"start\":\"86348\",\"end\":\"86352\"},{\"start\":\"86359\",\"end\":\"86361\"},{\"start\":\"86692\",\"end\":\"86693\"},{\"start\":\"86706\",\"end\":\"86711\"},{\"start\":\"86735\",\"end\":\"86742\"},{\"start\":\"86750\",\"end\":\"86758\"},{\"start\":\"87527\",\"end\":\"87530\"},{\"start\":\"87541\",\"end\":\"87546\"},{\"start\":\"87557\",\"end\":\"87561\"},{\"start\":\"87562\",\"end\":\"87565\"},{\"start\":\"87574\",\"end\":\"87579\"},{\"start\":\"88327\",\"end\":\"88331\"},{\"start\":\"88340\",\"end\":\"88347\"},{\"start\":\"88356\",\"end\":\"88363\"},{\"start\":\"88371\",\"end\":\"88376\"},{\"start\":\"88388\",\"end\":\"88394\"},{\"start\":\"88407\",\"end\":\"88415\"},{\"start\":\"88416\",\"end\":\"88417\"},{\"start\":\"88425\",\"end\":\"88431\"},{\"start\":\"88432\",\"end\":\"88433\"},{\"start\":\"88442\",\"end\":\"88450\"},{\"start\":\"88451\",\"end\":\"88452\"},{\"start\":\"88461\",\"end\":\"88466\"},{\"start\":\"89253\",\"end\":\"89260\"},{\"start\":\"89267\",\"end\":\"89273\"},{\"start\":\"89278\",\"end\":\"89284\"},{\"start\":\"89289\",\"end\":\"89293\"},{\"start\":\"89302\",\"end\":\"89306\"},{\"start\":\"89876\",\"end\":\"89877\"},{\"start\":\"89893\",\"end\":\"89894\"},{\"start\":\"89895\",\"end\":\"89896\"},{\"start\":\"89905\",\"end\":\"89912\"},{\"start\":\"90443\",\"end\":\"90444\"},{\"start\":\"90460\",\"end\":\"90461\"},{\"start\":\"90462\",\"end\":\"90463\"},{\"start\":\"91095\",\"end\":\"91100\"},{\"start\":\"91355\",\"end\":\"91359\"},{\"start\":\"91368\",\"end\":\"91374\"},{\"start\":\"91563\",\"end\":\"91564\"},{\"start\":\"91895\",\"end\":\"91899\"},{\"start\":\"91904\",\"end\":\"91910\"},{\"start\":\"91919\",\"end\":\"91927\"},{\"start\":\"91936\",\"end\":\"91941\"},{\"start\":\"91954\",\"end\":\"91961\"},{\"start\":\"91970\",\"end\":\"91977\"},{\"start\":\"92437\",\"end\":\"92446\"},{\"start\":\"92456\",\"end\":\"92464\"},{\"start\":\"92475\",\"end\":\"92481\"},{\"start\":\"92493\",\"end\":\"92494\"},{\"start\":\"92502\",\"end\":\"92506\"},{\"start\":\"92514\",\"end\":\"92521\"},{\"start\":\"92537\",\"end\":\"92538\"},{\"start\":\"92539\",\"end\":\"92540\"},{\"start\":\"92549\",\"end\":\"92554\"},{\"start\":\"92563\",\"end\":\"92570\"},{\"start\":\"92581\",\"end\":\"92587\"},{\"start\":\"92593\",\"end\":\"92599\"},{\"start\":\"92607\",\"end\":\"92611\"},{\"start\":\"92623\",\"end\":\"92629\"},{\"start\":\"92639\",\"end\":\"92644\"},{\"start\":\"92645\",\"end\":\"92646\"},{\"start\":\"92654\",\"end\":\"92661\"},{\"start\":\"93349\",\"end\":\"93356\"},{\"start\":\"93362\",\"end\":\"93368\"},{\"start\":\"93374\",\"end\":\"93381\"},{\"start\":\"93819\",\"end\":\"93830\"},{\"start\":\"93845\",\"end\":\"93850\"},{\"start\":\"93868\",\"end\":\"93875\"},{\"start\":\"94286\",\"end\":\"94293\"},{\"start\":\"94301\",\"end\":\"94305\"},{\"start\":\"94314\",\"end\":\"94323\"},{\"start\":\"94335\",\"end\":\"94342\"},{\"start\":\"94348\",\"end\":\"94352\"},{\"start\":\"94740\",\"end\":\"94746\"},{\"start\":\"94839\",\"end\":\"94845\"},{\"start\":\"94855\",\"end\":\"94856\"},{\"start\":\"95284\",\"end\":\"95290\"},{\"start\":\"95297\",\"end\":\"95301\"},{\"start\":\"95310\",\"end\":\"95318\"},{\"start\":\"95319\",\"end\":\"95320\"},{\"start\":\"95328\",\"end\":\"95343\"},{\"start\":\"95348\",\"end\":\"95353\"},{\"start\":\"96046\",\"end\":\"96051\"},{\"start\":\"96061\",\"end\":\"96067\"},{\"start\":\"96513\",\"end\":\"96519\"},{\"start\":\"96525\",\"end\":\"96531\"},{\"start\":\"96538\",\"end\":\"96546\"},{\"start\":\"97170\",\"end\":\"97173\"},{\"start\":\"97360\",\"end\":\"97367\"},{\"start\":\"97381\",\"end\":\"97382\"},{\"start\":\"97383\",\"end\":\"97384\"},{\"start\":\"97391\",\"end\":\"97396\"},{\"start\":\"98029\",\"end\":\"98037\"},{\"start\":\"98059\",\"end\":\"98063\"},{\"start\":\"98064\",\"end\":\"98067\"},{\"start\":\"98074\",\"end\":\"98079\"},{\"start\":\"98746\",\"end\":\"98754\"},{\"start\":\"98771\",\"end\":\"98778\"},{\"start\":\"99187\",\"end\":\"99190\"},{\"start\":\"99197\",\"end\":\"99203\"},{\"start\":\"99391\",\"end\":\"99398\"},{\"start\":\"99410\",\"end\":\"99417\"},{\"start\":\"99429\",\"end\":\"99435\"},{\"start\":\"99446\",\"end\":\"99452\"},{\"start\":\"99461\",\"end\":\"99469\"},{\"start\":\"100019\",\"end\":\"100024\"},{\"start\":\"100035\",\"end\":\"100040\"},{\"start\":\"100320\",\"end\":\"100327\"},{\"start\":\"100336\",\"end\":\"100342\"},{\"start\":\"100343\",\"end\":\"100344\"},{\"start\":\"100353\",\"end\":\"100354\"},{\"start\":\"100371\",\"end\":\"100380\"},{\"start\":\"100387\",\"end\":\"100392\"},{\"start\":\"100400\",\"end\":\"100405\"},{\"start\":\"101044\",\"end\":\"101054\"},{\"start\":\"101067\",\"end\":\"101072\"},{\"start\":\"101083\",\"end\":\"101092\"},{\"start\":\"101104\",\"end\":\"101111\"},{\"start\":\"101591\",\"end\":\"101597\"},{\"start\":\"101712\",\"end\":\"101717\"},{\"start\":\"101725\",\"end\":\"101730\"},{\"start\":\"102229\",\"end\":\"102236\"},{\"start\":\"102243\",\"end\":\"102249\"},{\"start\":\"102259\",\"end\":\"102265\"},{\"start\":\"102279\",\"end\":\"102284\"},{\"start\":\"102289\",\"end\":\"102294\"},{\"start\":\"102306\",\"end\":\"102309\"},{\"start\":\"102318\",\"end\":\"102325\"},{\"start\":\"102744\",\"end\":\"102750\"},{\"start\":\"102761\",\"end\":\"102768\"},{\"start\":\"102776\",\"end\":\"102779\"},{\"start\":\"102785\",\"end\":\"102789\"},{\"start\":\"103193\",\"end\":\"103200\"},{\"start\":\"103378\",\"end\":\"103386\"},{\"start\":\"103397\",\"end\":\"103398\"},{\"start\":\"103399\",\"end\":\"103400\"},{\"start\":\"103409\",\"end\":\"103414\"},{\"start\":\"103433\",\"end\":\"103434\"},{\"start\":\"103442\",\"end\":\"103450\"},{\"start\":\"103458\",\"end\":\"103464\"},{\"start\":\"103475\",\"end\":\"103478\"},{\"start\":\"103494\",\"end\":\"103495\"},{\"start\":\"103503\",\"end\":\"103509\"},{\"start\":\"103519\",\"end\":\"103526\"},{\"start\":\"104238\",\"end\":\"104242\"},{\"start\":\"104251\",\"end\":\"104257\"},{\"start\":\"104272\",\"end\":\"104279\"},{\"start\":\"104291\",\"end\":\"104292\"},{\"start\":\"104300\",\"end\":\"104305\"},{\"start\":\"104316\",\"end\":\"104322\"},{\"start\":\"105052\",\"end\":\"105059\"},{\"start\":\"105068\",\"end\":\"105072\"},{\"start\":\"105566\",\"end\":\"105574\"},{\"start\":\"105581\",\"end\":\"105585\"}]", "bib_author_last_name": "[{\"start\":\"83227\",\"end\":\"83236\"},{\"start\":\"83245\",\"end\":\"83250\"},{\"start\":\"83259\",\"end\":\"83265\"},{\"start\":\"83274\",\"end\":\"83278\"},{\"start\":\"83829\",\"end\":\"83836\"},{\"start\":\"84042\",\"end\":\"84048\"},{\"start\":\"84221\",\"end\":\"84228\"},{\"start\":\"84642\",\"end\":\"84647\"},{\"start\":\"84657\",\"end\":\"84662\"},{\"start\":\"84672\",\"end\":\"84676\"},{\"start\":\"84686\",\"end\":\"84691\"},{\"start\":\"85074\",\"end\":\"85081\"},{\"start\":\"85083\",\"end\":\"85088\"},{\"start\":\"85246\",\"end\":\"85252\"},{\"start\":\"85259\",\"end\":\"85267\"},{\"start\":\"85269\",\"end\":\"85275\"},{\"start\":\"85874\",\"end\":\"85879\"},{\"start\":\"86296\",\"end\":\"86300\"},{\"start\":\"86310\",\"end\":\"86312\"},{\"start\":\"86319\",\"end\":\"86323\"},{\"start\":\"86330\",\"end\":\"86333\"},{\"start\":\"86342\",\"end\":\"86346\"},{\"start\":\"86353\",\"end\":\"86357\"},{\"start\":\"86362\",\"end\":\"86367\"},{\"start\":\"86694\",\"end\":\"86704\"},{\"start\":\"86712\",\"end\":\"86733\"},{\"start\":\"86743\",\"end\":\"86748\"},{\"start\":\"86759\",\"end\":\"86766\"},{\"start\":\"86768\",\"end\":\"86780\"},{\"start\":\"87531\",\"end\":\"87539\"},{\"start\":\"87547\",\"end\":\"87555\"},{\"start\":\"87566\",\"end\":\"87572\"},{\"start\":\"87580\",\"end\":\"87589\"},{\"start\":\"88332\",\"end\":\"88338\"},{\"start\":\"88348\",\"end\":\"88354\"},{\"start\":\"88364\",\"end\":\"88369\"},{\"start\":\"88377\",\"end\":\"88386\"},{\"start\":\"88395\",\"end\":\"88405\"},{\"start\":\"88418\",\"end\":\"88423\"},{\"start\":\"88434\",\"end\":\"88440\"},{\"start\":\"88453\",\"end\":\"88459\"},{\"start\":\"88467\",\"end\":\"88472\"},{\"start\":\"89261\",\"end\":\"89265\"},{\"start\":\"89274\",\"end\":\"89276\"},{\"start\":\"89285\",\"end\":\"89287\"},{\"start\":\"89294\",\"end\":\"89300\"},{\"start\":\"89307\",\"end\":\"89315\"},{\"start\":\"89878\",\"end\":\"89885\"},{\"start\":\"89887\",\"end\":\"89891\"},{\"start\":\"89897\",\"end\":\"89903\"},{\"start\":\"89913\",\"end\":\"89916\"},{\"start\":\"89918\",\"end\":\"89927\"},{\"start\":\"90445\",\"end\":\"90452\"},{\"start\":\"90454\",\"end\":\"90458\"},{\"start\":\"90464\",\"end\":\"90470\"},{\"start\":\"90472\",\"end\":\"90475\"},{\"start\":\"91101\",\"end\":\"91106\"},{\"start\":\"91360\",\"end\":\"91366\"},{\"start\":\"91375\",\"end\":\"91379\"},{\"start\":\"91565\",\"end\":\"91569\"},{\"start\":\"91571\",\"end\":\"91578\"},{\"start\":\"91900\",\"end\":\"91902\"},{\"start\":\"91911\",\"end\":\"91917\"},{\"start\":\"91928\",\"end\":\"91934\"},{\"start\":\"91942\",\"end\":\"91952\"},{\"start\":\"91962\",\"end\":\"91968\"},{\"start\":\"91978\",\"end\":\"91983\"},{\"start\":\"92447\",\"end\":\"92454\"},{\"start\":\"92465\",\"end\":\"92473\"},{\"start\":\"92482\",\"end\":\"92491\"},{\"start\":\"92495\",\"end\":\"92500\"},{\"start\":\"92507\",\"end\":\"92512\"},{\"start\":\"92522\",\"end\":\"92530\"},{\"start\":\"92532\",\"end\":\"92535\"},{\"start\":\"92541\",\"end\":\"92547\"},{\"start\":\"92555\",\"end\":\"92561\"},{\"start\":\"92571\",\"end\":\"92579\"},{\"start\":\"92588\",\"end\":\"92591\"},{\"start\":\"92600\",\"end\":\"92605\"},{\"start\":\"92612\",\"end\":\"92621\"},{\"start\":\"92630\",\"end\":\"92637\"},{\"start\":\"92647\",\"end\":\"92652\"},{\"start\":\"92662\",\"end\":\"92669\"},{\"start\":\"92671\",\"end\":\"92680\"},{\"start\":\"93357\",\"end\":\"93360\"},{\"start\":\"93369\",\"end\":\"93372\"},{\"start\":\"93382\",\"end\":\"93385\"},{\"start\":\"93831\",\"end\":\"93843\"},{\"start\":\"93851\",\"end\":\"93866\"},{\"start\":\"93876\",\"end\":\"93883\"},{\"start\":\"94294\",\"end\":\"94299\"},{\"start\":\"94306\",\"end\":\"94312\"},{\"start\":\"94324\",\"end\":\"94333\"},{\"start\":\"94343\",\"end\":\"94346\"},{\"start\":\"94353\",\"end\":\"94366\"},{\"start\":\"94747\",\"end\":\"94755\"},{\"start\":\"94846\",\"end\":\"94853\"},{\"start\":\"94857\",\"end\":\"94864\"},{\"start\":\"94866\",\"end\":\"94870\"},{\"start\":\"95291\",\"end\":\"95295\"},{\"start\":\"95302\",\"end\":\"95308\"},{\"start\":\"95321\",\"end\":\"95326\"},{\"start\":\"95344\",\"end\":\"95346\"},{\"start\":\"95354\",\"end\":\"95360\"},{\"start\":\"96052\",\"end\":\"96059\"},{\"start\":\"96068\",\"end\":\"96072\"},{\"start\":\"96520\",\"end\":\"96523\"},{\"start\":\"96532\",\"end\":\"96536\"},{\"start\":\"96547\",\"end\":\"96554\"},{\"start\":\"96556\",\"end\":\"96559\"},{\"start\":\"97174\",\"end\":\"97180\"},{\"start\":\"97368\",\"end\":\"97379\"},{\"start\":\"97385\",\"end\":\"97389\"},{\"start\":\"97397\",\"end\":\"97403\"},{\"start\":\"97405\",\"end\":\"97414\"},{\"start\":\"98038\",\"end\":\"98057\"},{\"start\":\"98068\",\"end\":\"98072\"},{\"start\":\"98080\",\"end\":\"98086\"},{\"start\":\"98088\",\"end\":\"98097\"},{\"start\":\"98755\",\"end\":\"98769\"},{\"start\":\"98779\",\"end\":\"98788\"},{\"start\":\"98790\",\"end\":\"98797\"},{\"start\":\"99191\",\"end\":\"99195\"},{\"start\":\"99204\",\"end\":\"99208\"},{\"start\":\"99210\",\"end\":\"99213\"},{\"start\":\"99399\",\"end\":\"99408\"},{\"start\":\"99418\",\"end\":\"99427\"},{\"start\":\"99436\",\"end\":\"99444\"},{\"start\":\"99453\",\"end\":\"99459\"},{\"start\":\"99470\",\"end\":\"99476\"},{\"start\":\"99866\",\"end\":\"99879\"},{\"start\":\"100025\",\"end\":\"100033\"},{\"start\":\"100041\",\"end\":\"100048\"},{\"start\":\"100328\",\"end\":\"100334\"},{\"start\":\"100345\",\"end\":\"100351\"},{\"start\":\"100355\",\"end\":\"100369\"},{\"start\":\"100381\",\"end\":\"100385\"},{\"start\":\"100393\",\"end\":\"100398\"},{\"start\":\"100406\",\"end\":\"100419\"},{\"start\":\"101055\",\"end\":\"101065\"},{\"start\":\"101073\",\"end\":\"101081\"},{\"start\":\"101093\",\"end\":\"101102\"},{\"start\":\"101112\",\"end\":\"101118\"},{\"start\":\"101598\",\"end\":\"101604\"},{\"start\":\"101718\",\"end\":\"101723\"},{\"start\":\"101731\",\"end\":\"101744\"},{\"start\":\"102237\",\"end\":\"102241\"},{\"start\":\"102250\",\"end\":\"102257\"},{\"start\":\"102266\",\"end\":\"102277\"},{\"start\":\"102285\",\"end\":\"102287\"},{\"start\":\"102295\",\"end\":\"102304\"},{\"start\":\"102310\",\"end\":\"102316\"},{\"start\":\"102326\",\"end\":\"102331\"},{\"start\":\"102751\",\"end\":\"102759\"},{\"start\":\"102769\",\"end\":\"102774\"},{\"start\":\"102780\",\"end\":\"102783\"},{\"start\":\"102790\",\"end\":\"102794\"},{\"start\":\"103201\",\"end\":\"103204\"},{\"start\":\"103387\",\"end\":\"103395\"},{\"start\":\"103401\",\"end\":\"103407\"},{\"start\":\"103415\",\"end\":\"103421\"},{\"start\":\"103423\",\"end\":\"103431\"},{\"start\":\"103435\",\"end\":\"103440\"},{\"start\":\"103451\",\"end\":\"103456\"},{\"start\":\"103465\",\"end\":\"103473\"},{\"start\":\"103479\",\"end\":\"103484\"},{\"start\":\"103486\",\"end\":\"103492\"},{\"start\":\"103496\",\"end\":\"103501\"},{\"start\":\"103510\",\"end\":\"103517\"},{\"start\":\"103527\",\"end\":\"103533\"},{\"start\":\"103535\",\"end\":\"103538\"},{\"start\":\"104243\",\"end\":\"104249\"},{\"start\":\"104258\",\"end\":\"104270\"},{\"start\":\"104280\",\"end\":\"104289\"},{\"start\":\"104293\",\"end\":\"104298\"},{\"start\":\"104306\",\"end\":\"104314\"},{\"start\":\"104323\",\"end\":\"104329\"},{\"start\":\"105060\",\"end\":\"105066\"},{\"start\":\"105073\",\"end\":\"105079\"},{\"start\":\"105575\",\"end\":\"105579\"},{\"start\":\"105586\",\"end\":\"105594\"}]", "bib_entry": "[{\"start\":\"83120\",\"end\":\"83752\",\"attributes\":{\"matched_paper_id\":\"14320211\",\"id\":\"b0\"}},{\"start\":\"83754\",\"end\":\"84000\",\"attributes\":{\"id\":\"b1\"}},{\"start\":\"84002\",\"end\":\"84151\",\"attributes\":{\"id\":\"b2\"}},{\"start\":\"84153\",\"end\":\"84581\",\"attributes\":{\"matched_paper_id\":\"25912\",\"id\":\"b3\"}},{\"start\":\"84583\",\"end\":\"85061\",\"attributes\":{\"matched_paper_id\":\"4655395\",\"id\":\"b4\"}},{\"start\":\"85063\",\"end\":\"85189\",\"attributes\":{\"id\":\"b5\",\"doi\":\"10.1145/3196494.3196540\"}},{\"start\":\"85191\",\"end\":\"85809\",\"attributes\":{\"matched_paper_id\":\"7210768\",\"id\":\"b6\",\"doi\":\"10.1145/209936.209941\"}},{\"start\":\"85811\",\"end\":\"86197\",\"attributes\":{\"matched_paper_id\":\"206015000\",\"id\":\"b7\",\"doi\":\"10.1016/S0164-1212(00)00122-9\"}},{\"start\":\"86199\",\"end\":\"86636\",\"attributes\":{\"id\":\"b8\",\"doi\":\"arXiv:2002.02831\"}},{\"start\":\"86638\",\"end\":\"87442\",\"attributes\":{\"matched_paper_id\":\"184482705\",\"id\":\"b9\",\"doi\":\"10.1145/3316482.3326356\"}},{\"start\":\"87444\",\"end\":\"88261\",\"attributes\":{\"matched_paper_id\":\"8254904\",\"id\":\"b10\",\"doi\":\"10.1145/1346281.1346295\"}},{\"start\":\"88263\",\"end\":\"89214\",\"attributes\":{\"matched_paper_id\":\"207221476\",\"id\":\"b11\",\"doi\":\"10.1145/2694344.2694383\"}},{\"start\":\"89216\",\"end\":\"89827\",\"attributes\":{\"matched_paper_id\":\"8092019\",\"id\":\"b12\",\"doi\":\"10.1109/ISSREW.2012.24\"}},{\"start\":\"89829\",\"end\":\"90364\",\"attributes\":{\"matched_paper_id\":\"4960605\",\"id\":\"b13\",\"doi\":\"10.14722/ndss.2017.23287\"}},{\"start\":\"90366\",\"end\":\"91033\",\"attributes\":{\"matched_paper_id\":\"4918751\",\"id\":\"b14\",\"doi\":\"10.1145/3192366.3192388\"}},{\"start\":\"91035\",\"end\":\"91286\",\"attributes\":{\"id\":\"b15\"}},{\"start\":\"91288\",\"end\":\"91524\",\"attributes\":{\"id\":\"b16\"}},{\"start\":\"91526\",\"end\":\"91815\",\"attributes\":{\"matched_paper_id\":\"8911258\",\"id\":\"b17\",\"doi\":\"10.1145/1186736.1186737\"}},{\"start\":\"91817\",\"end\":\"92410\",\"attributes\":{\"matched_paper_id\":\"978061\",\"id\":\"b18\",\"doi\":\"10.1109/SP.2016.62\"}},{\"start\":\"92412\",\"end\":\"93302\",\"attributes\":{\"matched_paper_id\":\"33467313\",\"id\":\"b19\",\"doi\":\"10.1109/ICCD.2017.112\"}},{\"start\":\"93304\",\"end\":\"93750\",\"attributes\":{\"matched_paper_id\":\"222331525\",\"id\":\"b20\",\"doi\":\"10.1109/MICRO50266.2020.00095\"}},{\"start\":\"93752\",\"end\":\"94224\",\"attributes\":{\"matched_paper_id\":\"208157625\",\"id\":\"b21\",\"doi\":\"10.1145/3362064\"}},{\"start\":\"94226\",\"end\":\"94736\",\"attributes\":{\"matched_paper_id\":\"33667795\",\"id\":\"b22\"}},{\"start\":\"94738\",\"end\":\"94837\",\"attributes\":{\"id\":\"b23\",\"doi\":\"10.1145/3065913.3065920\"}},{\"start\":\"94839\",\"end\":\"95141\",\"attributes\":{\"id\":\"b24\"}},{\"start\":\"95143\",\"end\":\"95966\",\"attributes\":{\"matched_paper_id\":\"14648609\",\"id\":\"b25\",\"doi\":\"10.1145/2508859.2516713\"}},{\"start\":\"95968\",\"end\":\"96449\",\"attributes\":{\"matched_paper_id\":\"978769\",\"id\":\"b26\",\"doi\":\"10.1109/CGO.2004.1281665\"}},{\"start\":\"96451\",\"end\":\"97134\",\"attributes\":{\"matched_paper_id\":\"229702458\",\"id\":\"b27\",\"doi\":\"10.1145/3324884.3416533\"}},{\"start\":\"97136\",\"end\":\"97290\",\"attributes\":{\"id\":\"b28\"}},{\"start\":\"97292\",\"end\":\"97956\",\"attributes\":{\"matched_paper_id\":\"12959177\",\"id\":\"b29\",\"doi\":\"10.1145/2544137.2544147\"}},{\"start\":\"97958\",\"end\":\"98668\",\"attributes\":{\"matched_paper_id\":\"248719\",\"id\":\"b30\",\"doi\":\"10.1145/1542476.1542504\"}},{\"start\":\"98670\",\"end\":\"99183\",\"attributes\":{\"matched_paper_id\":\"208278084\",\"id\":\"b31\"}},{\"start\":\"99185\",\"end\":\"99314\",\"attributes\":{\"id\":\"b32\",\"doi\":\"10.1145/3359789.3359799\"}},{\"start\":\"99316\",\"end\":\"99817\",\"attributes\":{\"matched_paper_id\":\"49233609\",\"id\":\"b33\",\"doi\":\"10.1145/3224423\"}},{\"start\":\"99819\",\"end\":\"99988\",\"attributes\":{\"id\":\"b34\"}},{\"start\":\"99990\",\"end\":\"100257\",\"attributes\":{\"matched_paper_id\":\"9663345\",\"id\":\"b35\",\"doi\":\"10.1109/MSP.2012.152\"}},{\"start\":\"100259\",\"end\":\"100993\",\"attributes\":{\"matched_paper_id\":\"174799235\",\"id\":\"b36\",\"doi\":\"10.1145/3352460.3358299\"}},{\"start\":\"100995\",\"end\":\"101587\",\"attributes\":{\"matched_paper_id\":\"11024896\",\"id\":\"b37\"}},{\"start\":\"101589\",\"end\":\"101675\",\"attributes\":{\"id\":\"b38\"}},{\"start\":\"101677\",\"end\":\"102197\",\"attributes\":{\"matched_paper_id\":\"19177604\",\"id\":\"b39\",\"doi\":\"10.1109/ISCA.2018.00056\"}},{\"start\":\"102199\",\"end\":\"102714\",\"attributes\":{\"matched_paper_id\":\"48364047\",\"id\":\"b40\",\"doi\":\"10.1109/SP.2019.00010\"}},{\"start\":\"102716\",\"end\":\"103157\",\"attributes\":{\"matched_paper_id\":\"2937041\",\"id\":\"b41\",\"doi\":\"10.1109/SP.2013.13\"}},{\"start\":\"103159\",\"end\":\"103313\",\"attributes\":{\"id\":\"b42\"}},{\"start\":\"103315\",\"end\":\"104169\",\"attributes\":{\"matched_paper_id\":\"1158102\",\"id\":\"b43\",\"doi\":\"10.1109/ISCA.2014.6853201\"}},{\"start\":\"104171\",\"end\":\"104905\",\"attributes\":{\"matched_paper_id\":\"6111474\",\"id\":\"b44\",\"doi\":\"10.1145/1755688.1755707\"}},{\"start\":\"104907\",\"end\":\"105501\",\"attributes\":{\"matched_paper_id\":\"118683177\",\"id\":\"b45\",\"doi\":\"10.1109/TVLSI.2019.2926114\"}},{\"start\":\"105503\",\"end\":\"105830\",\"attributes\":{\"matched_paper_id\":\"2117879\",\"id\":\"b46\",\"doi\":\"10.1145/142181.142200\"}}]", "bib_title": "[{\"start\":\"83120\",\"end\":\"83216\"},{\"start\":\"84153\",\"end\":\"84214\"},{\"start\":\"84583\",\"end\":\"84633\"},{\"start\":\"85191\",\"end\":\"85242\"},{\"start\":\"85811\",\"end\":\"85861\"},{\"start\":\"86638\",\"end\":\"86690\"},{\"start\":\"87444\",\"end\":\"87525\"},{\"start\":\"88263\",\"end\":\"88325\"},{\"start\":\"89216\",\"end\":\"89251\"},{\"start\":\"89829\",\"end\":\"89874\"},{\"start\":\"90366\",\"end\":\"90441\"},{\"start\":\"91526\",\"end\":\"91561\"},{\"start\":\"91817\",\"end\":\"91893\"},{\"start\":\"92412\",\"end\":\"92435\"},{\"start\":\"93304\",\"end\":\"93347\"},{\"start\":\"93752\",\"end\":\"93817\"},{\"start\":\"94226\",\"end\":\"94284\"},{\"start\":\"95143\",\"end\":\"95282\"},{\"start\":\"95968\",\"end\":\"96044\"},{\"start\":\"96451\",\"end\":\"96511\"},{\"start\":\"97292\",\"end\":\"97358\"},{\"start\":\"97958\",\"end\":\"98027\"},{\"start\":\"98670\",\"end\":\"98744\"},{\"start\":\"99316\",\"end\":\"99389\"},{\"start\":\"99990\",\"end\":\"100017\"},{\"start\":\"100259\",\"end\":\"100318\"},{\"start\":\"100995\",\"end\":\"101042\"},{\"start\":\"101677\",\"end\":\"101710\"},{\"start\":\"102199\",\"end\":\"102227\"},{\"start\":\"102716\",\"end\":\"102742\"},{\"start\":\"103315\",\"end\":\"103376\"},{\"start\":\"104171\",\"end\":\"104236\"},{\"start\":\"104907\",\"end\":\"105050\"},{\"start\":\"105503\",\"end\":\"105564\"}]", "bib_author": "[{\"start\":\"83218\",\"end\":\"83238\"},{\"start\":\"83238\",\"end\":\"83252\"},{\"start\":\"83252\",\"end\":\"83267\"},{\"start\":\"83267\",\"end\":\"83280\"},{\"start\":\"83829\",\"end\":\"83838\"},{\"start\":\"84037\",\"end\":\"84050\"},{\"start\":\"84216\",\"end\":\"84230\"},{\"start\":\"84635\",\"end\":\"84649\"},{\"start\":\"84649\",\"end\":\"84664\"},{\"start\":\"84664\",\"end\":\"84678\"},{\"start\":\"84678\",\"end\":\"84693\"},{\"start\":\"85065\",\"end\":\"85083\"},{\"start\":\"85083\",\"end\":\"85090\"},{\"start\":\"85244\",\"end\":\"85254\"},{\"start\":\"85254\",\"end\":\"85269\"},{\"start\":\"85269\",\"end\":\"85277\"},{\"start\":\"85863\",\"end\":\"85867\"},{\"start\":\"85867\",\"end\":\"85881\"},{\"start\":\"86288\",\"end\":\"86302\"},{\"start\":\"86302\",\"end\":\"86314\"},{\"start\":\"86314\",\"end\":\"86325\"},{\"start\":\"86325\",\"end\":\"86335\"},{\"start\":\"86335\",\"end\":\"86348\"},{\"start\":\"86348\",\"end\":\"86359\"},{\"start\":\"86359\",\"end\":\"86369\"},{\"start\":\"86692\",\"end\":\"86706\"},{\"start\":\"86706\",\"end\":\"86735\"},{\"start\":\"86735\",\"end\":\"86750\"},{\"start\":\"86750\",\"end\":\"86768\"},{\"start\":\"86768\",\"end\":\"86782\"},{\"start\":\"87527\",\"end\":\"87541\"},{\"start\":\"87541\",\"end\":\"87557\"},{\"start\":\"87557\",\"end\":\"87574\"},{\"start\":\"87574\",\"end\":\"87591\"},{\"start\":\"88327\",\"end\":\"88340\"},{\"start\":\"88340\",\"end\":\"88356\"},{\"start\":\"88356\",\"end\":\"88371\"},{\"start\":\"88371\",\"end\":\"88388\"},{\"start\":\"88388\",\"end\":\"88407\"},{\"start\":\"88407\",\"end\":\"88425\"},{\"start\":\"88425\",\"end\":\"88442\"},{\"start\":\"88442\",\"end\":\"88461\"},{\"start\":\"88461\",\"end\":\"88474\"},{\"start\":\"89253\",\"end\":\"89267\"},{\"start\":\"89267\",\"end\":\"89278\"},{\"start\":\"89278\",\"end\":\"89289\"},{\"start\":\"89289\",\"end\":\"89302\"},{\"start\":\"89302\",\"end\":\"89317\"},{\"start\":\"89876\",\"end\":\"89887\"},{\"start\":\"89887\",\"end\":\"89893\"},{\"start\":\"89893\",\"end\":\"89905\"},{\"start\":\"89905\",\"end\":\"89918\"},{\"start\":\"89918\",\"end\":\"89929\"},{\"start\":\"90443\",\"end\":\"90454\"},{\"start\":\"90454\",\"end\":\"90460\"},{\"start\":\"90460\",\"end\":\"90472\"},{\"start\":\"90472\",\"end\":\"90477\"},{\"start\":\"91095\",\"end\":\"91108\"},{\"start\":\"91355\",\"end\":\"91368\"},{\"start\":\"91368\",\"end\":\"91381\"},{\"start\":\"91563\",\"end\":\"91571\"},{\"start\":\"91571\",\"end\":\"91580\"},{\"start\":\"91895\",\"end\":\"91904\"},{\"start\":\"91904\",\"end\":\"91919\"},{\"start\":\"91919\",\"end\":\"91936\"},{\"start\":\"91936\",\"end\":\"91954\"},{\"start\":\"91954\",\"end\":\"91970\"},{\"start\":\"91970\",\"end\":\"91985\"},{\"start\":\"92437\",\"end\":\"92456\"},{\"start\":\"92456\",\"end\":\"92475\"},{\"start\":\"92475\",\"end\":\"92493\"},{\"start\":\"92493\",\"end\":\"92502\"},{\"start\":\"92502\",\"end\":\"92514\"},{\"start\":\"92514\",\"end\":\"92532\"},{\"start\":\"92532\",\"end\":\"92537\"},{\"start\":\"92537\",\"end\":\"92549\"},{\"start\":\"92549\",\"end\":\"92563\"},{\"start\":\"92563\",\"end\":\"92581\"},{\"start\":\"92581\",\"end\":\"92593\"},{\"start\":\"92593\",\"end\":\"92607\"},{\"start\":\"92607\",\"end\":\"92623\"},{\"start\":\"92623\",\"end\":\"92639\"},{\"start\":\"92639\",\"end\":\"92654\"},{\"start\":\"92654\",\"end\":\"92671\"},{\"start\":\"92671\",\"end\":\"92682\"},{\"start\":\"93349\",\"end\":\"93362\"},{\"start\":\"93362\",\"end\":\"93374\"},{\"start\":\"93374\",\"end\":\"93387\"},{\"start\":\"93819\",\"end\":\"93845\"},{\"start\":\"93845\",\"end\":\"93868\"},{\"start\":\"93868\",\"end\":\"93885\"},{\"start\":\"94286\",\"end\":\"94301\"},{\"start\":\"94301\",\"end\":\"94314\"},{\"start\":\"94314\",\"end\":\"94335\"},{\"start\":\"94335\",\"end\":\"94348\"},{\"start\":\"94348\",\"end\":\"94368\"},{\"start\":\"94740\",\"end\":\"94757\"},{\"start\":\"94839\",\"end\":\"94855\"},{\"start\":\"94855\",\"end\":\"94866\"},{\"start\":\"94866\",\"end\":\"94872\"},{\"start\":\"95284\",\"end\":\"95297\"},{\"start\":\"95297\",\"end\":\"95310\"},{\"start\":\"95310\",\"end\":\"95328\"},{\"start\":\"95328\",\"end\":\"95348\"},{\"start\":\"95348\",\"end\":\"95362\"},{\"start\":\"96046\",\"end\":\"96061\"},{\"start\":\"96061\",\"end\":\"96074\"},{\"start\":\"96513\",\"end\":\"96525\"},{\"start\":\"96525\",\"end\":\"96538\"},{\"start\":\"96538\",\"end\":\"96556\"},{\"start\":\"96556\",\"end\":\"96561\"},{\"start\":\"97170\",\"end\":\"97182\"},{\"start\":\"97360\",\"end\":\"97381\"},{\"start\":\"97381\",\"end\":\"97391\"},{\"start\":\"97391\",\"end\":\"97405\"},{\"start\":\"97405\",\"end\":\"97416\"},{\"start\":\"98029\",\"end\":\"98059\"},{\"start\":\"98059\",\"end\":\"98074\"},{\"start\":\"98074\",\"end\":\"98088\"},{\"start\":\"98088\",\"end\":\"98099\"},{\"start\":\"98746\",\"end\":\"98771\"},{\"start\":\"98771\",\"end\":\"98790\"},{\"start\":\"98790\",\"end\":\"98799\"},{\"start\":\"99187\",\"end\":\"99197\"},{\"start\":\"99197\",\"end\":\"99210\"},{\"start\":\"99210\",\"end\":\"99215\"},{\"start\":\"99391\",\"end\":\"99410\"},{\"start\":\"99410\",\"end\":\"99429\"},{\"start\":\"99429\",\"end\":\"99446\"},{\"start\":\"99446\",\"end\":\"99461\"},{\"start\":\"99461\",\"end\":\"99478\"},{\"start\":\"99866\",\"end\":\"99881\"},{\"start\":\"100019\",\"end\":\"100035\"},{\"start\":\"100035\",\"end\":\"100050\"},{\"start\":\"100320\",\"end\":\"100336\"},{\"start\":\"100336\",\"end\":\"100353\"},{\"start\":\"100353\",\"end\":\"100371\"},{\"start\":\"100371\",\"end\":\"100387\"},{\"start\":\"100387\",\"end\":\"100400\"},{\"start\":\"100400\",\"end\":\"100421\"},{\"start\":\"101044\",\"end\":\"101067\"},{\"start\":\"101067\",\"end\":\"101083\"},{\"start\":\"101083\",\"end\":\"101104\"},{\"start\":\"101104\",\"end\":\"101120\"},{\"start\":\"101591\",\"end\":\"101606\"},{\"start\":\"101712\",\"end\":\"101725\"},{\"start\":\"101725\",\"end\":\"101746\"},{\"start\":\"102229\",\"end\":\"102243\"},{\"start\":\"102243\",\"end\":\"102259\"},{\"start\":\"102259\",\"end\":\"102279\"},{\"start\":\"102279\",\"end\":\"102289\"},{\"start\":\"102289\",\"end\":\"102306\"},{\"start\":\"102306\",\"end\":\"102318\"},{\"start\":\"102318\",\"end\":\"102333\"},{\"start\":\"102744\",\"end\":\"102761\"},{\"start\":\"102761\",\"end\":\"102776\"},{\"start\":\"102776\",\"end\":\"102785\"},{\"start\":\"102785\",\"end\":\"102796\"},{\"start\":\"103193\",\"end\":\"103206\"},{\"start\":\"103378\",\"end\":\"103397\"},{\"start\":\"103397\",\"end\":\"103409\"},{\"start\":\"103409\",\"end\":\"103423\"},{\"start\":\"103423\",\"end\":\"103433\"},{\"start\":\"103433\",\"end\":\"103442\"},{\"start\":\"103442\",\"end\":\"103458\"},{\"start\":\"103458\",\"end\":\"103475\"},{\"start\":\"103475\",\"end\":\"103486\"},{\"start\":\"103486\",\"end\":\"103494\"},{\"start\":\"103494\",\"end\":\"103503\"},{\"start\":\"103503\",\"end\":\"103519\"},{\"start\":\"103519\",\"end\":\"103535\"},{\"start\":\"103535\",\"end\":\"103540\"},{\"start\":\"104238\",\"end\":\"104251\"},{\"start\":\"104251\",\"end\":\"104272\"},{\"start\":\"104272\",\"end\":\"104291\"},{\"start\":\"104291\",\"end\":\"104300\"},{\"start\":\"104300\",\"end\":\"104316\"},{\"start\":\"104316\",\"end\":\"104331\"},{\"start\":\"105052\",\"end\":\"105068\"},{\"start\":\"105068\",\"end\":\"105081\"},{\"start\":\"105566\",\"end\":\"105581\"},{\"start\":\"105581\",\"end\":\"105596\"}]", "bib_venue": "[{\"start\":\"83280\",\"end\":\"83346\"},{\"start\":\"83754\",\"end\":\"83827\"},{\"start\":\"84002\",\"end\":\"84035\"},{\"start\":\"84230\",\"end\":\"84289\"},{\"start\":\"84693\",\"end\":\"84769\"},{\"start\":\"85298\",\"end\":\"85407\"},{\"start\":\"85910\",\"end\":\"85941\"},{\"start\":\"86199\",\"end\":\"86286\"},{\"start\":\"86805\",\"end\":\"86941\"},{\"start\":\"87614\",\"end\":\"87749\"},{\"start\":\"88497\",\"end\":\"88636\"},{\"start\":\"89339\",\"end\":\"89444\"},{\"start\":\"89953\",\"end\":\"90026\"},{\"start\":\"90500\",\"end\":\"90607\"},{\"start\":\"91035\",\"end\":\"91093\"},{\"start\":\"91288\",\"end\":\"91353\"},{\"start\":\"91603\",\"end\":\"91641\"},{\"start\":\"92003\",\"end\":\"92079\"},{\"start\":\"92703\",\"end\":\"92756\"},{\"start\":\"93416\",\"end\":\"93510\"},{\"start\":\"93900\",\"end\":\"93946\"},{\"start\":\"94368\",\"end\":\"94443\"},{\"start\":\"94872\",\"end\":\"94954\"},{\"start\":\"95385\",\"end\":\"95477\"},{\"start\":\"96098\",\"end\":\"96167\"},{\"start\":\"96584\",\"end\":\"96717\"},{\"start\":\"97136\",\"end\":\"97168\"},{\"start\":\"97439\",\"end\":\"97539\"},{\"start\":\"98122\",\"end\":\"98229\"},{\"start\":\"98799\",\"end\":\"98883\"},{\"start\":\"99493\",\"end\":\"99527\"},{\"start\":\"99819\",\"end\":\"99864\"},{\"start\":\"100070\",\"end\":\"100093\"},{\"start\":\"100444\",\"end\":\"100540\"},{\"start\":\"101120\",\"end\":\"101195\"},{\"start\":\"101769\",\"end\":\"101861\"},{\"start\":\"102354\",\"end\":\"102411\"},{\"start\":\"102814\",\"end\":\"102890\"},{\"start\":\"103159\",\"end\":\"103191\"},{\"start\":\"103565\",\"end\":\"103657\"},{\"start\":\"104354\",\"end\":\"104457\"},{\"start\":\"105107\",\"end\":\"105171\"},{\"start\":\"105617\",\"end\":\"105636\"},{\"start\":\"83348\",\"end\":\"83415\"},{\"start\":\"84291\",\"end\":\"84306\"},{\"start\":\"84771\",\"end\":\"84832\"},{\"start\":\"85409\",\"end\":\"85532\"},{\"start\":\"86943\",\"end\":\"87080\"},{\"start\":\"87751\",\"end\":\"87896\"},{\"start\":\"88638\",\"end\":\"88778\"},{\"start\":\"89446\",\"end\":\"89551\"},{\"start\":\"90028\",\"end\":\"90104\"},{\"start\":\"90609\",\"end\":\"90730\"},{\"start\":\"92081\",\"end\":\"92098\"},{\"start\":\"92758\",\"end\":\"92838\"},{\"start\":\"94445\",\"end\":\"94505\"},{\"start\":\"95479\",\"end\":\"95571\"},{\"start\":\"96169\",\"end\":\"96193\"},{\"start\":\"96719\",\"end\":\"96837\"},{\"start\":\"97541\",\"end\":\"97651\"},{\"start\":\"98231\",\"end\":\"98338\"},{\"start\":\"98885\",\"end\":\"98954\"},{\"start\":\"100542\",\"end\":\"100649\"},{\"start\":\"101197\",\"end\":\"101272\"},{\"start\":\"101863\",\"end\":\"101960\"},{\"start\":\"102413\",\"end\":\"102435\"},{\"start\":\"102892\",\"end\":\"102921\"},{\"start\":\"103659\",\"end\":\"103765\"},{\"start\":\"104459\",\"end\":\"104561\"}]"}}}, "year": 2023, "month": 12, "day": 17}