{"id": 4719239, "updated": "2023-10-01 00:13:32.174", "metadata": {"title": "Speech Commands: A Dataset for Limited-Vocabulary Speech Recognition", "authors": "[{\"first\":\"Pete\",\"last\":\"Warden\",\"middle\":[]}]", "venue": "ArXiv", "journal": "ArXiv", "publication_date": {"year": 2018, "month": 4, "day": 9}, "abstract": "Describes an audio dataset of spoken words designed to help train and evaluate keyword spotting systems. Discusses why this task is an interesting challenge, and why it requires a specialized dataset that is different from conventional datasets used for automatic speech recognition of full sentences. Suggests a methodology for reproducible and comparable accuracy metrics for this task. Describes how the data was collected and verified, what it contains, previous versions and properties. Concludes by reporting baseline results of models trained on this dataset.", "fields_of_study": "[\"Computer Science\"]", "external_ids": {"arxiv": "1804.03209", "mag": "2797583228", "acl": null, "pubmed": null, "pubmedcentral": null, "dblp": "journals/corr/abs-1804-03209", "doi": null}}, "content": {"source": {"pdf_hash": "97c59701b0d02f10be30999417441f95abf24b9f", "pdf_src": "Arxiv", "pdf_uri": "[\"https://arxiv.org/pdf/1804.03209v1.pdf\"]", "oa_url_match": false, "oa_info": null}, "grobid": {"id": "9e1357ecdae43938462c1e84a0b35f56180131af", "type": "plain-text", "url": "s3://ai2-s2-pdf-extraction-prod/parse-results/s2orc_worker/97c59701b0d02f10be30999417441f95abf24b9f.txt", "contents": "\nSpeech Commands: A Dataset for Limited-Vocabulary Speech Recognition\n9 Apr 2018 April 2018\n\nPete Warden petewarden@google.com \nMountain ViewCalifornia\n\nGoogle Brain \nMountain ViewCalifornia\n\nSpeech Commands: A Dataset for Limited-Vocabulary Speech Recognition\n9 Apr 2018 April 2018\nAbstractDescribes an audio dataset[1] of spoken words designed to help train and evaluate keyword spotting systems. Discusses why this task is an interesting challenge, and why it requires a specialized dataset that's different from conventional datasets used for automatic speech recognition of full sentences. Suggests a methodology for reproducible and comparable accuracy metrics for this task. Describes how the data was collected and verified, what it contains, previous versions[2] and properties. Concludes by reporting baseline results of models trained on this dataset.\n\nIntroduction\n\nSpeech recognition research has traditionally required the resources of large organizations such as universities or corporations to pursue. People working in those organizations usually have free access to either academic datasets through agreements with groups like the Linguistic Data Consortium [3], or to proprietary commercial data.\n\nAs speech technology has matured, the number of people who want to train and evaluate recognition models has grown beyond these traditional groups, but the availability of datasets hasn't widened. As the example of ImageNet [4] and similar collections in computer vision has shown, broadening access to datasets encourages collaborations across groups and enables apples-for-apples comparisons between different approaches, helping the whole field move forward.\n\nThe Speech Commands dataset is an attempt to build a standard training and evaluation dataset for a class of simple speech recognition tasks. Its primary goal is to provide a way to build and test small models that detect when a single word is spoken, from a set of ten or fewer target words, with as few false positives as possible from background noise or unrelated speech. This task is often known as keyword spotting.\n\nTo reach a wider audience of researchers and developers, this dataset has been released under the Creative Commons BY 4.0 license [5]. This enables it to easily be incorporated in tutorials and other scripts where it can be downloaded and used without any user intervention required (for example to register on a website or email an administrator for permission). This license is also well known in commercial settings, and so can usually be dealt with quickly by legal teams where approval is required.\n\n\nRelated Work\n\nMozilla's Common Voice dataset[6] has over 500 hours from 20,000 different people, and is available under the Creative Commons Zero license (similar to public domain). This licensing makes it very easy to build on top of. It is aligned by sentence, and was created by volunteers reading requested phrases through a web application.\n\nLibriSpeech [7] is a collection of 1,000 hours of read English speech, released under a Creative Commons BY 4.0 license, and stored using the open source FLAC encoder, which is widely supported. Its labels are aligned at the sentence level only, thus lacking word-level alignment information. This makes it more suitable for full automatic speech recognition than keyword spotting.\n\nTIDIGITS [8] contains 25,000 digit sequences spoken by 300 different speakers, recorded in a quiet room by paid contributors. The dataset is only available under a commercial license from the Language Data Consortium, and is stored in the NIST SPHERE file format, which proved hard to decode using modern software. Our initial experiments on keyword spotting were performed using this dataset. CHiME-5[9] has 50 hours of speech recorded in people's homes, stored as 16 KHz WAV files, and available under a restricted license. It's aligned at the sentence level.\n\n\nMotivations\n\nMany voice interfaces rely on keyword spotting to start interactions. For example you might say \"Hey Google\" or \"Hey Siri\"[10] to begin a query or command for your phone. Once the device knows that you want to interact, it's possible to send the audio to a web service to run a model that's only limited by commercial considerations, since it can run on a server whose resources are controlled by the cloud provider. The initial detection of the start of an interaction is impractical to run as a cloud-based service though, since it would require sending audio data over the web from all devices all the time. This would be very costly to maintain, and would increase the privacy risks of the technology.\n\nInstead, most voice interfaces run a recognition module locally on the phone or other device. This listens continuously to audio input from microphones, and rather than sending the data over the internet to a server, they run models that listen for the desired trigger phrases. Once a likely trigger is heard, the transfer of the audio to a web service begins. Because the local model is running on hardware that's not under the web service provider's control, there are hard resource constraints that the on-device model has to respect. The most obvious of these is that the mobile processors typically present have total compute capabilities that are much lower than most servers, so to run in near real-time for an interactive response, ondevice models must require fewer calculations than their cloud equivalents. More subtly, mobile devices have limited battery lives and anything that is running continuously needs to be very energy efficient or users will find their device is drained too quickly. This consideration doesn't apply to plugged-in home devices, but those do have thermal constraints on how much heat they can dissipate that restrict the amount of energy available to local models, and are encouraged by programs like EnergyStar to reduce their overall power usage as much as possible. A final consideration is that users expect a fast response from their devices, and network latency can be highly variable depending on the environment, so some initial acknowledgement that a command was received is important for a good experience, even if the full server response is delayed.\n\nThese constraints mean that the task of keyword spotting is quite different to the kind of speech recognition that's performed on a server once an interaction has been spotted:\n\n\u2022 Keyword spotting models must be smaller and involved less compute.\n\n\u2022 They need to run in a very energy-efficient way.\n\n\u2022 Most of their input will be silence or background noise, not speech, so false positives on those must be minimized.\n\n\u2022 Most of the input that is speech will be unrelated to the voice interface, so the model should be unlikely to trigger on arbitrary speech.\n\n\u2022 The important unit of recognition is a single word or short phrase, not an entire sentence.\n\nThese differences mean that the training and evaluation process between on-device keyword spotting and general speech recognition models is quite different. There are some promising datasets to support general speech tasks, such as Mozilla's Common Voice, but they aren't easily adaptable to keyword spotting.\n\nThis Speech Commands dataset aims to meet the special needs around building and testing on-device models, to enable model authors to demonstrate the accuracy of their architectures using metrics that are comparable to other models, and give a simple way for teams to reproduce baseline models by training on identical data. The hope is that this will speed up progress and collaboration, and improve the overall quality of models that are available.\n\nA second important audience is hardware manufacturers. By using a publicly-available task that closely reflects product requirements, chip vendors can demonstrate the accuracy and energy usage of their offerings in a way that's easily comparable for potential purchasers. This increased transparency should result in hardware that better meets product requirements over time. The models should also provide clear specifications that hardware engineers can use to optimize their chips, and potentially suggest model changes that make it easier to provide efficient implementations. This kind of co-design between machine learning and hardware can be a virtuous circle, increasing the flow of useful information between the domains in a way that helps both sides.\n\n\nCollection\n\n\nRequirements\n\nI made the decision to focus on capturing audio that reflected the on-device trigger phrase task described above. This meant that the use of studio-captured samples seemed unrealistic, since that audio would lack background noise, would be captured with highquality microphones, and in a formal setting. Successful models would need to cope with noisy environments, poor quality recording equipment, and people talking in a natural, chatty way. To reflect this, all utterances were captured through phone or laptop microphones, wherever users happened to be. The one exception was that I asked them to avoid recording themselves whenever there were background conversations happening for privacy reasons, so I asked them to be in a room alone with the door closed.\n\nI also decided to focus on English. This was for pragmatic reasons, to limit the scope of the gathering process and make it easier for native speakers to perform quality control on the gathered data. I hope that transfer learning and other techniques will still make this dataset useful for other languages though, and I open-sourced the collection application to allow others to easily gather similar data in other languages. I did want to gather as wide a variety of accents as possible however, since we're familiar from experience with the bias towards American English in many voice interfaces.\n\n\nWord Choice\n\nI wanted to have a limited vocabulary to make sure the capture process was lightweight, but still have enough variety for models trained on the data to potentially be useful for some applications. I also wanted the dataset to be usable in comparable ways to common proprietary collections like TIDIGITS. This led me to pick twenty common words as the core of our vocabulary. These included the digits zero to nine, and in version one, ten words that would be useful as commands in IoT or robotics applications; \"Yes\", \"No\", \"Up\", \"Down\", \"Left\", \"Right\", \"On\", \"Off\", \"Stop\", and \"Go\". In version 2 of the dataset, I added four more command words; \"Backward\", \"Forward\", \"Follow\", and \"Learn\". One of the most challenging problems for keyword recognition is ignoring speech that doesn't contain triggers, so I also needed a set of words that could act as tests of that ability in the dataset. Some of these, such as \"Tree\", were picked because they sound similar to target words and would be good tests of a model's discernment. Others were chosen arbitrarily as short words that covered a lot of different phonemes. The final list was \"Bed\", \"Bird\", \"Cat\", \"Dog\", \"Happy\", \"House\", \"Marvin\", \"Sheila\", \"Tree\", and \"Wow\".\n\n\nImplementation\n\nTo meet all these requirements, I created an opensource web-based application that recorded utterances using the WebAudioAPI[11]. This API is supported on desktop browsers like Firefox and Chrome, and on Android mobile devices. It's not available on iOS, which was considered to be unfortunate but there were no alternatives that were more attractive. I also looked into building native mobile applications for iOS and Android, but I found that users were reluctant to install them, for privacy and security reasons. The web experience requires users to grant permission to the website to access the microphone, but that seemed a lot more acceptable, based on the increased response rate. The initial test of the application was hosted at an appspot.com subdomain, but it was pointed out that teaching users to give microphone permissions to domains that were easy for malicious actors to create was a bad idea. To address this, the final home of the application was moved to:\nhttps://aiyprojects.withgoogle.com/ \u0592\u2192 open_speech_recording\nThis is a known domain that's controlled by Google, and so it should be much harder to create confusing spoofs of. The initial page that a new user sees when navigating to the application explains what the project is doing, and asks them to explicitly and formally agree to participating in the study. This process was designed to ensure that the resulting utterances could be freely redistributed as part of an open dataset, and that users had a clear understanding of what the application was doing. When a user clicks on \"I Agree\", a session cookie is added to record their agreement. The recording portion of the application will only be shown if this session cookie is found, and all upload accesses are guarded by cross-site request forgery tokens, to ensure that only audio recorded from the application can be uploaded, and that utterances are from users who have agreed to the terms.\n\nThe recording page asks users to press a \"Record\" button when they're ready, and then displays a random word from the list described above. The word is displayed for 1.5 seconds while audio is recorded, and then another randomly-chosen word is shown after a one-second pause. Each audio clip is added to a list that's stored locally on the client's machine, and they remain there until the user has finished recording all words and has a chance to review them. The random ordering of words was chosen to avoid pronunciation changes that might be caused by repetition of the same word multiple times. Core words are shown five times each in total, whereas auxiliary words only appear once. There are 135 utterances collected overall, which takes around six minutes in total to run through completely. The user can pause and restart at any point.\n\nOnce the recording process is complete, the user is asked to review all of the clips, and if they're happy with them, upload them. This then invokes a web API which uploads the audio to the server application, which saves them into a cloud storage bucket.\n\nThe WebAudioAPI returns the audio data in OGGcompressed format, and this is what gets stored in the resulting files. The session ID is used as the prefix of each file name, and then the requested word is followed by a unique instance ID for the recording. This session ID has been randomly generated, and is not tied to an account or any other demographic information, since none has been generated. It does serve as a speaker identifier for utterances however. To ensure there's a good distribution of different speakers, once a user has gone through this process once a cookie is added to the application that ensures they can't access the recording page again.\n\nTo gather volunteers for this process, I used appeals on social media to share the link and the aims of the project. I also experimented with using paid crowdsourcing for some of the utterances, though the majority of the dataset comes from the open site.\n\n\nQuality Control\n\nThe gathered audio utterances were of variable quality, and so I needed criteria to accept or reject submissions. The informal guideline I used was that if a human listener couldn't tell what word was being spoken, or it sounded like an incorrect word, then the clip should be rejected. To accomplish this, I used several layers of review.\n\nTo remove clips that were extremely short or quiet, I took advantage of the nature of the OGG compression format. Compressed clips that contained very little audio would be very small in size, so a good heuristic was that any files that were smaller than 5 KB were unlikely to be correct. To implement this rule, I used the following Linux shell command:\nfind ${BASEDIR}/oggs -iname \"*.ogg\" -size \u0592\u2192 -5k -delete\nWith that complete, I then converted the OGG files into uncompressed WAV files containing PCM sample data at 16KHz, since this is any easier format for further processing: Samples from other sources came as varying sample-rate WAV files, so they were also resampled to 16 KHz WAV files using a similar ffmpeg command.\n\n\nExtract Loudest Section\n\nFrom manual inspection of the results, there were still large numbers of utterances that were too quiet or completely silent. The alignment of the spoken words within the 1.5 second file was quite arbitrary too, depending on the speed of the user's response to the word displayed. To solve both these problems, I created a simple audio processing tool called Extract Loudest Section to examine the overall volume of the clips. As a first stage, I summed the absolute differences of all the samples from zero (using a scale where -32768 in the 16-bit sample data was -1.0 as a floating-point number, and +32767 was 1.0), and looked at the mean average of that value to estimate the overall volume of the utterance. From experimentation, anything below 0.004 on this metric was likely to be to quiet to be intelligible, and so all of those clips were removed.\n\nTo approximate the correct alignment, the tool then extracted the one-second clip that contained the highest overall volume. This tended to center the spoken word in the middle of the trimmed clip, assuming that the utterance was the loudest part of the recording. To run these processes, the following commands were called: \ngit\n\nManual Review\n\nThese automatic processes caught technical problems with quiet or silent recordings, but there were still some utterances that were of incorrect words or were unintelligible for other reasons. To filter these out I turned to commercial crowdsourcing. The task asked workers to type in the word they heard from each clip, and gave a list of the expected words as examples.\n\nEach clip was only evaluated by a single worker, and any clips that had responses that didn't match their expected labels were removed from the dataset.\n\n\nRelease Process\n\nThe recorded utterances were moved into folders, with one for each word. The original 16-digit hexadecimal speaker ID numbers from the web application's file names were hashed into 8-digit hexadecimal IDs. Speaker IDs from other sources (like the paid crowdsourcing sites) were also hashed into the same format. This was to ensure that any connection to worker IDs or other personally-identifiable information was removed. The hash function used is stable though, so in future releases the IDs for existing files should remain the same, even as more speakers are added.\n\n\nBackground Noise\n\nA key requirement for keyword spotting in real products is distinguishing between audio that contains speech, and clips that contain none. To help train and test this capability, I added several minute-long 16 KHz WAV files of various kinds of background noise. Several of these were recorded directly from noisy environments, for example near running water or machinery. Others were generated mathematically using these commands in Python: To distinguish these files from word utterances, they were placed in a specially-named \"_background_noise_\" folder, in the root of the archive.\n\n\nProperties\n\nThe final dataset consisted of 105,829 utterances of 35 words, broken into the categories and frequencies shown in Table 1.\n\nEach utterance is stored as a one-second (or less) WAVE format file, with the sample data encoded as linear 16-bit single-channel PCM values, at a 16 KHz rate. There are 2,618 speakers recorded, each with a unique eight-digit hexadecimal identifier assigned as described above. The uncompressed files take up approximately 3.8 GB on disk, and can be stored as a 2.7GB gzip-compressed tar archive.\n\n\nEvaluation\n\nOne of this dataset's primary goals is to enable meaningful comparisons between different models' results, so it's important to suggest some precise testing protocols. As a starting point, it's useful to specify exactly which utterances can be used for training, and which must be reserved for testing, to avoid overfitting. The dataset download includes a text file called validation_list.txt, which contains a list of files that are expected to be used for validating results during training, and so can be used frequently to help adjust hyperparameters and make other model changes. The testing_list.txt file contains the names of audio clips that should only be used for measuring the results of trained models, not for training or validation. The set that a file belongs to is chosen using a hash function on its name. This is to ensure that files remain in the same set across releases, even as the total number changes, so avoid set crosscontamination when trying old models on the more recent test data. The Python implementation of the  \n\n\nTop-One Error\n\nThe simplest metric to judge a trained model against is how many utterances it can correctly identify. In principle this can be calculated by running the model against all the files in the testing set, and comparing the reported against the expected label for each. Unlike image classification tasks like ImageNet, it's not obvious how to weight all of the different categories. For example, I want a model to indicate when no speech is present, and separately to indicate when it thinks a word has been spoken that's not one it recognizes. These \"open world\" categories need to be weighted according to their expected occurrence in a real application to produce a realistic metric that reflects the perceived quality of the results in a product. The standard chosen for the TensorFlow speech commands example code is to look for the ten words \"Yes\", \"No\", \"Up\", \"Down\", \"Left\", \"Right\", \"On\", \"Off\", \"Stop\", and \"Go\", and have one additional special label for \"Unknown Word\", and another for \"Silence\" (no speech detected). The testing is then done by providing equal numbers of examples for each of the twelve categories, which means each class accounts for approximately 8.3% of the total. The \"Unknown Word\" category contains words randomly sampled from classes that are part of the target set. The \"Silence\" category has one-second clips extracted randomly from the background noise audio files.\n\nI've uploaded a standard set of test files[13] to make it easier to reproduce this metric. If you want to calculate the canonical Top-One error for a model, run inference on each audio clip, and compare the top predicted class against the ground truth label encoded in its containing subfolder name. The proportion of correct predictions will give you the Top-One error. There's also a similar collection of test files[14] available for version one of the dataset.\n\nThe example training code that accompanies the dataset[15] provides results of 88.2% on this metric for the highest-quality model when fully trained. This translates into a model that qualitatively gives a reasonable, but far from perfect response, so it's expected that this will serve as a baseline to be ex-ceeded by more sophisticated architectures.\n\n\nStreaming Error Metrics\n\nTop-One captures a single dimension of the perceived quality of the results, but doesn't reveal much about other aspects of its performance in a real application. For example, models in products receive a continuous stream of audio data and don't know when words start and end, whereas the inputs to Top One evaluations are aligned to the beginning of utterances. The equal weighting of each category in the overall score also doesn't reflect the distribution of trigger words and silence in typical environments.\n\nTo measure some of these more complex properties of models, I test them against continuous streams of audio and score them on multiple metrics. Here's what the baseline model trained with V2 data produces:\n\n49.0% matched, 46.0% correctly, 3.0%\n\n\u0592\u2192 wrongly, 0.0% false positives\n\nTo produce this result, I ran the following bash script against the 10 minute streaming test audio clip and ground truth labels: \u2022 Matched-percentage represents how many words were correctly identified, within a given time tolerance.\nbazel\n\u2022 Wrong-percentage shows how many words were correctly distinguished as speech rather than background noise, but were given the wrong class label.\n\n\u2022 False-positive percentage is the number of words detected that were in parts of the audio where no speech was actually present.\n\nAn algorithm for calculating these values given an audio file and a text file listing ground truth labels is implemented in TensorFlow as test_streaming_accuracy.cc [16].\n\nPerforming successfully on these metrics requires more than basic template recognition of audio clips. There has to be at least a very crude set of rules to suppress repeated recognitions of the same word in short time frames, so default logic for this is implemented in recognize_commands.cc [17].\n\nThis allows a simple template-style recognition model to be used directly to generate these statistics. One of the other configurable features of the accuracy test is the time tolerance for how close to the ground truth's time a recognition result must be to count as a match. The default for this is set to 750ms, since that seems to match with requirements for some of the applications that are supported.\n\nTo make reproducing and comparing results easier, I've made available a one-hour audio file[18] containing a mix of utterances at random times and noise, together with a text file marking the times and ground truth labels of each utterance. This was generated using the script included in the TensorFlow tutorial, and can be used to compare different models performance on streaming applications. \n\n\nHistorical Evaluations\n\n\nApplications\n\nThe TensorFlow tutorial gives a variety of baseline models, but one of the goals of the dataset is to enable the creation and comparison of a wide range of models on a lot of different platforms, and version one of has enabled some interesting applications. CMSIS-NN [21] covers a new optimized implementation of neural network operations for ARM microcontrollers, and uses Speech Commands to train and evaluate the results. Listening to the World [22] demonstrates how combining the dataset and UrbanSounds [23] can improve the noise tolerance of recognition models. Did you Hear That [24] uses the dataset to test adversarial attacks on voice interfaces. Deep Residual Learning for Small Footprint Keyword Spotting [25] shows how approaches learned from ResNet can produce more efficient and accurate models. Raw Waveformbased Audio Classification [26] investigates alternatives to traditional feature extraction for speech and music models. Keyword Spotting Through Image Recognition [27] looks at the effect virtual adversarial training on the keyword task.\n\n\nConclusion\n\nThe Speech Commands dataset has shown to be useful for training and evaluating a variety of models, and the second version shows improved results on equivalent test data, compared to the original.\n\n\nfind ${BASEDIR}/oggs -iname \"*.ogg\" -print0\u0592\u2192 | xargs -0 basename -s .ogg | xargs\u0592\u2192 -I {} ffmpeg -i ${BASEDIR}/oggs/{}. \u0592\u2192 ogg -ar 16000 ${BASEDIR}/wavs/{}.wav\n\nFigure 1 :\n1How many recordings of each word are present in the dataset set assignment algorithm is given in the TensorFlow tutorial code[12] that is a companion to the dataset.\n\n\nclone https://github.com/petewarden/\u0592\u2192 extract_loudest_section tmp/ \n\u0592\u2192 extract_loudest_section \ncd tmp/extract_loudest_section \nmake \ncd ../.. \nmkdir -p ${BASEDIR}/trimmed_wavs \n/tmp/extract_loudest_section/gen/bin/ \n\u0592\u2192 extract_loudest_section ${BASEDIR}'/ \n\u0592\u2192 wavs/*.wav' ${BASEDIR}/trimmed_wavs/ \n\n\n\nVersion 1 of the dataset[2] was released August 3rd 2017, and contained 64,727 utterances from 1,881 speakers. Training the default convolution model from the TensorFlow tutorial (based on Convolutional Neural Networks for Small-footprint Keyword Spotting[19]) using the V1 training data gave a Top-One score of 85.4%, when evaluated against the test set from V1. Training the same model against version 2 of the dataset[1], documented in this paper, produces a model that scores 88.2% Top-One on the training set extracted from the V2 data. A model trained on V2 data, but evaluated against the V1 test set gives 89.7% Top-One, which indicates that the V2 training data is responsible for a substantial improvement in accuracy over V1. The full set of results are shown inTable 2.These figures were produced using the checkpoints produced by the following training commands:python tensorflow/examples/speech_commands/ \u0592\u2192 train.py --data_url=\\protect\\vrule \u0592\u2192 width0pt\\protect\\href{http:// \u0592\u2192 download.tensorflow.org/data/ \u0592\u2192 speech_commands_v0.01.tar.gz}{http \u0592\u2192 ://download.tensorflow.org/data/ \u0592\u2192 speech_commands_v0.01.tar.gz} python tensorflow/examples/speech_commands/ \u0592\u2192 train.py --data_url=\\protect\\vrule \u0592\u2192 width0pt\\protect\\href{http:// \u0592\u2192 download.tensorflow.org/data/ \u0592\u2192 speech_commands_v0.02.tar.gz}{http \u0592\u2192 ://download.tensorflow.org/data/ \u0592\u2192 speech_commands_v0.02.tar.gz} The results of these commands are available as pretrained checkpoints[20]. The evaluations were performed by running variations on the following command line (with the v1/v2's substituted as appropriate): python tensorflow/examples/speech_commands/ \u0592\u2192 train.py --data_url=\\protect\\vrule \u0592\u2192 width0pt\\protect\\href{http:// \u0592\u2192 download.tensorflow.org/data/ \u0592\u2192 speech_commands_v0.01}{http:// \u0592\u2192 download.tensorflow.org/data/ \u0592\u2192 speech_commands_v0.0{1},1}.tar.gz --\u0592\u2192 start_checkpoint=${HOME}/ \u0592\u2192 speech_commands_checkpoints/conv-v \u0592\u2192 {1,2}.ckpt-18000Data \nV1 Training V2 Training \nV1 Test \n85.4% \n89.7% \nV2 Test \n82.7% \n88.2% \n\nFigure 2: Top-One accuracy evaluations using differ-\nent training data \n\n\nAnother goal was to record as many different people as I could. Keyword-spotting models are much more useful if they're speaker-independent, since the process of personalizing a model to an individual requires an intrusive user interface experience. With this in mind, the recording process had to be quick and easy to use, to reduce the number of people who would fail to complete it.I also wanted to avoid recording any personallyidentifiable information from contributors, since any such data requires handling with extreme care for privacy reasons. This meant that I wouldn't ask for any attributes like gender or ethnicity, wouldn't require a sign-in through a user ID that could link to personal data, and would need users to agree to a data-usage agreement before contributing.To simplify the training and evaluation process, I decided to restrict all utterances to a standard duration of one second. This excludes longer words, but the usual targets for keyword recognition are short so this didn't seem to be too restrictive. I also decided to record only single words spoken in isolation, rather than as part of a sentence, since this more closely resembles the trigger word task we're targeting. It also makes labeling much easier, since alignment is not as crucial.\nAcknowledgementsMassive thanks are due to everyone who donated recordings to this data set, I'm very grateful. I also couldn't have put this together without the help and support of Billy Rutledge, Rajat Monga, Raziel Alvarez, Brad Krueger, Barbara Petit, Gursheesh Kour, Robert Munro, Kirsten Gokay, David Klein, Lukas Biewald, and all the AIY and TensorFlow teams.\nLinguistic data consortium. (2018) Linguistic data consortium. [Online]. Available: https://www.ldc.upenn.edu/\n\nImageNet: A Large-Scale Hierarchical Image Database. J Deng, W Dong, R Socher, L.-J Li, K Li, L Fei-Fei, 9J. Deng, W. Dong, R. Socher, L.-J. Li, K. Li, and L. Fei-Fei, \"ImageNet: A Large-Scale Hierarchical Image Database,\" in CVPR09, 2009.\n\nCreative commons international attribution international 4.0 license. (2018) Creative commons international attribution international 4.0 license. [Online]. Available: https://creativecommons.org/licenses/by/4.0/\n\nMozilla common voice. Mozilla common voice. [Online]. Available: https://voice.mozilla.org/en\n\nLibrispeech: an ASR corpus based on public domain audio books. V Panayotov, G Chen, D Povey, S Khudanpur, Proceedings of the International Conference on Acoustics, Speech and Signal Processing (ICASSP). the International Conference on Acoustics, Speech and Signal Processing (ICASSP)IEEEV. Panayotov, G. Chen, D. Povey, and S. Khudanpur, \"Librispeech: an ASR corpus based on public domain audio books,\" in Proceedings of the International Conference on Acoustics, Speech and Signal Processing (ICASSP). IEEE, 2015.\n\nHey siri: An on-device dnn-powered voice trigger for apple's personal assistant. R G Leonard, G R Doddington, The 5th chime speech separation and recognition challenge. Web audio api. [OnlineR. G. Leonard and G. R. Doddington. (1992) A speaker-independent connected-digit database. [Online]. Available: https://catalog.ldc.upenn.edu/docs/LDC93S10/tidigits.readme.html [9] (2018) The 5th chime speech separation and recognition challenge. [Online]. Available: http://spandh.dcs.shef.ac.uk/chime_challenge/data.html [10] (2017) Hey siri: An on-device dnn-powered voice trigger for apple's personal assistant. [Online]. Available: https://machinelearning.apple.com/2017/10/01/hey-siri.html [11] (2015) Web audio api. [Online].\n\nConvolutional Neural Networks for Small-Footprint Keyword Spotting. T N Sainath, C Parada, Sixteenth Annual Conference of the International Speech Communication Association. T. N. Sainath and C. Parada, \"Convolutional Neural Networks for Small-Footprint Keyword Spotting,\" in Sixteenth Annual Conference of the International Speech Communication Association, 2015. [Online].\n\nL Lai, N Suda, V Chandra, CMSIS-NN: Efficient Neural Network Kernels for Arm Cortex-M CPUs. ArXiv e-printsL. Lai, N. Suda, and V. Chandra, \"CMSIS-NN: Efficient Neural Network Kernels for Arm Cortex-M CPUs,\" ArXiv e-prints, Jan. 2018.\n\nListening to the World Improves Speech Command Recognition. B Mcmahan, D Rao, ArXiv e-printsB. McMahan and D. Rao, \"Listening to the World Improves Speech Command Recognition,\" ArXiv e-prints, Oct. 2017.\n\nA dataset and taxonomy for urban sound research. J Salamon, C Jacoby, J P Bello, http:/doi.acm.org/10.1145/2647868.2655045Proceedings of the 22Nd ACM International Conference on Multimedia, ser. MM '14. the 22Nd ACM International Conference on Multimedia, ser. MM '14New York, NY, USAACMJ. Salamon, C. Jacoby, and J. P. Bello, \"A dataset and taxonomy for urban sound research,\" in Proceedings of the 22Nd ACM International Conference on Multimedia, ser. MM '14. New York, NY, USA: ACM, 2014, pp. 1041-1044. [Online]. Available: http://doi.acm.org/10.1145/2647868.2655045\n\nDid you hear that? Adversarial Examples Against Automatic Speech Recognition. M Alzantot, B Balaji, M Srivastava, ArXiv e-printsM. Alzantot, B. Balaji, and M. Srivastava, \"Did you hear that? Adversarial Examples Against Auto- matic Speech Recognition,\" ArXiv e-prints, Jan. 2018.\n\nDeep Residual Learning for Small-Footprint Keyword Spotting. R Tang, J Lin, ArXiv e-printsR. Tang and J. Lin, \"Deep Residual Learning for Small-Footprint Keyword Spotting,\" ArXiv e-prints, Oct. 2017.\n\nRaw Waveform-based Audio Classification Using Sample-level CNN Architectures. J Lee, T Kim, J Park, J Nam, ArXiv e-printsJ. Lee, T. Kim, J. Park, and J. Nam, \"Raw Waveform-based Audio Classification Using Sample-level CNN Architectures,\" ArXiv e-prints, Dec. 2017.\n\nS Krishna Gouda, S Kanetkar, D Harrison, M K Warmuth, Speech Recognition: Keyword Spotting Through Image Recognition. ArXiv e-printsS. Krishna Gouda, S. Kanetkar, D. Harrison, and M. K. Warmuth, \"Speech Recognition: Keyword Spotting Through Image Recognition,\" ArXiv e-prints, Mar. 2018.\n", "annotations": {"author": "[{\"end\":152,\"start\":93},{\"end\":191,\"start\":153}]", "publisher": null, "author_last_name": "[{\"end\":104,\"start\":98},{\"end\":165,\"start\":160}]", "author_first_name": "[{\"end\":97,\"start\":93},{\"end\":159,\"start\":153}]", "author_affiliation": "[{\"end\":151,\"start\":128},{\"end\":190,\"start\":167}]", "title": "[{\"end\":69,\"start\":1},{\"end\":260,\"start\":192}]", "venue": null, "abstract": "[{\"end\":862,\"start\":283}]", "bib_ref": "[{\"attributes\":{\"ref_id\":\"b0\"},\"end\":1179,\"start\":1176},{\"attributes\":{\"ref_id\":\"b1\"},\"end\":1444,\"start\":1441},{\"attributes\":{\"ref_id\":\"b2\"},\"end\":2236,\"start\":2233},{\"attributes\":{\"ref_id\":\"b4\"},\"end\":2971,\"start\":2968},{\"attributes\":{\"ref_id\":\"b5\"},\"end\":3351,\"start\":3348},{\"end\":24396,\"start\":24392},{\"end\":24696,\"start\":24692},{\"attributes\":{\"ref_id\":\"b7\"},\"end\":25818,\"start\":25814},{\"attributes\":{\"ref_id\":\"b8\"},\"end\":25999,\"start\":25995},{\"attributes\":{\"ref_id\":\"b9\"},\"end\":26059,\"start\":26055},{\"attributes\":{\"ref_id\":\"b10\"},\"end\":26137,\"start\":26133},{\"attributes\":{\"ref_id\":\"b11\"},\"end\":26268,\"start\":26264},{\"attributes\":{\"ref_id\":\"b12\"},\"end\":26401,\"start\":26397},{\"attributes\":{\"ref_id\":\"b13\"},\"end\":26538,\"start\":26534},{\"attributes\":{\"ref_id\":\"b6\"},\"end\":27725,\"start\":27721}]", "figure": "[{\"attributes\":{\"id\":\"fig_0\"},\"end\":26981,\"start\":26820},{\"attributes\":{\"id\":\"fig_1\"},\"end\":27160,\"start\":26982},{\"attributes\":{\"id\":\"tab_0\",\"type\":\"table\"},\"end\":27463,\"start\":27161},{\"attributes\":{\"id\":\"tab_4\",\"type\":\"table\"},\"end\":29547,\"start\":27464}]", "paragraph": "[{\"end\":1215,\"start\":878},{\"end\":1678,\"start\":1217},{\"end\":2101,\"start\":1680},{\"end\":2606,\"start\":2103},{\"end\":2954,\"start\":2623},{\"end\":3337,\"start\":2956},{\"end\":3900,\"start\":3339},{\"end\":4621,\"start\":3916},{\"end\":6221,\"start\":4623},{\"end\":6399,\"start\":6223},{\"end\":6469,\"start\":6401},{\"end\":6521,\"start\":6471},{\"end\":6640,\"start\":6523},{\"end\":6782,\"start\":6642},{\"end\":6877,\"start\":6784},{\"end\":7188,\"start\":6879},{\"end\":7639,\"start\":7190},{\"end\":8402,\"start\":7641},{\"end\":9196,\"start\":8432},{\"end\":9797,\"start\":9198},{\"end\":11034,\"start\":9813},{\"end\":12029,\"start\":11053},{\"end\":12983,\"start\":12091},{\"end\":13829,\"start\":12985},{\"end\":14086,\"start\":13831},{\"end\":14751,\"start\":14088},{\"end\":15008,\"start\":14753},{\"end\":15367,\"start\":15028},{\"end\":15723,\"start\":15369},{\"end\":16098,\"start\":15781},{\"end\":16983,\"start\":16126},{\"end\":17310,\"start\":16985},{\"end\":17702,\"start\":17331},{\"end\":17856,\"start\":17704},{\"end\":18445,\"start\":17876},{\"end\":19050,\"start\":18466},{\"end\":19188,\"start\":19065},{\"end\":19586,\"start\":19190},{\"end\":20647,\"start\":19601},{\"end\":22065,\"start\":20665},{\"end\":22531,\"start\":22067},{\"end\":22886,\"start\":22533},{\"end\":23427,\"start\":22914},{\"end\":23634,\"start\":23429},{\"end\":23672,\"start\":23636},{\"end\":23706,\"start\":23674},{\"end\":23941,\"start\":23708},{\"end\":24094,\"start\":23948},{\"end\":24225,\"start\":24096},{\"end\":24397,\"start\":24227},{\"end\":24697,\"start\":24399},{\"end\":25106,\"start\":24699},{\"end\":25505,\"start\":25108},{\"end\":26608,\"start\":25547},{\"end\":26819,\"start\":26623}]", "formula": "[{\"attributes\":{\"id\":\"formula_0\"},\"end\":12090,\"start\":12030},{\"attributes\":{\"id\":\"formula_1\"},\"end\":15780,\"start\":15724},{\"attributes\":{\"id\":\"formula_2\"},\"end\":17314,\"start\":17311},{\"attributes\":{\"id\":\"formula_3\"},\"end\":23947,\"start\":23942}]", "table_ref": "[{\"end\":19187,\"start\":19180}]", "section_header": "[{\"attributes\":{\"n\":\"2\"},\"end\":876,\"start\":864},{\"attributes\":{\"n\":\"3\"},\"end\":2621,\"start\":2609},{\"attributes\":{\"n\":\"4\"},\"end\":3914,\"start\":3903},{\"attributes\":{\"n\":\"5\"},\"end\":8415,\"start\":8405},{\"attributes\":{\"n\":\"5.1\"},\"end\":8430,\"start\":8418},{\"attributes\":{\"n\":\"5.2\"},\"end\":9811,\"start\":9800},{\"attributes\":{\"n\":\"5.3\"},\"end\":11051,\"start\":11037},{\"attributes\":{\"n\":\"5.4\"},\"end\":15026,\"start\":15011},{\"attributes\":{\"n\":\"5.5\"},\"end\":16124,\"start\":16101},{\"attributes\":{\"n\":\"5.6\"},\"end\":17329,\"start\":17316},{\"attributes\":{\"n\":\"5.7\"},\"end\":17874,\"start\":17859},{\"attributes\":{\"n\":\"5.8\"},\"end\":18464,\"start\":18448},{\"attributes\":{\"n\":\"6\"},\"end\":19063,\"start\":19053},{\"attributes\":{\"n\":\"7\"},\"end\":19599,\"start\":19589},{\"attributes\":{\"n\":\"7.1\"},\"end\":20663,\"start\":20650},{\"attributes\":{\"n\":\"7.2\"},\"end\":22912,\"start\":22889},{\"attributes\":{\"n\":\"7.3\"},\"end\":25530,\"start\":25508},{\"attributes\":{\"n\":\"7.4\"},\"end\":25545,\"start\":25533},{\"attributes\":{\"n\":\"8\"},\"end\":26621,\"start\":26611},{\"end\":26993,\"start\":26983}]", "table": "[{\"end\":27463,\"start\":27199},{\"end\":29547,\"start\":29396}]", "figure_caption": "[{\"end\":26981,\"start\":26822},{\"end\":27160,\"start\":26995},{\"end\":27199,\"start\":27163},{\"end\":29396,\"start\":27466}]", "figure_ref": null, "bib_author_first_name": "[{\"end\":31359,\"start\":31358},{\"end\":31367,\"start\":31366},{\"end\":31375,\"start\":31374},{\"end\":31388,\"start\":31384},{\"end\":31394,\"start\":31393},{\"end\":31400,\"start\":31399},{\"end\":31919,\"start\":31918},{\"end\":31932,\"start\":31931},{\"end\":31940,\"start\":31939},{\"end\":31949,\"start\":31948},{\"end\":32453,\"start\":32452},{\"end\":32455,\"start\":32454},{\"end\":32466,\"start\":32465},{\"end\":32468,\"start\":32467},{\"end\":33165,\"start\":33164},{\"end\":33167,\"start\":33166},{\"end\":33178,\"start\":33177},{\"end\":33473,\"start\":33472},{\"end\":33480,\"start\":33479},{\"end\":33488,\"start\":33487},{\"end\":33768,\"start\":33767},{\"end\":33779,\"start\":33778},{\"end\":33962,\"start\":33961},{\"end\":33973,\"start\":33972},{\"end\":33983,\"start\":33982},{\"end\":33985,\"start\":33984},{\"end\":34563,\"start\":34562},{\"end\":34575,\"start\":34574},{\"end\":34585,\"start\":34584},{\"end\":34827,\"start\":34826},{\"end\":34835,\"start\":34834},{\"end\":35045,\"start\":35044},{\"end\":35052,\"start\":35051},{\"end\":35059,\"start\":35058},{\"end\":35067,\"start\":35066},{\"end\":35233,\"start\":35232},{\"end\":35241,\"start\":35234},{\"end\":35250,\"start\":35249},{\"end\":35262,\"start\":35261},{\"end\":35274,\"start\":35273},{\"end\":35276,\"start\":35275}]", "bib_author_last_name": "[{\"end\":31364,\"start\":31360},{\"end\":31372,\"start\":31368},{\"end\":31382,\"start\":31376},{\"end\":31391,\"start\":31389},{\"end\":31397,\"start\":31395},{\"end\":31408,\"start\":31401},{\"end\":31929,\"start\":31920},{\"end\":31937,\"start\":31933},{\"end\":31946,\"start\":31941},{\"end\":31959,\"start\":31950},{\"end\":32463,\"start\":32456},{\"end\":32479,\"start\":32469},{\"end\":33175,\"start\":33168},{\"end\":33185,\"start\":33179},{\"end\":33477,\"start\":33474},{\"end\":33485,\"start\":33481},{\"end\":33496,\"start\":33489},{\"end\":33776,\"start\":33769},{\"end\":33783,\"start\":33780},{\"end\":33970,\"start\":33963},{\"end\":33980,\"start\":33974},{\"end\":33991,\"start\":33986},{\"end\":34572,\"start\":34564},{\"end\":34582,\"start\":34576},{\"end\":34596,\"start\":34586},{\"end\":34832,\"start\":34828},{\"end\":34839,\"start\":34836},{\"end\":35049,\"start\":35046},{\"end\":35056,\"start\":35053},{\"end\":35064,\"start\":35060},{\"end\":35071,\"start\":35068},{\"end\":35247,\"start\":35242},{\"end\":35259,\"start\":35251},{\"end\":35271,\"start\":35263},{\"end\":35284,\"start\":35277}]", "bib_entry": "[{\"attributes\":{\"id\":\"b0\"},\"end\":31303,\"start\":31193},{\"attributes\":{\"id\":\"b1\"},\"end\":31544,\"start\":31305},{\"attributes\":{\"id\":\"b2\"},\"end\":31758,\"start\":31546},{\"attributes\":{\"id\":\"b3\"},\"end\":31853,\"start\":31760},{\"attributes\":{\"id\":\"b4\",\"matched_paper_id\":2191379},\"end\":32369,\"start\":31855},{\"attributes\":{\"id\":\"b5\"},\"end\":33094,\"start\":32371},{\"attributes\":{\"id\":\"b6\",\"matched_paper_id\":12088192},\"end\":33470,\"start\":33096},{\"attributes\":{\"id\":\"b7\"},\"end\":33705,\"start\":33472},{\"attributes\":{\"id\":\"b8\"},\"end\":33910,\"start\":33707},{\"attributes\":{\"doi\":\"http:/doi.acm.org/10.1145/2647868.2655045\",\"id\":\"b9\",\"matched_paper_id\":207217115},\"end\":34482,\"start\":33912},{\"attributes\":{\"id\":\"b10\"},\"end\":34763,\"start\":34484},{\"attributes\":{\"id\":\"b11\"},\"end\":34964,\"start\":34765},{\"attributes\":{\"id\":\"b12\"},\"end\":35230,\"start\":34966},{\"attributes\":{\"id\":\"b13\"},\"end\":35519,\"start\":35232}]", "bib_title": "[{\"end\":31916,\"start\":31855},{\"end\":33162,\"start\":33096},{\"end\":33959,\"start\":33912}]", "bib_author": "[{\"end\":31366,\"start\":31358},{\"end\":31374,\"start\":31366},{\"end\":31384,\"start\":31374},{\"end\":31393,\"start\":31384},{\"end\":31399,\"start\":31393},{\"end\":31410,\"start\":31399},{\"end\":31931,\"start\":31918},{\"end\":31939,\"start\":31931},{\"end\":31948,\"start\":31939},{\"end\":31961,\"start\":31948},{\"end\":32465,\"start\":32452},{\"end\":32481,\"start\":32465},{\"end\":33177,\"start\":33164},{\"end\":33187,\"start\":33177},{\"end\":33479,\"start\":33472},{\"end\":33487,\"start\":33479},{\"end\":33498,\"start\":33487},{\"end\":33778,\"start\":33767},{\"end\":33785,\"start\":33778},{\"end\":33972,\"start\":33961},{\"end\":33982,\"start\":33972},{\"end\":33993,\"start\":33982},{\"end\":34574,\"start\":34562},{\"end\":34584,\"start\":34574},{\"end\":34598,\"start\":34584},{\"end\":34834,\"start\":34826},{\"end\":34841,\"start\":34834},{\"end\":35051,\"start\":35044},{\"end\":35058,\"start\":35051},{\"end\":35066,\"start\":35058},{\"end\":35073,\"start\":35066},{\"end\":35249,\"start\":35232},{\"end\":35261,\"start\":35249},{\"end\":35273,\"start\":35261},{\"end\":35286,\"start\":35273}]", "bib_venue": "[{\"end\":31219,\"start\":31193},{\"end\":31356,\"start\":31305},{\"end\":31614,\"start\":31546},{\"end\":31780,\"start\":31760},{\"end\":32056,\"start\":31961},{\"end\":32450,\"start\":32371},{\"end\":33268,\"start\":33187},{\"end\":33562,\"start\":33498},{\"end\":33765,\"start\":33707},{\"end\":34113,\"start\":34034},{\"end\":34560,\"start\":34484},{\"end\":34824,\"start\":34765},{\"end\":35042,\"start\":34966},{\"end\":35348,\"start\":35286},{\"end\":32138,\"start\":32058},{\"end\":34196,\"start\":34115}]"}}}, "year": 2023, "month": 12, "day": 17}